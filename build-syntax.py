import subprocess


definers = [
    "define",
    "define-enumeration",
    "define-structure",
    "define-syntax",
    "define-ftype",
    "define-top-level-syntax",
    "define-record",
    "define-property",
    "define-top-level-value",
    "define-condition-type",
    "define-record-type",
    "define-values"
]

syntaxes = [
    "&assertion",
    "&condition",
    "&continuation",
    "&error",
    "&format",
    "&i/o",
    "&i/o-decoding",
    "&i/o-encoding",
    "&i/o-file-already-exists",
    "&i/o-file-does-not-exist",
    "&i/o-file-is-read-only",
    "&i/o-file-protection",
    "&i/o-filename",
    "&i/o-invalid-position",
    "&i/o-port",
    "&i/o-read",
    "&i/o-write",
    "&implementation-restriction",
    "&irritants",
    "&lexical",
    "&message",
    "&no-infinities",
    "&no-nans",
    "&non-continuable",
    "&serious",
    "&source",
    "&syntax",
    "&undefined",
    "&violation",
    "&warning",
    "&who",
    "alias",
    "begin",
    "case",
    "case-lambda",
    "cond",
    "do",
    "else",
    "eval-when",
    "export",
    "extend-syntax",
    "for-each",
    "guard",
    "ieee",
    "if",
    "import",
    "immutable",
    "mutable",
    "include",
    "lambda",
    "let",
    "letrec",
    "let-syntax",
    "let-values",
    "let*",
    "let*-values",
    "letrec-syntax",
    "library",
    "meta",
    "meta-cond",
    "module",
    "quasiquote",
    "quasisyntax",
    "quote",
    "r6rs:case",
    "rec",
    "record-case",
    "scheme",
    "set!",
    "syntax",
    "syntax-case",
    "unless",
    "when",
    "with-implicit",
    "with-syntax",
    "type-descriptor",
    "record-type-descriptor"
]

if __name__ == "__main__":
    p = subprocess.Popen("scheme",
        stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    out, err = p.communicate("(environment-symbols (scheme-environment))")

# out.
