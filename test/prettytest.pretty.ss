;;; 3.ms
;;; Copyright 1984-2017 Cisco Systems, Inc.
;;; 
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;; 
;;; http://www.apache.org/licenses/LICENSE-2.0
;;; 
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

(define-syntax matrest
  (lambda (x)
    (define matrest-argerr-test
      (lambda (ls)
        (if (null? ls)
            '()
            (cons (with-syntax (((n ...) (make-list (length (cdr ls)) 1)))
                    (syntax (error? (matrestf n ...))))
                  (matrest-argerr-test (cdr ls))))))
    (define iota
      (lambda (i n)
        (if (= i n) '() (cons i (iota (+ i 1) n)))))
    (define matrest-test
      (lambda (n ls)
        (let* ((m (length ls)) (n (+ n m)))
          (let f ((n n))
            (if (< n m)
                '()
                (cons (with-syntax (((x ...) (iota 0 m)) ((y ...) (iota m n)))
                        (syntax (equal? (matrestf x ... y ...) '(y ...))))
                      (f (- n 1))))))))
    (syntax-case x ()
      ((k n)
       (let ((n (datum n)))
         (with-syntax (((g ...) (generate-temporaries (make-list n)))
                       (name (datum->syntax (syntax k)
                               (string->symbol (format "matrest~s" n)))))
           (with-syntax
             (((at ...) (matrest-argerr-test (syntax (g ...))))
              ((t ...) (matrest-test 10 (syntax (g ...)))))
             (syntax (mat name
                          (begin
                            (define (matrestf g ... . r) r)
                            #t)
                          at
                          ...
                          t
                          ...)))))))))

(matrest 0)
(matrest 1)
(matrest 2)
(matrest 3)
(matrest 4)
(matrest 5)
(matrest 6)
(matrest 7)
(matrest 8)
(matrest 9)
(matrest 10)

(mat application (error? ((list '(a b c)))))

(mat lambda
     (let ((f (lambda () 'a))) (eq? (f) 'a))
     (let ((f (lambda (x) x))) (eq? (f 'a) 'a))
     (let ((f (lambda x x)))
       (and (equal? (f) '())
            (equal? (f 1) '(1))
            (equal? (f 1 2) '(1 2))
            (equal? (f 1 2 3 4 5 6 7) '(1 2 3 4 5 6 7))))
     (let ((f (lambda (x y) (cons x y))))
       (equal? (f 1 2) '(1 . 2)))
     (let ((f (lambda (x . y) (cons x y))))
       (and (equal? (f 1) '(1))
            (equal? (f 1 2) '(1 2))
            (equal? (f 1 2 3) '(1 2 3))
            (equal? (f 1 2 3 4 5 6 7) '(1 2 3 4 5 6 7))))
     (let ((f (lambda (x y z) (list x y z))))
       (equal? (f 1 2 3) '(1 2 3)))
     (let ((f (lambda (x y . z) (cons x (cons y z)))))
       (and (equal? (f 1 2) '(1 2))
            (equal? (f 1 2 3) '(1 2 3))
            (equal? (f 1 2 3 4) '(1 2 3 4))
            (equal? (f 1 2 3 4 5 6 7) '(1 2 3 4 5 6 7))))
     (let ((f (lambda (x y) (set! x 3) (cons x y))))
       ;see if there is an implicit "begin"
       (equal? (f 1 2) '(3 . 2)))
     (eqv? (let ((f (case-lambda
                      ((x) (+ x 1))
                      ((x . xs) (cons (+ x 2) xs))
                      (xs 0))))
             (f))
           0))

(mat case-lambda
     (procedure? (case-lambda))
     (error? ((case-lambda)))
     (error? (let ((f (case-lambda))) (f 3 4 5)))
     (begin
       (define foo (case-lambda [() 0] [(a b c) 3]))
       (eq? (foo 1 2 3) 3))
     (eq? (foo) 0)
     (error? (foo 1))
     (error? (foo 1 2))
     (error? (foo 1 2 3 4))
     (begin
       (define foo (case-lambda [(a b c) 3] [() 0]))
       (eq? (foo 1 2 3) 3))
     (eq? (foo) 0)
     (error? (foo 1))
     (error? (foo 1 2))
     (error? (foo 1 2 3 4))
     (begin
       (define foo (case-lambda [() 0] [(a) 1] [args 2]))
       (eq? (foo 1 2 3) 2))
     (eq? (foo) 0)
     (eq? (foo 1) 1)
     (begin
       (define foo
         (case-lambda [() 0] [(a) 1] [(a b c . args) 3]))
       (eq? (foo 1 2 3) 3))
     (eq? (foo) 0)
     (eq? (foo 1) 1)
     (error? (foo 1 2))
     (begin
       (define foo
         (case-lambda [() 0] [args 1] [(a b c . args) 3]))
       (and (eq? (foo 1 2 3) 1)
            (eq? (foo 1 2) 1)
            (eq? (foo 1) 1)
            (eq? (foo) 0))))

(mat let
     (let ((x 'a)) (eq? x 'a))
     (let ((x 'a)) (let ((x 'b)) (eq? x 'b)))
     (let ((x 'a) (y 'b)) (equal? (cons x y) '(a . b)))
     (let ((x 'a))
       ;test for implicit "begin"
       (let ((y 'b)) #f (set! x y))
       (eq? x 'b))
     ((lambda (x) (eq? x 'a)) 'a)
     ((lambda (x . r) (eq? x 'a)) 'a)
     ((lambda r (eq? (car r) 'a)) 'a)
     (error? ((lambda (x . r) (eq? x 'a)))))

(mat let*
     (let* ((x 'a)) (eq? x 'a))
     (let* ((x (cons 1 2)) (y x)) (eq? x y))
     (let ((x 1) (y 2))
       (let* ((x 10) (y 12)) (equal? (cons x y) '(10 . 12))))
     (let* ((x 'a))
       ;test for implicit "begin"
       (let* ((y 'b)) #f (set! x y))
       (eq? x 'b)))

(mat letrec
     (letrec ((f (lambda () x)) (x (cons 1 2))) (eq? (f) x))
     (letrec ((f (lambda () g)) (g (lambda () f)))
       (and (eq? (f) g) (eq? (g) f)))
     (letrec ((f (lambda (x) (if (zero? x) 'odd (g (1- x)))))
              (g (lambda (x) (if (zero? x) 'even (f (1- x))))))
       (and (eq? (g 10) 'even)
            (eq? (g 13) 'odd)
            (eq? (f 13) 'even)))
     (letrec ((x 'a))
       ;test for implicit "begin"
       (letrec ((y 'b)) #f (set! x y))
       (eq? x 'b))
     #;
     (eqv? (letrec ((v 0) (k (call/cc (lambda (x) x))))
             ; invalid in r6rs
             ; david carlton's bug
             (set! v (+ v 1))
             (k (lambda (x) v)))
           1)
     #;
     (eqv? (letrec ((k (call/cc (lambda (x) x))) (v 0))
             ; invalid in r6rs
             ; david carlton's bug
             (set! v (+ v 1))
             (k (lambda (x) v)))
           1)
     #;
     (eqv? (letrec* ((v 0) (k (call/cc (lambda (x) x))))
             ; invalid in r6rs
             ; variation on david carlton's "bug"
             (set! v (+ v 1))
             (k (lambda (x) v)))
           2)
     #;
     (eqv? (letrec* ((k (call/cc (lambda (x) x))) (v 0))
             ; invalid in r6rs
             ; another variation on david carlton's "bug"
             (set! v (+ v 1))
             (k (lambda (x) v)))
           1)
     ; testing for named-let equivalents
     (eqv? (letrec ((f (lambda (x) (if (zero? x) 1 (* x (f (1- x)))))))
             (f 5))
           120)
     (letrec ((f (lambda (x) (if (zero? x) #t (f (1- x))))))
       (f 10000))
     (letrec ((f (lambda (x y)
                   (or (and (= x 0) (= y 10))
                       (f (- x 1) (+ y 1))))))
       (f 10 0))
     (eqv? (letrec ((f (lambda (x) (if (= x 0) 1 (+ (f (- x 1)) 1)))))
             (f 10))
           11)
     (eqv? (let ([base 20])
             (letrec ((f (lambda (x) (if (= x 0) base (+ (f (- x 1)) 1)))))
               (f 10)))
           30)
     (error? (letrec ((x (lambda (x) x))) (f 3 4)))
     (eq? (letrec ((f (lambda (x) (if x (list (f x)) 0)))) (f #f)) 0)
     (equal? (letrec ((f (lambda (x) (if x (list (f (not x))) 0)))) (f #t))
             '(0))
     (equal? (letrec ((f (lambda (x) (if x (list (g x)) 0)))
                      (g (lambda (x) (f #f))))
               (f #t))
             '(0))
     (equal? (letrec ((f (lambda (x) (if x (list (g (not x))) 0)))
                      (g (lambda (x) (f x))))
               (g #t))
             '(0))
     (error? (letrec ([a 3] [b a]) (+ a b)))
     ; shouldn't get warnings for these if valid-check algorithm is working
     ; properly
     (procedure? (letrec ([bar (letrec ([f (lambda (x) f)]) f)]) bar))
     (eqv? (letrec ([fllog 3] [flacosh (or values (lambda (x) fllog))])
             (flacosh 4))
           4)
     (eqv? (let ()
             (define $b #t)
             (letrec ([fllog 3]
                      [flacosh (if $b (lambda (x) fllog) values)])
               (flacosh 4)))
           3)
     (equal? (letrec ([a 3]
                      [b (#2%cons (lambda () a) (lambda (x) (set! a x)))])
               ((cdr b) 17)
               (list a ((car b))))
             '(17 17))
     #;
     (pair? (member (letrec ([k (call/cc (lambda (k) k))]
                             ; invalid in r6rs
                             [f (let ([n 0])
                                  (lambda (a)
                                    (set! n (+ n 1))
                                    n))])
                      (f (void))
                      (let ([m (k f)])
                        (list (eq? k f) m (f (void)))))
                    '((#f 2 2) (#t 3 4))))
     (error? (letrec ([a (set! b 0)] [b 3]) 17))
     ; test strongly connected components algorithm used by cpletrec
     (equal? (letrec ([f0 (lambda (x) (f4 (cons 0 x)))]
                      [f1 (lambda (x)
                            (if (fx> (length x) 10)
                                x
                                (f3 (f4 (cons 1 x)))))]
                      [f2 (lambda (x) (f3 (cons 2 x)))]
                      [f3 (lambda (x) (f1 (cons 3 x)))]
                      [f4 (lambda (x) (f1 (f2 (cons 4 x))))])
               (apply (lambda (t0 t1 t2 t3 t4)
                        (set! f0 (values t0))
                        (set! f1 (values t1))
                        (set! f2 (values t2))
                        (set! f3 (values t3))
                        (set! f4 (values t4)))
                      (list f0 f1 f2 f3 f4))
               (f0 '()))
             '(3 3 3 2 4 1 3 2 4 1 3 2 4 0))
     (equal? (letrec ([f0 (list (lambda (x) ((car f4) (cons 0 x))))]
                      [f1 (list (lambda (x)
                                  (if (fx> (length x) 10)
                                      x
                                      ((car f3) ((car f4) (cons 1 x))))))]
                      [f2 (list (lambda (x) ((car f3) (cons 2 x))))]
                      [f3 (list (lambda (x) ((car f1) (cons 3 x))))]
                      [f4 (list (lambda (x)
                                  ((car f1) ((car f2) (cons 4 x)))))])
               ((car f0) '()))
             '(3 3 3 2 4 1 3 2 4 1 3 2 4 0)))

(mat letrec*
     (letrec* ((f (lambda () x)) (x (cons 1 2))) (eq? (f) x))
     (letrec* ((f (lambda () g)) (g (lambda () f)))
              (and (eq? (f) g) (eq? (g) f)))
     (letrec* ((f (lambda (x) (if (zero? x) 'odd (g (1- x)))))
               (g (lambda (x) (if (zero? x) 'even (f (1- x))))))
              (and (eq? (g 10) 'even)
                   (eq? (g 13) 'odd)
                   (eq? (f 13) 'even)))
     (letrec* ((x 'a))
       ;test for implicit "begin"
       (letrec ((y 'b)) #f (set! x y))
       (eq? x 'b))
     #;
     (eqv? (letrec* ((v 0) (k (call/cc (lambda (x) x))))
             ; invalid in r6rs
             ; variation on david carlton's "bug"
             (set! v (+ v 1))
             (k (lambda (x) v)))
           2)
     #;
     (eqv? (letrec* ((k (call/cc (lambda (x) x))) (v 0))
             ; invalid in r6rs
             ; another variation on david carlton's "bug"
             (set! v (+ v 1))
             (k (lambda (x) v)))
           1)
     ; testing for named-let equivalents
     (eqv? (letrec* ((f (lambda (x) (if (zero? x) 1 (* x (f (1- x)))))))
                    (f 5))
           120)
     (letrec* ((f (lambda (x) (if (zero? x) #t (f (1- x)))))) (f 10000))
     (letrec* ((f (lambda (x y)
                    (or (and (= x 0) (= y 10))
                        (f (- x 1) (+ y 1))))))
              (f 10 0))
     (eqv? (letrec* ((f (lambda (x) (if (= x 0) 1 (+ (f (- x 1)) 1)))))
                    (f 10))
           11)
     (eqv? (let ([base 20])
             (letrec* ((f (lambda (x) (if (= x 0) base (+ (f (- x 1)) 1)))))
                      (f 10)))
           30)
     (error? (letrec* ((x (lambda (x) x))) (f 3 4)))
     (eq? (letrec* ((f (lambda (x) (if x (list (f x)) 0)))) (f #f)) 0)
     (equal? (letrec* ((f (lambda (x) (if x (list (f (not x))) 0))))
                      (f #t))
             '(0))
     (equal? (letrec* ((f (lambda (x) (if x (list (g x)) 0)))
                       (g (lambda (x) (f #f))))
                      (f #t))
             '(0))
     (equal? (letrec* ((f (lambda (x) (if x (list (g (not x))) 0)))
                       (g (lambda (x) (f x))))
                      (g #t))
             '(0))
     (equal? (letrec* ((x 3) (y x)) (+ x y)) 6)
     (equal? (parameterize ([internal-defines-as-letrec* #t])
               (eval '(let () (define x 3) (define y x) (+ x y))))
             6)
     (error? (letrec* ((y x) (x 3)) (+ x y)))
     (error? (letrec* ((x x)) x))
     ; shouldn't get warnings for these if valid-check algorithm is working
     ; properly
     (procedure? (letrec* ([bar (letrec* ([f (lambda (x) f)]) f)]) bar))
     (eqv? (letrec* ([fllog 3] [flacosh (or values (lambda (x) fllog))])
                    (flacosh 4))
           4)
     (eqv? (let ()
             (define $b #t)
             (letrec* ([fllog 3]
                       [flacosh (if $b (lambda (x) fllog) values)])
                      (flacosh 4)))
           3)
     (equal? (letrec* ([a 3]
                       [b (#2%cons (lambda () a) (lambda (x) (set! a x)))])
                      ((cdr b) 17)
                      (list a ((car b))))
             '(17 17))
     (equal? (letrec* ([f (let ([n 0]) (lambda () (set! n (+ n 1)) n))])
                      (letrec* ([x (f)] [y (f)]) (list x y)))
             '(1 2))
     (error? (letrec* ([a (set! b 0)] [b 3]) 17))
     (eqv? (letrec* ([b 3] [a (set! b 0)]) 17) 17)
     #;
     (equal? (letrec* ([k (call/cc (lambda (k) k))]
                       ; invalid in r6rs
                       [f (let ([n 0]) (lambda (a) (set! n (+ n 1)) n))])
                      (f (void))
                      (let ([m (k f)])
                        (list (eq? k f) m (f (void)))))
             '(#f 2 2))
     #;
     (equal? (letrec* ([f (let ([n 0]) (lambda (a) (set! n (+ n 1)) n))]
                       [k (call/cc (lambda (k) k))])
                      ; invalid in r6rs
                      (f (void))
                      (let ([m (k f)])
                        (list (eq? k f) m (f (void)))))
             '(#t 3 4))

     ; make sure letrec* doesn't treat global or local assignable
     ; variables simple
     (begin
       (define $frodo)
       (letrec* ([merry 'merry]
                 [ignore (set! $frodo (lambda () pippin))]
                 [pippin (#3%cons $frodo $frodo)])
                (void))
       (eq? (car ($frodo)) $frodo))
     (begin
       (define $frodo)
       (letrec* ([merry 'merry]
                 [ignore (set! $frodo (lambda () pippin))]
                 [pippin $frodo])
                (void))
       (eq? ($frodo) $frodo))
     (let ([$frodo #f])
       (letrec* ([merry 'merry]
                 [ignore (set! $frodo (lambda () pippin))]
                 [pippin $frodo])
                (void))
       (eq? ($frodo) $frodo))

     ; similarly, make sure letrec* doesn't reorder primitives that can
     ; observe effects of other expressions
     (equal? (letrec* ([t (cons 'a 'b)]
                       [f (lambda () y)]
                       [x (begin (set-car! t 'c) (car t))]
                       [p (car t)]
                       [g (lambda () x)]
                       [y (begin (set-car! t 'd) (car t))]
                       [q (car t)])
                      (list t p q x y (f) (g)))
             `((d . b) c d c d d c))

     (equal? (letrec* ([t (gensym)]
                       [f (lambda () y)]
                       [x (list (putprop t 'ham f))]
                       [p (property-list t)]
                       [g (lambda () x)]
                       [y (list (putprop t 'spam g))]
                       [q (property-list t)])
                      (list (equal? p (list 'ham f))
                            (or (equal? q (list 'ham f 'spam g))
                                (equal? q (list 'spam g 'ham f)))
                            (procedure? f)
                            (procedure? g)
                            x
                            y))
             `(#t #t #t #t (,(void)) (,(void))))
     ; test strongly connected components algorithm used by cpletrec
     (equal? (letrec* ([f0 (lambda (x) (f4 (cons 0 x)))]
                       [f1 (lambda (x)
                             (if (fx> (length x) 10)
                                 x
                                 (f3 (f4 (cons 1 x)))))]
                       [f2 (lambda (x) (f3 (cons 2 x)))]
                       [f3 (lambda (x) (f1 (cons 3 x)))]
                       [f4 (lambda (x) (f1 (f2 (cons 4 x))))])
                      (apply (lambda (t0 t1 t2 t3 t4)
                               (set! f0 (values t0))
                               (set! f1 (values t1))
                               (set! f2 (values t2))
                               (set! f3 (values t3))
                               (set! f4 (values t4)))
                             (list f0 f1 f2 f3 f4))
                      (f0 '()))
             '(3 3 3 2 4 1 3 2 4 1 3 2 4 0))
     (equal? (letrec* ([f0 (list (lambda (x) ((car f4) (cons 0 x))))]
                       [f1 (list (lambda (x)
                                   (if (fx> (length x) 10)
                                       x
                                       ((car f3) ((car f4) (cons 1 x))))))]
                       [f2 (list (lambda (x) ((car f3) (cons 2 x))))]
                       [f3 (list (lambda (x) ((car f1) (cons 3 x))))]
                       [f4 (list (lambda (x)
                                   ((car f1) ((car f2) (cons 4 x)))))])
                      ((car f0) '()))
             '(3 3 3 2 4 1 3 2 4 1 3 2 4 0)))

(mat dipa-letrec
     ; from Dipa Sarkar
     (error? ; undefined variable c
       (letrec* ([a (lambda () c)] [b (a)] [c (cons 1 2)]) b))
     (error? ; undefined variable c
       (letrec* ([a (lambda () c)] [b (let ([d a]) (d))] [c (cons 1 2)]) b))
     (error? ; undefined variable c
       (letrec* ([a (let ([d (lambda () c)]) (d))] [b a] [c (cons 1 2)]) b))
     (error? ; undefined variable c
       (letrec* ([a (letrec* ([b (lambda () c)] [d (b)] [c (cons 1 2)]) d)])
                a))
     (error? ; undefined variable c
       (letrec* ([a (lambda () c)]
                 [b (lambda (f) (f))]
                 [d (b a)]
                 [c (cons 1 2)])
                d))
     (error? ; undefined variable c
       (letrec* ([a (lambda () c)]
                 [b (lambda () a)]
                 [d ((b))]
                 [c (cons 1 2)])
                d))
     (error? ; undefined variable c
       (letrec* ([a (lambda () (set! c d))] [b (a)] [c (cons 1 2)]) b))
     (error? ; undefined variable c
       (letrec* ([a (lambda () (set! d c))] [b (a)] [c (cons 1 2)]) d))
     (equal? (letrec* ([a (lambda () c)] [b (if #t a (a))] [c (cons 1 2)])
                      (b))
             '(1 . 2))
     (error? ; undefined variable c
       (letrec* ([a (lambda () c)] [b (if #t (a) a)] [c (cons 1 2)]) b))
     (error? ; undefined variable a
       (letrec ([a (letrec* ([b (lambda () a)]) (b))] [c (cons 1 2)])
         (cons a c)))
     (error? ; undefined variable a
       (letrec ([a (lambda () c)] [b (lambda () a)] [c ((b))] [d (cons 1 2)])
         d))
     (error? ; undefined variable a
       (letrec ([a (lambda () b)] [b (lambda () c)] [c (a)])
         c))
     (error? ; undefined variable a
       (letrec ([a (letrec* ([b (lambda () c)] [c (cons 1 2)]) (b))] [d a])
         d))
     (error? ; undefined variable a
       (letrec ([a (let ([x 0]) (lambda () x))] [b (let ([y 2]) (* y (a)))])
         b))
     (error? ; undefined variable c
       (letrec ([a (letrec* ([b (lambda () c)] [d c]) (b))] [c (cons 1 2)])
         (letrec* ([m (lambda () n)] [n (cons 3 4)]) (cons (m) n))))
     (error? ; undefined variable c
       (letrec ([a (letrec* ([b (lambda () c)] [d c]) b)] [c (cons 1 2)])
         (letrec* ([m (lambda () n)] [n (cons 3 4)]) (cons (m) n))))
     (equal? '((3 . 4) 3 . 4)
       (letrec ([a (letrec* ([b (lambda () c)] [d 0]) b)] [c (cons 1 2)])
         (letrec* ([m (lambda () n)] [n (cons 3 4)]) (cons (m) n))))
     (equal? '((1 . 2) (3 . 4) 3 . 4)
       (letrec ([a (letrec* ([b (lambda () (lambda () c))] [d (b)]) d)] [c (cons 1 2)])
         (letrec* ([m (lambda () n)] [n (cons 3 4)]) (cons c (cons (m) n)))))
     (error? ; undefined variable b
       (letrec ([a (letrec ([b (lambda () (lambda () c))] [d (b)]) d)] [c (cons 1 2)])
         (letrec* ([m (lambda () n)] [n (cons 3 4)]) (cons c (cons (m) n)))))
     (error? ; undefined variable b
       (letrec ([a (letrec ([b (lambda () (lambda () c))] [d ((b))]) d)] [c (cons 1 2)])
         (letrec* ([m (lambda () n)] [n (cons 3 4)]) (cons c (cons (m) n)))))
     (error? ; undefined variable c
       (letrec ([a (letrec* ([b (lambda () (lambda () c))] [d ((b))]) d)] [c (cons 1 2)])
         (letrec* ([m (lambda () n)] [n (cons 3 4)]) (cons c (cons (m) n)))))
     (equal? '((1 . 2) ((1 . 2) . 4) (1 . 2) . 4)
       (letrec ([a (letrec* ([b (lambda () (lambda () c))] [d (b)]) d)] [c (cons 1 2)])
         (letrec* ([m (lambda () n)] [n (cons c 4)])
                  (cons (a) (cons (m) n)))))
     (equal? '(1 . 2)
       (letrec* ([m (let ([f (lambda () n)]) f)] [n (cons 1 2)]) n))
     (error? ; undefined variable n
       (letrec* ([m (let ([f (lambda () n)]) (f))] [n (cons 1 2)]) n))
     (eqv? #f
           (letrec* ([a (lambda (n) (n 0))]
                     [b (a (lambda (x) (if (zero? x) #f c)))]
                     [c #t])
                    b))
     (error? ; undefined variable c
       (letrec* ([a (lambda (n) (n 0))]
                 [b (a (lambda (x) (if (zero? x) c #f)))]
                 [c #t])
                b))
     (error? ; undefined variable a
       (letrec ([a (letrec ([b (letrec ([c (lambda () a)]) (c))])
                     (lambda () b))])
         ((lambda () c))))
     (error? ; undefined variable c
       (letrec* ([a (lambda (f g) (f g))] [b (lambda (x) c)] [c (b b)])
                (list a b c)))
     (error? ; undefined variable m
       (letrec ([m (lambda (x) (cons n x))] [n ((lambda () m))])
         (m '())))
     (error? ; undefined variable a
       (letrec ([a (lambda () 0)] [b (zero? (a))] [c (if b (a) a)])
         c))
     (error? ; undefined variable y
       (letrec ([x (lambda () y)]
                [y (lambda (f) (f))]
                [z (y (lambda () (x)))])
         (z (lambda () 3))))
     (eq? 3
          (letrec* ([x (lambda (f) (f))] [y (lambda () x)] [z (x y)])
                   (z (lambda () 3))))
     (eq? 3
          (letrec ([x (lambda (f) (f))]
                   [y (lambda () x)]
                   [z (lambda () (x y))])
            ((z) (lambda () 3))))
     #;
     (error? ; undefined variable y
       (letrec ([x (lambda () y)]
                [y (lambda (f) (f))]
                [z (call/cc (lambda (k) (y (lambda () (x)))))])
         ; invalid in r6rs
         ((z) (lambda () 3))))
     #;
     (eq? 3
          (letrec ([x (lambda (f) (f))]
                   [y (lambda () x)]
                   [z (call/cc (lambda (k) (lambda () (x y))))])
            ; invalid in r6rs
            ((z) (lambda () 3))))
     (error? ; undefined variable a
       (letrec ([a 3] [b (letrec* ([c (lambda () a)] [d (c)]) (* d d))])
         (* a b)))
     (error? ; undefined variable a
       (letrec ([a 3]
                [b (letrec* ([c (lambda () (lambda () a))] [d (c)])
                            (* (d) (d)))])
         (* a b)))
     (eq? 9
          (letrec ([a 3]
                   [b (letrec* ([c (lambda () (lambda () a))] [d (c)]) d)])
            (* a (b))))
     (eq? 27
          (letrec ([a 3]
                   [b (lambda ()
                        (letrec* ([c (lambda () (lambda () a))] [d (c)])
                                 (* (d) (d))))])
            (* a (b))))
     #;
     (error? ; undefined variable b
       (letrec* ([a (call/cc (lambda (k) (lambda (n) (if (zero? n) k b))))]
                 [b ((a 0) (a 10))])
                ; invalid in r6rs
                b)))

(mat cpvalid
     (error? (letrec ([a (lambda () c)] [b (a)] [c 4]) b))
     (error? (letrec* ([a (lambda () c)] [b (a)] [c 4]) b))
     (error? (letrec ([f (lambda () (g))] [h (f)] [g (lambda () 3)]) h))
     (error? (letrec* ([f (lambda () (g))] [h (f)] [g (lambda () 3)]) h))
     (error? (letrec ([a (set! b 0)] [b 3]) b))
     (error? (letrec ([b 3] [a (set! b 723)]) b))
     (error? (letrec* ([a (set! b 0)] [b 3]) b))
     (eqv? (letrec* ([b 3] [a (set! b 723)]) b) 723)
     (error? (letrec ([a (lambda () c)]
                      [b (let ((f (lambda () (a)))) (f))]
                      [c 44])
               (list (a) b c)))
     (error? (letrec* ([a (lambda () c)]
                       [b (let ((f (lambda () (a)))) (f))]
                       [c 44])
                      (list (a) b c)))
     (error? (letrec ([a (lambda () c)]
                      [b (let ((f (lambda () a))) (f))]
                      [c 44])
               (list (a) (b) c)))
     (equal? (letrec* ([a (lambda () c)]
                       [b (let ((f (lambda () a))) (f))]
                       [c 44])
                      (list (a) (b) c))
             '(44 44 44))
     (equal? (letrec ([a (cons (lambda () b) (lambda () c))]
                      [b (cons (lambda () a) (lambda () c))]
                      [c (cons (lambda () a) (lambda () b))]
                      [d (list (lambda () d))])
               (map pair?
                    (list ((car a)) ((cdr b)) c ((car d)))))
             '(#t #t #t #t))
     (equal? (letrec* ([a (cons (lambda () b) (lambda () c))]
                       [b (cons (lambda () a) (lambda () c))]
                       [c (cons (lambda () a) (lambda () b))]
                       [d (list (lambda () d))])
                      (map pair?
                           (list ((car a)) ((cdr b)) c ((car d)))))
             '(#t #t #t #t))
     (error? (letrec ([a (letrec ([b (lambda () (c))]
                                  [c (lambda () a)]
                                  [d (lambda () (b))])
                           (d))])
               (a 55)))
     (error? (letrec ([a (letrec* ([b (lambda () (c))]
                                   [c (lambda () a)]
                                   [d (lambda () (b))])
                                  (d))])
               (a 55)))
     (error? (letrec ([a (letrec ([b (lambda () (c))] [c (lambda () a)] [d (b)])
                           (d))])
               (a 55)))
     (error? (letrec ([a (letrec* ([b (lambda () (c))] [c (lambda () a)] [d (b)])
                                  (d))])
               (a 55)))
     (eqv? (letrec* ([b (lambda () (c))] [c (lambda () 73)] [d (b)]) d) 73)
     (procedure?
       (let ()
         (define f (rec f* (lambda () (g))))
         (define g (rec g* (lambda () (f))))
         g))
     (equal? (let ([q #f])
               (letrec ((a (letrec ((f (lambda () a)) (g (lambda () (set! q "hi\n"))))
                             (g)
                             (lambda () (f)))))
                 (list (eq? a (a)) q)))
             '(#t "hi\n"))
     (error? ; should complain about g
       (let ()
         (define f (letrec ((f* (lambda () (g)))) (f*)))
         (define g (letrec ((g* (lambda () (f)))) (g*)))
         g))
     (internal-defines-as-letrec*)
     (begin
       (internal-defines-as-letrec* #f)
       (not (internal-defines-as-letrec*)))
     (error? ; might complain about f or g
       (let ()
         (define f (letrec ((f* (lambda () (g)))) (f*)))
         (define g (letrec ((g* (lambda () (f)))) (g*)))
         g))
     (begin
       (internal-defines-as-letrec* #t)
       (internal-defines-as-letrec*))
     (error? (letrec* ((a (lambda () (c)))
                       (b (lambda () (d)))
                       (c (lambda () (f)))
                       (d (lambda () (f)))
                       (e (cons (a) (lambda () (b))))
                       (f ((cdr e))))
                      7))
     (error? (letrec* ((a (lambda () (b))) (b (lambda () (c))) (c (a))) 7))
     ; verify that cpletrec output is straight rec-binding:
     (equal? (letrec* ((e (lambda (x) (or (= x 0) (o (- x 1)))))
                       (o (lambda (x) (and (not (= x 0)) (e (- x 1))))))
                      (list (e 7) (o 7) (e 6) (o 6)))
             '(#f #t #t #f))
     ; verify that cpletrec output is straight rec-binding:
     (letrec ([a (letrec* ([b (lambda () (c))]
                           [c (lambda () a)]
                           [d (lambda () (b))])
                          (lambda () (d)))])
       (eq? a (a)))
     ; check for warnings when requested
     (eq? (parameterize ([undefined-variable-warnings "yes please!"])
            (undefined-variable-warnings))
          #t)
     (warning? ; possible undefined variable
       (parameterize ([undefined-variable-warnings #t] [optimize-level 2])
         (eval '(let () (define x x) x))))
     (error? ; undefined variable
       (parameterize ([undefined-variable-warnings #f] [optimize-level 2])
         (eval '(let () (define x x) x))))
     (begin
       (with-output-to-file "testfile.ss"
         (lambda ()
           (pretty-print '(let () (define x x) (x y))))
         'replace)
       #t)
     (warning? ; possible undefined variable, with source info
               (parameterize
                 ([undefined-variable-warnings #t] [optimize-level 2])
                 (compile-file "testfile")))
     (error? ; undefined variable, with source info
       (parameterize ([undefined-variable-warnings #f] [optimize-level 2])
         (compile-file "testfile")
         (load "testfile.so"))))

(mat cpvalid2
     ; from Dipa
     (error? ; undefined variable c
       (letrec* ([a (lambda () c)] [b (a)] [c (cons 1 2)]) b))
     (error? ; undefined variable c
       (letrec* ([a (lambda () c)] [b (let ((d a)) (d))] [c (cons 1 2)]) b))
     (error? ; undefined variable c
       (letrec* ([a (let ([d (lambda () c)]) (d))] [b a] [c (cons 1 2)]) b))
     (error? ; undefined variable c
       (letrec* ([a (letrec* ([b (lambda () c)] [d (b)] [c (cons 1 2)]) d)])
                a))
     (error? ; undefined variable c
       (letrec* ([a (lambda () c)]
                 [b (lambda (f) (f))]
                 [d (b a)]
                 [c (cons 1 2)])
                d))
     (error? ; undefined variable c
       (letrec* ([a (lambda () c)]
                 [b (lambda () a)]
                 [d ((b))]
                 [c (cons 1 2)])
                d))
     (error? ; undefined variable c
       (letrec* ([a (lambda () (set! c d))] [b (a)] [c (cons 1 2)]) b))
     (error? ; undefined variable c
       (letrec* ([a (lambda () (set! d c))] [b (a)] [c (cons 1 2)]) d))
     (equal? (letrec* ([a (lambda () c)] [b (if #t a (a))] [c (cons 1 2)])
                      (b))
             '(1 . 2))
     (error? ; undefined variable c
       (letrec* ([a (lambda () c)] [b (if #t (a) a)] [c (cons 1 2)]) b))
     (error? ; undefined variable a
       (letrec ([a (letrec* ([b (lambda () a)]) (b))] [c (cons 1 2)])
         (cons a c))))

(mat rec
     (let ((f (rec g (lambda () g)))) (eq? f (f)))
     (let ((f (rec g (lambda (x) (if (zero? x) 1 (* x (g (1- x))))))))
       (= (f 4) 24)))

(mat define
     (begin (define xxxx 'xxxxval) #t)
     (and (top-level-bound? 'xxxx)
          (eqv? (top-level-value 'xxxx) 'xxxxval))
     (begin (define (ffff x) (+ x x)) #t)
     (and (top-level-bound? 'ffff)
          (eqv? ((top-level-value 'ffff) 17) 34))
     (begin (define (eeee . l) l) #t)
     (equal? (eeee 1 2 3) '(1 2 3))
     (begin (define (dddd x . l) (cons x l)) #t)
     (equal? (dddd 1 2 3 4) '(1 2 3 4))
     ((lambda (x)
        (define yyyy x)
        (define (gggg y) (+ yyyy y))
        (and (not (top-level-bound? 'yyyy))
             (not (top-level-bound? 'gggg))
             (eqv? (gggg 22) 25))) 3)
     (let ((x 3))
       (define yyyy x)
       (define (gggg y) (+ yyyy y))
       (and (not (top-level-bound? 'yyyy))
            (not (top-level-bound? 'gggg))
            (eqv? (gggg 22) 25)))
     (let* ((x 3))
       (define yyyy x)
       (define (gggg y) (+ yyyy y))
       (and (not (top-level-bound? 'yyyy))
            (not (top-level-bound? 'gggg))
            (eqv? (gggg 22) 25)))
     (letrec ((x 3))
       (define yyyy x)
       (define (gggg y) (+ yyyy y))
       (and (not (top-level-bound? 'yyyy))
            (not (top-level-bound? 'gggg))
            (eqv? (gggg 22) 25)))
     (let ()
       (begin (define x 3) (define y 4))
       (begin)
       (begin (define z 5))
       (= (+ (* x x) (* y y)) (* z z)))
     (error? (lambda () 0 (define x 3) x))
     (error? (lambda () 0 (begin (define x 3)) x))
     (error? (lambda () 0 (begin) x))
     (error? (case-lambda [() 0 (define x 3) x]))
     (error? (let () 0 (define x 3) x))
     (error? (let* () 0 (define x 3) x))
     (error? (letrec () 0 (define x 3) x))
     (error? (if (define x 3) x x)))

(mat define-values
     (begin (define-values ($dv-x $dv-y) (values 'a 'b)) #t)
     (eq? $dv-x 'a)
     (eq? $dv-y 'b)
     (begin (define-values $dv-r (values)) #t)
     (equal? $dv-r '())
     (begin (define-values $dv-r (values 1)) #t)
     (equal? $dv-r '(1))
     (begin (define-values $dv-r (values 1 2 3 4 5)) #t)
     (equal? $dv-r '(1 2 3 4 5))
     (begin
       (define-values ($dv-x $dv-y . $dv-r) (values 1 2 3 4 5))
       #t)
     (eqv? $dv-x 1)
     (eqv? $dv-y 2)
     (equal? $dv-r '(3 4 5))
     (begin
       (define-values ($dv-x $dv-y) (div-and-mod 19 4))
       #t)
     (eqv? $dv-x 4)
     (eqv? $dv-y 3)
     (begin
       (define-values ($dv-x $dv-y . $dv-z) (div-and-mod 19 4))
       #t)
     (eqv? $dv-x 4)
     (eqv? $dv-y 3)
     (equal? $dv-z '())
     (error? ; invalid number of arguments
             (define-values ($dv-x . $dv-r) (values)))
     (error? ; invalid number of arguments
             (define-values ($dv-x $dv-y . $dv-r) (values)))
     (error? ; invalid number of arguments
             (define-values ($dv-x $dv-y . $dv-r) (values 1)))
     (error? ; invalid number of arguments
             (define-values ($dv-x $dv-y $dv-z . $dv-r) (div-and-mod 19 4)))
     (error? ; invalid number of arguments
             (define-values ($dv-x) (div-and-mod 19 4)))
     (error? ; invalid number of arguments
             (define-values () (div-and-mod 19 4)))
     (error? ; duplicate variable name
             (define-values ($dv-x $dv-x) (div-and-mod 19 4)))
     (error? ; duplicate variable name
             (define-values ($dv-x . $dv-x) (div-and-mod 19 4)))
     (equal? (let () (define-values (x y) (values 'a 'b)) (list x y))
             '(a b))
     (equal? (let () (define-values r (values)) r) '())
     (equal? (let () (module (r) (define-values r (values 1))) r) '(1))
     (equal? (let () (define-values r (values 1 2 3 4 5)) r) '(1 2 3 4 5))
     (equal? (let ()
               (define-values (x y . r) (values 1 2 3 4 5))
               (vector x y r))
             '#(1 2 (3 4 5)))
     (equal? (let () (define-values (x y) (div-and-mod 19 4)) (list y x))
             '(3 4))
     (equal? (let ()
               (define-values (x y . z) (div-and-mod 19 4))
               (vector z x y))
             '#(() 4 3))
     (error? ; invalid number of arguments
             (let () (define-values (x . r) (values)) r))
     (error? ; no expressions in body
             (let () (define-values (x y . r) (values))))
     (error? ; invalid number of arguments
             (let () (define-values (x y . r) (values 1)) x))
     (error? ; invalid number of arguments
             (let ()
               (define-values (x y z . r) (div-and-mod 19 4))
               x))
     (error? ; invalid number of arguments
             (let ()
               (define-values (x) (div-and-mod 19 4))
               x))
     (error? ; invalid number of arguments
             (let () (define-values () (div-and-mod 19 4)) #t))
     (error? ; duplicate variable name
             (let ()
               (define-values (x x) (div-and-mod 19 4))
               x))
     (error? ; duplicate variable name
             (let ()
               (define-values (x . x) (div-and-mod 19 4))
               x))
     (begin
       (library ($dv-foo)
         (export $dv-foo-x)
         (import (chezscheme))
         (define-values $dv-foo-x (div-and-mod 19 4)))
       #t)
     (equal? (let () (import ($dv-foo)) $dv-foo-x) '(4 3))
     (begin (import ($dv-foo)) #t)
     (equal? $dv-foo-x '(4 3))
     (begin
       (library ($dv-foo1)
         (export $dv-foo1-x)
         (import (chezscheme))
         (define-values ($dv-foo1-x . r) (values)))
       #t)
     (error? ; invalid number of arguments
             (let () (import ($dv-foo1)) $dv-foo1-x))
     (error? ; duplicate variable name
       (library ($dv-foo2)
         (export $dv-foo2-x)
         (import (chezscheme))
         (define-values ($dv-foo2-x . $dv-foo2-x) (values))
         $dv-foo2-x))
     ; make sure pattern variables and ellipses on RHS don't screw us up
     (eqv? (let ()
             (define-syntax q
               (lambda (x)
                 (syntax-case x ()
                   [(_ dots) (free-identifier=? #'dots #'(... ...)) 3])))
             (define-values (a) (q ...))
             a)
           3)
     (equal? (let ()
               (define-syntax q
                 (lambda (x)
                   (syntax-case x ()
                     [(_ dots) (free-identifier=? #'dots #'(... ...)) 3])))
               (define-values a (q ...))
               a)
             '(3))
     (equal? (let ()
               (define-syntax q
                 (lambda (x)
                   (syntax-case x ()
                     [(_ dots) (free-identifier=? #'dots #'(... ...)) 3])))
               (define-values (a . b) (q ...))
               (list a b))
             '(3 ()))
     (equal? (syntax-case '(a b c) ()
               [(x ...) (let () (define-values (args) #'(x ...)) args)])
             '(a b c))
     (equal? (syntax-case '(a b c) ()
               [(x ...)
                (let ()
                  (define-values (args . rot)
                    (values #'(x ...) #'(x ...) 3))
                  (list args rot))])
             '((a b c) ((a b c) 3)))
     (equal? (let ()
               (define x 1)
               (define-values ()
                 (begin
                   "don't interrupt definitions"
                   (values)))
               (define y 2)
               (list x y))
             '(1 2)))

(mat assimilation
     (syntax-case (parameterize
                    ([run-cp0 (lambda (cp0 x) (cp0 x))]
                     [#%$suppress-primitive-inlining #f]
                     [optimize-level 2])
                    (expand/optimize
                      '(letrec* ([x (let ([y 0])
                                      (lambda ()
                                        (set! y (- y 1))
                                        y))]
                                 [z (lambda () (x))])
                                (z)
                                (x)))) (lambda set! - $primitive)
       [(let ([y1 0]) (set! y2 (#2%- y3 1)) (set! y4 (#2%- y5 1)) y6) #t]
       [_ #f])
     (syntax-case (parameterize
                    ([run-cp0 (lambda (cp0 x) (cp0 x))]
                     [#%$suppress-primitive-inlining #f]
                     [optimize-level 2])
                    (expand/optimize
                      '(letrec ([x (let ([y 0])
                                     (lambda ()
                                       (set! y (- y 1))
                                       y))]
                                [z (lambda () (x))])
                         (z)
                         (x)))) (lambda set! - $primitive)
       [(let ([y1 0]) (set! y2 (#2%- y3 1)) (set! y4 (#2%- y5 1)) y6) #t]
       [_ #f])
     (syntax-case (parameterize
                    ([run-cp0 (lambda (cp0 x) (cp0 x))]
                     [#%$suppress-primitive-inlining #f]
                     [optimize-level 2])
                    (expand/optimize
                      '(letrec* ([w 15]
                                 [x (let ([y w])
                                      (lambda ()
                                        (set! y (- y 1))
                                        y))]
                                 [z (lambda () (x))])
                                (z)
                                (x)))) (lambda set! - $primitive)
       [(let ([y1 15]) (set! y2 (#2%- y3 1)) (set! y4 (#2%- y5 1)) y6) #t]
       [_ #f])
     (equal? (let ([f (letrec ([e? (lambda (x) (or (zero? x) (o? (- x 1))))]
                               [o? (lambda (x) (not (e? x)))])
                        (lambda (a b)
                          (vector (e? a) (e? b) (o? a) (o? b))))])
               (f 3 0))
             '#(#f #t #t #f))
     (equal? (let ([f (letrec ([q? (lambda (x) (not (p? x)))]
                               [p? (lambda (x) (> x 0))])
                        (lambda (a b)
                          (vector (p? a) (p? b) (q? a) (q? b))))])
               (f 3 -3))
             '#(#t #f #f #t))
     (equal? (let ([f (letrec* ([x 5] [y (+ x x)])
                        (lambda ()
                          (set! x (+ x y))
                          (set! y (+ y x))
                          (cons x y)))])
               (let ([t (f)]) (list t (f))))
             '((15 . 25) (40 . 65)))
     (equal? (letrec ([f (letrec* ([g (lambda (x)
                                        (lambda (y)
                                          (if (= x y)
                                              0
                                              (+ 2 (h (- y 1))))))]
                                   [x0 17]
                                   [h (g x0)])
                                  (lambda (y1 y2)
                                    (cons (h y1) (h y2))))])
               (list (f 20 25) (f 28 31)))
             '((6 . 16) (22 . 28)))
     (equal? (letrec ([f (letrec* ([g (lambda (n f)
                                        (if (= n 0)
                                            f
                                            (g (- n 1) (lambda (m) (f (+ m 1))))))]
                                   [q 7]
                                   [h (g q (lambda (x) (* x 2)))])
                                  (lambda (y1 y2 y3)
                                    (list (h y1) (h y2) ((g 5 values) 7))))])
               (vector (f 1 2 3) (f 4 5 6)))
             '#((16 18 12) (22 24 12)))
     (equal? (letrec ([f (letrec* ([g (values (lambda (n f)
                                                (if (= n 0)
                                                    f
                                                    (g (- n 1) (lambda (m)
                                                          (f (+ m 1)))))))]
                                   [q 7]
                                   [h (g q (lambda (x) (* x 2)))])
                                  (lambda (y1 y2 y3)
                                    (list (h y1) (h y2) ((g 5 values) 7))))])
               (vector (f 1 2 3) (f 4 5 6)))
             '#((16 18 12) (22 24 12)))
     (equal? (letrec ([f (letrec* ([g (lambda (n f)
                                        (if (= n 0)
                                            f
                                            (g (- n 1) (lambda (m) (f (+ m 1))))))] [g^ g] [g^^ g^])
                                  (lambda (y1 y2 y3)
                                    (when #f
                                          (set! g 0)
                                          (set! g^ 1)
                                          (set! g^^ 2))
                                    (list ((g y1 values) y2)
                                          ((g^ y2 (lambda (x) (* x x))) y3)
                                          ((g^^ y3 (lambda (x) (- x))) y1))))])
               (vector (f 1 2 3) (f 4 5 6)))
             '#((3 25 -4) (9 121 -10))))

(mat set!
     (begin (set! foo 'hello) (eq? foo 'hello))
     (let ([x 'a]) (set! x 'b) (eq? x 'b))
     (let ([x 'a])
       (let ([f (lambda () (set! x 'b))])
         (and (eq? x 'a) (begin (f) (eq? x 'b)))))
     ; test gensym set!/reference
     (equal? (begin (set! #0=#{a |pig|} '#0#) (set! #1=#{b |sty|} #0#) #1#)
             '#0#))

(mat fluid-let
     (fluid-let () #t)
     (eq? (fluid-let () (define x 4) x) 4)
     (let* ((x 'a) (f (lambda () x)))
       (and (fluid-let ((x 'b)) (and (eq? x 'b) (eq? (f) 'b)))
            (eq? x 'a)
            (eq? (f) 'a)))
     (let* ((x 'a) (f (lambda () x)))
       (and (call/cc
              (lambda (return)
                (fluid-let ((x 'b))
                  (return (and (eq? x 'b) (eq? (f) 'b))))))
            (eq? x 'a)
            (eq? (f) 'a)))
     (equal? (let* ((x 'a) (f (lambda () x)))
               ((call/cc
                  (lambda (return)
                    (fluid-let ((x 'b))
                      (call/cc
                        (lambda (back) (return back)))
                      (let ((ans (f)))
                        (lambda (y) (list ans x)))))) '()))
             '(b a))
     (eqv? (let ([x 75]) (fluid-let ([x 23] [x 23]) 0) x) 75))

;(mat variable
;   (eq? (fluid-let ([car 3])
;           ((parameterize ([optimize-level 2])
;               (eval '(lambda () car)))))
;        car)
;   (eq? (fluid-let ([car 3])
;           ((parameterize ([$compiling-system-code #t])
;               (eval '(lambda () car)))))
;        car)
;   (eq? ((parameterize ([$compiling-system-code #t])   
;            (eval '(lambda () $oblist))))
;        (parameterize ([$compiling-system-code #t])
;            (eval '$oblist)))
;   (error? ((parameterize ([optimize-level 2])
;               (eval '(lambda () (set! car 3))))))
; )

(mat mrvs
     (error? (values))
     (error? (if (values 1 2 3) 4 5))
     (error? (values 1 2 3))
     (eq? (values 2) 2)
     (eq? (let ((f (lambda () (values))))
            (+ 2 (call-with-values f (lambda () 5))))
          7)
     (error? (let ((f (lambda () (values)))) (+ 2 (f))))
     (eq? (call-with-values (lambda () (begin 5 (values 2 3)))
            (lambda (x y) (+ x y)))
          5)
     (error? (call-with-values (lambda () (begin 5 (values 2)))
               (lambda (x y) (+ x y))))
     (eq? (call-with-values (lambda () (begin 5 (values 1 2)))
            (lambda (x y) (+ x y)))
          3)
     (eq? (call-with-values (lambda () (values 2 3)) (lambda (x y) (+ x y)))
          5)
     (equal? (let ((f (lambda () (values 2 3)))
                   (g (lambda (x y) (cons x y))))
               (call-with-values f g))
             '(2 . 3))
     (eq? (let ((f (lambda () (lambda () (values 2 3)))) (g (lambda (x) x)))
            (call-with-values (call-with-values f g) +))
          5)
     (eq? (let ((f (lambda () (lambda () (values 2 3)))))
            (call-with-values (car (call-with-values f list)) +))
          5)
     (equal? (cons 1
                   (let ((f (lambda () (values 2 3))))
                     (call-with-values f list)))
             '(1 2 3))
     (eq? (let ((f (lambda (g h) (+ 1 (call-with-values g h)))))
            (f (lambda () (values 1 2)) (lambda (x y) (+ x y))))
          4)
     (eq? (let ((f (lambda (f g) (call-with-values f g))))
            (f (lambda () (call/cc (lambda (k) (values 5 k))))
               (lambda (x k) (if (= x 5) (k 0 k) 1))))
          1)
     (eq? (+ 2
             (call/cc
               (lambda (k)
                 (let ((f (lambda () (k 5))))
                   (call-with-values f list)))))
          7)
     (eq? (let ((f (lambda ()
                     (let ((f (lambda (f g) (call-with-values f g))))
                       (f (lambda () (call/cc (lambda (k) (values 0 k))))
                          (lambda (x k)
                            (call/cc (lambda (k1) (k 1 k1))))))))
                (g (lambda (x y) x)))
            (call-with-values f g))
          1)
     (bignum? (letrec ((f (lambda (x)
                            (if (= x 0)
                                (values 1 0 0)
                                (let ((g (lambda (u v w)
                                           (values (* x u) (+ v 1) (+ w 2)))))
                                  (call-with-values (lambda () (f (- x 1))) g))))))
                (let ((h (lambda (x y z) x)))
                  (call-with-values (lambda () (f 2000)) h))))
     (equal? (let ((h (lambda (x) (lambda (y z) (list x y z))))
                   (g (lambda (x) (lambda () (values x 3)))))
               (cons 0 (call-with-values (g 2) (h 1))))
             '(0 1 2 3))
     (eqv? (call-with-values
             (lambda () (apply values (make-list 1000 1)))
             +)
           1000)
     (equal? (call-with-values (lambda () (if (random 10) 2 3)) list) '(2))
     (equal? (call-with-values (case-lambda (x x) (() 3)) list) '(()))
     (eqv? (let ([f (lambda () (values 1 2 3))])
             (+ 2 (call-with-values f (lambda x (length x)))))
           5)
     (equal? (let ((x list)) (call-with-values (lambda () (set! x +) 3) x))
             '(3))
     (error? (call-with-values values (lambda (x) x)))
     (error? (call-with-values values (lambda (x y) x)))
     (error? (let ((f values)) (call-with-values f (lambda (x y) x))))
     (equal? (let ()
               (define f
                 (lambda (a b c)
                   (call-with-values (let ((x values)) (lambda () (x 1 2)))
                     (lambda (d e) (list a b c d e)))))
               (f 3 4 5))
             '(3 4 5 1 2))
     (eqv? (let ()
             (define f1 (lambda (x) (values 1 0)))
             (define f2
               (lambda (a)
                 (vector-ref a 0)
                 (call-with-values (lambda () (f1 a)) (lambda (d e) d))))
             (f2 '#(a)))
           1)
     (equal? (let ()
               (define f1
                 (lambda (x) (lambda () (values 1 2))))
               (define f2
                 (lambda (a)
                   (random 10)
                   (call-with-values (f1 a)
                     (lambda (x y) (random 20) (list a x y)))))
               (f2 0))
             '(0 1 2))
     (null? (call-with-values (lambda () (call/cc (lambda (k) (values))))
              (lambda args args)))
     (null? (call-with-values (lambda () (call/cc (lambda (k) (k))))
              (lambda args args)))
     (equal? (call-with-values
               (lambda ()
                 (call/cc (lambda (k) (k 'a 'b 'c))))
               (lambda args args))
             '(a b c))
     (equal? (call-with-values
               (lambda ()
                 (call/cc (lambda (k) (values 'a 'b 'c))))
               (lambda args args))
             '(a b c))
     (null? (call-with-values
              (lambda () (dynamic-wind values values values))
              list))
     (equal? (call-with-values
               (lambda ()
                 (call/cc
                   (lambda (k)
                     (values 1 2 3 4 5 6 7 8 9 10))))
               list)
             '(1 2 3 4 5 6 7 8 9 10))
     (eqv? (letrec ((z 2)
                    (f (lambda () (values 1 z)))
                    (g (lambda (x y) (values x y z))))
             (call-with-values
               (lambda ()
                 (call-with-values f (lambda (z b) (g z b))))
               (lambda (c d e) (+ c d e z))))
           7)
     (or (= (optimize-level) 3)
         (guard (c [(not (warning? c)) (collect) #t])
           (if (call-with-values current-output-port
                 (lambda (v out) (current-output-port)))
               1
               2)))
     (equal? (let ()
               (define split
                 (lambda (ls)
                   (if (or (null? ls) (null? (cdr ls)))
                       (values ls '())
                       (call-with-values (lambda () (split (cddr ls)))
                         (lambda (odds evens)
                           (values (cons (car ls) odds)
                                   (cons (cadr ls) evens)))))))
               (call-with-values (lambda () (split '(a b c d e f))) vector))
             '#((a c e) (b d f)))

     ; test chains of consumers
     (begin
       (define-syntax $mrvs-a
         (syntax-rules ()
           [(_) ($mrvs-f0)]
           [(_ f1 f2 ...)
            (let ([f1 (lambda (a b c d) (values d a b c))])
              (call-with-values (lambda () ($mrvs-a f2 ...)) f1))]))
       (define $mrvs-f0 (lambda () (values 1 2 3 4)))
       (define $mrvs-list (lambda args args))
       #t)

     ; test chains of consumers ending in a non-tail call
     (equal? (call-with-values (lambda () ($mrvs-a)) $mrvs-list) '(1 2 3 4))

     (equal? (call-with-values (lambda () ($mrvs-a f1)) $mrvs-list)
             '(4 1 2 3))

     (equal? (call-with-values (lambda () ($mrvs-a f1 f2 f3 f4)) $mrvs-list)
             '(1 2 3 4))

     ; test chains of consumers ending in a tail call
     (begin
       (define $mrvs-q
         (lambda ()
           (call-with-values (lambda () ($mrvs-a)) $mrvs-list)))
       #t)
     (equal? ($mrvs-q) '(1 2 3 4))

     (begin
       (define $mrvs-q
         (lambda ()
           (call-with-values (lambda () ($mrvs-a f1)) $mrvs-list)))
       #t)
     (equal? ($mrvs-q) '(4 1 2 3))

     (begin
       (define $mrvs-q
         (lambda ()
           (call-with-values (lambda () ($mrvs-a f1 f2 f3 f4)) $mrvs-list)))
       #t)
     (equal? ($mrvs-q) '(1 2 3 4))

     (begin
       (define $mrvs-q
         (lambda (foo)
           (call-with-values (lambda () ($mrvs-a f1 f2 f3)) foo)))
       #t)
     (equal? ($mrvs-q $mrvs-list) '(2 3 4 1))

     (begin
       (define $mrvs-q
         (lambda (foo)
           (lambda ()
             (call-with-values (lambda () ($mrvs-a f1 f2 f3)) foo))))
       #t)
     (equal? (($mrvs-q $mrvs-list)) '(2 3 4 1))

     ; test chains of consumers ending in a let-values
     (equal? (let-values ([(a . r) ($mrvs-a)]) (cons r a)) '((2 3 4) . 1))

     (equal? (let-values ([(a . r) ($mrvs-a f1)]) (cons r a))
             '((1 2 3) . 4))

     (equal? (let-values ([(a . r) ($mrvs-a f1 f2 f3 f4)]) (cons r a))
             '((2 3 4) . 1))

     ; test chains of consumers ending in a let-values-like call-with-values
     (equal? (call-with-values (lambda () ($mrvs-a))
               (lambda (a b . r) (cons* r b a)))
             '((3 4) 2 . 1))

     (equal? (call-with-values (lambda () ($mrvs-a f1))
               (lambda (a b . r) (cons* r b a)))
             '((2 3) 1 . 4))

     (equal? (call-with-values (lambda () ($mrvs-a f1 f2 f3 f4))
               (lambda (a b . r) (cons* r b a)))
             '((3 4) 2 . 1))

     ; test chains of consumers w/fi as free variables
     (begin
       (define-syntax $mrvs-a
         (syntax-rules ()
           [(_ f ...)
            (let ([x 17])
              (let ([f (lambda (y a b c d) (values x d a b c))] ...)
                (set! x (* x 4))
                (lambda () ($mrvs-b f ...))))]))
       (define-syntax $mrvs-b
         (syntax-rules ()
           [(_) ($mrvs-f0)]
           [(_ f1 f2 ...)
            (call-with-values (lambda () ($mrvs-b f2 ...)) f1)]))
       (define $mrvs-f0 (lambda () (values 0 1 2 3 4)))
       (define $mrvs-list (lambda args args))
       #t)

     ; test chains of consumers ending in a non-tail call
     (equal? (call-with-values (lambda () (($mrvs-a))) $mrvs-list)
             '(0 1 2 3 4))

     (equal? (call-with-values (lambda () (($mrvs-a f1))) $mrvs-list)
             '(68 4 1 2 3))

     (equal? (call-with-values
               (lambda () (($mrvs-a f1 f2 f3 f4)))
               $mrvs-list)
             '(68 1 2 3 4))

     ; test chains of consumers ending in a tail call
     (begin
       (define $mrvs-q
         (lambda ()
           (call-with-values (lambda () (($mrvs-a))) $mrvs-list)))
       #t)
     (equal? ($mrvs-q) '(0 1 2 3 4))

     (begin
       (define $mrvs-q
         (lambda ()
           (call-with-values (lambda () (($mrvs-a f1))) $mrvs-list)))
       #t)
     (equal? ($mrvs-q) '(68 4 1 2 3))

     (begin
       (define $mrvs-q
         (lambda ()
           (call-with-values (lambda () (($mrvs-a f1 f2 f3 f4))) $mrvs-list)))
       #t)
     (equal? ($mrvs-q) '(68 1 2 3 4))

     (begin
       (define $mrvs-q
         (lambda (foo)
           (call-with-values (lambda () (($mrvs-a f1 f2 f3))) foo)))
       #t)
     (equal? ($mrvs-q $mrvs-list) '(68 2 3 4 1))

     (begin
       (define $mrvs-q
         (lambda (foo)
           (lambda ()
             (call-with-values (lambda () (($mrvs-a f1 f2 f3))) foo))))
       #t)
     (equal? (($mrvs-q $mrvs-list)) '(68 2 3 4 1))

     ; test chains of consumers ending in a let-values
     (equal? (let-values ([(x a . r) (($mrvs-a))]) (cons* x r a))
             '(0 (2 3 4) . 1))

     (equal? (let-values ([(x a . r) (($mrvs-a f1))]) (cons* x r a))
             '(68 (1 2 3) . 4))

     (equal? (let-values ([(x a . r) (($mrvs-a f1 f2 f3 f4))])
               (cons* x r a))
             '(68 (2 3 4) . 1))

     ; test chains of consumers ending in a let-values-like call-with-values
     (equal? (call-with-values (lambda () (($mrvs-a)))
               (lambda (x a b . r) (cons* x r b a)))
             '(0 (3 4) 2 . 1))

     (equal? (call-with-values (lambda () (($mrvs-a f1)))
               (lambda (x a b . r) (cons* x r b a)))
             '(68 (2 3) 1 . 4))

     (equal? (call-with-values (lambda () (($mrvs-a f1 f2 f3 f4)))
               (lambda (x a b . r) (cons* x r b a)))
             '(68 (3 4) 2 . 1))

     (begin
       (define-syntax $mrvs-qcons (lambda (x) #`'#,cons))
       (define-syntax $mrvs-qvalues
         (lambda (x) #`'#,(lambda args (apply values args))))
       (define $mrvs-f (lambda () (values 1 2)))
       #t)

     (equal? (call-with-values (lambda () (values 1 2)) $mrvs-qcons)
             '(1 . 2))

     (equal? (let ([f (lambda () (values 1 2))])
               (call-with-values f $mrvs-qcons))
             '(1 . 2))

     (equal? (call-with-values $mrvs-f $mrvs-qcons) '(1 . 2))

     (equal? (call-with-values
               (lambda ()
                 (call-with-values $mrvs-f $mrvs-qvalues))
               $mrvs-qcons)
             '(1 . 2))

     (equal? (let ([f (lambda ()
                        (call-with-values
                          (lambda () (values 1 2))
                          $mrvs-qcons))])
               (f))
             '(1 . 2))

     (equal? (let ([f (lambda ()
                        (let ([f (lambda () (values 1 2))])
                          (call-with-values f $mrvs-qcons)))])
               (f))
             '(1 . 2))

     (equal? (let ([f (lambda () (call-with-values $mrvs-f $mrvs-qcons))])
               (f))
             '(1 . 2))

     (equal? (let ([f (lambda ()
                        (call-with-values
                          (lambda ()
                            (call-with-values $mrvs-f $mrvs-qvalues))
                          $mrvs-qcons))])
               (f))
             '(1 . 2))

     (equal? (letrec ((f (lambda (x) (values 7 8 9))))
               (let ((h list))
                 (call-with-values (lambda () (f 0)) h)))
             '(7 8 9))

     (equal? (let-values ([(a . b) (values 1 2 3)]) (cons b a))
             '((2 3) . 1))

     (equal? (let ([f (lambda (x) (values x (+ x 1)))])
               (let-values ([(a b) (f 3)]) (cons b a)))
             '(4 . 3))

     ; let-values inserts an "else" (effectively) clause---the following doesn't
     (equal? (let ([f (lambda (x) (values x (+ x 1)))])
               (call-with-values (lambda () (f 3))
                 (lambda (a b) (cons b a))))
             '(4 . 3))

     (equal? (let ([f (lambda (x) (values x (+ x 1)))]) (begin (f 3) 7)) 7)

     (equal? ((lambda (a . b) (cons b a)) 7 8 9) '((8 9) . 7))

     (equal? (call-with-values
               (lambda ()
                 (let ([f (lambda (x) (values x (+ x 1) (+ x 2)))] [g (lambda () 7)])
                   (call-with-values g f)))
               list*)
             '(7 8 . 9))

     (equal? (let ([q (lambda ()
                        (let ([f (lambda (x) (values x (+ x 1) (+ x 2)))] [g (lambda () 7)])
                          (call-with-values g f)))])
               (call-with-values q (lambda (a b c) (list c b a))))
             '(9 8 7))

     (equal? (let ([q (lambda ()
                        (let ([f (lambda (x y) (values x (+ x 1) (+ y 2)))]
                              [g (lambda () (values 7 8))])
                          (call-with-values g f)))])
               (call-with-values q (lambda (a b c) (list c b a))))
             '(10 8 7))
     (error? ; unbound variable $mrvs-foo
       (call-with-values
         (lambda () (set! $mrvs-foo list) (values 3 2 1))
         $mrvs-foo))
     (begin (define $mrvs-foo 17) #t)
     (error? ; attempt to call nonprocedure 17
       (call-with-values
         (lambda () (set! $mrvs-foo list) (values 3 2 1))
         $mrvs-foo))
     (begin (define $mrvs-foo vector) #t)
     (equal? (call-with-values
               (lambda ()
                 (set! $mrvs-foo list)
                 (values 3 2 1))
               $mrvs-foo)
             '#(3 2 1))
     (or (= (optimize-level) 3)
         (eqv? (let ([x 0] [f (lambda (x) (values 1 2))])
                 (guard (c [#t x])
                   (call-with-values (begin (set! x (+ x 3)) f)
                     (begin (set! x (+ x 7)) 'oops))))
               10))
     (or (= (optimize-level) 3)
         (eqv? (let ([x 0] [f (lambda (x y z) (list z y x))])
                 (guard (c [#t x])
                   (#2%call-with-values (begin (set! x (+ x 3)) 'oops)
                     (begin (set! x (+ x 7)) f))))
               10))

     ; testing of chains that do not get washed away into direct calls with mvlet
     (begin
       (define-syntax $mrvs-c
         (lambda (x)
           (define help
             (lambda (f* k)
               (if (null? f*)
                   (k #'($mrvs-f0))
                   (with-syntax ([f1 (car f*)])
                     #`(let ([f1 (lambda (a b c d) (values d a b c))])
                         ; using random to confuse cp0 until it gets smart enough to defeat this
                         (let ([f1 (if (eqv? (random 5) 10) #f f1)])
                           #,(help (cdr f*)
                                   (lambda (body)
                                     (k #`(call-with-values (lambda ()
                                                              #,body) f1))))))))))
           (syntax-case x ()
             [(_) #'($mrvs-f0)]
             [(_ f1 f2 ...) (help #'(f1 f2 ...) values)])))
       (define $mrvs-f0 (lambda () (values 1 2 3 4)))
       (define $mrvs-list (lambda args args))
       #t)

     ; test chains of consumers ending in a non-tail call
     (equal? (call-with-values (lambda () ($mrvs-c)) $mrvs-list) '(1 2 3 4))

     (equal? (call-with-values (lambda () ($mrvs-c f1)) $mrvs-list)
             '(4 1 2 3))

     (equal? (call-with-values (lambda () ($mrvs-c f1 f2 f3 f4)) $mrvs-list)
             '(1 2 3 4))

     ; test chains of consumers ending in a tail call
     (begin
       (define $mrvs-q
         (lambda ()
           (call-with-values (lambda () ($mrvs-c)) $mrvs-list)))
       #t)
     (equal? ($mrvs-q) '(1 2 3 4))

     (begin
       (define $mrvs-q
         (lambda ()
           (call-with-values (lambda () ($mrvs-c f1)) $mrvs-list)))
       #t)
     (equal? ($mrvs-q) '(4 1 2 3))

     (begin
       (define $mrvs-q
         (lambda ()
           (call-with-values (lambda () ($mrvs-c f1 f2 f3 f4)) $mrvs-list)))
       #t)
     (equal? ($mrvs-q) '(1 2 3 4))

     (begin
       (define $mrvs-q
         (lambda (foo)
           (call-with-values (lambda () ($mrvs-c f1 f2 f3)) foo)))
       #t)
     (equal? ($mrvs-q $mrvs-list) '(2 3 4 1))

     (begin
       (define $mrvs-q
         (lambda (foo)
           (lambda ()
             (call-with-values (lambda () ($mrvs-c f1 f2 f3)) foo))))
       #t)
     (equal? (($mrvs-q $mrvs-list)) '(2 3 4 1))

     ; test chains of consumers ending in a let-values
     (equal? (let-values ([(a . r) ($mrvs-c)]) (cons r a)) '((2 3 4) . 1))

     (equal? (let-values ([(a . r) ($mrvs-c f1)]) (cons r a))
             '((1 2 3) . 4))

     (equal? (let-values ([(a . r) ($mrvs-c f1 f2 f3 f4)]) (cons r a))
             '((2 3 4) . 1))

     ; test chains of consumers ending in a let-values-like call-with-values
     (equal? (call-with-values (lambda () ($mrvs-c))
               (lambda (a b . r) (cons* r b a)))
             '((3 4) 2 . 1))

     (equal? (call-with-values (lambda () ($mrvs-c f1))
               (lambda (a b . r) (cons* r b a)))
             '((2 3) 1 . 4))

     (equal? (call-with-values (lambda () ($mrvs-c f1 f2 f3 f4))
               (lambda (a b . r) (cons* r b a)))
             '((3 4) 2 . 1))

     ; test chains of consumers w/fi as free variables
     (begin
       (define-syntax $mrvs-c
         (syntax-rules ()
           [(_ f ...)
            (let ([x 17])
              (let ([f (lambda (y a b c d) (values x d a b c))] ...)
                (let ([f (if (eqv? (random 5) 10) #f f)] ...)
                  (set! x (* x 4))
                  (lambda () ($mrvs-d f ...)))))]))
       (define-syntax $mrvs-d
         (syntax-rules ()
           [(_) ($mrvs-f0)]
           [(_ f1 f2 ...)
            (call-with-values (lambda () ($mrvs-d f2 ...)) f1)]))
       (define $mrvs-f0 (lambda () (values 0 1 2 3 4)))
       (define $mrvs-list (lambda args args))
       #t)

     ; test chains of consumers ending in a non-tail call
     (equal? (call-with-values (lambda () (($mrvs-c))) $mrvs-list)
             '(0 1 2 3 4))

     (equal? (call-with-values (lambda () (($mrvs-c f1))) $mrvs-list)
             '(68 4 1 2 3))

     (equal? (call-with-values
               (lambda () (($mrvs-c f1 f2 f3 f4)))
               $mrvs-list)
             '(68 1 2 3 4))

     ; test chains of consumers ending in a tail call
     (begin
       (define $mrvs-q
         (lambda ()
           (call-with-values (lambda () (($mrvs-c))) $mrvs-list)))
       #t)
     (equal? ($mrvs-q) '(0 1 2 3 4))

     (begin
       (define $mrvs-q
         (lambda ()
           (call-with-values (lambda () (($mrvs-c f1))) $mrvs-list)))
       #t)
     (equal? ($mrvs-q) '(68 4 1 2 3))

     (begin
       (define $mrvs-q
         (lambda ()
           (call-with-values (lambda () (($mrvs-c f1 f2 f3 f4))) $mrvs-list)))
       #t)
     (equal? ($mrvs-q) '(68 1 2 3 4))

     (begin
       (define $mrvs-q
         (lambda (foo)
           (call-with-values (lambda () (($mrvs-c f1 f2 f3))) foo)))
       #t)
     (equal? ($mrvs-q $mrvs-list) '(68 2 3 4 1))

     (begin
       (define $mrvs-q
         (lambda (foo)
           (lambda ()
             (call-with-values (lambda () (($mrvs-c f1 f2 f3))) foo))))
       #t)
     (equal? (($mrvs-q $mrvs-list)) '(68 2 3 4 1))

     ; test chains of consumers ending in a let-values
     (equal? (let-values ([(x a . r) (($mrvs-c))]) (cons* x r a))
             '(0 (2 3 4) . 1))

     (equal? (let-values ([(x a . r) (($mrvs-c f1))]) (cons* x r a))
             '(68 (1 2 3) . 4))

     (equal? (let-values ([(x a . r) (($mrvs-c f1 f2 f3 f4))])
               (cons* x r a))
             '(68 (2 3 4) . 1))

     ; test chains of consumers ending in a let-values-like call-with-values
     (equal? (call-with-values (lambda () (($mrvs-c)))
               (lambda (x a b . r) (cons* x r b a)))
             '(0 (3 4) 2 . 1))

     (equal? (call-with-values (lambda () (($mrvs-c f1)))
               (lambda (x a b . r) (cons* x r b a)))
             '(68 (2 3) 1 . 4))

     (equal? (call-with-values (lambda () (($mrvs-c f1 f2 f3 f4)))
               (lambda (x a b . r) (cons* x r b a)))
             '(68 (3 4) 2 . 1))

     ; regression tests to make sure a bug in the compiler's handling of
     ; values in a single value context is properly handled in all cases
     (begin
       (module $mrvs-double-call
         (double-call)
         (define split
           (lambda (ls)
             (if (null? ls)
                 (values #f '())
                 (values #t (cdr ls)))))
         (define double-call
           (lambda (x)
             (let-values ([(x y) (split (split x))])
               (list y x)))))
       #t)

     (error? ; returned two values to single value return context
             (let ()
               (import $mrvs-double-call)
               (double-call '(a b))))

     (error? ; returned two values to single value return context
             (let ()
               (import $mrvs-double-call)
               (double-call '())))

     (error? ; a is not a pair
       (let () (import $mrvs-double-call) (double-call 'a)))

     ; regression testing for handling mvset in tail context
     (call-with-values
       (lambda ()
         (call-with-values (lambda () (+ (random 1) 7)) list))
       (lambda l (equal? l '((7)))))

     ; regression testing for handling mvset in predicate context
     (if (call-with-values
           (lambda ()
             (call-with-values (lambda () (+ (random 1) 7)) list))
           (lambda l (equal? l '((7)))))
         #t
         #f))

(mat let-values
     (error? (let-values))
     (error? (let-values ((x))))
     (error? (let-values ()))
     (error? (let-values (((x) 3))))
     (error? (let-values (((3) 4)) 5))
     (error? (let-values (((3 4) (values 1 2))) 5))
     (error? (let-values (((x . 3) (values 1 2 3))) x))
     (error? (let-values ((() (values 1 2))) 7))
     (error? (let-values (((x) (values 1 2))) x))
     (error? (let-values (((x y z) (values 1 2))) x))
     (error? (let-values (((x y z . w) (values 1 2))) x))
     (error? (let-values ((() 1)) 7))
     (error? (let-values (((x y) 1)) x))
     (error? (let-values (((x y z) 1)) x))
     (error? (let-values (((x y . w) 1)) x))
     (error? (let-values (((x x . w) (values 1 2 3))) (list x w)))
     (error? (let-values (((x y . w) (values 1 2 3)) [(x q) (values 4 5)])
               (list x w q)))
     (equal? (let-values (((x) 3)) x) 3)
     (equal? (let-values (((x y) (values 3 4))) (list x y)) '(3 4))
     (equal? (let-values (((x . y) (values 3 4))) (list x y)) '(3 (4)))
     (equal? (let-values ((x (values 3 4))) x) '(3 4))
     (equal? (let-values ((x 3)) x) '(3))
     (equal? (let-values (((x . y) (values 1 2 3)) ((z) (values 4)))
               (list x y z))
             '(1 (2 3) 4))
     (equal? (let ()
               (define split
                 (lambda (ls)
                   (if (or (null? ls) (null? (cdr ls)))
                       (values ls '())
                       (let-values (((odds evens) (split (cddr ls))))
                         (values (cons (car ls) odds)
                                 (cons (cadr ls) evens))))))
               (call-with-values (lambda () (split '(a b c d e f))) vector))
             '#((a c e) (b d f)))
     (equal? (let ()
               (define f
                 (lambda (a b c)
                   (let-values (((d e) (let ((x values)) (x 1 2))))
                     (list a b c d e))))
               (f 3 4 5))
             '(3 4 5 1 2))
     (equal? (let ()
               (define f1
                 (lambda (x)
                   (apply values (vector->list x))))
               (define f2
                 (lambda (a b)
                   (let-values
                     ([(d) (f1 a)]
                      [(e . f) (f1 b)]
                      [(g h i) (f1 b)]
                      [j (f1 b)])
                     (list d e f g h i j))))
               (f2 '#(a) '#(b c d)))
             '(a b (c d) b c d (b c d)))
     (eqv? (letrec ((z 2)
                    (f (lambda () (values 1 z)))
                    (g (lambda (x y) (values x y z))))
             (let-values ([(c d e) (let-values ([(z b) (f)]) (g z b))])
               (+ c d e z)))
           7)
     (equal? (let ([a 3])
               (let-values
                 ([(a b) (values (+ a 1) (+ a 2))] [(c) (values (+ a 3))])
                 (list a b c)))
             '(4 5 6))
     ; make sure pattern variables and ellipses on RHS don't screw us up
     (eqv? (let ()
             (define-syntax q
               (lambda (x)
                 (syntax-case x ()
                   [(_ dots) (free-identifier=? #'dots #'(... ...)) 3])))
             (let-values ([(a) (q ...)]) a))
           3)
     (equal? (syntax-case '(a b c) ()
               [(x ...) (let-values ([(args) #'(x ...)]) args)])
             '(a b c)))

(mat let*-values
     (error? (let*-values))
     (error? (let*-values ((x))))
     (error? (let*-values ()))
     (error? (let*-values (((x) 3))))
     (error? (let*-values (((3) 4)) 5))
     (error? (let*-values (((3 4) (values 1 2))) 5))
     (error? (let*-values (((x . 3) (values 1 2 3))) x))
     (error? (let*-values ((() (values 1 2))) 7))
     (error? (let*-values (((x) (values 1 2))) x))
     (error? (let*-values (((x y z) (values 1 2))) x))
     (error? (let*-values (((x y z . w) (values 1 2))) x))
     (error? (let*-values ((() 1)) 7))
     (error? (let*-values (((x y) 1)) x))
     (error? (let*-values (((x y z) 1)) x))
     (error? (let*-values (((x y . w) 1)) x))
     (error? (let*-values (((x x . w) (values 1 2 3))) (list x w)))
     (equal? (let*-values (((x) 3)) x) 3)
     (equal? (let*-values (((x y) (values 3 4))) (list x y)) '(3 4))
     (equal? (let*-values (((x . y) (values 3 4))) (list x y)) '(3 (4)))
     (equal? (let*-values ((x (values 3 4))) x) '(3 4))
     (equal? (let*-values ((x 3)) x) '(3))
     (equal? (let*-values (((x . y) (values 1 2 3)) ((z) (values 4)))
               (list x y z))
             '(1 (2 3) 4))
     (equal? (let ()
               (define split
                 (lambda (ls)
                   (if (or (null? ls) (null? (cdr ls)))
                       (values ls '())
                       (let*-values (((odds evens) (split (cddr ls))))
                         (values (cons (car ls) odds)
                                 (cons (cadr ls) evens))))))
               (call-with-values (lambda () (split '(a b c d e f))) vector))
             '#((a c e) (b d f)))
     (equal? (let ()
               (define f
                 (lambda (a b c)
                   (let*-values (((d e) (let ((x values)) (x 1 2))))
                     (list a b c d e))))
               (f 3 4 5))
             '(3 4 5 1 2))
     (equal? (let ()
               (define f1
                 (lambda (x)
                   (apply values (vector->list x))))
               (define f2
                 (lambda (a b)
                   (let*-values
                     ([(d) (f1 a)]
                      [(e . f) (f1 b)]
                      [(g h i) (f1 b)]
                      [j (f1 b)])
                     (list d e f g h i j))))
               (f2 '#(a) '#(b c d)))
             '(a b (c d) b c d (b c d)))
     (eqv? (letrec ((z 2)
                    (f (lambda () (values 1 z)))
                    (g (lambda (x y) (values x y z))))
             (let*-values ([(c d e) (let*-values ([(z b) (f)]) (g z b))])
               (+ c d e z)))
           7)
     (equal? (let ([a 3])
               (let*-values
                 ([(a b) (values (+ a 1) (+ a 2))] [(c) (values (+ a 3))])
                 (list a b c)))
             '(4 5 7))
     ; make sure pattern variables and ellipses on RHS don't screw us up
     (eqv? (let ()
             (define-syntax q
               (lambda (x)
                 (syntax-case x ()
                   [(_ dots) (free-identifier=? #'dots #'(... ...)) 3])))
             (let*-values ([(a) (q ...)]) a))
           3)
     (equal? (syntax-case '(a b c) ()
               [(x ...) (let*-values ([(args) #'(x ...)]) args)])
             '(a b c)))
;;; 5_3.ms
;;; Copyright 1984-2017 Cisco Systems, Inc.
;;; 
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;; 
;;; http://www.apache.org/licenses/LICENSE-2.0
;;; 
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

(mat number-syntax
     (eqv? 0 (- (most-positive-fixnum) (most-positive-fixnum)))
     (eqv? 3 (1+ (1+ (1+ 0))))
     (eqv? 9 (* 3 3))
     (eqv? 27 (* 3 9))
     (eqv? +99 99)
     (eqv? -99 (- 99))
     (eqv? -19683 (expt -27 3))
     (eqv? #e32 32)
     (eqv? #E-32 -32)
     (eqv? #12r-3b -47)
     (eqv? #12R3b 47)
     (eqv? #i+32 (inexact 32))
     (eqv? #I32 (inexact 32))
     (eqv? #b+101 5)
     (eqv? #B-101 -5)
     (eqv? #o-75 -61)
     (eqv? #O75 61)
     (eqv? #d91 91)
     (eqv? #D-91 -91)
     (eqv? #x-7f -127)
     (eqv? #X+7f 127)
     (eqv? #e#x-1e -30)
     (eqv? #i321 (inexact 321))
     (eqv? #i#b011 (inexact 3))
     (eqv? #e#o-76 -62)
     (eqv? #e#D+29 29)
     (eqv? #e#x-abcd -43981)
     (eqv? #i#32r+21 (inexact 65))
     (eqv? #i#32R-21 (inexact -65))
     (eqv? #20r#e10 20)
     (eqv? #x#iabc (inexact 2748))
     (eqv? .321 (inexact (/ 321 1000)))
     (eqv? -20/317 (/ 20 -317))
     (symbol? 'a)
     (symbol? '+)
     (eqv? +.91 .91)
     (eqv? -.257 (- .257))
     (symbol? '-a)
     (eqv? 98.21 (* .9821 100))
     (eqv? 98## 9800.0)
     (eqv? #e98## 9800)
     (eqv? 27e10 270000000000.0)
     (fl~= -1e-9 (- (/ 1e9)))
     (fl~= -1e-30 (- (/ 1e30)))
     (eqv? #e27e10 270000000000)
     (symbol? '1+)
     (eqv? 23. (inexact 23))
     (eqv? #e23. 23)
     (eqv? 2.e3 2000.)
     (eqv? 2s3 2000.)
     (eqv? 2.0f3 2000.)
     (eqv? 2.###d3 2000.)
     (eqv? 2#.#l2 2000.)
     (eqv? 2/1E3 2000.)
     (eqv? 1/5S4 2000.)
     (eqv? -1/5F4 -2000.)
     (eqv? .2D4 2000.)
     (eqv? 1##/5##L4 2000.)
     (symbol? '2.a)
     (eqv? 21#/2## (inexact 21/20))
     (symbol? '21##.321)
     (eqv? 21##e-2 21.)
     (symbol? '98##9)
     (symbol? '32/)
     (symbol? '32/#)
     (eqv? #i32/7 (inexact 32/7))
     (symbol? '32/23#0)
     (symbol? '...)
     (eqv? #e.231 231/1000)
     (eqv? #e.231## 231/1000)
     (eqv? #e21##.#### 2100)
     (symbol? '.231.)
     (eqv? 2.3#E-2 .023)
     (symbol? '-2.3e)
     (eqv? #I#10r-32############.#e-12 -32.0)
     (symbol? '-2/3ex)
     (symbol? '2.1e-)
     (symbol? '2e-1.0i)
     (eqv? #e2/3e4 20000/3)
     (symbol? '2.0e10a)
     (eqv? +1.0i (make-rectangular 0 1.0))
     (eqv? -1.0i (make-rectangular 0.0 -1))
     (eqv? +1i (make-rectangular 0 1))
     (eqv? -1i (make-rectangular 0 -1))
     (symbol? 'i)
     (eqv? -221.0i (make-rectangular 0.0 -221))
     (eqv? +201.0i (make-rectangular 0.0 201))
     (symbol? '201i)
     (eqv? 3.0+1.0i (make-rectangular 3 1.0))
     (eqv? -3-1.0i (make-rectangular -3.0 -1))
     (eqv? 3.2-2/3i (make-rectangular 3.2 (inexact -2/3)))
     (eqv? 1/2@1/3 (make-polar 1/2 1/3))
     (eqv? 3+1i (make-rectangular 3 1))
     (eqv? -3-1i (make-rectangular -3 -1))
     (eqv? 3/2-2/3i (make-rectangular 3/2 -2/3))
     (symbol? '2@3@4)
     (symbol? '2@3+4i)
     ; check for float read bug introduced into 3.0:
     (< -.039 -.038413 -.038))

(mat string->number
     ; error cases
     (error? (string->number 'a))
     (error? (string->number "a" 0))
     (error? (string->number "a" 37))
     (error? (string->number "a" 'a))
     (error? (string->number "a" 10 10))
     ; one argument case
     (not (string->number ""))
     (eqv? (string->number "0")
           (- (most-positive-fixnum) (most-positive-fixnum)))
     (eqv? (string->number "3") (1+ (1+ (1+ (string->number "0")))))
     (eqv? (string->number "9")
           (* (string->number "3") (string->number "3")))
     (eqv? (string->number "27")
           (* (string->number "3") (string->number "9")))
     (eqv? (string->number "+99") (string->number "99"))
     (eqv? (string->number "-99") (- (string->number "99")))
     (eqv? (string->number "-19683") (expt (string->number "-27") 3))
     (eqv? (string->number "#e32") (string->number "32"))
     (eqv? (string->number "#E-32") (string->number "-32"))
     (not (string->number "#"))
     (eqv? (string->number "#12r-3b") (string->number "-47"))
     (eqv? (string->number "#12R3b") (string->number "47"))
     (eqv? (string->number "#i+32") (inexact (string->number "32")))
     (eqv? (string->number "#I32") (inexact (string->number "32")))
     (eqv? (string->number "#b+101") (string->number "5"))
     (eqv? (string->number "#B-101") (string->number "-5"))
     (eqv? (string->number "#o-75") (string->number "-61"))
     (eqv? (string->number "#O75") (string->number "61"))
     (eqv? (string->number "#d91") (string->number "91"))
     (eqv? (string->number "#D-91") (string->number "-91"))
     (eqv? (string->number "#x-7f") (string->number "-127"))
     (eqv? (string->number "#X+7f") (string->number "127"))
     (not (string->number "#a"))
     (not (string->number "#32"))
     (not (string->number "#32="))
     (not (string->number "#47r0"))
     (not (string->number "#110r0"))
     (not (string->number "#e"))
     (eqv? (string->number "#e#x-1e") (string->number "-30"))
     (eqv? (string->number "#i321") (inexact (string->number "321")))
     (not (string->number "#e#"))
     (eqv? (string->number "#i#b011") (inexact (string->number "3")))
     (eqv? (string->number "#e#o-76") (string->number "-62"))
     (eqv? (string->number "#e#D+29") (string->number "29"))
     (eqv? (string->number "#e#x-abcd") (string->number "-43981"))
     (not (string->number "#e#*"))
     (not (string->number "#i#32"))
     (eqv? (string->number "#i#32r+21") (inexact (string->number "65")))
     (eqv? (string->number "#i#32R-21") (inexact (string->number "-65")))
     (not (string->number "#i#321r"))
     (not (string->number "#e#39r"))
     (not (string->number "#20r"))
     (eqv? (string->number "#20r#e10") (string->number "20"))
     (not (string->number "#20r#"))
     (eqv? (string->number "#x#iabc") (inexact (string->number "2748")))
     (not (string->number "#x##"))
     (not (string->number "#e#x"))
     (eqv? (string->number ".321")
           (inexact (/ (string->number "321") (string->number "1000"))))
     (eqv? (string->number "-20/317")
           (/ (string->number "20") (string->number "-317")))
     (not (string->number "a"))
     (not (string->number "+"))
     (eqv? (string->number "+.91") (string->number ".91"))
     (eqv? (string->number "-.257") (- (string->number ".257")))
     (not (string->number "-a"))
     (eqv? (string->number "98.21")
           (* (string->number ".9821") (string->number "100")))
     (eqv? (string->number "98##") (string->number "9800.0"))
     (eqv? (string->number "#e98##") (string->number "9800"))
     (eqv? (string->number "27e10") (string->number "270000000000.0"))
     (eqv? (string->number "#e27e10") (string->number "270000000000"))
     (not (string->number "1+"))
     (eqv? (string->number "23.") (inexact (string->number "23")))
     (eqv? (string->number "#e23.") (string->number "23"))
     (eqv? (string->number "2.e3") (string->number "2000."))
     (eqv? (string->number "2s3") (string->number "2000."))
     (eqv? (string->number "2.0f3") (string->number "2000."))
     (eqv? (string->number "2.###d3") (string->number "2000."))
     (eqv? (string->number "2#.#l2") (string->number "2000."))
     (eqv? (string->number "2/1E3") (string->number "2000."))
     (eqv? (string->number "1/5S4") (string->number "2000."))
     (eqv? (string->number "-1/5F4") (string->number "-2000."))
     (eqv? (string->number ".2D4") (string->number "2000."))
     (eqv? (string->number "1##/5##L4") (string->number "2000."))
     (not (string->number "2.a"))
     (eqv? (string->number "21#/2##") (inexact (string->number "21/20")))
     (not (string->number "21##.321"))
     (eqv? (string->number "21##e-2") (string->number "21."))
     (not (string->number "98##9"))
     (not (string->number "32/"))
     (not (string->number "32/#"))
     (eqv? (string->number "#i32/7") (inexact (string->number "32/7")))
     (not (string->number "32/23#0"))
     (not (string->number "."))
     (not (string->number "..."))
     (eqv? (string->number "#e.231") (string->number "231/1000"))
     (eqv? (string->number "#e.231##") (string->number "231/1000"))
     (eqv? (string->number "#e21##.####") (string->number "2100"))
     (not (string->number ".231."))
     (eqv? (string->number "2.3#E-2") (string->number ".023"))
     (not (string->number "-2.3e"))
     (eqv? (string->number "#I#10r-32############.#e-12")
           (string->number "-32.0"))
     (not (string->number "-2/3ex"))
     (not (string->number "2.1e-"))
     (not (string->number "2e-i"))
     (eqv? (string->number "#e2/3e4") (string->number "20000/3"))
     (not (string->number "2.0e10a"))
     ; complex cases
     (equal? (string->number "+i") +i)
     (equal? (string->number "-i") -i)
     (not (string->number "i"))
     (equal? (string->number "-221i") -221i)
     (equal? (string->number "+201i") +201i)
     (not (string->number "201i"))
     (equal? (string->number "3+i") 3+i)
     (equal? (string->number "-3+i") -3+i)
     (equal? (string->number "3.2-2/3i") 3.2-2/3i)
     (equal? (string->number "1/2@1/2") 1/2@1/2)
     (not (string->number "2@3@4"))
     (not (string->number "2@3+4i"))
     ; two argument case
     (eqv? (string->number "+101" 2) (string->number "5"))
     (eqv? (string->number "#B-101" 7) (string->number "-5"))
     (eqv? (string->number "-75" 8) (string->number "-61"))
     (eqv? (string->number "#O75" 10) (string->number "61"))
     (eqv? (string->number "91" 10) (string->number "91"))
     (eqv? (string->number "#D-91" 16) (string->number "-91"))
     (eqv? (string->number "-7f" 16) (string->number "-127"))
     (eqv? (string->number "#X+7f" 35) (string->number "127"))
     (eqv? (string->number "22" 35) (string->number "72"))
     (eqv? (string->number "#35r22" 17) (string->number "72"))

     ; getting division by zero right
     (eqv? (string->number "0/0") #f)
     (== (string->number "0/0#") +nan.0)
     (eqv? (string->number "0#/0") #f)
     (== (string->number "0/0e20") +nan.0)
     (== (string->number "0/0#e20") +nan.0)
     (== (string->number "0#/0#") +nan.0)
     (== (string->number "#i0/0") +nan.0)
     (== (string->number "#i0/0#") +nan.0)
     (== (string->number "#i0#/0") +nan.0)
     (== (string->number "#i0#/0#") +nan.0)
     (== (string->number "#i0/0e20") +nan.0)
     (== (string->number "#i0/0#e20") +nan.0)
     (eqv? (string->number "#e0/0") #f)
     (eqv? (string->number "#e0/0#") #f)
     (eqv? (string->number "#e0#/0") #f)
     (eqv? (string->number "#e0#/0#") #f)
     (eqv? (string->number "#e0/0e20") #f)
     (eqv? (string->number "#e0/0#e20") #f)
     (eqv? (string->number "1/0") #f)
     (eqv? (string->number "1/0#") +inf.0)
     (eqv? (string->number "1#/0") #f)
     (eqv? (string->number "1#/0#") +inf.0)
     (eqv? (string->number "#i1/0") +inf.0)
     (eqv? (string->number "#i1/0#") +inf.0)
     (eqv? (string->number "#i1#/0") +inf.0)
     (eqv? (string->number "#i1#/0#") +inf.0)
     (eqv? (string->number "#e1/0") #f)
     (eqv? (string->number "#e1/0#") #f)
     (eqv? (string->number "#e1#/0") #f)
     (eqv? (string->number "#e1#/0#") #f)
     (eqv? (string->number "1/0+1.0i") #f)
     (eqv? (string->number "1.0+1/0i") #f)
     (== (string->number "1/0###+0/0###i") +inf.0+nan.0i)
     (== (string->number "0/0###+1/0###i") +nan.0+inf.0i)
     (== (string->number "0###/0###+1/0###i") +nan.0+inf.0i)
     (eqv? (string->number "#e1e1000") (expt 10 1000))
     (eqv? (string->number "#e1#e1000") (expt 10 1001))

     ; same set, with minus signs
     (eqv? (string->number "-0/0") #f)
     (== (string->number "-0/0#") +nan.0)
     (eqv? (string->number "-0#/0") #f)
     (== (string->number "-0#/0#") +nan.0)
     (== (string->number "#i-0/0") +nan.0)
     (== (string->number "#i-0/0#") +nan.0)
     (== (string->number "#i-0#/0") +nan.0)
     (== (string->number "#i-0#/0#") +nan.0)
     (eqv? (string->number "#e-0/0") #f)
     (eqv? (string->number "#e-0/0#") #f)
     (eqv? (string->number "#e-0#/0") #f)
     (eqv? (string->number "#e-0#/0#") #f)
     (eqv? (string->number "-1/0") #f)
     (eqv? (string->number "-1/0#") -inf.0)
     (eqv? (string->number "-1#/0") #f)
     (eqv? (string->number "-1#/0#") -inf.0)
     (eqv? (string->number "#i-1/0") -inf.0)
     (eqv? (string->number "#i-1/0#") -inf.0)
     (eqv? (string->number "#i-1#/0") -inf.0)
     (eqv? (string->number "#i-1#/0#") -inf.0)
     (eqv? (string->number "#e-1/0") #f)
     (eqv? (string->number "#e-1/0#") #f)
     (eqv? (string->number "#e-1#/0") #f)
     (eqv? (string->number "#e-1#/0#") #f)
     (eqv? (string->number "-1/0+1.0i") #f)
     (eqv? (string->number "1.0-1/0i") #f)
     (== (string->number "-1/0###-0/0###i") -inf.0+nan.0i)
     (== (string->number "-0/0###-1/0###i") +nan.0-inf.0i)
     (== (string->number "-0###/0###-1/0###i") +nan.0-inf.0i)
     (eqv? (string->number "#e-1e1000") (- (expt 10 1000)))
     (eqv? (string->number "#e-1#e1000") (- (expt 10 1001)))

     ; same set, with plus signs
     (eqv? (string->number "+0/0") #f)
     (== (string->number "+0/0#") +nan.0)
     (eqv? (string->number "+0#/0") #f)
     (== (string->number "+0#/0#") +nan.0)
     (== (string->number "#i+0/0") +nan.0)
     (== (string->number "#i+0/0#") +nan.0)
     (== (string->number "#i+0#/0") +nan.0)
     (== (string->number "#i+0#/0#") +nan.0)
     (eqv? (string->number "#e+0/0") #f)
     (eqv? (string->number "#e+0/0#") #f)
     (eqv? (string->number "#e+0#/0") #f)
     (eqv? (string->number "#e+0#/0#") #f)
     (eqv? (string->number "+1/0") #f)
     (eqv? (string->number "+1/0#") +inf.0)
     (eqv? (string->number "+1#/0") #f)
     (eqv? (string->number "+1#/0#") +inf.0)
     (eqv? (string->number "#i+1/0") +inf.0)
     (eqv? (string->number "#i+1/0#") +inf.0)
     (eqv? (string->number "#i+1#/0") +inf.0)
     (eqv? (string->number "#i+1#/0#") +inf.0)
     (eqv? (string->number "#e+1/0") #f)
     (eqv? (string->number "#e+1/0#") #f)
     (eqv? (string->number "#e+1#/0") #f)
     (eqv? (string->number "#e+1#/0#") #f)
     (eqv? (string->number "+1/0+1.0i") #f)
     (eqv? (string->number "1.0+1/0i") #f)
     (== (string->number "+1/0###+0/0###i") +inf.0+nan.0i)
     (== (string->number "+0/0###+1/0###i") +nan.0+inf.0i)
     (== (string->number "+0###/0###+1/0###i") +nan.0+inf.0i)
     (eqv? (string->number "#e+1e1000") (expt 10 1000))
     (eqv? (string->number "#e+1#e1000") (expt 10 1001))

     ; misc. similar tests
     (eqv? (string->number "1/0000") #f)
     (eqv? (string->number "-1/0000") #f)
     (eqv? (string->number "#e-1/0000") #f)
     (eqv? (string->number "#i-1/0000") -inf.0)
     (eqv? (string->number "#e1/0###") #f)
     (eqv? (string->number "#e-1/0###") #f)
     (eqv? (string->number "1/0###") +inf.0)
     (eqv? (string->number "-1/0###") -inf.0)

     (eqv? (string->number "1###/0") #f)
     (eqv? (string->number "-1###/0") #f)
     (eqv? (string->number "-1###/0###") -inf.0)

     (eqv? (string->number "0/0000") #f)
     (eqv? (string->number "-0/0000") #f)
     (eqv? (string->number "#e-0/0000") #f)
     (== (string->number "#i-0/0000") +nan.0)
     (eqv? (string->number "#e0/0###") #f)
     (eqv? (string->number "#e-0/0###") #f)
     (== (string->number "0/0###") +nan.0)
     (== (string->number "-0/0###") +nan.0)

     (== (string->number "0/0e10") +nan.0)
     (== (string->number "#i0/0e10") +nan.0)
     (== (string->number "0/0###e10") +nan.0)
     (eqv? (string->number "1/0e10") +inf.0)
     (eqv? (string->number "#i1/0e10") +inf.0)
     (eqv? (string->number "1/0###e10") +inf.0)
     (eqv? (string->number "-1/0e10") -inf.0)
     (eqv? (string->number "#i-1/0e10") -inf.0)
     (eqv? (string->number "-1/0###e10") -inf.0)

     (eqv? (string->number "-1/2e10000") -inf.0)
     (eqv? (string->number "1/2e10000") +inf.0)
     (eqv? (string->number "#e-1/2e10000") (* -1/2 (expt 10 10000)))
     (eqv? (string->number "#e1/2e10000") (* 1/2 (expt 10 10000)))

     (eqv? (string->number "0e25") 0.0)
     (eqv? (string->number "-0e25") -0.0)
     (eqv? (string->number "0/1e25") 0.0)
     (eqv? (string->number "-0/1e25") -0.0)

     ; can't have no exact nans and infinities
     (eqv? (string->number "#e+nan.0") #f)
     (eqv? (string->number "#e+inf.0") #f)
     (eqv? (string->number "#e-inf.0") #f)

     ; don't make no sense
     (eqv? (string->number "3@4i") #f)
     (eqv? (string->number "3@-i") #f)

     ; zero with large exponent
     (eqv? (string->number "0.0e3000") 0.0)
     (eqv? (string->number "-0.0e3000") -0.0)

     ; exact polar complex numbers.  r6rs says anything w/o radix point, exponent sign, or precision is exact.
     ; we also include polar numbers w/o #e prefix that can't be represented exactly
     (eqv? (string->number "0@0") 0)
     (eqv? (string->number "1@0") 1)
     (eqv? (string->number "0@1") 0)
     (eqv? (string->number "1@1") (string->number "1.0@1.0"))
     (not (string->number "#e1@1"))
     (eqv? (string->number "#i1@1") (make-polar 1.0 1.0))
     (eqv? (string->number "1.0@1") (make-polar 1.0 1.0))
     (eqv? (string->number "1@1.0") (make-polar 1.0 1.0))
     (eqv? (string->number "1.0@1.0") (make-polar 1.0 1.0))

     ; filling in some cases shown missing by profiling
     (eqv? (string->number "1e-5000000000") 0.0)
     (eqv? (string->number "-1e-5000000000") -0.0)
     (eqv? (string->number "#e0e2000") 0)
     (eqv? (string->number "#e0e-2000") 0)
     (eqv? (string->number "1/0@5") #f)
     (eqv? (string->number "1/0+5") #f)
     (eqv? (string->number "#e1e20@0") (expt 10 20))
     (eqv? (string->number "+1/0+5i") #f)
     (eqv? (string->number "-1/0+5i") #f)
     (eqv? (string->number "+1/0i") #f)
     (eqv? (string->number "-1/0i") #f)
     (eqv? (string->number "#e+inf.0+1i") #f)
     (eqv? (string->number "1|21") 1.0)
     (eqv? (string->number "1.5|21") 1.5)
     (eqv? (string->number "1.5e2|21") 150.)
     (eqv? (string->number "1.5e2|21+2i") 150.0+2.0i)
     (eqv? (string->number "1.5e2|") #f)
     (eqv? (string->number "1.5e2@") #f)
     (eqv? (string->number "1.5e2@.5") (make-polar 1.5e2 .5))
     (eqv? (string->number "1.5e2@+.5") (make-polar 1.5e2 .5))
     (eqv? (string->number "1.5e2@-.5") (make-polar 1.5e2 -.5))
     (eqv? (string->number "+in") #f)
     (eqv? (string->number "+inf") #f)
     (eqv? (string->number "+inf.") #f)
     (eqv? (string->number "-in") #f)
     (eqv? (string->number "-inf") #f)
     (eqv? (string->number "-inf.") #f)
     (eqv? (string->number "+n") #f)
     (eqv? (string->number "+na") #f)
     (eqv? (string->number "+nan") #f)
     (eqv? (string->number "+nan.") #f)
     (eqv? (string->number "-n") #f)
     (eqv? (string->number "-na") #f)
     (eqv? (string->number "-nan") #f)
     (eqv? (string->number "-nan.") #f))

(mat r6rs:string->number
     ; error cases
     (error? (r6rs:string->number 'a))
     (error? (r6rs:string->number "a" 0))
     (error? (r6rs:string->number "a" 37))
     (error? (r6rs:string->number "a" 3))
     (error? (r6rs:string->number "a" 4))
     (error? (r6rs:string->number "a" 12))
     (error? (r6rs:string->number "a" 20))
     (error? (r6rs:string->number "a" 32))
     (error? (r6rs:string->number "a" 36))
     (error? (r6rs:string->number "a" 'a))
     (error? (r6rs:string->number "a" 10 10))

     ; r6rs number syntax doesn't have # digits
     (not (r6rs:string->number "-1/0###e10"))
     (not (r6rs:string->number "1###"))
     (not (r6rs:string->number "1/3###"))
     (not (r6rs:string->number "1.3###"))
     (not (r6rs:string->number ".1###"))
     (not (r6rs:string->number "1#e17"))
     (not (r6rs:string->number "98##"))
     (not (r6rs:string->number "#e98##"))
     (not (r6rs:string->number "#12r-3b"))
     (not (r6rs:string->number "#12R3b"))
     (not (r6rs:string->number "#i#32r+21"))
     (not (r6rs:string->number "#i#32R-21"))
     (not (r6rs:string->number "#20r#e10"))
     (not (r6rs:string->number "2.###d3"))
     (not (r6rs:string->number "2#.#l2"))
     (not (r6rs:string->number "1##/5##L4"))
     (not (r6rs:string->number "21#/2##"))
     (not (r6rs:string->number "21##e-2"))
     (not (r6rs:string->number "#e.231##"))
     (not (r6rs:string->number "#e21##.####"))
     (not (r6rs:string->number "2.3#E-2"))
     (not (r6rs:string->number "#I#10r-32############.#e-12"))

     ; one argument case
     (not (r6rs:string->number ""))
     (eqv? (r6rs:string->number "0")
           (- (most-positive-fixnum) (most-positive-fixnum)))
     (eqv? (r6rs:string->number "3") (1+ (1+ (1+ (string->number "0")))))
     (eqv? (r6rs:string->number "9")
           (* (string->number "3") (string->number "3")))
     (eqv? (r6rs:string->number "27")
           (* (string->number "3") (string->number "9")))
     (eqv? (r6rs:string->number "+99") (string->number "99"))
     (eqv? (r6rs:string->number "-99") (- (string->number "99")))
     (eqv? (r6rs:string->number "-19683") (expt (string->number "-27") 3))
     (eqv? (r6rs:string->number "#e32") (string->number "32"))
     (eqv? (r6rs:string->number "#E-32") (string->number "-32"))
     (not (r6rs:string->number "#"))
     (eqv? (r6rs:string->number "#i+32") (inexact (string->number "32")))
     (eqv? (r6rs:string->number "#I32") (inexact (string->number "32")))
     (eqv? (r6rs:string->number "#b+101") (string->number "5"))
     (eqv? (r6rs:string->number "#B-101") (string->number "-5"))
     (eqv? (r6rs:string->number "#o-75") (string->number "-61"))
     (eqv? (r6rs:string->number "#O75") (string->number "61"))
     (eqv? (r6rs:string->number "#d91") (string->number "91"))
     (eqv? (r6rs:string->number "#D-91") (string->number "-91"))
     (eqv? (r6rs:string->number "#x-7f") (string->number "-127"))
     (eqv? (r6rs:string->number "#X+7f") (string->number "127"))
     (not (r6rs:string->number "#a"))
     (not (r6rs:string->number "#32"))
     (not (r6rs:string->number "#32="))
     (not (r6rs:string->number "#47r0"))
     (not (r6rs:string->number "#110r0"))
     (not (r6rs:string->number "#e"))
     (eqv? (r6rs:string->number "#e#x-1e") (string->number "-30"))
     (eqv? (r6rs:string->number "#i321") (inexact (string->number "321")))
     (not (r6rs:string->number "#e#"))
     (eqv? (r6rs:string->number "#i#b011") (inexact (string->number "3")))
     (eqv? (r6rs:string->number "#e#o-76") (string->number "-62"))
     (eqv? (r6rs:string->number "#e#D+29") (string->number "29"))
     (eqv? (r6rs:string->number "#e#x-abcd") (string->number "-43981"))
     (not (r6rs:string->number "#e#*"))
     (not (r6rs:string->number "#i#32"))
     (not (r6rs:string->number "#i#321r"))
     (not (r6rs:string->number "#e#39r"))
     (not (r6rs:string->number "#20r"))
     (not (r6rs:string->number "#20r#"))
     (eqv? (r6rs:string->number "#x#iabc")
           (inexact (string->number "2748")))
     (not (r6rs:string->number "#x##"))
     (not (r6rs:string->number "#e#x"))
     (eqv? (r6rs:string->number ".321")
           (inexact (/ (r6rs:string->number "321") (string->number "1000"))))
     (eqv? (r6rs:string->number "-20/317")
           (/ (r6rs:string->number "20") (string->number "-317")))
     (not (r6rs:string->number "a"))
     (not (r6rs:string->number "+"))
     (eqv? (r6rs:string->number "+.91") (string->number ".91"))
     (eqv? (r6rs:string->number "-.257") (- (string->number ".257")))
     (not (r6rs:string->number "-a"))
     (eqv? (r6rs:string->number "98.21")
           (* (r6rs:string->number ".9821") (string->number "100")))
     (eqv? (r6rs:string->number "27e10") (string->number "270000000000.0"))
     (eqv? (r6rs:string->number "#e27e10") (string->number "270000000000"))
     (not (r6rs:string->number "1+"))
     (eqv? (r6rs:string->number "23.") (inexact (string->number "23")))
     (eqv? (r6rs:string->number "#e23.") (string->number "23"))
     (eqv? (r6rs:string->number "2.e3") (string->number "2000."))
     (eqv? (r6rs:string->number "2s3") (string->number "2000."))
     (eqv? (r6rs:string->number "2.0f3") (string->number "2000."))
     (eqv? (r6rs:string->number "2/1E3") #f)
     (eqv? (r6rs:string->number "1/5S4") #f)
     (eqv? (r6rs:string->number "-1/5F4") #f)
     (eqv? (r6rs:string->number ".2D4") (string->number "2000."))
     (not (r6rs:string->number "2.a"))
     (not (r6rs:string->number "21##.321"))
     (not (r6rs:string->number "98##9"))
     (not (r6rs:string->number "32/"))
     (not (r6rs:string->number "32/#"))
     (eqv? (r6rs:string->number "#i32/7")
           (inexact (string->number "32/7")))
     (not (r6rs:string->number "32/23#0"))
     (not (r6rs:string->number "."))
     (not (r6rs:string->number "..."))
     (eqv? (r6rs:string->number "#e.231") (string->number "231/1000"))
     (not (r6rs:string->number ".231."))
     (not (r6rs:string->number "-2.3e"))
     (not (r6rs:string->number "-2/3ex"))
     (not (r6rs:string->number "2.1e-"))
     (not (r6rs:string->number "2e-i"))
     (eqv? (r6rs:string->number "#e2/3e4") #f)
     (not (r6rs:string->number "2.0e10a"))
     ; complex cases
     (equal? (r6rs:string->number "+i") +i)
     (equal? (r6rs:string->number "-i") -i)
     (not (r6rs:string->number "i"))
     (equal? (r6rs:string->number "-221i") -221i)
     (equal? (r6rs:string->number "+201i") +201i)
     (not (r6rs:string->number "201i"))
     (equal? (r6rs:string->number "3+i") 3+i)
     (equal? (r6rs:string->number "-3+i") -3+i)
     (equal? (r6rs:string->number "3.2-2/3i") 3.2-2/3i)
     (equal? (r6rs:string->number "1/2@1/2") 1/2@1/2)
     (not (r6rs:string->number "2@3@4"))
     (not (r6rs:string->number "2@3+4i"))
     ; two argument case
     (eqv? (r6rs:string->number "+101" 2) (string->number "5"))
     (eqv? (r6rs:string->number "-75" 8) (string->number "-61"))
     (eqv? (r6rs:string->number "#O75" 10) (string->number "61"))
     (eqv? (r6rs:string->number "91" 10) (string->number "91"))
     (eqv? (r6rs:string->number "#D-91" 16) (string->number "-91"))
     (eqv? (r6rs:string->number "-7f" 16) (string->number "-127"))

     ; getting division by zero right
     (eqv? (r6rs:string->number "0/0") #f)
     (== (r6rs:string->number "#i0/0") +nan.0)
     (eqv? (r6rs:string->number "#e0/0") #f)
     (eqv? (r6rs:string->number "1/0") #f)
     (eqv? (r6rs:string->number "1#/0") #f)
     (eqv? (r6rs:string->number "#i1/0") +inf.0)
     (eqv? (r6rs:string->number "#e1/0") #f)
     (eqv? (r6rs:string->number "1/0+1.0i") #f)
     (eqv? (r6rs:string->number "1.0+1/0i") #f)
     (eqv? (r6rs:string->number "#e1e1000") (expt 10 1000))

     ; same set, with minus signs
     (eqv? (r6rs:string->number "-0/0") #f)
     (== (r6rs:string->number "#i-0/0") +nan.0)
     (eqv? (r6rs:string->number "#e-0/0") #f)
     (eqv? (r6rs:string->number "-1/0") #f)
     (eqv? (r6rs:string->number "#i-1/0") -inf.0)
     (eqv? (r6rs:string->number "#e-1/0") #f)
     (eqv? (r6rs:string->number "-1/0+1.0i") #f)
     (eqv? (r6rs:string->number "1.0-1/0i") #f)
     (eqv? (r6rs:string->number "#e-1e1000") (- (expt 10 1000)))

     ; same set, with plus signs
     (eqv? (r6rs:string->number "+0/0") #f)
     (== (r6rs:string->number "#i+0/0") +nan.0)
     (eqv? (r6rs:string->number "#e+0/0") #f)
     (eqv? (r6rs:string->number "+1/0") #f)
     (eqv? (r6rs:string->number "#i+1/0") +inf.0)
     (eqv? (r6rs:string->number "#e+1/0") #f)
     (eqv? (r6rs:string->number "+1/0+1.0i") #f)
     (eqv? (r6rs:string->number "1.0+1/0i") #f)
     (eqv? (r6rs:string->number "#e+1e1000") (expt 10 1000))

     ; misc. similar tests
     (eqv? (r6rs:string->number "1/0000") #f)
     (eqv? (r6rs:string->number "-1/0000") #f)
     (eqv? (r6rs:string->number "#e-1/0000") #f)
     (eqv? (r6rs:string->number "#i-1/0000") -inf.0)


     (eqv? (r6rs:string->number "0/0000") #f)
     (eqv? (r6rs:string->number "-0/0000") #f)
     (eqv? (r6rs:string->number "#e-0/0000") #f)
     (== (r6rs:string->number "#i-0/0000") +nan.0)

     (eqv? (r6rs:string->number "0/0e10") #f)
     (eqv? (r6rs:string->number "#i0/0e10") #f)
     (eqv? (r6rs:string->number "#e0/0e10") #f)
     (eqv? (r6rs:string->number "1/0e10") #f)
     (eqv? (r6rs:string->number "#i1/0e10") #f)
     (eqv? (r6rs:string->number "#e1/0e10") #f)
     (eqv? (r6rs:string->number "-1/0e10") #f)
     (eqv? (r6rs:string->number "#i-1/0e10") #f)
     (eqv? (r6rs:string->number "#e-1/0e10") #f)

     (eqv? (r6rs:string->number "-1/2e10000") #f)
     (eqv? (r6rs:string->number "1/2e10000") #f)
     (eqv? (r6rs:string->number "#e-1/2e10000") #f)
     (eqv? (r6rs:string->number "#e1/2e10000") #f)

     (eqv? (r6rs:string->number "0e25") 0.0)
     (eqv? (r6rs:string->number "-0e25") -0.0)
     (eqv? (r6rs:string->number "0/1e25") #f)
     (eqv? (r6rs:string->number "-0/1e25") #f)

     ; can't have no exact nans and infinities
     (eqv? (r6rs:string->number "#e+nan.0") #f)
     (eqv? (r6rs:string->number "#e+inf.0") #f)
     (eqv? (r6rs:string->number "#e-inf.0") #f)

     ; don't make no sense
     (eqv? (r6rs:string->number "3@4i") #f)
     (eqv? (r6rs:string->number "3@-i") #f)

     ; filling in some cases shown missing by profiling
     (eqv? (r6rs:string->number "1e-5000000000") 0.0)
     (eqv? (r6rs:string->number "-1e-5000000000") -0.0)
     (eqv? (r6rs:string->number "#e0e2000") 0)
     (eqv? (r6rs:string->number "#e0e-2000") 0)
     (eqv? (r6rs:string->number "1/0@5") #f)
     (eqv? (r6rs:string->number "1/0+5") #f)
     (eqv? (r6rs:string->number "#e1e20@0") (expt 10 20))
     (eqv? (r6rs:string->number "+1/0+5i") #f)
     (eqv? (r6rs:string->number "-1/0+5i") #f)
     (eqv? (r6rs:string->number "+1/0i") #f)
     (eqv? (r6rs:string->number "-1/0i") #f)
     (eqv? (r6rs:string->number "#e+inf.0+1i") #f)
     (eqv? (r6rs:string->number "1|21") 1.0)
     (eqv? (r6rs:string->number "1.5|21") 1.5)
     (eqv? (r6rs:string->number "1.5e2|21") 150.)
     (eqv? (r6rs:string->number "1.5e2|21+2i") 150.0+2.0i)
     (eqv? (r6rs:string->number "1.5e2|") #f)
     (eqv? (r6rs:string->number "1.5e2@") #f)
     (eqv? (r6rs:string->number "1.5e2@.5") (make-polar 1.5e2 .5))
     (eqv? (r6rs:string->number "1.5e2@+.5") (make-polar 1.5e2 .5))
     (eqv? (r6rs:string->number "1.5e2@-.5") (make-polar 1.5e2 -.5))
     (eqv? (r6rs:string->number "+in") #f)
     (eqv? (r6rs:string->number "+inf") #f)
     (eqv? (r6rs:string->number "+inf.") #f)
     (eqv? (r6rs:string->number "-in") #f)
     (eqv? (r6rs:string->number "-inf") #f)
     (eqv? (r6rs:string->number "-inf.") #f)
     (eqv? (r6rs:string->number "+n") #f)
     (eqv? (r6rs:string->number "+na") #f)
     (eqv? (r6rs:string->number "+nan") #f)
     (eqv? (r6rs:string->number "+nan.") #f)
     (eqv? (r6rs:string->number "-n") #f)
     (eqv? (r6rs:string->number "-na") #f)
     (eqv? (r6rs:string->number "-nan") #f)
     (eqv? (r6rs:string->number "-nan.") #f)
     (eqv? (r6rs:string->number "1.0e+5000") +inf.0)
     (eqv? (r6rs:string->number "-1.0e+5000") -inf.0)
     (eqv? (r6rs:string->number "0@1") 0)
     (eqv? (r6rs:string->number "#e1@1") #f))

(mat number->string
     (error? ; not a number
             (number->string 'a))
     (error? ; not a number
             (number->string 'a 24))
     (error? ; not a number
             (number->string 'a 16 24))
     (error? ; invalid radix
             (number->string 0.0 'a))
     (error? ; invalid radix
             (number->string 0.0 -1))
     (error? ; invalid radix
             (number->string 0.0 0))
     (error? ; invalid radix
             (number->string 0.0 1))
     (error? ; invalid radix
             (number->string 0.0 'a 24))
     (error? ; invalid radix
             (number->string 0.0 -1 24))
     (error? ; invalid radix
             (number->string 0.0 0 24))
     (error? ; invalid radix
             (number->string 0.0 1 24))
     (error? ; invalid precision
             (number->string 0.0 10 'a))
     (error? ; invalid precision
             (number->string 0.0 10 0))
     (error? ; invalid precision
             (number->string 0.0 10 -24))
     (error? ; invalid precision
       (number->string 0.0 10 (- (most-negative-fixnum) 1)))
     (error? ; precision given w/exact number
             (number->string 1 10 24))
     (equal? (number->string 3) "3")
     (equal? (number->string 3/4) "3/4")
     (equal? (number->string 3.024) "3.024")
     (eqv? (string->number (number->string #i2/3)) #i2/3)
     (equal? (number->string 3.000) "3.0")
     (equal? (number->string 3.2e20) "3.2e20")
     (equal? (number->string 3.2e2) "320.0")
     (equal? (number->string 3200000) "3200000")
     (equal? (number->string 320000) "320000")
     (equal? (number->string 3+4.0i) "3.0+4.0i")
     (equal? (number->string 3-4.0i) "3.0-4.0i")
     (equal? (number->string 1.003-4i) "1.003-4.0i")
     (equal? (number->string 3+4i) "3+4i")
     (equal? (number->string 3-4i) "3-4i")
     (equal? (number->string (make-rectangular 3.0 4)) "3.0+4.0i")
     (equal? (number->string (make-rectangular 3 4.0)) "3.0+4.0i")
     (equal? (number->string (make-rectangular 3 4)) "3+4i")
     (equal? (number->string 100.5 10 53) "100.5|53")
     (equal? (number->string #x100 16) "100")
     (equal? (number->string #x100 8) "400")
     (equal? (number->string #x100 16) "100"))

(mat r6rs:number->string
     (error? ; not a number
             (r6rs:number->string 'a))
     (error? ; not a number
             (r6rs:number->string 'a 24))
     (error? ; not a number
             (r6rs:number->string 'a 16 24))
     (error? ; invalid radix
             (r6rs:number->string 0.0 'a))
     (error? ; invalid radix
             (r6rs:number->string 0.0 -1))
     (error? ; invalid radix
             (r6rs:number->string 0.0 0))
     (error? ; invalid radix
             (r6rs:number->string 0.0 1))
     (error? ; invalid radix
             (r6rs:number->string 0.0 'a 24))
     (error? ; invalid radix
             (r6rs:number->string 0.0 -1 24))
     (error? ; invalid radix
             (r6rs:number->string 0.0 0 24))
     (error? ; invalid radix
             (r6rs:number->string 0.0 1 24))
     (error? ; invalid precision
             (r6rs:number->string 0.0 10 'a))
     (error? ; invalid precision
             (r6rs:number->string 0.0 10 0))
     (error? ; invalid precision
             (r6rs:number->string 0.0 10 -24))
     (error? ; invalid precision
       (r6rs:number->string 0.0 10 (- (most-negative-fixnum) 1)))
     (error? ; precision given w/exact number
             (r6rs:number->string 1 10 24))
     (error? ; precision given radix other than 10
             (r6rs:number->string 1 16 24))
     (equal? (r6rs:number->string 3) "3")
     (equal? (r6rs:number->string 3/4) "3/4")
     (equal? (r6rs:number->string 3.024) "3.024")
     (eqv? (string->number (r6rs:number->string #i2/3)) #i2/3)
     (equal? (r6rs:number->string 3.000) "3.0")
     (equal? (r6rs:number->string 3.2e20) "3.2e20")
     (equal? (r6rs:number->string 3.2e2) "320.0")
     (equal? (r6rs:number->string 3200000) "3200000")
     (equal? (r6rs:number->string 320000) "320000")
     (equal? (r6rs:number->string 3+4.0i) "3.0+4.0i")
     (equal? (r6rs:number->string 3-4.0i) "3.0-4.0i")
     (equal? (r6rs:number->string 1.003-4i) "1.003-4.0i")
     (equal? (r6rs:number->string 3+4i) "3+4i")
     (equal? (r6rs:number->string 3-4i) "3-4i")
     (equal? (r6rs:number->string (make-rectangular 3.0 4)) "3.0+4.0i")
     (equal? (r6rs:number->string (make-rectangular 3 4.0)) "3.0+4.0i")
     (equal? (r6rs:number->string (make-rectangular 3 4)) "3+4i")
     (equal? (r6rs:number->string 100.5 10 53) "100.5|53")
     (equal? (r6rs:number->string #x100 16) "100")
     (equal? (r6rs:number->string #x100 8) "400")
     (equal? (r6rs:number->string #x100 16) "100"))

(mat most-positive-fixnum
     (procedure? most-positive-fixnum)
     (fixnum? (most-positive-fixnum))
     (not (bignum? (most-positive-fixnum)))
     (fixnum? (1- (most-positive-fixnum)))
     (not (bignum? (1- (most-positive-fixnum))))
     (not (fixnum? (1+ (most-positive-fixnum))))
     (bignum? (1+ (most-positive-fixnum))))

(mat most-negative-fixnum
     (fixnum? (most-negative-fixnum))
     (not (bignum? (most-negative-fixnum)))
     (fixnum? (1+ (most-negative-fixnum)))
     (not (bignum? (1+ (most-negative-fixnum))))
     (not (fixnum? (1- (most-negative-fixnum))))
     (bignum? (1- (most-negative-fixnum))))

(mat fixnum?
     (fixnum? 3)
     (fixnum? 18/2)
     (fixnum? 1+0i)
     (not (fixnum? 23084982309482034820348023423048230482304))
     (not (fixnum? 203480234802384/23049821))
     (not (fixnum? -3/4))
     (fixnum? -1)
     (fixnum? 0)
     (fixnum? 1)
     (fixnum? -12)
     (fixnum? (most-positive-fixnum))
     (not (fixnum? (1+ (most-positive-fixnum))))
     (fixnum? (most-negative-fixnum))
     (not (fixnum? (1- (most-negative-fixnum))))
     (not (fixnum? 3.5))
     (not (fixnum? 1.8e-10))
     (not (fixnum? -3e5))
     (not (fixnum? -1231.2344))
     (not (fixnum? 3+5.0i))
     (not (fixnum? 1.8e10@10))
     (not (fixnum? -3e5+1.0i))
     (not (fixnum? -1.0i))
     (not (fixnum? +1.0i))
     (not (fixnum? 'a))
     (not (fixnum? "hi"))
     (not (fixnum? (cons 3 4))))

(mat bignum?
     (not (bignum? 3))
     (not (bignum? 18/2))
     (not (bignum? 1+0i))
     (bignum? 23084982309482034820348023423048230482304)
     (not (bignum? 203480234802384/23049821))
     (not (bignum? -3/4))
     (not (bignum? -1))
     (not (bignum? 0))
     (not (bignum? -12))
     (not (bignum? (most-positive-fixnum)))
     (bignum? (1+ (most-positive-fixnum)))
     (not (bignum? (most-negative-fixnum)))
     (bignum? (1- (most-negative-fixnum)))
     (not (bignum? 3.5))
     (not (bignum? 1.8e-10))
     (not (bignum? -3e5))
     (not (bignum? -1231.2344))
     (not (bignum? 3+5.0i))
     (not (bignum? 1.8e10@10))
     (not (bignum? -3e5+1.0i))
     (not (bignum? -1.0i))
     (not (bignum? +1.0i))
     (not (bignum? 'a))
     (not (bignum? "hi"))
     (not (bignum? (cons 3 4))))

(mat ratnum?
     (not (ratnum? 3))
     (not (ratnum? 18/2))
     (not (ratnum? 1+0i))
     (not (ratnum? 23084982309482034820348023423048230482304))
     (ratnum? 203480234802384/23049821)
     (ratnum? -3/4)
     (not (ratnum? -1))
     (not (ratnum? 0))
     (not (ratnum? -12))
     (not (ratnum? 3.5))
     (not (ratnum? 1.8e-10))
     (not (ratnum? -3e5))
     (not (ratnum? -1231.2344))
     (not (ratnum? 3+5.0i))
     (not (ratnum? 1.8e10@10))
     (not (ratnum? -3e5+1.0i))
     (not (ratnum? -1.0i))
     (not (ratnum? +1.0i))
     (not (ratnum? 'a))
     (not (ratnum? "hi"))
     (not (ratnum? (cons 3 4)))
     (not (ratnum? 3/2+2/3i)))

(mat flonum?
     (not (flonum? 3))
     (not (flonum? 18/2))
     (not (flonum? 1+0i))
     (not (flonum? 23084982309482034820348023423048230482304))
     (not (flonum? 203480234802384/23049821))
     (not (flonum? -3/4))
     (not (flonum? -1))
     (not (flonum? 0))
     (not (flonum? -12))
     (flonum? 3.5)
     (flonum? 1.8e-10)
     (flonum? -3e5)
     (flonum? -1231.2344)
     (not (flonum? 3+5.0i))
     (not (flonum? 1.8e10@10))
     (not (flonum? -3e5+1.0i))
     (not (flonum? -1.0i))
     (not (flonum? +1.0i))
     (not (flonum? 'a))
     (not (flonum? "hi"))
     (not (flonum? (cons 3 4))))

(mat exact?
     (error? (exact? 'a))
     (exact? 1)
     (exact? 112310831023012)
     (exact? 3/4)
     (not (exact? 3.4))
     (not (exact? 3+4.0i))
     (exact? 3+4i)
     (exact? 3+0i))

(mat inexact?
     (error? (inexact? '()))
     (not (inexact? -1))
     (not (inexact? -112310831023012))
     (not (inexact? 3/4))
     (inexact? 3.4)
     (inexact? 3+4.0i)
     (not (inexact? 3+4i))
     (not (inexact? 3+0i)))

(mat =
     (error? (=))
     (error? (= 'a))
     (error? (= 3 'a))
     (error? (= 'a 3))
     (error? (= 3 3 'a))
     (error? (= 4 3 'a))
     (error? (= 'a 3 4))
     (error? (= 4 'a 3))
     (error? (= 3 4 'a 5))
     (= 3 3)
     (not (= 3 4))
     (= -3 -3)
     (not (= -3 -4))
     (= -2.3e10 -2.3e10)
     (not (= -2.3e10 -2.3e9))
     (= 3 3.0)
     (not (= 3 2.9))
     (= 7/3 7/3)
     (not (= 7/3 8/3))
     (= 1/2 0.5)
     (not (= 1/2 0.4))
     (= 2)
     (= 1 1.0 1 1.0)
     (= 1/2 0.5 1/2 0.5)
     (not (= 1 1.1 1 1.0))
     (not (= 1/2 0.5 1/3 0.5))
     (not (= 1 99999999999999999999999999999))
     (not (= -1 99999999999999999999999999999))
     (not (= 1 -99999999999999999999999999999))
     (not (= -1 -99999999999999999999999999999))
     (not (= 99999999999999999999999999999 -99999999999999999999999999999))
     (not (= -99999999999999999999999999999 99999999999999999999999999999))
     (not (= 99999999999999999999999999999 99999999999999999999999999998))
     (not (= 99999999999999999999999999998 99999999999999999999999999999))
     (= 99999999999999999999999999999 99999999999999999999999999999)
     (= 2.0+1.0i 2.0+1.0i)
     (not (= 2.0+1.0i 2.0+1.1i))
     (= 2-1/2i 2-1/2i)
     (= 2-1/2i 2.0-0.5i))

(mat <
     (error? (<))
     (error? (< 'a))
     (error? (< 3 'a))
     (error? (< 'a 3))
     (error? (< 3 4 'a))
     (error? (< 4 3 'a))
     (error? (< 'a 3 4))
     (error? (< 4 'a 3))
     (error? (< 3 5 'a 4))
     (error? (< 3+1i))
     (error? (< 3+1i 4))
     (error? (< 2 3+1i))
     (error? (< 2 3 3+1i))
     (error? (< 3.4+0.0i))
     (error? (< 3.4+0.0i 3.5))
     (error? (< 3.2 3.4+0.0i))
     (error? (< 3.2 3.3 3.4+0.0i))
     (not (< 3 3))
     (< 3 4)
     (not (< -3 -3))
     (not (< -3 -4))
     (not (< -2.3e10 -2.3e10))
     (< -2.3e10 -2.3e9)
     (not (< 3 3.0))
     (not (< 3 2.9))
     (not (< 7/3 7/3))
     (< 7/3 8/3)
     (not (< 1/2 0.5))
     (not (< 1/2 0.4))
     (< 1)
     (< 1 2 3)
     (< 1 2 3 4)
     (not (< 1 2 2 4))
     (not (< 4 3 2 1))
     (not (< 4 2 2 1))
     (not (< 1 3 2 4))
     (< 1.0 3/2 2 2.5 1000000000023)
     (< 1 99999999999999999999999999999)
     (< -1 99999999999999999999999999999)
     (not (< 1 -99999999999999999999999999999))
     (not (< -1 -99999999999999999999999999999))
     (not (< 99999999999999999999999999999 -99999999999999999999999999999))
     (< -99999999999999999999999999999 99999999999999999999999999999)
     (not (< 99999999999999999999999999999 99999999999999999999999999998))
     (< 99999999999999999999999999998 99999999999999999999999999999)
     (not (< 99999999999999999999999999999 99999999999999999999999999999))
     (error? (< 2.0+1.0i 3.0))
     (error? (< 2+i 3))
     (error? (< 2 3+i))
     (guard (c [#t #t]) (< (#3%length (error #f "oops")) 0)))

(mat <=
     (error? (<=))
     (error? (<= 'a))
     (error? (<= 3 'a))
     (error? (<= 'a 3))
     (error? (<= 3 4 'a))
     (error? (<= 4 3 'a))
     (error? (<= 'a 3 4))
     (error? (<= 4 'a 3))
     (error? (<= 3 5 'a 4))
     (error? (<= 3+1i))
     (error? (<= 3+1i 4))
     (error? (<= 2 3+1i))
     (error? (<= 2 3 3+1i))
     (error? (<= 3.4+0.0i))
     (error? (<= 3.4+0.0i 3.5))
     (error? (<= 3.2 3.4+0.0i))
     (error? (<= 3.2 3.3 3.4+0.0i))
     (<= 3 3)
     (<= 3 4)
     (<= -3 -3)
     (not (<= -3 -4))
     (<= -2.3e10 -2.3e10)
     (<= -2.3e10 -2.3e9)
     (<= 3 3.0)
     (not (<= 3 2.9))
     (<= 7/3 7/3)
     (<= 7/3 8/3)
     (<= 1/2 0.5)
     (not (<= 1/2 0.4))
     (<= 1)
     (<= 1 2 3)
     (<= 1 2 3 4)
     (<= 1 2 2 4)
     (not (<= 4 3 2 1))
     (not (<= 4 2 2 1))
     (not (<= 1 3 2 4))
     (<= 1.0 3/2 2 2.5 1000000000023)
     (<= 1 99999999999999999999999999999)
     (<= -1 99999999999999999999999999999)
     (not (<= 1 -99999999999999999999999999999))
     (not (<= -1 -99999999999999999999999999999))
     (not (<= 99999999999999999999999999999 -99999999999999999999999999999))
     (<= -99999999999999999999999999999 99999999999999999999999999999)
     (not (<= 99999999999999999999999999999 99999999999999999999999999998))
     (<= 99999999999999999999999999998 99999999999999999999999999999)
     (<= 99999999999999999999999999999 99999999999999999999999999999)
     (error? (<= 2.0+1.0i 3.0))
     (error? (<= 2+i 3))
     (error? (<= 2 3+i)))

(mat >
     (error? (>))
     (error? (> 'a))
     (error? (> 3 'a))
     (error? (> 'a 3))
     (error? (> 3 4 'a))
     (error? (> 4 3 'a))
     (error? (> 'a 3 4))
     (error? (> 4 'a 3))
     (error? (> 3 5 'a 4))
     (error? (> 3+1i))
     (error? (> 3+1i 4))
     (error? (> 2 3+1i))
     (error? (> 2 3 3+1i))
     (error? (> 3.4+0.0i))
     (error? (> 3.4+0.0i 3.5))
     (error? (> 3.2 3.4+0.0i))
     (error? (> 3.2 3.3 3.4+0.0i))
     (not (> 3 3))
     (not (> 3 4))
     (not (> -3 -3))
     (> -3 -4)
     (not (> -2.3e10 -2.3e10))
     (not (> -2.3e10 -2.3e9))
     (not (> 3 3.0))
     (> 3 2.9)
     (not (> 7/3 7/3))
     (not (> 7/3 8/3))
     (not (> 1/2 0.5))
     (> 1/2 0.4)
     (> 1)
     (> 3 2 1)
     (not (> 1 2 3 4))
     (not (> 1 2 2 4))
     (> 4 3 2 1)
     (not (> 4 2 2 1))
     (not (> 4 2 3 1))
     (> 1000000000023 2.5 2 3/2 1.0)
     (not (> 1 99999999999999999999999999999))
     (not (> -1 99999999999999999999999999999))
     (> 1 -99999999999999999999999999999)
     (> -1 -99999999999999999999999999999)
     (> 99999999999999999999999999999 -99999999999999999999999999999)
     (not (> -99999999999999999999999999999 99999999999999999999999999999))
     (> 99999999999999999999999999999 99999999999999999999999999998)
     (not (> 99999999999999999999999999998 99999999999999999999999999999))
     (not (> 99999999999999999999999999999 99999999999999999999999999999))
     (error? (> 2.0+1.0i 3.0))
     (error? (> 2+i 3))
     (error? (> 2 3+i)))

(mat >=
     (error? (>=))
     (error? (>= 'a))
     (error? (>= 3 'a))
     (error? (>= 'a 3))
     (error? (>= 3 4 'a))
     (error? (>= 4 3 'a))
     (error? (>= 'a 3 4))
     (error? (>= 4 'a 3))
     (error? (>= 3 5 'a 4))
     (error? (>= 3+1i))
     (error? (>= 3+1i 4))
     (error? (>= 2 3+1i))
     (error? (>= 2 3 3+1i))
     (error? (>= 3.4+0.0i))
     (error? (>= 3.4+0.0i 3.5))
     (error? (>= 3.2 3.4+0.0i))
     (error? (>= 3.2 3.3 3.4+0.0i))
     (>= 3 3)
     (not (>= 3 4))
     (>= -3 -3)
     (>= -3 -4)
     (>= -2.3e10 -2.3e10)
     (not (>= -2.3e10 -2.3e9))
     (>= 3 3.0)
     (>= 3 2.9)
     (>= 7/3 7/3)
     (not (>= 7/3 8/3))
     (>= 1/2 0.5)
     (>= 1/2 0.4)
     (>= 1)
     (>= 3 2 1)
     (not (>= 1 2 3 4))
     (not (>= 1 2 2 4))
     (>= 4 3 2 1)
     (>= 4 2 2 1)
     (not (>= 4 2 3 1))
     (>= 1000000000023 2.5 2 3/2 1.0)
     (not (>= #x40000000 #x80000000))
     (not (>= 1 99999999999999999999999999999))
     (not (>= -1 99999999999999999999999999999))
     (>= 1 -99999999999999999999999999999)
     (>= -1 -99999999999999999999999999999)
     (>= 99999999999999999999999999999 -99999999999999999999999999999)
     (not (>= -99999999999999999999999999999 99999999999999999999999999999))
     (>= 99999999999999999999999999999 99999999999999999999999999998)
     (not (>= 99999999999999999999999999998 99999999999999999999999999999))
     (<= 99999999999999999999999999999 99999999999999999999999999999)
     (error? (>= 2.0+1.0i 3.0))
     (error? (>= 2+i 3))
     (error? (>= 2 3+i))
     (guard (c [#t #t]) (not (>= (#3%length (error #f "oops")) 0))))


(mat r6rs:=
     (error? (r6rs:=))
     (error? (r6rs:= 3))
     (error? (r6rs:= 3 'a))
     (error? (r6rs:= 'a 3))
     (error? (r6rs:= 3 3 'a))
     (error? (r6rs:= 4 3 'a))
     (error? (r6rs:= 'a 3 4))
     (error? (r6rs:= 4 'a 3))
     (error? (r6rs:= 3 4 'a 5))
     (r6rs:= 3 3)
     (not (r6rs:= 3 4))
     (r6rs:= -3 -3)
     (not (r6rs:= -3 -4))
     (r6rs:= -2.3e10 -2.3e10)
     (not (r6rs:= -2.3e10 -2.3e9))
     (r6rs:= 3 3.0)
     (not (r6rs:= 3 2.9))
     (r6rs:= 7/3 7/3)
     (not (r6rs:= 7/3 8/3))
     (r6rs:= 1/2 0.5)
     (not (r6rs:= 1/2 0.4))
     (r6rs:= 1 1.0 1 1.0)
     (r6rs:= 1/2 0.5 1/2 0.5)
     (not (r6rs:= 1 1.1 1 1.0))
     (not (r6rs:= 1/2 0.5 1/3 0.5))
     (not (r6rs:= 1 99999999999999999999999999999))
     (not (r6rs:= -1 99999999999999999999999999999))
     (not (r6rs:= 1 -99999999999999999999999999999))
     (not (r6rs:= -1 -99999999999999999999999999999))
     (not (r6rs:= 99999999999999999999999999999
                  -99999999999999999999999999999))
     (not (r6rs:= -99999999999999999999999999999
                  99999999999999999999999999999))
     (not (r6rs:= 99999999999999999999999999999
                  99999999999999999999999999998))
     (not (r6rs:= 99999999999999999999999999998
                  99999999999999999999999999999))
     (r6rs:= 99999999999999999999999999999 99999999999999999999999999999)
     (r6rs:= 2.0+1.0i 2.0+1.0i)
     (not (r6rs:= 2.0+1.0i 2.0+1.1i))
     (r6rs:= 2-1/2i 2-1/2i)
     (r6rs:= 2-1/2i 2.0-0.5i))

(mat r6rs:<
     (error? (r6rs:<))
     (error? (r6rs:< 3))
     (error? (r6rs:< 3 'a))
     (error? (r6rs:< 'a 3))
     (error? (r6rs:< 3 4 'a))
     (error? (r6rs:< 4 3 'a))
     (error? (r6rs:< 'a 3 4))
     (error? (r6rs:< 4 'a 3))
     (error? (r6rs:< 3 5 'a 4))
     (not (r6rs:< 3 3))
     (r6rs:< 3 4)
     (not (r6rs:< -3 -3))
     (not (r6rs:< -3 -4))
     (not (r6rs:< -2.3e10 -2.3e10))
     (r6rs:< -2.3e10 -2.3e9)
     (not (r6rs:< 3 3.0))
     (not (r6rs:< 3 2.9))
     (not (r6rs:< 7/3 7/3))
     (r6rs:< 7/3 8/3)
     (not (r6rs:< 1/2 0.5))
     (not (r6rs:< 1/2 0.4))
     (r6rs:< 1 2 3)
     (r6rs:< 1 2 3 4)
     (not (r6rs:< 1 2 2 4))
     (not (r6rs:< 4 3 2 1))
     (not (r6rs:< 4 2 2 1))
     (not (r6rs:< 1 3 2 4))
     (r6rs:< 1.0 3/2 2 2.5 1000000000023)
     (r6rs:< 1 99999999999999999999999999999)
     (r6rs:< -1 99999999999999999999999999999)
     (not (r6rs:< 1 -99999999999999999999999999999))
     (not (r6rs:< -1 -99999999999999999999999999999))
     (not (r6rs:< 99999999999999999999999999999
                  -99999999999999999999999999999))
     (r6rs:< -99999999999999999999999999999 99999999999999999999999999999)
     (not (r6rs:< 99999999999999999999999999999
                  99999999999999999999999999998))
     (r6rs:< 99999999999999999999999999998 99999999999999999999999999999)
     (not (r6rs:< 99999999999999999999999999999
                  99999999999999999999999999999))
     (error? (r6rs:< 2.0+1.0i 3.0))
     (error? (r6rs:< 2+i 3))
     (error? (r6rs:< 2 3+i)))

(mat r6rs:<=
     (error? (r6rs:<=))
     (error? (r6rs:<= 3))
     (error? (r6rs:<= 3 'a))
     (error? (r6rs:<= 'a 3))
     (error? (r6rs:<= 3 4 'a))
     (error? (r6rs:<= 4 3 'a))
     (error? (r6rs:<= 'a 3 4))
     (error? (r6rs:<= 4 'a 3))
     (error? (r6rs:<= 3 5 'a 4))
     (r6rs:<= 3 3)
     (r6rs:<= 3 4)
     (r6rs:<= -3 -3)
     (not (r6rs:<= -3 -4))
     (r6rs:<= -2.3e10 -2.3e10)
     (r6rs:<= -2.3e10 -2.3e9)
     (r6rs:<= 3 3.0)
     (not (r6rs:<= 3 2.9))
     (r6rs:<= 7/3 7/3)
     (r6rs:<= 7/3 8/3)
     (r6rs:<= 1/2 0.5)
     (not (r6rs:<= 1/2 0.4))
     (r6rs:<= 1 2 3)
     (r6rs:<= 1 2 3 4)
     (r6rs:<= 1 2 2 4)
     (not (r6rs:<= 4 3 2 1))
     (not (r6rs:<= 4 2 2 1))
     (not (r6rs:<= 1 3 2 4))
     (r6rs:<= 1.0 3/2 2 2.5 1000000000023)
     (r6rs:<= 1 99999999999999999999999999999)
     (r6rs:<= -1 99999999999999999999999999999)
     (not (r6rs:<= 1 -99999999999999999999999999999))
     (not (r6rs:<= -1 -99999999999999999999999999999))
     (not (r6rs:<= 99999999999999999999999999999
                   -99999999999999999999999999999))
     (r6rs:<= -99999999999999999999999999999 99999999999999999999999999999)
     (not (r6rs:<= 99999999999999999999999999999
                   99999999999999999999999999998))
     (r6rs:<= 99999999999999999999999999998 99999999999999999999999999999)
     (r6rs:<= 99999999999999999999999999999 99999999999999999999999999999)
     (error? (r6rs:<= 2.0+1.0i 3.0))
     (error? (r6rs:<= 2+i 3))
     (error? (r6rs:<= 2 3+i)))

(mat r6rs:>
     (error? (r6rs:>))
     (error? (r6rs:> 3))
     (error? (r6rs:> 3 'a))
     (error? (r6rs:> 'a 3))
     (error? (r6rs:> 3 4 'a))
     (error? (r6rs:> 4 3 'a))
     (error? (r6rs:> 'a 3 4))
     (error? (r6rs:> 4 'a 3))
     (error? (r6rs:> 3 5 'a 4))
     (not (r6rs:> 3 3))
     (not (r6rs:> 3 4))
     (not (r6rs:> -3 -3))
     (r6rs:> -3 -4)
     (not (r6rs:> -2.3e10 -2.3e10))
     (not (r6rs:> -2.3e10 -2.3e9))
     (not (r6rs:> 3 3.0))
     (r6rs:> 3 2.9)
     (not (r6rs:> 7/3 7/3))
     (not (r6rs:> 7/3 8/3))
     (not (r6rs:> 1/2 0.5))
     (r6rs:> 1/2 0.4)
     (r6rs:> 3 2 1)
     (not (r6rs:> 1 2 3 4))
     (not (r6rs:> 1 2 2 4))
     (r6rs:> 4 3 2 1)
     (not (r6rs:> 4 2 2 1))
     (not (r6rs:> 4 2 3 1))
     (r6rs:> 1000000000023 2.5 2 3/2 1.0)
     (not (r6rs:> 1 99999999999999999999999999999))
     (not (r6rs:> -1 99999999999999999999999999999))
     (r6rs:> 1 -99999999999999999999999999999)
     (r6rs:> -1 -99999999999999999999999999999)
     (r6rs:> 99999999999999999999999999999 -99999999999999999999999999999)
     (not (r6rs:> -99999999999999999999999999999
                  99999999999999999999999999999))
     (r6rs:> 99999999999999999999999999999 99999999999999999999999999998)
     (not (r6rs:> 99999999999999999999999999998
                  99999999999999999999999999999))
     (not (r6rs:> 99999999999999999999999999999
                  99999999999999999999999999999))
     (error? (r6rs:> 2.0+1.0i 3.0))
     (error? (r6rs:> 2+i 3))
     (error? (r6rs:> 2 3+i)))

(mat r6rs:>=
     (error? (r6rs:>=))
     (error? (r6rs:>= 3))
     (error? (r6rs:>= 3 'a))
     (error? (r6rs:>= 'a 3))
     (error? (r6rs:>= 3 4 'a))
     (error? (r6rs:>= 4 3 'a))
     (error? (r6rs:>= 'a 3 4))
     (error? (r6rs:>= 4 'a 3))
     (error? (r6rs:>= 3 5 'a 4))
     (r6rs:>= 3 3)
     (not (r6rs:>= 3 4))
     (r6rs:>= -3 -3)
     (r6rs:>= -3 -4)
     (r6rs:>= -2.3e10 -2.3e10)
     (not (r6rs:>= -2.3e10 -2.3e9))
     (r6rs:>= 3 3.0)
     (r6rs:>= 3 2.9)
     (r6rs:>= 7/3 7/3)
     (not (r6rs:>= 7/3 8/3))
     (r6rs:>= 1/2 0.5)
     (r6rs:>= 1/2 0.4)
     (r6rs:>= 3 2 1)
     (not (r6rs:>= 1 2 3 4))
     (not (r6rs:>= 1 2 2 4))
     (r6rs:>= 4 3 2 1)
     (r6rs:>= 4 2 2 1)
     (not (r6rs:>= 4 2 3 1))
     (r6rs:>= 1000000000023 2.5 2 3/2 1.0)
     (not (r6rs:>= #x40000000 #x80000000))
     (not (r6rs:>= 1 99999999999999999999999999999))
     (not (r6rs:>= -1 99999999999999999999999999999))
     (r6rs:>= 1 -99999999999999999999999999999)
     (r6rs:>= -1 -99999999999999999999999999999)
     (r6rs:>= 99999999999999999999999999999 -99999999999999999999999999999)
     (not (r6rs:>= -99999999999999999999999999999
                   99999999999999999999999999999))
     (r6rs:>= 99999999999999999999999999999 99999999999999999999999999998)
     (not (r6rs:>= 99999999999999999999999999998
                   99999999999999999999999999999))
     (r6rs:<= 99999999999999999999999999999 99999999999999999999999999999)
     (error? (r6rs:>= 2.0+1.0i 3.0))
     (error? (r6rs:>= 2+i 3))
     (error? (r6rs:>= 2 3+i)))

(mat +
     (error? (+ 'a))
     (error? (+ 'a 3))
     (error? (+ 'a 3 4))
     (error? (+ 3 5 'a 4))
     (eqv? (+ 1 2) 3)
     (fl~= (+ 1.0 2) 3.0)
     (fl~= (+ 1 2.0) 3.0)
     (eqv? (+ 3/5 2/5) 1)
     (eqv? (+ 1/2 3) 7/2)
     (eqv? (+ 2/3 5/3) 7/3)
     (fl~= (+ 3.2 1/2) 3.7)
     (fl~= (+ 3.2 -2.5) 0.7)
     (eqv? (+) 0)
     (eqv? (+ 2) 2)
     (eqv? (+ 2 3 4) 9)
     (eqv? (+ 2 3 4 5) 14)
     (eqv? (+ 2/3 3/4 4/5 5/6) 61/20)
     (cfl~= (+ 1.0+2.2i -3.7+5.3i) -2.7+7.5i)
     (cfl~= (+ 1.0+2.2i -3.7) -2.7+2.2i)
     (cfl~= (+ 1.0 -3.7+5.3i) -2.7+5.3i)
     (cfl~= (+ 1.0+2.2i +5.3i) 1.0+7.5i)
     (cfl~= (+ +2.2i -3.7+5.3i) -3.7+7.5i)
     (let ([v '#(2 3.2 2/3 4-7i 2.1+4.2i)])
       (let f ([i 0])
         (or (= i (vector-length v))
             (let g ([j 0])
               (if (= j (vector-length v))
                   (f (+ i 1))
                   (let ([x (vector-ref v i)] [y (vector-ref v j)])
                     (and (~= (+ x y) (+ y x))
                          (~= (- (+ x y) y) x)
                          (if (exact? (+ x y))
                              (and (exact? x) (exact? y))
                              (or (inexact? x) (inexact? y)))
                          (g (+ j 1)))))))))
     (error? ; oops
       (+ 'a 'b (error #f "oops")))
     (error? ; oops
       (+ 'a (error #f "oops") 'c))
     (error? ; oops
       (+ (error #f "oops") 'b 'c))
     (error? ; #f is not a fixnum
             (+ 3 #f))
     (error? ; #f is not a fixnum
             (+ #f 3))
     ; see also misc.ms mat cp0-partial-folding
     (eqv? (parameterize
             ([optimize-level 2]
              [enable-cp0 #t]
              [#%$suppress-primitive-inlining #f])
             (expand/optimize '(+ 3 4 5 6)))
           18)
     (test-cp0-expansion eqv? '(+ 1 2) 3)
     (test-cp0-expansion fl~= '(+ 1.0 2) 3.0)
     (test-cp0-expansion fl~= '(+ 1 2.0) 3.0)
     (test-cp0-expansion eqv? '(+ 3/5 2/5) 1)
     (test-cp0-expansion eqv? '(+ 1/2 3) 7/2)
     (test-cp0-expansion eqv? '(+ 2/3 5/3) 7/3)
     (test-cp0-expansion fl~= '(+ 3.2 1/2) 3.7)
     (test-cp0-expansion fl~= '(+ 3.2 -2.5) 0.7)
     (test-cp0-expansion eqv? '(+) 0)
     (test-cp0-expansion eqv? '(+ 2) 2)
     (test-cp0-expansion eqv? '(+ 2 3 4) 9)
     (test-cp0-expansion eqv? '(+ 2 3 4 5) 14)
     (test-cp0-expansion eqv? '(+ 2/3 3/4 4/5 5/6) 61/20)
     (test-cp0-expansion cfl~= '(+ 1.0+2.2i -3.7+5.3i) -2.7+7.5i)
     (test-cp0-expansion cfl~= '(+ 1.0+2.2i -3.7) -2.7+2.2i)
     (test-cp0-expansion cfl~= '(+ 1.0 -3.7+5.3i) -2.7+5.3i)
     (test-cp0-expansion cfl~= '(+ 1.0+2.2i +5.3i) 1.0+7.5i)
     (test-cp0-expansion cfl~= '(+ +2.2i -3.7+5.3i) -3.7+7.5i))

(mat -
     (error? (-))
     (error? (- 'a))
     (error? (- 'a 3))
     (error? (- 'a 3 4))
     (error? (- 3 5 'a 4))
     (eqv? (- 1 2) -1)
     (fl~= (- 1.0 2) -1.0)
     (fl~= (- 1 2.0) -1.0)
     (eqv? (- 3/5 2/5) 1/5)
     (eqv? (- 1/2 3) -5/2)
     (eqv? (- 2/3 5/3) -1)
     (fl~= (- 3.2 1/2) 2.7)
     (fl~= (- 3.2 -2.5) 5.7)
     (eqv? (- 2) -2)
     (eqv? (- 2 3 4) -5)
     (eqv? (- 2 3 4 5) -10)
     (eqv? (- 2/3 3/4 4/5 5/6) -103/60)
     (cfl~= (- 1.0+2.2i -3.7+5.3i) 4.7-3.1i)
     (cfl~= (- 1.0+2.2i -3.7) 4.7+2.2i)
     (cfl~= (- 1.0 -3.7+5.3i) 4.7-5.3i)
     (cfl~= (- 1.0+2.2i +5.3i) 1.0-3.1i)
     (cfl~= (- +2.2i -3.7+5.3i) 3.7-3.1i)
     (let ([v '#(100 32.23 22/33 44-79i 2.9+8.7i)])
       (let f ([i 0])
         (or (= i (vector-length v))
             (let g ([j 0])
               (if (= j (vector-length v))
                   (f (+ i 1))
                   (let ([x (vector-ref v i)] [y (vector-ref v j)])
                     (and (~= (+ (- x y) (- y x)) 0)
                          (~= (+ (- x y) y) x)
                          (if (exact? (- x y))
                              (and (exact? x) (exact? y))
                              (or (inexact? x) (inexact? y)))
                          (g (+ j 1)))))))))
     (error? ; #f is not a fixnum
             (- 3 #f))
     (error? ; #f is not a fixnum
             (- #f 3))
     ((lambda (x ls) (and (member x ls) #t))
      (with-output-to-string
        (lambda ()
          (write (- (begin
                      (write 'x)
                      (+ (begin (write 'a) 3) (begin (write 'b) 4)))
                    (begin
                      (write 'y)
                      (+ (begin (write 'c) 5) (begin (write 'd) 7)))))))
      '("xabycd-5"
         "xbaycd-5"
         "xabydc-5"
         "xbaydc-5"
         "ycdxab-5"
         "ycdxba-5"
         "ydcxab-5"
         "ydcxba-5"))
     (test-cp0-expansion eqv? '(- 1 2) -1)
     (test-cp0-expansion fl~= '(- 1.0 2) -1.0)
     (test-cp0-expansion fl~= '(- 1 2.0) -1.0)
     (test-cp0-expansion eqv? '(- 3/5 2/5) 1/5)
     (test-cp0-expansion eqv? '(- 1/2 3) -5/2)
     (test-cp0-expansion eqv? '(- 2/3 5/3) -1)
     (test-cp0-expansion fl~= '(- 3.2 1/2) 2.7)
     (test-cp0-expansion fl~= '(- 3.2 -2.5) 5.7)
     (test-cp0-expansion eqv? '(- 2) -2)
     (test-cp0-expansion eqv? '(- 2 3 4) -5)
     (test-cp0-expansion eqv? '(- 2 3 4 5) -10)
     (test-cp0-expansion eqv? '(- 2/3 3/4 4/5 5/6) -103/60)
     (test-cp0-expansion cfl~= '(- 1.0+2.2i -3.7+5.3i) 4.7-3.1i)
     (test-cp0-expansion cfl~= '(- 1.0+2.2i -3.7) 4.7+2.2i)
     (test-cp0-expansion cfl~= '(- 1.0 -3.7+5.3i) 4.7-5.3i)
     (test-cp0-expansion cfl~= '(- 1.0+2.2i +5.3i) 1.0-3.1i)
     (test-cp0-expansion cfl~= '(- +2.2i -3.7+5.3i) 3.7-3.1i))

(mat *
     (error? (* 'a))
     (error? (* 'a 3))
     (error? (* 'a 3 4))
     (error? (* 3 5 'a 4))
     (eqv? (* 1 2) 2)
     (eqv? (* 23170 23170) 536848900)
     (eqv? (* 23170 -23170) -536848900)
     (eqv? (* -23170 23170) -536848900)
     (eqv? (* -23170 -23170) 536848900)
     (eqv? (* 23171 23170) 536872070)
     (eqv? (* 23171 -23170) -536872070)
     (eqv? (* -23171 23170) -536872070)
     (eqv? (* -23171 -23170) 536872070)
     (eqv? (* 23171 23171) 536895241)
     (eqv? (* 23171 -23171) -536895241)
     (eqv? (* -23171 23171) -536895241)
     (eqv? (* -23171 -23171) 536895241)
     (eqv? (* #x3FFFFFFF #x3FFFFFFF) #xFFFFFFF80000001)
     (eqv? (* #x3FFFFFFF #x-3FFFFFFF) #x-FFFFFFF80000001)
     (eqv? (* #x-3FFFFFFF #x3FFFFFFF) #x-FFFFFFF80000001)
     (eqv? (* #x-3FFFFFFF #x-3FFFFFFF) #xFFFFFFF80000001)
     (eqv? (* #x40000000 #x3FFFFFFF) #xFFFFFFFC0000000)
     (eqv? (* #x40000000 #x-3FFFFFFF) #x-FFFFFFFC0000000)
     (eqv? (* #x-40000000 #x3FFFFFFF) #x-FFFFFFFC0000000)
     (eqv? (* #x-40000000 #x-3FFFFFFF) #xFFFFFFFC0000000)
     (eqv? (* #x40000000 #x40000000) #x1000000000000000)
     (eqv? (* #x40000000 #x-40000000) #x-1000000000000000)
     (eqv? (* #x-40000000 #x40000000) #x-1000000000000000)
     (eqv? (* #x-40000000 #x-40000000) #x1000000000000000)
     (fl~= (* 1.0 2) 2.0)
     (fl~= (* 1 2.0) 2.0)
     (eqv? (* 3/5 2/5) 6/25)
     (eqv? (* 1/2 3) 3/2)
     (eqv? (* 2/3 5/3) 10/9)
     (fl~= (* 3.2 1/2) 1.6)
     (fl~= (* 3.2 -2.5) -8.0)
     (eqv? (*) 1)
     (eqv? (* 2) 2)
     (eqv? (* 2 3 4) 24)
     (eqv? (* 2 3 4 5) 120)
     (eqv? (* 2/3 3/4 4/5 5/6) 1/3)
     (cfl~= (* 1.0+2.0i 3.0+4.0i) -5.0+10.0i)
     (cfl~= (* 1.0+2.0i 3.0) 3.0+6.0i)
     (cfl~= (* -2.0 3.0+4.0i) -6.0-8.0i)
     (cfl~= (* 1.0+2.0i +4.0i) -8.0+4.0i)
     (cfl~= (* +2.0i 3.0+4.0i) -8.0+6.0i)
     (let ([v '#(18 3.23 2/33 4-79i 2.9+.7i)])
       (let f ([i 0])
         (or (= i (vector-length v))
             (let g ([j 0])
               (if (= j (vector-length v))
                   (f (+ i 1))
                   (let ([x (vector-ref v i)] [y (vector-ref v j)])
                     (and (~= (* x y) (* y x))
                          (~= (/ (* x y) y) x)
                          (if (exact? (* x y))
                              (and (exact? x) (exact? y))
                              (or (inexact? x) (inexact? y)))
                          (g (+ j 1)))))))))
     (error? ; #f is not a fixnum
             (* 3 #f))
     (error? ; #f is not a fixnum
             (* #f 3))
     (test-cp0-expansion eqv? '(* 1 2) 2)
     (test-cp0-expansion fl~= '(* 1.0 2) 2.0)
     (test-cp0-expansion fl~= '(* 1 2.0) 2.0)
     (test-cp0-expansion eqv? '(* 3/5 2/5) 6/25)
     (test-cp0-expansion eqv? '(* 1/2 3) 3/2)
     (test-cp0-expansion eqv? '(* 2/3 5/3) 10/9)
     (test-cp0-expansion fl~= '(* 3.2 1/2) 1.6)
     (test-cp0-expansion fl~= '(* 3.2 -2.5) -8.0)
     (test-cp0-expansion eqv? '(*) 1)
     (test-cp0-expansion eqv? '(* 2) 2)
     (test-cp0-expansion eqv? '(* 2 3 4) 24)
     (test-cp0-expansion eqv? '(* 2 3 4 5) 120)
     (test-cp0-expansion eqv? '(* 2/3 3/4 4/5 5/6) 1/3)
     (test-cp0-expansion cfl~= '(* 1.0+2.0i 3.0+4.0i) -5.0+10.0i)
     (test-cp0-expansion cfl~= '(* 1.0+2.0i 3.0) 3.0+6.0i)
     (test-cp0-expansion cfl~= '(* -2.0 3.0+4.0i) -6.0-8.0i)
     (test-cp0-expansion cfl~= '(* 1.0+2.0i +4.0i) -8.0+4.0i)
     (test-cp0-expansion cfl~= '(* +2.0i 3.0+4.0i) -8.0+6.0i))

(mat /
     (error? (/))
     (error? (/ 'a))
     (error? (/ 'a 3))
     (error? (/ 'a 3 4))
     (error? (/ 3 5 'a 4))
     (eqv? (/ 1 2) 1/2)
     (eqv? (/ 1 -2) -1/2)
     (eqv? (/ 1/2 -2) -1/4)
     (eqv? (/ 1 -1/2) -2)
     (fl~= (/ 1.0 2) 0.5)
     (fl~= (/ 1 2.0) 0.5)
     (eqv? (/ 3/5 2/5) 3/2)
     (eqv? (/ -3/5 2/5) -3/2)
     (eqv? (/ 3/5 -2/5) -3/2)
     (eqv? (/ -3/5 -2/5) 3/2)
     (eqv? (/ 1/2 3) 1/6)
     (eqv? (/ 2/3 5/3) 2/5)
     (fl~= (/ 3.2 1/2) 6.4)
     (fl~= (/ 3.2 -2.5) -1.28)
     (eqv? (/ 2) 1/2)
     (eqv? (/ 2 3 4) 1/6)
     (eqv? (/ 2 3 4 5) 1/30)
     (eqv? (/ 2/3 3/4 4/5 5/6) 4/3)
     (cfl~= (/ -5.0+10.0i 1.0+2.0i) 3.0+4.0i)
     (cfl~= (/ -6.0-8.0i -2.0) 3.0+4.0i)
     (cfl~= (/ 26.0 3.0-2.0i) 6.0+4.0i)
     (cfl~= (/ -8.0+6.0i +2.0i) 3.0+4.0i)
     (cfl~= (/ +26.0i 3.0+2.0i) 4.0+6.0i)
     (let ([v '#(100 32.23 22/33 44-79i 2.9+8.7i)])
       (let f ([i 0])
         (or (= i (vector-length v))
             (let g ([j 0])
               (if (= j (vector-length v))
                   (f (+ i 1))
                   (let ([x (vector-ref v i)] [y (vector-ref v j)])
                     (and (~= (* (/ x y) (/ y x)) 1)
                          (~= (* (/ x y) y) x)
                          (if (exact? (/ x y))
                              (and (exact? x) (exact? y))
                              (or (inexact? x) (inexact? y)))
                          (g (+ j 1)))))))))
     (eqv? (/ 1.0 #e1e500) 0.0)
     ; catch bug found in 4.0a
     ;; following returns incorrect result in all versions prior to 5.9b
     (eq? (/ (most-negative-fixnum) (- (most-negative-fixnum))) -1)
     (let ([x (/ 9 50000000000)])
       (and (eqv? (numerator x) 9)
            (eqv? (denominator x) 50000000000)))
     (== (/ 3.5 0) +inf.0)
     (== (/ -3.5 0) -inf.0)
     (== (/ 0.0 0) (nan))
     (test-cp0-expansion eqv? '(/ 1 2) 1/2)
     (test-cp0-expansion eqv? '(/ 1 -2) -1/2)
     (test-cp0-expansion eqv? '(/ 1/2 -2) -1/4)
     (test-cp0-expansion eqv? '(/ 1 -1/2) -2)
     (test-cp0-expansion fl~= '(/ 1.0 2) 0.5)
     (test-cp0-expansion fl~= '(/ 1 2.0) 0.5)
     (test-cp0-expansion eqv? '(/ 3/5 2/5) 3/2)
     (test-cp0-expansion eqv? '(/ -3/5 2/5) -3/2)
     (test-cp0-expansion eqv? '(/ 3/5 -2/5) -3/2)
     (test-cp0-expansion eqv? '(/ -3/5 -2/5) 3/2)
     (test-cp0-expansion eqv? '(/ 1/2 3) 1/6)
     (test-cp0-expansion eqv? '(/ 2/3 5/3) 2/5)
     (test-cp0-expansion fl~= '(/ 3.2 1/2) 6.4)
     (test-cp0-expansion fl~= '(/ 3.2 -2.5) -1.28)
     (test-cp0-expansion eqv? '(/ 2) 1/2)
     (test-cp0-expansion eqv? '(/ 2 3 4) 1/6)
     (test-cp0-expansion eqv? '(/ 2 3 4 5) 1/30)
     (test-cp0-expansion eqv? '(/ 2/3 3/4 4/5 5/6) 4/3)
     (test-cp0-expansion cfl~= '(/ -5.0+10.0i 1.0+2.0i) 3.0+4.0i)
     (test-cp0-expansion cfl~= '(/ -6.0-8.0i -2.0) 3.0+4.0i)
     (test-cp0-expansion cfl~= '(/ 26.0 3.0-2.0i) 6.0+4.0i)
     (test-cp0-expansion cfl~= '(/ -8.0+6.0i +2.0i) 3.0+4.0i)
     (test-cp0-expansion cfl~= '(/ +26.0i 3.0+2.0i) 4.0+6.0i)
     (test-cp0-expansion == '(/ 3.5 0) +inf.0)
     (test-cp0-expansion == '(/ -3.5 0) -inf.0)
     (test-cp0-expansion == '(/ 0.0 0) (nan)))

(mat nan?
     (error? (nan? 'a))
     (error? (nan? 3+4i))
     (error? (nan? 3.0-0.0i))
     (not (nan? 3))
     (not (nan? (* (most-positive-fixnum) 15)))
     (not (nan? (/ 3 40)))
     (nan? (nan))
     (not (nan? 5.0))
     (not (nan? +inf.0))
     (not (nan? -inf.0)))

(mat finite?
     (error? (finite? 'a))
     (error? (finite? 3+4i))
     (error? (finite? 3.0-0.0i))
     (finite? 3)
     (finite? (* (most-positive-fixnum) 15))
     (finite? (/ 3 40))
     (not (finite? (nan)))
     (finite? 5.0)
     (not (finite? +inf.0))
     (not (finite? -inf.0))
     ; r6rs:
     (not (finite? +inf.0))
     (finite? 5.0))

(mat infinite?
     (error? (infinite? 'a))
     (error? (infinite? 3+4i))
     (error? (infinite? 3.0-0.0i))
     (not (infinite? 3))
     (not (infinite? (* (most-positive-fixnum) 15)))
     (not (infinite? (/ 3 40)))
     (not (infinite? 5.0))
     (infinite? +inf.0)
     (infinite? -inf.0)
     ; r6rs:
     (not (infinite? 5.0))
     (infinite? +inf.0))

(mat zero?
     (error? (zero?))
     (error? (zero? 0 1))
     (error? (zero? 'a))
     (zero? 0)
     (zero? 0.0)
     (zero? 0/5)
     (not (zero? 234))
     (not (zero? 23423423/234241211))
     (not (zero? 23.4))
     (not (zero? -1734234))
     (not (zero? -2/3))
     (not (zero? -0.1)))

(mat positive?
     (error? (positive?))
     (error? (positive? 0 1))
     (error? (positive? 'a))
     (error? (positive? 1+1.0i))
     (error? (positive? 1+1i))
     (error? (positive? 1.0+0.0i))
     (not (positive? 0))
     (not (positive? 0.0))
     (not (positive? 0/5))
     (positive? 234)
     (positive? 23423423/234241211)
     (positive? 23.4)
     (not (positive? -1734234))
     (not (positive? -2/3))
     (not (positive? -0.1)))

(mat nonpositive?
     (error? (nonpositive?))
     (error? (nonpositive? 0 1))
     (error? (nonpositive? 'a))
     (error? (nonpositive? 1+1.0i))
     (error? (nonpositive? 1+1i))
     (error? (nonpositive? 1.0+0.0i))
     (nonpositive? 0)
     (nonpositive? 0.0)
     (nonpositive? 0/5)
     (not (nonpositive? 234))
     (not (nonpositive? 23423423/234241211))
     (not (nonpositive? 23.4))
     (nonpositive? -1734234)
     (nonpositive? -2/3)
     (nonpositive? -0.1))

(mat negative?
     (error? (negative?))
     (error? (negative? 0 1))
     (error? (negative? 'a))
     (error? (negative? 1+1.0i))
     (error? (negative? 1+1i))
     (error? (negative? 1.0+0.0i))
     (not (negative? 0))
     (not (negative? 0.0))
     (not (negative? 0/5))
     (not (negative? 234))
     (not (negative? 23423423/234241211))
     (not (negative? 23.4))
     (negative? -1734234)
     (negative? -2/3)
     (negative? -0.1))

(mat nonnegative?
     (error? (nonnegative?))
     (error? (nonnegative? 0 1))
     (error? (nonnegative? 'a))
     (error? (nonnegative? 1+1i))
     (error? (nonnegative? 1.0+1.0i))
     (error? (nonnegative? 1.0+0.0i))
     (nonnegative? 0)
     (nonnegative? 0.0)
     (nonnegative? 0/5)
     (nonnegative? 234)
     (nonnegative? 23423423/234241211)
     (nonnegative? 23.4)
     (not (nonnegative? -1734234))
     (not (nonnegative? -2/3))
     (not (nonnegative? -0.1)))

(mat even?
     (error? (even?))
     (error? (even? 0 1))
     (error? (even? 'a))
     (not (even? -3))
     (even? 2)
     (not (even? 1208312083280477))
     (even? 1208312083280478)
     (even? 4.0)
     (not (even? 3.0))
     (error? (even? 3.2))
     (error? (even? 3.0+1.0i))
     (error? (even? 1+1i))
     (error? (even? +inf.0))
     (error? (even? +nan.0)))

(mat odd?
     (error? (odd?))
     (error? (odd? 0 1))
     (error? (odd? 'a))
     (odd? -3)
     (not (odd? 2))
     (odd? 1208312083280477)
     (not (odd? 1208312083280478))
     (not (odd? 4.0))
     (odd? 3.0)
     (error? (odd? 3.2))
     (error? (odd? 3.0+1.0i))
     (error? (odd? 3+1i))
     (error? (odd? +inf.0))
     (error? (odd? +nan.0)))

(mat 1+
     (error? (1+))
     (error? (1+ 0 1))
     (error? (1+ 'a))
     (eqv? (1+ 1) 2)
     (eqv? (1+ -1) 0)
     (eqv? (1+ 10231231208412) 10231231208413)
     (eqv? (1+ -10231231208412) -10231231208411)
     (eqv? (1+ 2/3) 5/3)
     (fl~= (1+ -9.6) -8.6)
     (eqv? (1+ 1+1.0i) 2+1.0i)
     (eqv? (1+ 1+1i) 2+1i))

(mat add1
     (error? (add1))
     (error? (add1 0 1))
     (error? (add1 'a))
     (eqv? (add1 1) 2)
     (eqv? (add1 -1) 0)
     (eqv? (add1 10231231208412) 10231231208413)
     (eqv? (add1 -10231231208412) -10231231208411)
     (eqv? (add1 2/3) 5/3)
     (fl~= (add1 -9.6) -8.6)
     (eqv? (add1 1+1.0i) 2+1.0i)
     (eqv? (add1 1+1i) 2+1i))

(mat 1-
     (error? (1-))
     (error? (1- 0 1))
     (error? (1- 'a))
     (eqv? (1- 1) 0)
     (eqv? (1- -1) -2)
     (eqv? (1- 10231231208412) 10231231208411)
     (eqv? (1- -10231231208412) -10231231208413)
     (eqv? (1- 2/3) -1/3)
     (fl~= (1- -9.6) -10.6)
     (eqv? (1- 1+1.0i) +1.0i)
     (eqv? (1- 1+1i) +1i))

(mat sub1
     (error? (sub1))
     (error? (sub1 0 1))
     (error? (sub1 'a))
     (eqv? (sub1 1) 0)
     (eqv? (sub1 -1) -2)
     (eqv? (sub1 10231231208412) 10231231208411)
     (eqv? (sub1 -10231231208412) -10231231208413)
     (eqv? (sub1 2/3) -1/3)
     (fl~= (sub1 -9.6) -10.6)
     (eqv? (sub1 1+1.0i) +1.0i)
     (eqv? (sub1 1+1i) +1i))

(mat -1+
     (error? (-1+))
     (error? (-1+ 0 1))
     (error? (-1+ 'a))
     (eqv? (-1+ 1) 0)
     (eqv? (-1+ -1) -2)
     (eqv? (-1+ 10231231208412) 10231231208411)
     (eqv? (-1+ -10231231208412) -10231231208413)
     (eqv? (-1+ 2/3) -1/3)
     (fl~= (-1+ -9.6) -10.6)
     (eqv? (-1+ 1+1.0i) +1.0i)
     (eqv? (-1+ 1+1i) +1i))

(mat quotient
     (error? (quotient))
     (error? (quotient 1))
     (error? (quotient 1 0))
     (error? (quotient 1 2 3))
     (error? (quotient 'a 1))
     (error? (quotient 1 'a))
     (eqv? (quotient 1 2) 0)
     (eqv? (quotient (most-positive-fixnum) -1) (- (most-positive-fixnum)))
     (eqv? (quotient (most-negative-fixnum) -1) (- (most-negative-fixnum)))
     (not (eqv? (quotient 1.0 2) 0))
     (not (eqv? (quotient 1 2.0) 0))
     (error? (quotient 3/5 2/5))
     (error? (quotient 1/2 3))
     (error? (quotient 2/3 5/3))
     (error? (quotient 3.2 1/2))
     (error? (quotient 3.2 -2.5))
     (error? (quotient 3.2 2))
     (error? (quotient 3 2.1))
     (error? (quotient 3 2+i))
     (error? (quotient 2+i 3))
     (error? (quotient 2.0+i 3))
     (fl= (quotient 4 2.0) 2.0)
     (fl= (quotient 4.0 2) 2.0)
     (fl= (quotient 4.0 2.0) 2.0)
     (fl= (quotient 4.0 2.0) 2.0)
     (fl= (quotient 3.0 -2.0) -1.0)
     (fl= (quotient -3.0 -2.0) 1.0)
     (fl= (quotient -3.0 2) -1.0)
     ;; following returns incorrect result in all versions prior to 5.9b
     (eq? (quotient (most-negative-fixnum) (- (most-negative-fixnum))) -1))

(mat remainder
     (error? (remainder))
     (error? (remainder 1))
     (error? (remainder 1 0))
     (error? (remainder 1 2 3))
     (error? (remainder 'a 1))
     (error? (remainder 1 'a))
     (eqv? (remainder 1 2) 1)
     (not (eqv? (remainder 1.0 2) 1))
     (not (eqv? (remainder 1 2.0) 1))
     (fl= (remainder 1.0 2) 1.0)
     (fl= (remainder 1 2.0) 1.0)
     (error? (remainder 3/5 2/5))
     (error? (remainder 1/2 3))
     (error? (remainder 2/3 5/3))
     (error? (remainder 3.2 1/2))
     (error? (remainder 3.2 -2.5))
     (error? (remainder -3.2 2.5))
     (error? (remainder -3.2 2.5))
     (error? (remainder -3+2i 2))
     (fl= (remainder 5 2.0) 1.0)
     (fl= (remainder 5.0 2) 1.0)
     (fl= (remainder 5.0 2.0) 1.0)
     (fl= (remainder 5.0 2.0) 1.0)
     (fl= (remainder -5.0 3.0) -2.0)
     (fl= (remainder 5.0 -3.0) 2.0)
     ;; following returns incorrect result with naive algorithm,
     ;; i.e., remainder = (lambda (x,y) (- x (* (quotient x y) y)))
     (fl= (remainder 1e194 10.0) 0.0)
     ;; following returns incorrect result in all versions prior to 5.9b
     (eq? (remainder (most-negative-fixnum) (- (most-negative-fixnum))) 0))

(mat modulo
     (error? (modulo))
     (error? (modulo 1))
     (error? (modulo 1 2 3))
     (error? (modulo 'a 1))
     (error? (modulo 1 'a))
     (eqv? (modulo 1 2) 1)
     (not (eqv? (modulo 1.0 2) 1))
     (not (eqv? (modulo 1 2.0) 1))
     (fl= (modulo 1.0 2) 1.0)
     (fl= (modulo 1 2.0) 1.0)
     (error? (modulo 3/5 2/5))
     (error? (modulo 1/2 3))
     (error? (modulo 2/3 5/3))
     (error? (modulo 3.2 1/2))
     (error? (modulo 3.2 -2.5))
     (error? (modulo -3.2 2.5))
     (error? (modulo -3+2i 2))
     (fl= (modulo 5 2.0) 1.0)
     (fl= (modulo 5.0 2) 1.0)
     (fl= (modulo 5.0 2.0) 1.0)
     (fl= (modulo 5.0 2.0) 1.0))

(mat truncate
     (error? (truncate))
     (error? (truncate 2 3))
     (error? (truncate 'a))
     (error? (truncate 2+1.0i))
     (error? (truncate 2+1i))
     (error? (truncate 2.0+0.0i))
     (eqv? (truncate 19) 19)
     (eqv? (truncate 2/3) 0)
     (eqv? (truncate -2/3) 0)
     (fl= (truncate 17.3) 17.0)
     (eqv? (truncate -17/2) -8)
     (fl= (truncate 2.5) 2.0))

(mat floor
     (error? (floor))
     (error? (floor 2 3))
     (error? (floor 'a))
     (error? (floor 2+1.0i))
     (error? (floor 2+1i))
     (error? (floor 2.0+0.0i))
     (eqv? (floor 19) 19)
     (eqv? (floor 2/3) 0)
     (eqv? (floor -2/3) -1)
     (fl= (floor 17.3) 17.0)
     (eqv? (floor -17/2) -9)
     (fl= (floor 2.5) 2.0))

(mat ceiling
     (error? (ceiling))
     (error? (ceiling 2 3))
     (error? (ceiling 'a))
     (error? (ceiling 2+1.0i))
     (error? (ceiling -1.7+0.i))
     (error? (ceiling 2.0+0.0i))
     (eqv? (ceiling 19) 19)
     (eqv? (ceiling 2/3) 1)
     (eqv? (ceiling -2/3) 0)
     (fl= (ceiling 17.3) 18.0)
     (eqv? (ceiling -17/2) -8)
     (fl= (ceiling 2.5) 3.0))

(mat round
     (error? (round))
     (error? (round 2 3))
     (error? (round 'a))
     (error? (round 2+1.0i))
     (error? (round 2+1i))
     (error? (round 2.0+0.0i))
     (eqv? (round 19) 19)
     (eqv? (round 2/3) 1)
     (eqv? (round -2/3) -1)
     (fl= (round 17.3) 17.0)
     (eqv? (round -17/2) -8)
     (fl= (round 2.5) 2.0)
     (fl= (round 0.5000000000000000) 0.0)
     (fl= (round 0.5000000000000001) 1.0))

(mat abs
     (error? (abs))
     (error? (abs 1 2))
     (error? (abs 'a))
     (eqv? (abs 1) 1)
     (eqv? (abs -15) 15)
     (eqv? (abs (most-negative-fixnum)) (- (most-negative-fixnum)))
     (eqv? (abs (+ (most-positive-fixnum) 1)) (+ (most-positive-fixnum) 1))
     (eqv? (abs (- (most-negative-fixnum) 1)) (- 1 (most-negative-fixnum)))
     (eqv? (abs -3/4) 3/4)
     (eqv? (abs -1152263041152514306628192408100392992507/32981512763495262007329078307916574411635755078241)
           1152263041152514306628192408100392992507/32981512763495262007329078307916574411635755078241)
     (error? (abs 3+4i))
     (fl~= (abs 1.83) 1.83)
     (fl~= (abs -0.093) 0.093)
     (error? (abs 3.0+4.0i)))

(mat magnitude
     (error? (magnitude))
     (error? (magnitude 1 2))
     (error? (magnitude 'a))
     (eqv? (magnitude 1) 1)
     (eqv? (magnitude -3/4) 3/4)
     (eqv? (magnitude 3+4i) 5)
     (fl~= (magnitude 1.83) 1.83)
     (fl~= (magnitude -0.093) 0.093)
     (fl~= (magnitude 3+4.0i) 5.0)
     (fl~= (magnitude 0.0-0.093i) 0.093)
     (fl~= (magnitude 1+1.0i) (sqrt 2.0))
     (fl~= (magnitude 99.9+88.8i) (sqrt (+ (* 99.9 99.9) (* 88.8 88.8))))
     (fl~= (magnitude 1e20+1.0i) 1e20))

(mat max
     (error? (max))
     (error? (max 'a))
     (error? (max 1 'a))
     (error? (max 1 'a 2))
     (error? (max 1 2 3 'a))
     (error? (max 1 2 3 0+1.0i))
     (error? (max 1 2 3 +1i))
     (eqv? (max 1) 1)
     (eqv? (max 3 -3) 3)
     (fl= (max 3.2 1.0) 3.2)
     (fl= (max 3.2 1.0) 3.2)
     (fl= (max 1/2 0.5) 0.5)
     (fl= (max 1/2 -0.5) 0.5)
     (eqv? (max 3 5 1 4 6 2) 6))

(mat min
     (error? (min))
     (error? (min 'a))
     (error? (min 1 'a))
     (error? (min 1 'a 2))
     (error? (min 1 2 3 'a))
     (error? (min 1 2 3 0+1.0i))
     (error? (min 1 2 3 +1i))
     (error? (min 3.0+0.0i))
     (error? (min 2 3.0+0.0i))
     (error? (min 2 3.0+0.0i 3))
     (error? (min 1 2 2 3.0+0.0i))
     (eqv? (min -17) -17)
     (eqv? (min 3 -3) -3)
     (eqv? (min 3.2 1.0) 1.0)
     (fl= (min 3.2 1.0) 1.0)
     (fl= (min 1/2 0.5) 0.5)
     (fl= (min -1/2 0.5) -0.5)
     (eqv? (min 3 5 1 4 6 2) 1))

(mat gcd
     (error? (gcd 'a))
     (error? (gcd 3.4))
     (error? (gcd 3/4))
     (error? (gcd +inf.0))
     (error? (gcd +nan.0))
     (error? (gcd 1 3.4))
     (error? (gcd 1 2/3 2))
     (error? (gcd 1 2 3 'a))
     (error? (gcd 1 2 3 1+1.0i))
     (error? (gcd 1 2 3 1+1i))
     (error? (gcd 3.0+0.0i))
     (error? (gcd 2 3.0+0.0i))
     (error? (gcd 2 3.0+0.0i 3))
     (error? (gcd 1 2 2 3.0+0.0i))
     (error? (gcd 0 +inf.0))
     (error? (gcd -inf.0 0))
     (error? (gcd 1 +inf.0))
     (error? (gcd -inf.0 1))
     (error? (gcd +inf.0 15 27))
     (error? (gcd 15 +inf.0 27))
     (error? (gcd 15 27 +inf.0))
     (error? (gcd +nan.0 15 27))
     (error? (gcd 15 +nan.0 27))
     (error? (gcd 15 27 +nan.0))
     (eqv? (gcd) 0)
     (eqv? (gcd 1123123) 1123123)
     (eqv? (gcd 33 15) 3)
     (eqv? (gcd 28 -14) 14)
     (eqv? (gcd 0 15) 15)
     (fl= (gcd 0 15.0) 15.0)
     (fl= (gcd 0.0 15) 15.0)
     (fl= (gcd 0.0 15.0) 15.0)
     (eqv? (gcd 0 0) 0)
     (eqv? (gcd 2 4 8 16) 2)
     (eqv? (gcd 12 6 15) 3)
     (let f ([n 5])
       (or (= n 0)
           (and (let ((gcd-test (lambda (count seed size)
                                  (do ((x seed (+ y (* (1+ (random size)) x)))
                                       (y 0 x)
                                       (n count (1- n)))
                                      ((zero? n) (= (gcd x y) seed) #t)))))
                  (and (gcd-test 100 73 100)
                       (gcd-test 50 73 1000000)
                       (gcd-test 50 73 100000000000)
                       (gcd-test 25 73 #e1e200)))
                (f (- n 1)))))
     (eqv? (gcd 0 -333333333333333333) 333333333333333333))

(mat lcm
     (error? (lcm 'a))
     (error? (lcm 3.4))
     (error? (lcm 3/4))
     (error? (lcm +inf.0))
     (error? (lcm +nan.0))
     (error? (lcm 1 3.4))
     (error? (lcm 1 2/3 2))
     (error? (lcm 1 2 3 'a))
     (error? (lcm 1 2 3 1+1.0i))
     (error? (lcm 1 2 3 1+1i))
     (error? (lcm 1 +inf.0))
     (error? (lcm -inf.0 1))
     (error? (lcm +inf.0 15 27))
     (error? (lcm 15 +inf.0 27))
     (error? (lcm 15 27 +inf.0))
     (error? (lcm +nan.0 15 27))
     (error? (lcm 15 +nan.0 27))
     (error? (lcm 15 27 +nan.0))
     (error? (lcm +inf.0 0 27))
     (error? (lcm 15 +inf.0 0))
     (error? (lcm 0 27 +inf.0))
     (error? (lcm +nan.0 0 27))
     (error? (lcm 15 +nan.0 0))
     (error? (lcm 0 27 +nan.0))
     (eqv? (lcm) 1)
     (eqv? (lcm 13) 13)
     (eqv? (lcm -13) 13)
     (eqv? (lcm 7 5) 35)
     (eqv? (lcm -7 5) 35)
     (eqv? (lcm 15 15) 15)
     (eqv? (lcm 15 25) 75)
     (fl= (lcm 15 25.0) 75.0)
     (fl= (lcm 15.0 25) 75.0)
     (fl= (lcm -15.0 25) 75.0)
     (fl= (lcm 15.0 25.0) 75.0)
     (eqv? (lcm 15 25 30) 150)
     (eqv? (lcm 15 -25 30) 150)
     (eqv? (lcm 0 0) 0)
     (eqv? (lcm 10 0) 0)
     (eqv? (lcm 0 10) 0)
     (eqv? (lcm 0 0 0) 0)
     (eqv? (lcm 10 0 0) 0)
     (eqv? (lcm 0 10 0) 0)
     (eqv? (lcm 0 0 10) 0)
     (eqv? (lcm 0 6 10) 0)
     (eqv? (lcm 6 0 10) 0)
     (eqv? (lcm 6 10 0) 0)
     (eqv? (lcm 0 0 0 10) 0)
     (eqv? (lcm 10 0 0 0) 0)
     (eqv? (lcm 0 6 7 10) 0)
     (eqv? (lcm 10 6 7 0) 0)
     (eqv? (lcm 0.0 0.0) 0.0)
     (eqv? (lcm 10.0 0.0) 0.0)
     (eqv? (lcm 0.0 10.0) 0.0)
     (eqv? (lcm 0.0 0.0 0.0) 0.0)
     (eqv? (lcm 10.0 0.0 0.0) 0.0)
     (eqv? (lcm 0.0 10.0 0.0) 0.0)
     (eqv? (lcm 0.0 0.0 10.0) 0.0)
     (eqv? (lcm 0.0 6.0 10.0) 0.0)
     (eqv? (lcm 6.0 0.0 10.0) 0.0)
     (eqv? (lcm 6.0 10.0 0.0) 0.0)
     (eqv? (lcm 0.0 0.0 0.0 10.0) 0.0)
     (eqv? (lcm 10.0 0.0 0.0 0.0) 0.0)
     (eqv? (lcm 0.0 6.0 7.0 10.0) 0.0)
     (eqv? (lcm 10.0 6.0 7.0 0.0) 0.0))

(mat expt
     (error? (expt))
     (error? (expt 5))
     (error? (expt 3 4 5))
     (error? (expt 'a 3))
     (error? (expt 3 'a))
     (error? (expt 0 -1))
     (error? (expt 0 +1i))
     (eqv? (expt 2+2i 4) -64)
     (eqv? (expt 10.0 -20) 1e-20)
     (eqv? (expt 2 10) 1024)
     (eqv? (expt 0 0) 1)
     (eqv? (expt 0 2) 0)
     (eqv? (expt 100 0) 1)
     (eqv? (expt 2 -10) 1/1024)
     (eqv? (expt -1/2 5) -1/32)
     (fl~= (expt 9 1/2) 3.0)
     (fl~= (expt 3.0 3) 27.0)
     (~= (expt -0.5 2) .25)
     (~= (expt -0.5 -2) 4.0)
     (~= (expt 3 2.5) (sqrt (* 3 3 3 3 3)))
     (fl= (expt 0.0 2.0) 0.0)
     (fl= (expt 0.0 0.0) 1.0)
     (fl= (expt 2.0 0.0) 1.0)
     (eqv? (expt -2/3 -3) -27/8)
     (fl= (expt 10.0 -1000) 0.0)
     (fl= (expt .1 1000) 0.0)
     (cfl~= (expt -1 1/2) +1.0i)
     (cfl~= (expt 2.4-.3i 3.0) (* 2.4-.3i 2.4-.3i 2.4-.3i))
     (cfl~= (expt 2.4-.3i 3) (* 2.4-.3i 2.4-.3i 2.4-.3i))
     (cfl~= (expt 7.7-11.11i -2.0)
            (* (/ 1.0 7.7-11.11i) (/ 1.0 7.7-11.11i)))
     (~= (expt 11 1/2) (sqrt 11))
     (fl~= (expt 1.5e-20 0.5) (sqrt 1.5e-20))
     ; test cp0 handling of expt
     (begin
       (define $probably-should-not-use
         (lambda () (expt 1000000 10000000000000000)))
       (procedure? $probably-should-not-use))
     (equal? (let ([ls '(a b c)])
               (let ([n (expt (begin (set! ls (append ls ls)) 2)
                              (begin
                                (set! ls (reverse ls))
                                3))])
                 (cons n ls)))
             '(8 c b a c b a)))

(mat expt-mod
     (error? (expt-mod))
     (error? (expt-mod 5))
     (error? (expt-mod 4 5))
     (error? (expt-mod 3 4 5 6))
     (error? (expt-mod 'a 3 4))
     (error? (expt-mod 1 -2 3))
     (error? (expt-mod 1 -2 0))
     (eqv? (expt-mod 2 4 3) 1)
     (eqv? (expt-mod 2 76543 76543) 2)
     (eqv? (expt-mod 2 10 7) 2)
     (let ([x 3] [y 10] [z 8])
       (eqv? (expt-mod x y z) (modulo (expt x y) z)))
     (let ([x 3] [y 10] [z -8])
       (eqv? (expt-mod x y z) (modulo (expt x y) z)))
     (let ([x -3] [y 10] [z 8])
       (eqv? (expt-mod x y z) (modulo (expt x y) z)))
     (let ([x -3] [y 10] [z -8])
       (eqv? (expt-mod x y z) (modulo (expt x y) z))))

(mat random
     (error? (random))
     (error? (random +1i))
     (error? (random 1 2))
     (error? (random 'a))
     (error? (random -3))
     (error? (random 0))
     (error? (random 'a))
     (error? (random 0.0))
     (error? (random -1.0))
     (error? (random 1/2))
     (error? (random 3.0+0.0i))
     (let f ((n 1000))
       (or (zero? n)
           (and (let ((r (random n))) (and (>= r 0) (< r n)))
                (f (1- n)))))
     (let f ((n 1000001000))
       (or (= n 1000000000)
           (and (let ((r (random n))) (and (>= r 0) (< r n)))
                (f (1- n)))))
     (let f ((n 1000.0))
       (or (<= n 0.0)
           (and (let ((r (random n))) (and (>= r 0.0) (< r n)))
                (let ((r (random (+ n 1e30))))
                  (and (>= r 0) (< r (+ n 1e30))))
                (f (- n (random 2.0)))))))

(mat random-seed
     (integer? (random-seed))
     (= (random-seed) (random-seed))
     (error? (random-seed 'a))
     (error? (random-seed 0))
     (error? (random-seed -1))
     (error? (random-seed (expt 2 32)))
     (= 100 (begin (random-seed 100) (random-seed)))
     (let ([r (random-seed)])
       (let ([s (random 10)])
         (random-seed r)
         (= s (random 10))))
     (begin
       ; test bug with return address saving in the assemblers; if this
       ; fails to terminate, it's likely that return addresses are not
       ; saved properly in the foreign-procedure (for random-seed) =>
       ; dofretuns => get-room => (C)get_more_room call chain, 
       (let f ((n 0))
         (unless (>= (random-seed) (expt 2 29))
                 (f (random 2))))
       (let f ((n 1000))
         (unless (fx= n 0) (random-seed) (f (fx- n 1))))
       #t))

(mat inexact
     (error? (inexact))
     (error? (inexact 1 2))
     (error? (inexact 'a))
     (fl= (inexact 3.2) 3.2)
     (fl= (inexact -1/2) -0.5)
     (fl= (inexact 19) 19.0)
     (fl~= (inexact 87000000000000000) 8.7e+16)
     (cfl~= (inexact 3+1/2i) 3.0+.5i))

(mat exact
     (error? (exact))
     (error? (exact 1 2))
     (error? (exact 'a))
     (eqv? (exact -15) -15)
     (eqv? (exact 19/3) 19/3)
     (rational? (exact 3.272))
     (fl~= (inexact (exact 3.272)) 3.272)
     (eqv? (exact 3.0+.5i) 3+1/2i))

(mat rationalize
     (error? (rationalize))
     (error? (rationalize 3 4 5))
     (error? (rationalize 3))
     (error? (rationalize 'a 1))
     (error? (rationalize 3.4 'a))
     (error? (rationalize 3.4+0.0i 1))
     (eqv? (rationalize -15 0) -15)
     (eqv? (rationalize 19/3 1/10) 19/3)
     (fl= (rationalize 3.272 0) 3.272)
     (fluid-let ([*fuzz* .0001])
       (fl~= (rationalize 3.272 0.0001) 3.272))
     (eqv? (rationalize (exact 2/3) 1/10) 2/3)
     ;; from r3.99rs
     (eqv? (rationalize (exact .3) 1/10) 1/3)
     (eqv? (rationalize .3 1/10) #i1/3))

(mat numerator
     (error? (numerator))
     (error? (numerator 3 4))
     (error? (numerator 'a))
     (error? (numerator +1i))
     (error? (numerator 2.2+1.1i))
     (eqv? (numerator 3.25) 13.0)
     (eqv? (numerator 9) 9)
     (eqv? (numerator 2/3) 2)
     (eqv? (numerator -9/4) -9)
     (error? (numerator +inf.0))
     (error? (numerator -inf.0))
     (error? (numerator +nan.0)))

(mat denominator
     (error? (denominator))
     (error? (denominator 3 4))
     (error? (denominator 'a))
     (error? (denominator +1i))
     (error? (denominator 2.2+1.1i))
     (eqv? (denominator 3.25) 4.0)
     (eqv? (denominator 9) 1)
     (eqv? (denominator 2/3) 3)
     (eqv? (denominator -9/4) 4)
     (error? (denominator +inf.0))
     (error? (denominator -inf.0))
     (error? (denominator +nan.0)))

(mat real-part
     (error? (real-part))
     (error? (real-part 3 4))
     (error? (real-part 'a))
     (eqv? (real-part 3+4.0i) 3.0)
     (eqv? (real-part 3.001-4.0i) 3.001)
     (eqv? (real-part -.1+4.0i) -.1)
     (eqv? (real-part 3+4i) 3)
     (eqv? (real-part -1/10+4i) -1/10))

(mat imag-part
     (error? (imag-part))
     (error? (imag-part 3 4))
     (error? (imag-part 'a))
     (eqv? (imag-part 3.0+4/3i) (inexact 4/3))
     (eqv? (imag-part 3+4.01i) 4.01)
     (eqv? (imag-part -.1-4e20i) -4e20)
     (eqv? (imag-part 3+4i) 4)
     ; r6rs says (real? -2.5) is #t and real? returns #t only when
     ; imaginary part is exact 0, thus (imag-part -2.5) is 0
     (eqv? (imag-part -2.5) 0)
     (eqv? (imag-part -1-420/840i) -1/2))

(mat make-rectangular
     (error? (make-rectangular 3 'a))
     (error? (make-rectangular 'b 4))
     (error? (make-rectangular 3.4+0.0i 2.3))
     (error? (make-rectangular 2.3 3.4+0.0i))
     (eqv? (make-rectangular 3.0 -4) 3.0-4.0i)
     (eqv? (make-rectangular 3 -4.0) 3.0-4.0i)
     (eqv? (make-rectangular 3 -4) 3-4i))

(mat make-polar
     (error? (make-polar 3 'a))
     (error? (make-polar 'b 4))
     (error? (make-polar 3.4+0.0i 2.3))
     (error? (make-polar 2.3 3.4+0.0i))
     (eqv? (make-polar 3 -4) 3@-4))

(mat angle
     (error? (angle))
     (error? (angle 3 4))
     (error? (angle 'a))
     (if (memq (machine-type) '(i3qnx ti3qnx))
         (fl~= (angle 3.0@2.0) 2.0)
         (fl= (angle 3.0@2.0) 2.0))
     (let ([z 24.3-200.2i])
       (cfl~= z (make-polar (magnitude z) (angle z))))
     (= (angle 3+1i) (angle 3.0+1.0i)))

(mat sqrt
     (error? (sqrt))
     (error? (sqrt 3 4))
     (error? (sqrt 'a))
     (= (sqrt -1.0) 0.0+1.0i)
     (eqv? (sqrt -1) +1i)
     (= (sqrt 9) 3)
     (= (sqrt 1/4) 1/2)
     (~= (* (sqrt 189) (sqrt 189)) 189)
     (fl~= (* (sqrt 2) (sqrt 2.0)) 2.0)
     (cfl~= (* (sqrt 3+3.0i) (sqrt 3+3.0i)) 3+3.0i)
     (let ([x 8-1.5i]) (~= (sqrt (* x x)) x))
     (let ([x 8-3/2i]) (eqv? (sqrt (* x x)) x))
     (~= (sqrt 5+12i) (sqrt 5.0+12.0i))
     (~= (sqrt -5+12i) (sqrt -5.0+12.0i))
     (~= (sqrt 5-12i) (sqrt 5.0-12.0i))
     (~= (sqrt -5-12i) (sqrt -5.0-12.0i))
     (~= (sqrt 1e38) (sqrt #e1e38)))

(mat isqrt
     (error? (isqrt))
     (error? (isqrt 3 4))
     (error? (isqrt 1.1))
     (error? (isqrt 'a))
     (error? (isqrt -1))
     (error? (isqrt 10.0+0.0i))
     (eqv? (isqrt 1.0) 1.0)
     (eqv? (isqrt 9.0) 3.0)
     (eqv? (isqrt 9) 3)
     (eqv? (isqrt 10) 3)
     (eqv? (isqrt 1000) 31)
     (let ([x 11111111111111111111111111111111111111111111111111111111111111111])
       (let ([i (isqrt x)])
         (and (<= (* i i) x) (> (* (+ i 1) (+ i 1)) x)))))

(mat exp
     (error? (exp))
     (error? (exp 3 4))
     (error? (exp 'a))
     (fl= (exp 0.0) 1.0)
     (~= (* (exp 1) (exp 1)) (exp 2))
     (fl~= (/ (exp 24.2) (exp 2)) (exp 22.2))
     (fluid-let ([*fuzz* 1.1e-14])
       (let ([x 24.2+3.1i] [y 2.1-2.0i])
         (cfl~= (* (exp x) (exp y)) (exp (+ x y)))))
     (cfl~= (exp 34.2+5.8i)
       (* (exp 34.2) (+ (cos 5.8) (* +1.0i (sin 5.8))))))

(mat log
     (error? (log))
     (error? (log 'a))
     (error? (log 0))
     (= (log 1) 0)
     (fl= (log 1.0) 0.0)
     (~= (log (exp 7)) 7)
     (fl~= (log (exp 10.2)) 10.2)
     (cfl~= (log -1) (* pi +1.0i))
     (let ([x -1-2.0i])
       (cfl~= (exp (log (* x x))) (exp (+ (log x) (log x)))))
     (cfl~= (exp (log (exp +4.0i))) (exp +4.0i))
     (cfl~= (exp (log (exp 34.2+5.8i))) (exp 34.2+5.8i))
     (~= (log 1e30) (log #e1e30))
     (cfl~= (log -1e30) (log #e-1e30))
     (~= (/ (log (expt 10 500)) (log 10)) 500)
     (~= (log 3/4) (log .75))
     (~= (log 10 10) 1.0)
     (~= (log 50 50) 1.0)
     (~= (log -50 -50) 1.0+0.0i)
     (~= (log 1000 10) 3))

(mat sin
     (and (> pi 3.14159265) (< pi 3.14159266))
     (error? (sin))
     (error? (sin 3 4))
     (error? (sin 'a))
     (fl~= (sin (/ pi 6)) 0.5))

(mat cos
     (error? (cos))
     (error? (cos 3 4))
     (error? (cos 'a))
     (fl~= (cos (/ pi 3)) 0.5)
     (let ([x 3.3])
       (let ([s (sin x)] [c (cos x)])
         (~= (+ (* s s) (* c c)) 1.0)))
     (fluid-let ([*fuzz* 1e-13])
       (let ([x 3.3+3.3i])
         (let ([s (sin x)] [c (cos x)])
           (cfl~= (+ (* s s) (* c c)) 1.0)))))

(mat tan
     (error? (tan))
     (error? (tan 3 4))
     (error? (tan 'a))
     (fl~= (tan (/ pi 4)) 1.0)
     (let ([x 4.4]) (~= (tan x) (/ (sin x) (cos x))))
     (fluid-let ([*fuzz* 3e-12])
       (let ([x 4.4-5.5i])
         (cfl~= (tan x) (/ (sin x) (cos x))))))

(mat asin
     (error? (asin))
     (error? (asin 3 4))
     (error? (asin 'a))
     (fl~= (asin 1.0) (/ pi 2))
     (let ([x 1.0]) (fl~= (asin (sin x)) x))
     (let ([x 1.0+1.0i]) (cfl~= (asin (sin x)) x))
     (let ([x 0.5]) (fl~= (asin (sin x)) x))
     (let ([x 0.5+1.5i]) (cfl~= (asin (sin x)) x))
     (let ([x 0.5-1.5i]) (cfl~= (asin (sin x)) x))
     (let ([z 2.2-1.1i])
       (cfl~= (asin z) (/ (asinh (* +1.0i z)) +1.0i))))

(mat acos
     (error? (acos))
     (error? (acos 3 4))
     (error? (acos 'a))
     (fl~= (acos 0.5) (/ pi 3))
     (let ([x 0.5]) (fl~= (acos (cos x)) x))
     (let ([x 0.5+1.5i]) (cfl~= (acos (cos x)) x))
     (let ([x 0.5-1.5i]) (cfl~= (acos (cos x)) x))
     (fluid-let ([*fuzz* 2.4e-13])
       (let ([z 99+.99i]) (cfl~= (cos (acos z)) z)))
     (let ([z +9.0i])
       (cfl~= (acos z)
         (/ (* 2
               (log (+ (sqrt (/ (+ 1 z) 2)) (* +1.0i (sqrt (/ (- 1 z) 2))))))
            +1.0i)))
     (let ([x 10+10.0i])
       (cfl~= (+ (asin x) (acos x)) (/ pi 2))))

(mat atan
     (error? (atan))
     (error? (atan 3 4 5))
     (error? (atan 'a))
     (error? (atan 'a 3))
     (error? (atan 3 'a))
     (error? (atan +i))
     (error? (atan -i))
     (error? (atan 3.0+0.0i 3.2))
     (fl~= (atan 1.0) (/ pi 4))
     (fl~= (atan 2.0 2.0) (/ pi 4))
     (let ([x 0.5]) (fl~= (atan (tan x)) x))
     (let ([x 0.5+1.5i]) (cfl~= (atan (tan x)) x))
     (let ([x 0.5-1.5i]) (cfl~= (atan (tan x)) x))
     (let ([z 2.2-1.1i])
       (cfl~= (atan z) (/ (atanh (* +1.0i z)) +1.0i)))
     (let ([z 2.2-1.1i])
       (cfl~= (atan z) (/ (atanh (* +1.0i z)) +1.0i)))
     (fl~= (atan 10.0 -10.0) (angle -10+10i))
     (fl~= (atan 10.0 -10.0) (angle -10.0+10.0i))
     (fl~= (atan 10 -10.0) (atan 10.0 -10.0))
     (fl~= (atan 10 -10.0) (atan 10.0 -10)))

(mat sinh
     (let ([x 23])
       (~= (sinh x) (* 1/2 (- (exp x) (exp (- x))))))
     (let ([x 3-3.2i])
       (~= (sinh x) (* 1/2 (- (exp x) (exp (- x))))))
     (let ([x 50]) (~= (- (sinh x)) (sinh (- x))))
     (let ([x 4-12i]) (~= (- (sinh x)) (sinh (- x))))
     (let ([x 5.4+4.5i])
       (~= (sinh (* +i x)) (* +i (sin x))))
     (let ([x 5.4+4.5i])
       (let ([s (sinh x)])
         (~= (* s s) (* 1/2 (- (cosh (* 2 x)) 1)))))
     (let ([x 5.4+4.5i])
       (let ([s (sinh x)])
         (~= (* s s s) (* 1/4 (+ (* -3 (sinh x)) (sinh (* 3 x))))))))

(mat cosh
     (let ([x 9])
       (~= (cosh x) (* 1/2 (+ (exp x) (exp (- x))))))
     (let ([x 4+4i])
       (~= (cosh x) (* 1/2 (+ (exp x) (exp (- x))))))
     (let ([x 50]) (~= (cosh x) (cosh (- x))))
     (let ([x 4-12i]) (~= (cosh x) (cosh (- x))))
     (fluid-let ([*fuzz* 1e-12])
       (let ([x 5.4])
         (let ([c (cosh x)] [s (sinh x)])
           (~= (- (* c c) (* s s)) 1))))
     (let ([x +4.5i])
       (let ([c (cosh x)] [s (sinh x)])
         (~= (- (* c c) (* s s)) 1)))
     (fluid-let ([*fuzz* 1e-11])
       (let ([x 5.4+4.5i])
         (let ([c (cosh x)] [s (sinh x)])
           (~= (- (* c c) (* s s)) 1))))
     (let ([x 5.4+4.5i]) (~= (cosh (* +i x)) (cos x)))
     (let ([x 5.4+4.5i])
       (let ([c (cosh x)])
         (~= (* c c) (* 1/2 (+ (cosh (* 2 x)) 1)))))
     (let ([x 5.4+4.5i])
       (let ([c (cosh x)])
         (~= (* c c c) (* 1/4 (+ (* 3 (cosh x)) (cosh (* 3 x))))))))

(mat tanh
     (let ([x 50]) (~= (- (tanh x)) (tanh (- x))))
     (let ([x 4-12i]) (~= (- (tanh x)) (tanh (- x))))
     (let ([x -5]) (~= (tanh x) (/ (sinh x) (cosh x))))
     (fluid-let ([*fuzz* 1e-13])
       (let ([x 3-2i]) (~= (tanh x) (/ (sinh x) (cosh x)))))
     (let ([x 5.4+4.5i])
       (~= (tanh (* +i x)) (* +i (tan x)))))


(mat asinh
     (error? (asinh))
     (error? (asinh 3 4))
     (error? (asinh 'a))
     (fl~= (asinh (sinh 5.7)) 5.7)
     (let ([x 0.5]) (fl~= (asinh (sinh x)) x))
     (let ([x 0.5+1.5i]) (cfl~= (asinh (sinh x)) x))
     (let ([x 0.5-1.5i]) (cfl~= (asinh (sinh x)) x))
     (let ([z 3+3.0i])
       (cfl~= (asinh z) (log (+ z (sqrt (+ 1 (* z z)))))))
     (let ([z -3.1-9.9i])
       (cfl~= (asinh z) (* -1.0i (asin (* +1.0i z)))))
     (let ([z 10+999.0i])
       (cfl~= (asinh z) (* -1.0i (asin (* +1.0i z)))))
     (let ([z 9.5])
       (cfl~= (asinh z) (* -1.0i (asin (* +1.0i z))))))

(mat acosh
     (error? (acosh))
     (error? (acosh 3 4))
     (error? (acosh 'a))
     (fl~= (acosh (cosh 13.3)) 13.3)
     (let ([x 0.5]) (fl~= (acosh (cosh x)) x))
     (let ([x 0.5+1.5i]) (cfl~= (acosh (cosh x)) x))
     (let ([x 0.5-1.5i]) (cfl~= (acosh (cosh x)) x))
     (let ([z 3+3.0i])
       (cfl~= (acosh z)
         (* 2 (log (+ (sqrt (/ (+ z 1) 2)) (sqrt (/ (- z 1) 2)))))))
     (let ([z -3.1-9.9i])
       (cfl~= (acosh z) (* -1.0i (acos z))))
     (let ([z 10+999.0i])
       (cfl~= (acosh z) (* +1.0i (acos z)))))

(mat atanh
     (error? (atanh))
     (error? (atanh 3 4))
     (error? (atanh 'a))
     (error? (atanh -1))
     (error? (atanh 1))
     (fl~= (atanh (tanh 1.0)) 1.0)
     (fl~= (atanh (tanh 1.0)) 1.0)
     (let ([x 0.5]) (fl~= (atanh (tanh x)) x))
     (let ([x 0.5+1.5i]) (cfl~= (atanh (tanh x)) x))
     (let ([x 0.5-1.5i]) (cfl~= (atanh (tanh x)) x))
     (let ([z 3+3.0i])
       (cfl~= (atanh z) (/ (- (log (+ 1 z)) (log (- 1 z))) 2)))
     (let ([z -3.1-9.9i])
       (cfl~= (atanh z) (* -1.0i (atan (* +1.0i z)))))
     (not (= (imag-part (atanh 2)) 0))
     (not (= (imag-part (atanh -2)) 0))
     (let ([z 3.2+2.3i])
       (cfl~= (sinh z) (* (tanh z) (cosh z))))
     (let ([z 100+99.0i])
       (cfl~= (atanh z) (- (atanh (- z)))))
     (let ([z 2.3-3.2i])
       (let ([c (cosh z)] [s (sinh z)])
         (cfl~= (- (* c c) (* s s)) 1.0))))

(mat ash
     (error? (ash))
     (error? (ash 1))
     (error? (ash 1 1 1))
     (error? (ash .1 1))
     (error? (ash 1 .1))
     #;
     (error? (ash 1 (+ (most-positive-fixnum) 1)))
     #;
     (error? (ash 1 (- (most-negative-fixnum) 1)))
     (= (ash 234 0) 234)
     (= (ash 1 4) 16)
     (= (ash 8 -4) 0)
     (= (ash (ash 4 4) -4) 4)
     (= (ash 1 100) (expt 2 100))
     (= (ash 1 -100) 0)
     (= (ash (ash 1 100) -100) 1)
     (= (ash 100 100) (* 100 (expt 2 100)))
     (let ([x 11111111111111111111111111111111111111111111111] [n 10])
       (= (ash x n) (* x (expt 2 n))))
     (let ([x 11111111111111111111111111111111111111111111111] [n -10])
       (= (ash x n) (floor (* x (expt 2 n)))))
     (let ([x -11111111111111111111111111111111111111111111111] [n 10])
       (= (ash x n) (* x (expt 2 n))))
     (let ([x -11111111111111111111111111111111111111111111111] [n -10])
       (= (ash x n) (floor (* x (expt 2 n)))))
     (let ([x (- (expt 2 29))] [n -1])
       (= (ash x n) (floor (* x (expt 2 n)))))
     (let ([x (- (expt 2 30))] [n -1])
       (= (ash x n) (floor (* x (expt 2 n)))))
     (let ([x (most-negative-fixnum)] [n -1])
       (= (ash x n) (floor (* x (expt 2 n)))))
     (let ([x (- (most-negative-fixnum) 1)] [n -1])
       (= (ash x n) (floor (* x (expt 2 n)))))
     ; check for bugs with large negative shift counts
     (= (ash 1 -32) 0)
     (= (ash 1 -33) 0)
     (= (ash 1 -96) 0)
     (= (ash 987239487293874234 -1000) 0)
     (= (ash -987239487293874234 -1000) -1)
     (let f ([i -1000])
       (or (fx= i 0)
           (and (negative?
                  (ash -232342342340033477676766821733948948594358 i))
                (f (fx+ i 1)))))
     (eqv? (ash #x-8000000000000000 -31) #x-100000000)
     (eqv? (ash #x-8000000000000000 -32) #x-80000000)
     (eqv? (ash #x-8000000000000000 -33) #x-40000000))

(mat bitwise-arithmetic-shift
     (error? (bitwise-arithmetic-shift))
     (error? (bitwise-arithmetic-shift 1))
     (error? (bitwise-arithmetic-shift 1 1 1))
     (error? (bitwise-arithmetic-shift .1 1))
     (error? (bitwise-arithmetic-shift 1 .1))
     (= (bitwise-arithmetic-shift 234 0) 234)
     (= (bitwise-arithmetic-shift 1 4) 16)
     (= (bitwise-arithmetic-shift 8 -4) 0)
     (= (bitwise-arithmetic-shift (bitwise-arithmetic-shift 4 4) -4) 4)
     (= (bitwise-arithmetic-shift 1 100) (expt 2 100))
     (= (bitwise-arithmetic-shift 1 -100) 0)
     (= (bitwise-arithmetic-shift (bitwise-arithmetic-shift 1 100) -100) 1)
     (= (bitwise-arithmetic-shift 100 100) (* 100 (expt 2 100)))
     (let ([x 11111111111111111111111111111111111111111111111] [n 10])
       (= (bitwise-arithmetic-shift x n) (* x (expt 2 n))))
     (let ([x 11111111111111111111111111111111111111111111111] [n -10])
       (= (bitwise-arithmetic-shift x n) (floor (* x (expt 2 n)))))
     (let ([x -11111111111111111111111111111111111111111111111] [n 10])
       (= (bitwise-arithmetic-shift x n) (* x (expt 2 n))))
     (let ([x -11111111111111111111111111111111111111111111111] [n -10])
       (= (bitwise-arithmetic-shift x n) (floor (* x (expt 2 n)))))
     (let ([x (- (expt 2 29))] [n -1])
       (= (bitwise-arithmetic-shift x n) (floor (* x (expt 2 n)))))
     (let ([x (- (expt 2 30))] [n -1])
       (= (bitwise-arithmetic-shift x n) (floor (* x (expt 2 n)))))
     (let ([x (most-negative-fixnum)] [n -1])
       (= (bitwise-arithmetic-shift x n) (floor (* x (expt 2 n)))))
     (let ([x (- (most-negative-fixnum) 1)] [n -1])
       (= (bitwise-arithmetic-shift x n) (floor (* x (expt 2 n)))))
     ; check for bugs with large negative shift counts
     (= (bitwise-arithmetic-shift 1 -32) 0)
     (= (bitwise-arithmetic-shift 1 -33) 0)
     (= (bitwise-arithmetic-shift 1 -96) 0)
     (= (bitwise-arithmetic-shift 987239487293874234 -1000) 0)
     (= (bitwise-arithmetic-shift -987239487293874234 -1000) -1)
     (let f ([i -1000])
       (or (fx= i 0)
           (and (negative?
                  (bitwise-arithmetic-shift
                    -232342342340033477676766821733948948594358
                    i))
                (f (fx+ i 1)))))
     (eqv? (bitwise-arithmetic-shift #x-8000000000000000 -31) #x-100000000)
     (eqv? (bitwise-arithmetic-shift #x-8000000000000000 -32) #x-80000000)
     (eqv? (bitwise-arithmetic-shift #x-8000000000000000 -33) #x-40000000))

(mat bitwise-arithmetic-shift-left/right
     (error? (bitwise-arithmetic-shift-left))
     (error? (bitwise-arithmetic-shift-left 1))
     (error? (bitwise-arithmetic-shift-left 1 1 1))
     (error? (bitwise-arithmetic-shift-left .1 1))
     (error? (bitwise-arithmetic-shift-left 1 .1))
     (= (bitwise-arithmetic-shift-left 234 0) 234)
     (= (bitwise-arithmetic-shift-left 1 4) 16)
     (= (bitwise-arithmetic-shift-right 8 4) 0)
     (= (bitwise-arithmetic-shift-right
          (bitwise-arithmetic-shift-left 4 4)
          4)
        4)
     (= (bitwise-arithmetic-shift-left 1 100) (expt 2 100))
     (= (bitwise-arithmetic-shift-right 1 100) 0)
     (= (bitwise-arithmetic-shift-right
          (bitwise-arithmetic-shift-left 1 100)
          100)
        1)
     (= (bitwise-arithmetic-shift-left 100 100) (* 100 (expt 2 100)))
     (let ([x 11111111111111111111111111111111111111111111111] [n 10])
       (= (bitwise-arithmetic-shift-left x n) (* x (expt 2 n))))
     (let ([x 11111111111111111111111111111111111111111111111] [n -10])
       (= (bitwise-arithmetic-shift-right x (- n))
          (floor (* x (expt 2 n)))))
     (let ([x -11111111111111111111111111111111111111111111111] [n 10])
       (= (bitwise-arithmetic-shift-left x n) (* x (expt 2 n))))
     (let ([x -11111111111111111111111111111111111111111111111] [n -10])
       (= (bitwise-arithmetic-shift-right x (- n))
          (floor (* x (expt 2 n)))))
     (let ([x (- (expt 2 29))] [n -1])
       (= (bitwise-arithmetic-shift-right x (- n))
          (floor (* x (expt 2 n)))))
     (let ([x (- (expt 2 30))] [n -1])
       (= (bitwise-arithmetic-shift-right x (- n))
          (floor (* x (expt 2 n)))))
     (let ([x (most-negative-fixnum)] [n -1])
       (= (bitwise-arithmetic-shift-right x (- n))
          (floor (* x (expt 2 n)))))
     (let ([x (- (most-negative-fixnum) 1)] [n -1])
       (= (bitwise-arithmetic-shift-right x (- n))
          (floor (* x (expt 2 n)))))
     ; check for bugs with large negative shift counts
     (= (bitwise-arithmetic-shift-right 1 32) 0)
     (= (bitwise-arithmetic-shift-right 1 33) 0)
     (= (bitwise-arithmetic-shift-right 1 96) 0)
     (= (bitwise-arithmetic-shift-right 987239487293874234 1000) 0)
     (= (bitwise-arithmetic-shift-right -987239487293874234 1000) -1)
     (let f ([i -1000])
       (or (fx= i 0)
           (and (negative?
                  (bitwise-arithmetic-shift-right
                    -232342342340033477676766821733948948594358
                    (- i)))
                (f (fx+ i 1)))))
     (eqv? (bitwise-arithmetic-shift-right #x-8000000000000000 31)
           #x-100000000)
     (eqv? (bitwise-arithmetic-shift-right #x-8000000000000000 32)
           #x-80000000)
     (eqv? (bitwise-arithmetic-shift-right #x-8000000000000000 33)
           #x-40000000))

(mat bitwise-bit-field
     (error? (bitwise-bit-field))
     (error? (bitwise-bit-field 35))
     (error? (bitwise-bit-field 35 5))
     (error? (bitwise-bit-field 35 5 8 15))
     (error? (bitwise-bit-field 35.0 5 8))
     (error? (bitwise-bit-field 35 5.0 8))
     (error? (bitwise-bit-field 35 5 8.0))
     (error? (bitwise-bit-field 'a 5 8))
     (error? (bitwise-bit-field 35 '(a b) 8))
     (error? (bitwise-bit-field 35 5 "hello"))
     (error? (bitwise-bit-field 35 -5 8))
     (error? (bitwise-bit-field 35 5 -8))
     (error? (bitwise-bit-field 35 5 3))
     (error? (bitwise-bit-field 35
               (+ (* (greatest-fixnum) 2) 10)
               (* (greatest-fixnum) 2)))
     (eqv? (bitwise-bit-field 35 100 150) 0)
     (eqv? (bitwise-bit-field -35 100 150) (- (expt 2 50) 1))
     (do ([n 1000 (fx- n 1)])
         ((fx= n 0) #t)
         (let ([x (random (expt 10 1000))])
           (let ([len (integer-length x)])
             (let ([i (random len)] [j (random len)])
               (let-values ([(i j) (if (< i j) (values i j) (values j i))])
                 (unless (= (bitwise-ior
                              (bitwise-arithmetic-shift-left
                                (bitwise-bit-field x i j)
                                i)
                              (bitwise-arithmetic-shift-left
                                (bitwise-bit-field x j len)
                                j)
                              (bitwise-bit-field x 0 i))
                            x)
                         (errorf #f "failed for ~s, ~s, ~s" x i j)))))))
     (do ([n 1000 (fx- n 1)])
         ((fx= n 0) #t)
         (let ([x (- (random (expt 10 1000)))])
           (let ([len (integer-length x)])
             (let ([i (random len)] [j (random len)])
               (let-values ([(i j) (if (< i j) (values i j) (values j i))])
                 (unless (= (bitwise-ior
                              (bitwise-arithmetic-shift-left -1 len)
                              (bitwise-arithmetic-shift-left
                                (bitwise-bit-field x i j)
                                i)
                              (bitwise-arithmetic-shift-left
                                (bitwise-bit-field x j len)
                                j)
                              (bitwise-bit-field x 0 i))
                            x)
                         (errorf #f "failed for ~s, ~s, ~s" x i j)))))))
     (eqv? (bitwise-bit-field 35
             (* (greatest-fixnum) 2)
             (+ (* (greatest-fixnum) 2) 10))
           0)
     (eqv? (bitwise-bit-field -35
             (* (greatest-fixnum) 2)
             (+ (* (greatest-fixnum) 2) 10))
           #b1111111111)
     (eqv? (bitwise-bit-field (+ (greatest-fixnum) 1)
             (* (greatest-fixnum) 2)
             (+ (* (greatest-fixnum) 2) 10))
           0)
     (eqv? (bitwise-bit-field (- (least-fixnum) 1)
             (* (greatest-fixnum) 2)
             (+ (* (greatest-fixnum) 2) 10))
           #b1111111111))

(mat bitwise-copy-bit-field
     (error? (bitwise-copy-bit-field))
     (error? (bitwise-copy-bit-field 0))
     (error? (bitwise-copy-bit-field 0 0))
     (error? (bitwise-copy-bit-field 0 0 0))
     (error? (bitwise-copy-bit-field 0 0 0 0 0))
     (error? (bitwise-copy-bit-field 'a 0 0 0))
     (error? (bitwise-copy-bit-field 0 0.0 0 0))
     (error? (bitwise-copy-bit-field 0 0 2.0 0))
     (error? (bitwise-copy-bit-field 0 0 0 3/4))
     (error? (bitwise-copy-bit-field 0 -1 0 0))
     (error? (bitwise-copy-bit-field 0 (- (most-negative-fixnum) 1) 0 0))
     (error? (bitwise-copy-bit-field 0 0 -5 0))
     (error? (bitwise-copy-bit-field 0 0 (- (most-negative-fixnum) 1) 0))
     (error? (bitwise-copy-bit-field 0 -10 -5 0))
     (error? (bitwise-copy-bit-field 0 7 5 0))
     (error? (bitwise-copy-bit-field 0
               (+ (most-positive-fixnum) 1)
               (most-positive-fixnum)
               0))
     (error? (bitwise-copy-bit-field 0
               (+ (most-positive-fixnum) 2)
               (+ (most-positive-fixnum) 1)
               0))
     (eqv? (bitwise-copy-bit-field 0 0 0 0) 0)
     (eqv? (bitwise-copy-bit-field -1 0 0 0) -1)
     (eqv? (bitwise-copy-bit-field #b101101011101111 2 7 #b10101010101010)
           #b101101010101011)
     (eqv? (bitwise-copy-bit-field
             #xabcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789
             12
             132
             #xdcabe15629dcabe15629dcabe15629dcabe15629)
           #xabcdef0123456789abcdef0123456789abcdef012345678dcabe15629dcabe15629dcabe15629789)
     (let ()
       (define (r6rs-bitwise-copy-bit-field ei1 ei2 ei3 ei4)
         (let* ([to ei1]
                [start ei2]
                [end ei3]
                [from ei4]
                [mask1 (bitwise-arithmetic-shift-left -1 start)]
                [mask2 (bitwise-not (bitwise-arithmetic-shift-left -1 end))]
                [mask (bitwise-and mask1 mask2)])
           (bitwise-if mask (bitwise-arithmetic-shift-left from start) to)))
       (do ([n 500 (fx- n 1)])
           ((fx= n 0) #t)
           (let ([x (random (+ (most-positive-fixnum) 1))]
                 [y (+ (most-positive-fixnum) 1)])
             (let ([i (random (fixnum-width))] [j (random (fixnum-width))])
               (let-values ([(i j) (if (< i j) (values i j) (values j i))])
                 (unless (and (= (bitwise-copy-bit-field x i j y)
                                 (r6rs-bitwise-copy-bit-field x i j y))
                              (= (bitwise-copy-bit-field (- x) i j y)
                                 (r6rs-bitwise-copy-bit-field (- x) i j y))
                              (= (bitwise-copy-bit-field x i j (- y))
                                 (r6rs-bitwise-copy-bit-field x i j (- y)))
                              (= (bitwise-copy-bit-field (- x) i j (- y))
                                 (r6rs-bitwise-copy-bit-field (- x) i j (- y))))
                         (errorf #f "failed for ~s ~s ~s ~s" x i j y))))))
       (do ([n 500 (fx- n 1)])
           ((fx= n 0) #t)
           (let ([x (random (expt 10 100))] [y (random (expt 10 1000))])
             (let ([len (integer-length x)])
               (let ([i (random len)] [j (random len)])
                 (let-values ([(i j) (if (< i j) (values i j) (values j i))])
                   (unless (and (= (bitwise-copy-bit-field x i j y)
                                   (r6rs-bitwise-copy-bit-field x i j y))
                                (= (bitwise-copy-bit-field (- x) i j y)
                                   (r6rs-bitwise-copy-bit-field (- x) i j y))
                                (= (bitwise-copy-bit-field x i j (- y))
                                   (r6rs-bitwise-copy-bit-field x i j (- y)))
                                (= (bitwise-copy-bit-field (- x) i j (- y))
                                   (r6rs-bitwise-copy-bit-field (- x) i j (- y))))
                           (errorf #f "failed for ~s ~s ~s ~s" x i j y)))))))))

(mat bitwise-rotate-bit-field
     (error? (bitwise-rotate-bit-field))
     (error? (bitwise-rotate-bit-field 0))
     (error? (bitwise-rotate-bit-field 0 0))
     (error? (bitwise-rotate-bit-field 0 0 0))
     (error? (bitwise-rotate-bit-field 0 0 0 0 0))
     (error? (bitwise-rotate-bit-field 'a 0 0 0))
     (error? (bitwise-rotate-bit-field 0 0.0 0 0))
     (error? (bitwise-rotate-bit-field 0 0 2.0 0))
     (error? (bitwise-rotate-bit-field 0 0 0 3/4))
     (error? (bitwise-rotate-bit-field 0 -1 0 0))
     (error? (bitwise-rotate-bit-field 0 (- (most-negative-fixnum) 1) 0 0))
     (error? (bitwise-rotate-bit-field 0 0 -5 0))
     (error? (bitwise-rotate-bit-field 0 0 (- (most-negative-fixnum) 1) 0))
     (error? (bitwise-rotate-bit-field 0 0 0 -1))
     (error? (bitwise-rotate-bit-field 0 -10 -5 0))
     (error? (bitwise-rotate-bit-field 0 7 5 0))
     (error? (bitwise-rotate-bit-field 0
               (+ (most-positive-fixnum) 1)
               (most-positive-fixnum)
               0))
     (error? (bitwise-rotate-bit-field 0
               (+ (most-positive-fixnum) 2)
               (+ (most-positive-fixnum) 1)
               0))
     (eqv? (bitwise-rotate-bit-field 0 0 0 0) 0)
     (eqv? (bitwise-rotate-bit-field -1 0 0 0) -1)
     (eqv? (bitwise-rotate-bit-field #b101101011101111 2 7 3)
           #b101101011111011)
     (eqv? (bitwise-rotate-bit-field #b101101011101111 2 7 153)
           #b101101011111011)
     (eqv? (bitwise-rotate-bit-field
             #b101101011101111
             2
             7
             (+ (expt 5 100) 3))
           #b101101011111011)
     (eqv? (bitwise-rotate-bit-field
             #xabcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789
             12
             132
             20)
           #xabcdef0123456789abcdef0123456789abcdef012345678ef0123456789abcdef01234569abcd789)
     (let ()
       (define (r6rs-bitwise-rotate-bit-field ei1 ei2 ei3 ei4)
         (let* ([n ei1]
                [start ei2]
                [end ei3]
                [count ei4]
                [width (- end start)])
           (if (positive? width)
               (let* ([count (mod count width)]
                      [field0 (bitwise-bit-field n start end)]
                      [field1 (bitwise-arithmetic-shift-left field0 count)]
                      [field2 (bitwise-arithmetic-shift-right field0
                                (- width count))]
                      [field (bitwise-ior field1 field2)])
                 (bitwise-copy-bit-field n start end field))
               n)))
       (do ([n 500 (fx- n 1)])
           ((fx= n 0) #t)
           (let ([x (random (+ (most-positive-fixnum) 1))])
             (let ([i (random (fixnum-width))]
                   [j (random (fixnum-width))]
                   [k (random (most-positive-fixnum))])
               (let-values ([(i j) (if (< i j) (values i j) (values j i))])
                 (unless (and (= (bitwise-rotate-bit-field x i j k)
                                 (r6rs-bitwise-rotate-bit-field x i j k))
                              (= (bitwise-rotate-bit-field (- x) i j k)
                                 (r6rs-bitwise-rotate-bit-field (- x) i j k)))
                         (errorf #f "failed for ~s ~s ~s ~s" x i j k))))))
       (do ([n 500 (fx- n 1)])
           ((fx= n 0) #t)
           (let ([x (random (expt 10 100))])
             (let ([len (integer-length x)])
               (let ([i (random len)]
                     [j (random len)]
                     [k (random (* (most-positive-fixnum) 2))])
                 (let-values ([(i j) (if (< i j) (values i j) (values j i))])
                   (unless (and (= (bitwise-rotate-bit-field x i j k)
                                   (r6rs-bitwise-rotate-bit-field x i j k))
                                (= (bitwise-rotate-bit-field (- x) i j k)
                                   (r6rs-bitwise-rotate-bit-field (- x) i j k)))
                           (errorf #f "failed for ~s ~s ~s ~s" x i j k)))))))))

(mat bitwise-bit-field
     (error? (bitwise-reverse-bit-field))
     (error? (bitwise-reverse-bit-field 35))
     (error? (bitwise-reverse-bit-field 35 5))
     (error? (bitwise-reverse-bit-field 35 5 8 15))
     (error? (bitwise-reverse-bit-field 35.0 5 8))
     (error? (bitwise-reverse-bit-field 35 5.0 8))
     (error? (bitwise-reverse-bit-field 35 5 8.0))
     (error? (bitwise-reverse-bit-field 'a 5 8))
     (error? (bitwise-reverse-bit-field 35 '(a b) 8))
     (error? (bitwise-reverse-bit-field 35 5 "hello"))
     (error? (bitwise-reverse-bit-field 35 -5 8))
     (error? (bitwise-reverse-bit-field 35 5 -8))
     (error? (bitwise-reverse-bit-field 35 5 3))
     (error? (bitwise-reverse-bit-field 35
               (+ (* (greatest-fixnum) 2) 10)
               (* (greatest-fixnum) 2)))
     (eqv? (bitwise-reverse-bit-field 35 100 150) 35)
     (eqv? (bitwise-reverse-bit-field -35 100 150) -35)
     (eqv? (bitwise-reverse-bit-field 0 0 10) 0)
     (eqv? (bitwise-reverse-bit-field -1 0 10) -1)
     (eqv? (bitwise-reverse-bit-field #b101101011101111 2 7)
           #b101101011101111)
     (eqv? (bitwise-reverse-bit-field #b101101011101111 3 9)
           #b101101101110111)
     (eqv? (bitwise-reverse-bit-field
             (greatest-fixnum)
             0
             (fx- (fixnum-width) 1))
           (greatest-fixnum))
     (eqv? (bitwise-reverse-bit-field
             (greatest-fixnum)
             0
             (fx- (fixnum-width) 1))
           (greatest-fixnum))
     (eqv? (bitwise-reverse-bit-field
             (least-fixnum)
             0
             (fx- (fixnum-width) 1))
           (least-fixnum))
     (eqv? (bitwise-reverse-bit-field
             (least-fixnum)
             0
             (fx- (fixnum-width) 1))
           (least-fixnum))
     (eqv? (bitwise-reverse-bit-field -1 0 (fx- (fixnum-width) 1)) -1)
     (eqv? (bitwise-reverse-bit-field -1 0 (fx- (fixnum-width) 1)) -1)
     (let ()
       (define (refimpl n start end)
         (define (swap n i j)
           (bitwise-copy-bit
             (bitwise-copy-bit n i (bitwise-bit-field n j (+ j 1)))
             j
             (bitwise-bit-field n i (+ i 1))))
         (let ([end (- end 1)])
           (if (>= start end)
               n
               (refimpl (swap n start end) (+ start 1) end))))
       (do ([n 500 (- n 1)])
           ((= n 0) #t)
           (let* ([x (random (expt (greatest-fixnum) 10))]
                  [maxend (+ (bitwise-length x) 10)])
             (let ([i (random maxend)] [j (random maxend)])
               (let-values ([(i j) (if (< i j) (values i j) (values j i))])
                 (unless (and (= (bitwise-reverse-bit-field x i j)
                                 (refimpl x i j))
                              (= (bitwise-reverse-bit-field (- x) i j)
                                 (refimpl (- x) i j)))
                         (errorf #f "failed for ~s ~s ~s" x i j))))))))

(mat exact-integer-sqrt
     (error? (exact-integer-sqrt))
     (error? (exact-integer-sqrt 3 4))
     (error? (exact-integer-sqrt 1.0))
     (error? (exact-integer-sqrt 'a))
     (error? (exact-integer-sqrt -1))
     (error? (exact-integer-sqrt 10.0+0.0i))
     (begin
       (define ($eispair x)
         (call-with-values (lambda () (exact-integer-sqrt x)) cons))
       #t)
     (equal? ($eispair 1) '(1 . 0))
     (equal? ($eispair 9) '(3 . 0))
     (equal? ($eispair 10) '(3 . 1))
     (equal? ($eispair 1000) '(31 . 39))
     (do ([n 1000 (fx- n 1)])
         ((fx= n 0) #t)
         (let ([x (random (expt 10 1000))])
           (unless (let ([p ($eispair x)])
                     (let ([s (car p)] [r (cdr p)])
                       (and (<= (* s s) x)
                            (> (* (+ s 1) (+ s 1)) x)
                            (= (+ (* s s) r) x))))
                   (errorf #f "failed for ~s" x)))))


(define x -11111111111111111111111111111111111111111111111)
(define n -10)


(mat integer-length
     (error? (integer-length))
     (error? (integer-length 1 1 1))
     (error? (integer-length .1))
     (= (integer-length 0) 0)
     (= (integer-length 1) 1)
     (= (integer-length 3) 2)
     (= (integer-length 4) 3)
     (= (integer-length 7) 3)
     (= (integer-length -1) 0)
     (= (integer-length -4) 2)
     (= (integer-length -7) 3)
     (= (integer-length -8) 3)
     (= (integer-length (expt 2 1000)) 1001)
     (= (integer-length (+ (expt 2 1000) 1)) 1001)
     (= (integer-length (- (expt 2 1000) 1)) 1000)
     (= (integer-length (- (expt 2 1000))) 1000)
     (= (integer-length (- -1 (expt 2 1000))) 1001)
     (= (integer-length (- 1 (expt 2 1000))) 1000))

(mat bitwise-length
     (error? (bitwise-length))
     (error? (bitwise-length 1 1 1))
     (error? (bitwise-length .1))
     (= (bitwise-length 0) 0)
     (= (bitwise-length 1) 1)
     (= (bitwise-length 3) 2)
     (= (bitwise-length 4) 3)
     (= (bitwise-length 7) 3)
     (= (bitwise-length -1) 0)
     (= (bitwise-length -4) 2)
     (= (bitwise-length -7) 3)
     (= (bitwise-length -8) 3)
     (= (bitwise-length (expt 2 1000)) 1001)
     (= (bitwise-length (+ (expt 2 1000) 1)) 1001)
     (= (bitwise-length (- (expt 2 1000) 1)) 1000)
     (= (bitwise-length (- (expt 2 1000))) 1000)
     (= (bitwise-length (- -1 (expt 2 1000))) 1001)
     (= (bitwise-length (- 1 (expt 2 1000))) 1000)
     (let ()
       (define r6rs-length
         (lambda (x)
           (do ([result 0 (+ result 1)]
                [bits (if (negative? x) (bitwise-not x) x)
                      (bitwise-arithmetic-shift-right bits 1)])
               ((zero? bits) result))))
       (let f ([n 10000])
         (or (= n 0)
             (let ([x (random (expt 2 1000))])
               (and (= (bitwise-length x) (r6rs-length x))
                    (= (bitwise-length (- x)) (r6rs-length (- x)))
                    (f (- n 1))))))))

(mat bitwise-bit-count
     (error? (bitwise-bit-count))
     (error? (bitwise-bit-count 75 32))
     (error? (bitwise-bit-count 3.0))
     (error? (bitwise-bit-count 'a))
     (eqv? (bitwise-bit-count 0) 0)
     (eqv? (bitwise-bit-count #xabcd) 10)
     (eqv? (bitwise-bit-count #xabcdf0123456789abcdef0123456789) 61)
     (eqv? (bitwise-bit-count -1) -1)
     (eqv? (bitwise-bit-count -10) -3)
     (equal? (map bitwise-bit-count '(0 1 2 3 4 5 6 7 8 9 10))
             '(0 1 1 2 1 2 2 3 1 2 2))
     (equal? (map bitwise-bit-count '(-1 -2 -3 -4 -5 -6 -7 -8 -9 -10))
             '(-1 -2 -2 -3 -2 -3 -3 -4 -2 -3))
     (let ([n (expt (+ (greatest-fixnum) 1) 4)])
       (let f ([i 2] [j 1])
         (or (= i n)
             (and (eqv? (bitwise-bit-count i) 1)
                  (eqv? (bitwise-bit-count (+ i 1)) 2)
                  (eqv? (bitwise-bit-count (- i 1)) j)
                  (f (bitwise-arithmetic-shift i 1) (+ j 1))))))
     (let ([n (expt (+ (greatest-fixnum) 1) 4)])
       (define slow-bit-count
         (lambda (x)
           (if (< x 0)
               (bitwise-not (slow-bit-count (bitwise-not x)))
               (let f ([x x] [c 0])
                 (if (= x 0)
                     c
                     (f (bitwise-arithmetic-shift-right x 1)
                        (if (bitwise-bit-set? x 0)
                            (+ c 1)
                            c)))))))
       (let f ([i 10000])
         (let ([r (random n)])
           (or (fx= i 0)
               (and (= (bitwise-bit-count r) (slow-bit-count r))
                    (= (bitwise-bit-count (- r)) (slow-bit-count (- r)))
                    (f (fx- i 1))))))))

(mat bitwise-first-bit-set
     (error? (bitwise-first-bit-set))
     (error? (bitwise-first-bit-set 75 32))
     (error? (bitwise-first-bit-set 3.0))
     (error? (bitwise-first-bit-set 'a))
     (eqv? (bitwise-first-bit-set 0) -1)
     (eqv? (bitwise-first-bit-set 1) 0)
     (eqv? (bitwise-first-bit-set -1) 0)
     (eqv? (bitwise-first-bit-set -4) 2)
     (eqv? (bitwise-first-bit-set #xabcdf0123400000000000000000) 70)
     (eqv? (bitwise-first-bit-set #x-abcdf0123400000000000000000) 70)
     (equal? (map bitwise-first-bit-set '(0 1 2 3 4 5 6 7 8 9 10))
             '(-1 0 1 0 2 0 1 0 3 0 1))
     (equal? (map bitwise-first-bit-set '(-1 -2 -3 -4 -5 -6 -7 -8 -9 -10))
             '(0 1 0 2 0 1 0 3 0 1))
     (let ([n (expt (+ (greatest-fixnum) 1) 4)])
       (let f ([i 2] [j 1])
         (or (= i n)
             (and (eqv? (bitwise-first-bit-set i) j)
                  (eqv? (bitwise-first-bit-set (+ i 1)) 0)
                  (eqv? (bitwise-first-bit-set (- i 1)) 0)
                  (f (bitwise-arithmetic-shift i 1) (fx+ j 1))))))
     (let ([n (+ (greatest-fixnum) 1)])
       (define slow-first-bit-set
         (lambda (x)
           (if (= x 0)
               0
               (let f ([x x])
                 (if (odd? x)
                     0
                     (+ (f (bitwise-arithmetic-shift-right x 1)) 1))))))
       (let f ([i 10000])
         (let ([r (bitwise-arithmetic-shift-left (random n) (random 100))])
           (unless (fx= i 0)
                   (unless (and (= (bitwise-first-bit-set r)
                                   (slow-first-bit-set r))
                                (= (bitwise-first-bit-set (- r))
                                   (slow-first-bit-set (- r))))
                           (errorf #f "failed for ~s" r))
                   (f (fx- i 1)))))
       #t))

(define quotient-remainder
  (parameterize ([subset-mode 'system]) (eval '$quotient-remainder)))

(mat $quotient-remainder
     (error? (quotient-remainder))
     (error? (quotient-remainder 1))
     (error? (quotient-remainder 1 1 1))
     (error? (quotient-remainder 1 0))
     (equal? (quotient-remainder 103 5) '(20 . 3))
     (equal? (quotient-remainder 103 -5) '(-20 . 3))
     (equal? (quotient-remainder -103 5) '(-20 . -3))
     (equal? (quotient-remainder -103 -5) '(20 . -3))
     (let ([x 11111111111111111] [y 11111111111111])
       (equal? (quotient-remainder x y)
               (cons (quotient x y) (remainder x y))))
     (let ([x 11111111111111111] [y -11111111111111])
       (equal? (quotient-remainder x y)
               (cons (quotient x y) (remainder x y))))
     (let ([x -11111111111111111] [y 11111111111111])
       (equal? (quotient-remainder x y)
               (cons (quotient x y) (remainder x y))))
     (let ([x -11111111111111111] [y -11111111111111])
       (equal? (quotient-remainder x y)
               (cons (quotient x y) (remainder x y))))
     ;; following returns incorrect result in all versions prior to 5.9b
     (equal? (quotient-remainder (most-negative-fixnum)
               (- (most-negative-fixnum)))
             '(-1 . 0)))

(mat lognot
     (error? (lognot (void)))
     (error? (lognot "hello"))
     (error? (lognot 3/4))
     (error? (lognot 7.7))
     (error? (lognot 1+3i))
     (error? (lognot 1.0-7.5i))
     (error? (lognot 3.0))
     (eqv? (lognot 0) -1)
     (eqv? (lognot -1) 0)
     (eqv? (lognot 2) -3)
     (eqv? (lognot #xfffffffffffffffffffffffffffff)
           #x-100000000000000000000000000000)
     (eqv? (lognot #x-100000000000000000000000000000)
           #xfffffffffffffffffffffffffffff))

(mat bitwise-not
     (error? (bitwise-not (void)))
     (error? (bitwise-not "hello"))
     (error? (bitwise-not 3/4))
     (error? (bitwise-not 7.7))
     (error? (bitwise-not 1+3i))
     (error? (bitwise-not 1.0-7.5i))
     (error? (bitwise-not 3.0))
     (eqv? (bitwise-not 0) -1)
     (eqv? (bitwise-not -1) 0)
     (eqv? (bitwise-not 2) -3)
     (eqv? (bitwise-not #xfffffffffffffffffffffffffffff)
           #x-100000000000000000000000000000)
     (eqv? (bitwise-not #x-100000000000000000000000000000)
           #xfffffffffffffffffffffffffffff))

(mat logand
     (error? (logand (void) 0))
     (error? (logand 0 (void)))
     (error? (logand 'a 17))
     (error? (logand 17 'a))
     (error? (logand 25 "oops"))
     (error? (logand "oops" 25))
     (error? (logand 25 3.4))
     (error? (logand 3.4 25))
     (error? (logand 0 3/4))
     (error? (logand 3/4 0))
     (error? (logand 0 1+1i))
     (error? (logand 1+1i 0))
     (error? (logand 1 3.4-2.3i))
     (error? (logand 3.4-2.3i 1))
     (error? (logand 3.0 4.0))
     (eqv? (logand 0 0) 0)
     (eqv? (logand -1 0) 0)
     (eqv? (logand #xfffffffffffffffffffffffff 0) 0)
     (eqv? (logand 0 -1) 0)
     (eqv? (logand 0 #xfffffffffffffffffffffffff) 0)
     (eqv? (logand 20 -1) 20)
     (eqv? (logand #xfffffffffffffffffffffffff -1)
           #xfffffffffffffffffffffffff)
     (eqv? (logand #x1111111111111111111111111 -1)
           #x1111111111111111111111111)
     (eqv? (logand (- (expt 2 300) 167) -1) (- (expt 2 300) 167))
     (eqv? (logand (- 167 (expt 2 300)) -1) (- 167 (expt 2 300)))
     (eqv? (logand (- (expt 2 300) 167) (- (expt 2 300) 167))
           (- (expt 2 300) 167))
     (eqv? (logand (- 167 (expt 2 300)) (- 167 (expt 2 300)))
           (- 167 (expt 2 300)))
     (eqv? (logand #x1111111111111111111111111 #x2222222222222222222222222)
           0)
     (eqv? (logand #x1212121212121212121212121 #x2222222222222222222222222)
           #x202020202020202020202020)
     (eqv? (logand #x-1212121212121212121212121
                   #x-2222222222222222222222222)
           #x-3232323232323232323232322)
     (eqv? (logand #x-123456789abcdeffedca987654321
                   #xfedca987654321123456789abcdef)
           #xECC8A9876543210010146088A8CCF)
     (eqv? (logand #x2B225D27F49C1FED301B89103 #x-F2D8DD782236F835A1A50858)
           #x20025020749C106C200189100)
     (eqv? (logand #x2B225D27F49C1FED301B89103 #x1F366567) #x1300103)
     (eqv? (logand #x2B225D27F49C1FED301B89103 #x-717D004)
           #x2B225D27F49C1FED300A80100)
     (eqv? (logand #x-F2D8DD782236F835A1A50858 #x1F366567) #x1E126520)
     (eqv? (logand #x-F2D8DD782236F835A1A50858 #x-717D004)
           #x-F2D8DD782236F835A7B7D858)
     (eqv? (logand #x1F366567 #x2B225D27F49C1FED301B89103) #x1300103)
     (eqv? (logand #x-717D004 #x2B225D27F49C1FED301B89103)
           #x2B225D27F49C1FED300A80100)
     (eqv? (logand #x1F366567 #x-F2D8DD782236F835A1A50858) #x1E126520)
     (eqv? (logand #x-717D004 #x-F2D8DD782236F835A1A50858)
           #x-F2D8DD782236F835A7B7D858)
     (eqv? (logand) -1)
     (eqv? (logand #x1212121212121212121212121)
           #x1212121212121212121212121)
     (eqv? (logand #x1212121212121212121212121
                   #x2222222222222222222222222
                   #x0103010301030103010301030)
           #x2000200020002000200020)
     (eqv? (logand #b1110111 #b1101011 -1 #b1011110 #b1000111) #b1000010)
     (eqv? (logand #b1110111 #b1101011 0 #b1011110 #b1000111) 0)
     (test-cp0-expansion eqv? '(logand 0 0) 0)
     (test-cp0-expansion eqv? '(logand -1 0) 0)
     (test-cp0-expansion eqv? '(logand #xfffffffffffffffffffffffff 0) 0)
     (test-cp0-expansion eqv? '(logand 0 -1) 0)
     (test-cp0-expansion eqv? '(logand 0 #xfffffffffffffffffffffffff) 0)
     (test-cp0-expansion eqv? '(logand 20 -1) 20)
     (test-cp0-expansion eqv?
       '(logand #xfffffffffffffffffffffffff -1)
       #xfffffffffffffffffffffffff)
     (test-cp0-expansion eqv?
       '(logand #x1111111111111111111111111 -1)
       #x1111111111111111111111111)
     (test-cp0-expansion eqv?
       '(logand (- (expt 2 300) 167) -1)
       (- (expt 2 300) 167))
     (test-cp0-expansion eqv?
       '(logand (- 167 (expt 2 300)) -1)
       (- 167 (expt 2 300)))
     (test-cp0-expansion eqv?
       '(logand (- (expt 2 300) 167) (- (expt 2 300) 167))
       (- (expt 2 300) 167))
     (test-cp0-expansion eqv?
       '(logand (- 167 (expt 2 300)) (- 167 (expt 2 300)))
       (- 167 (expt 2 300)))
     (test-cp0-expansion eqv?
       '(logand #x1111111111111111111111111 #x2222222222222222222222222)
       0)
     (test-cp0-expansion eqv?
       '(logand #x1212121212121212121212121 #x2222222222222222222222222)
       #x202020202020202020202020)
     (test-cp0-expansion eqv?
       '(logand #x-1212121212121212121212121 #x-2222222222222222222222222)
       #x-3232323232323232323232322)
     (test-cp0-expansion eqv?
       '(logand #x-123456789abcdeffedca987654321
                #xfedca987654321123456789abcdef)
       #xECC8A9876543210010146088A8CCF)
     (test-cp0-expansion eqv?
       '(logand #x2B225D27F49C1FED301B89103 #x-F2D8DD782236F835A1A50858)
       #x20025020749C106C200189100)
     (test-cp0-expansion eqv?
       '(logand #x2B225D27F49C1FED301B89103 #x1F366567)
       #x1300103)
     (test-cp0-expansion eqv?
       '(logand #x2B225D27F49C1FED301B89103 #x-717D004)
       #x2B225D27F49C1FED300A80100)
     (test-cp0-expansion eqv?
       '(logand #x-F2D8DD782236F835A1A50858 #x1F366567)
       #x1E126520)
     (test-cp0-expansion eqv?
       '(logand #x-F2D8DD782236F835A1A50858 #x-717D004)
       #x-F2D8DD782236F835A7B7D858)
     (test-cp0-expansion eqv?
       '(logand #x1F366567 #x2B225D27F49C1FED301B89103)
       #x1300103)
     (test-cp0-expansion eqv?
       '(logand #x-717D004 #x2B225D27F49C1FED301B89103)
       #x2B225D27F49C1FED300A80100)
     (test-cp0-expansion eqv?
       '(logand #x1F366567 #x-F2D8DD782236F835A1A50858)
       #x1E126520)
     (test-cp0-expansion eqv?
       '(logand #x-717D004 #x-F2D8DD782236F835A1A50858)
       #x-F2D8DD782236F835A7B7D858)
     (test-cp0-expansion eqv? '(logand) -1)
     (test-cp0-expansion eqv?
       '(logand #x1212121212121212121212121)
       #x1212121212121212121212121)
     (test-cp0-expansion eqv?
       '(logand #x1212121212121212121212121
                #x2222222222222222222222222
                #x0103010301030103010301030)
       #x2000200020002000200020)
     (test-cp0-expansion eqv?
       '(logand #b1110111 #b1101011 -1 #b1011110 #b1000111)
       #b1000010)
     (test-cp0-expansion eqv?
       '(logand #b1110111 #b1101011 0 #b1011110 #b1000111)
       0))

(mat bitwise-and
     (error? (bitwise-and (void) 0))
     (error? (bitwise-and 0 (void)))
     (error? (bitwise-and 'a 17))
     (error? (bitwise-and 17 'a))
     (error? (bitwise-and 25 "oops"))
     (error? (bitwise-and "oops" 25))
     (error? (bitwise-and 25 3.4))
     (error? (bitwise-and 3.4 25))
     (error? (bitwise-and 0 3/4))
     (error? (bitwise-and 3/4 0))
     (error? (bitwise-and 0 1+1i))
     (error? (bitwise-and 1+1i 0))
     (error? (bitwise-and 1 3.4-2.3i))
     (error? (bitwise-and 3.4-2.3i 1))
     (error? (bitwise-and 3.0 4.0))
     (eqv? (bitwise-and 0 0) 0)
     (eqv? (bitwise-and -1 0) 0)
     (eqv? (bitwise-and #xfffffffffffffffffffffffff 0) 0)
     (eqv? (bitwise-and 0 -1) 0)
     (eqv? (bitwise-and 0 #xfffffffffffffffffffffffff) 0)
     (eqv? (bitwise-and 20 -1) 20)
     (eqv? (bitwise-and #xfffffffffffffffffffffffff -1)
           #xfffffffffffffffffffffffff)
     (eqv? (bitwise-and #x1111111111111111111111111 -1)
           #x1111111111111111111111111)
     (eqv? (bitwise-and (- (expt 2 300) 167) -1) (- (expt 2 300) 167))
     (eqv? (bitwise-and (- 167 (expt 2 300)) -1) (- 167 (expt 2 300)))
     (eqv? (bitwise-and (- (expt 2 300) 167) (- (expt 2 300) 167))
           (- (expt 2 300) 167))
     (eqv? (bitwise-and (- 167 (expt 2 300)) (- 167 (expt 2 300)))
           (- 167 (expt 2 300)))
     (eqv? (bitwise-and
             #x1111111111111111111111111
             #x2222222222222222222222222)
           0)
     (eqv? (bitwise-and
             #x1212121212121212121212121
             #x2222222222222222222222222)
           #x202020202020202020202020)
     (eqv? (bitwise-and
             #x-1212121212121212121212121
             #x-2222222222222222222222222)
           #x-3232323232323232323232322)
     (eqv? (bitwise-and
             #x-123456789abcdeffedca987654321
             #xfedca987654321123456789abcdef)
           #xECC8A9876543210010146088A8CCF)
     (eqv? (bitwise-and
             #x2B225D27F49C1FED301B89103
             #x-F2D8DD782236F835A1A50858)
           #x20025020749C106C200189100)
     (eqv? (bitwise-and #x2B225D27F49C1FED301B89103 #x1F366567) #x1300103)
     (eqv? (bitwise-and #x2B225D27F49C1FED301B89103 #x-717D004)
           #x2B225D27F49C1FED300A80100)
     (eqv? (bitwise-and #x-F2D8DD782236F835A1A50858 #x1F366567) #x1E126520)
     (eqv? (bitwise-and #x-F2D8DD782236F835A1A50858 #x-717D004)
           #x-F2D8DD782236F835A7B7D858)
     (eqv? (bitwise-and #x1F366567 #x2B225D27F49C1FED301B89103) #x1300103)
     (eqv? (bitwise-and #x-717D004 #x2B225D27F49C1FED301B89103)
           #x2B225D27F49C1FED300A80100)
     (eqv? (bitwise-and #x1F366567 #x-F2D8DD782236F835A1A50858) #x1E126520)
     (eqv? (bitwise-and #x-717D004 #x-F2D8DD782236F835A1A50858)
           #x-F2D8DD782236F835A7B7D858)
     (eqv? (bitwise-and) -1)
     (eqv? (bitwise-and #x1212121212121212121212121)
           #x1212121212121212121212121)
     (eqv? (bitwise-and
             #x1212121212121212121212121
             #x2222222222222222222222222
             #x0103010301030103010301030)
           #x2000200020002000200020)
     (eqv? (bitwise-and #b1110111 #b1101011 -1 #b1011110 #b1000111)
           #b1000010)
     (eqv? (bitwise-and #b1110111 #b1101011 0 #b1011110 #b1000111) 0)
     (test-cp0-expansion eqv? '(bitwise-and 0 0) 0)
     (test-cp0-expansion eqv? '(bitwise-and -1 0) 0)
     (test-cp0-expansion eqv?
       '(bitwise-and #xfffffffffffffffffffffffff 0)
       0)
     (test-cp0-expansion eqv? '(bitwise-and 0 -1) 0)
     (test-cp0-expansion eqv?
       '(bitwise-and 0 #xfffffffffffffffffffffffff)
       0)
     (test-cp0-expansion eqv? '(bitwise-and 20 -1) 20)
     (test-cp0-expansion eqv?
       '(bitwise-and #xfffffffffffffffffffffffff -1)
       #xfffffffffffffffffffffffff)
     (test-cp0-expansion eqv?
       '(bitwise-and #x1111111111111111111111111 -1)
       #x1111111111111111111111111)
     (test-cp0-expansion eqv?
       '(bitwise-and (- (expt 2 300) 167) -1)
       (- (expt 2 300) 167))
     (test-cp0-expansion eqv?
       '(bitwise-and (- 167 (expt 2 300)) -1)
       (- 167 (expt 2 300)))
     (test-cp0-expansion eqv?
       '(bitwise-and (- (expt 2 300) 167) (- (expt 2 300) 167))
       (- (expt 2 300) 167))
     (test-cp0-expansion eqv?
       '(bitwise-and (- 167 (expt 2 300)) (- 167 (expt 2 300)))
       (- 167 (expt 2 300)))
     (test-cp0-expansion eqv?
       '(bitwise-and
          #x1111111111111111111111111
          #x2222222222222222222222222)
       0)
     (test-cp0-expansion eqv?
       '(bitwise-and
          #x1212121212121212121212121
          #x2222222222222222222222222)
       #x202020202020202020202020)
     (test-cp0-expansion eqv?
       '(bitwise-and
          #x-1212121212121212121212121
          #x-2222222222222222222222222)
       #x-3232323232323232323232322)
     (test-cp0-expansion eqv?
       '(bitwise-and
          #x-123456789abcdeffedca987654321
          #xfedca987654321123456789abcdef)
       #xECC8A9876543210010146088A8CCF)
     (test-cp0-expansion eqv?
       '(bitwise-and
          #x2B225D27F49C1FED301B89103
          #x-F2D8DD782236F835A1A50858)
       #x20025020749C106C200189100)
     (test-cp0-expansion eqv?
       '(bitwise-and #x2B225D27F49C1FED301B89103 #x1F366567)
       #x1300103)
     (test-cp0-expansion eqv?
       '(bitwise-and #x2B225D27F49C1FED301B89103 #x-717D004)
       #x2B225D27F49C1FED300A80100)
     (test-cp0-expansion eqv?
       '(bitwise-and #x-F2D8DD782236F835A1A50858 #x1F366567)
       #x1E126520)
     (test-cp0-expansion eqv?
       '(bitwise-and #x-F2D8DD782236F835A1A50858 #x-717D004)
       #x-F2D8DD782236F835A7B7D858)
     (test-cp0-expansion eqv?
       '(bitwise-and #x1F366567 #x2B225D27F49C1FED301B89103)
       #x1300103)
     (test-cp0-expansion eqv?
       '(bitwise-and #x-717D004 #x2B225D27F49C1FED301B89103)
       #x2B225D27F49C1FED300A80100)
     (test-cp0-expansion eqv?
       '(bitwise-and #x1F366567 #x-F2D8DD782236F835A1A50858)
       #x1E126520)
     (test-cp0-expansion eqv?
       '(bitwise-and #x-717D004 #x-F2D8DD782236F835A1A50858)
       #x-F2D8DD782236F835A7B7D858)
     (test-cp0-expansion eqv? '(bitwise-and) -1)
     (test-cp0-expansion eqv?
       '(bitwise-and #x1212121212121212121212121)
       #x1212121212121212121212121)
     (test-cp0-expansion eqv?
       '(bitwise-and
          #x1212121212121212121212121
          #x2222222222222222222222222
          #x0103010301030103010301030)
       #x2000200020002000200020)
     (test-cp0-expansion eqv?
       '(bitwise-and #b1110111 #b1101011 -1 #b1011110 #b1000111)
       #b1000010)
     (test-cp0-expansion eqv?
       '(bitwise-and #b1110111 #b1101011 0 #b1011110 #b1000111)
       0))

(mat logior
     ; same as logor
     (error? (logior (void) 0))
     (error? (logior 0 (void)))
     (error? (logior 'a 17))
     (error? (logior 17 'a))
     (error? (logior 25 "oops"))
     (error? (logior "oops" 25))
     (error? (logior 25 3.4))
     (error? (logior 3.4 25))
     (error? (logior 0 3/4))
     (error? (logior 3/4 0))
     (error? (logior 0 1+1i))
     (error? (logior 1+1i 0))
     (error? (logior 1 3.4-2.3i))
     (error? (logior 3.4-2.3i 1))
     (error? (logior 3.0 4.0))
     (eqv? (logior 0 0) 0)
     (eqv? (logior -1 0) -1)
     (eqv? (logior #xfffffffffffffffffffffffff 0)
           #xfffffffffffffffffffffffff)
     (eqv? (logior 0 -1) -1)
     (eqv? (logior 0 #xfffffffffffffffffffffffff)
           #xfffffffffffffffffffffffff)
     (eqv? (logior 20 -1) -1)
     (eqv? (logior #xfffffffffffffffffffffffff -1) -1)
     (eqv? (logior #x1111111111111111111111111 -1) -1)
     (eqv? (logior (- (expt 2 300) 167) -1) -1)
     (eqv? (logior (- 167 (expt 2 300)) -1) -1)
     (eqv? (logior (- (expt 2 300) 167) (- (expt 2 300) 167))
           (- (expt 2 300) 167))
     (eqv? (logior (- 167 (expt 2 300)) (- 167 (expt 2 300)))
           (- 167 (expt 2 300)))
     (eqv? (logior #x1111111111111111111111111 #x2222222222222222222222222)
           #x3333333333333333333333333)
     (eqv? (logior #x1212121212121212121212121 #x2222222222222222222222222)
           #x3232323232323232323232323)
     (eqv? (logior #x-1212121212121212121212121
                   #x-2222222222222222222222222)
           #x-202020202020202020202021)
     (eqv? (logior #x-3333333333333333333333333
                   #x-2222222222222222222222222)
           #x-2222222222222222222222221)
     (eqv? (logior #x-123456789abcdeffedca987654321
                   #x-fedca987654321123456789abcdef)
           #x-12140000000000122442181214121)
     (eqv? (logior #x-123456789abcdeffedca987654321
                   #x-fedca987654321123456789abcdef)
           #x-12140000000000122442181214121)
     (eqv? (logior #x-123456789abcdeffedca987654321
                   #xfedca987654321123456789abcdef)
           #x-2056789ABCDEEDC988806440201)
     (eqv? (logior #x2B225D27F49C1FED301B89103 #x-F2D8DD782236F835A1A50858)
           #x-40D80D0022360024A0050855)
     (eqv? (logior #x2B225D27F49C1FED301B89103 #x1F366567)
           #x2B225D27F49C1FED31FBEF567)
     (eqv? (logior #x2B225D27F49C1FED301B89103 #x-717D004) #x-6074001)
     (eqv? (logior #x-F2D8DD782236F835A1A50858 #x1F366567)
           #x-F2D8DD782236F835A0810811)
     (eqv? (logior #x-F2D8DD782236F835A1A50858 #x-717D004) #x-1050004)
     (eqv? (logior #x1F366567 #x2B225D27F49C1FED301B89103)
           #x2B225D27F49C1FED31FBEF567)
     (eqv? (logior #x-717D004 #x2B225D27F49C1FED301B89103) #x-6074001)
     (eqv? (logior #x1F366567 #x-F2D8DD782236F835A1A50858)
           #x-F2D8DD782236F835A0810811)
     (eqv? (logior #x-717D004 #x-F2D8DD782236F835A1A50858) #x-1050004)
     (eqv? (logior) 0)
     (eqv? (logior #x1212121212121212121212121)
           #x1212121212121212121212121)
     (eqv? (logior #x1212121212121212121212121
                   #x2222222222222222222222222
                   #x0103010301030103010301030)
           #x3333333333333333333333333)
     (eqv? (logior #b1010111 #b1001011 -1 #b1011110 #b1000111) -1)
     (eqv? (logior #b1010111 #b1001011 0 #b1011110 #b1000111) #b1011111)
     (test-cp0-expansion eqv? '(logior 0 0) 0)
     (test-cp0-expansion eqv? '(logior -1 0) -1)
     (test-cp0-expansion eqv?
       '(logior #xfffffffffffffffffffffffff 0)
       #xfffffffffffffffffffffffff)
     (test-cp0-expansion eqv? '(logior 0 -1) -1)
     (test-cp0-expansion eqv?
       '(logior 0 #xfffffffffffffffffffffffff)
       #xfffffffffffffffffffffffff)
     (test-cp0-expansion eqv? '(logior 20 -1) -1)
     (test-cp0-expansion eqv? '(logior #xfffffffffffffffffffffffff -1) -1)
     (test-cp0-expansion eqv? '(logior #x1111111111111111111111111 -1) -1)
     (test-cp0-expansion eqv? '(logior (- (expt 2 300) 167) -1) -1)
     (test-cp0-expansion eqv? '(logior (- 167 (expt 2 300)) -1) -1)
     (test-cp0-expansion eqv?
       '(logior (- (expt 2 300) 167) (- (expt 2 300) 167))
       (- (expt 2 300) 167))
     (test-cp0-expansion eqv?
       '(logior (- 167 (expt 2 300)) (- 167 (expt 2 300)))
       (- 167 (expt 2 300)))
     (test-cp0-expansion eqv?
       '(logior #x1111111111111111111111111 #x2222222222222222222222222)
       #x3333333333333333333333333)
     (test-cp0-expansion eqv?
       '(logior #x1212121212121212121212121 #x2222222222222222222222222)
       #x3232323232323232323232323)
     (test-cp0-expansion eqv?
       '(logior #x-1212121212121212121212121 #x-2222222222222222222222222)
       #x-202020202020202020202021)
     (test-cp0-expansion eqv?
       '(logior #x-3333333333333333333333333 #x-2222222222222222222222222)
       #x-2222222222222222222222221)
     (test-cp0-expansion eqv?
       '(logior #x-123456789abcdeffedca987654321
                #x-fedca987654321123456789abcdef)
       #x-12140000000000122442181214121)
     (test-cp0-expansion eqv?
       '(logior #x-123456789abcdeffedca987654321
                #x-fedca987654321123456789abcdef)
       #x-12140000000000122442181214121)
     (test-cp0-expansion eqv?
       '(logior #x-123456789abcdeffedca987654321
                #xfedca987654321123456789abcdef)
       #x-2056789ABCDEEDC988806440201)
     (test-cp0-expansion eqv?
       '(logior #x2B225D27F49C1FED301B89103 #x-F2D8DD782236F835A1A50858)
       #x-40D80D0022360024A0050855)
     (test-cp0-expansion eqv?
       '(logior #x2B225D27F49C1FED301B89103 #x1F366567)
       #x2B225D27F49C1FED31FBEF567)
     (test-cp0-expansion eqv?
       '(logior #x2B225D27F49C1FED301B89103 #x-717D004)
       #x-6074001)
     (test-cp0-expansion eqv?
       '(logior #x-F2D8DD782236F835A1A50858 #x1F366567)
       #x-F2D8DD782236F835A0810811)
     (test-cp0-expansion eqv?
       '(logior #x-F2D8DD782236F835A1A50858 #x-717D004)
       #x-1050004)
     (test-cp0-expansion eqv?
       '(logior #x1F366567 #x2B225D27F49C1FED301B89103)
       #x2B225D27F49C1FED31FBEF567)
     (test-cp0-expansion eqv?
       '(logior #x-717D004 #x2B225D27F49C1FED301B89103)
       #x-6074001)
     (test-cp0-expansion eqv?
       '(logior #x1F366567 #x-F2D8DD782236F835A1A50858)
       #x-F2D8DD782236F835A0810811)
     (test-cp0-expansion eqv?
       '(logior #x-717D004 #x-F2D8DD782236F835A1A50858)
       #x-1050004)
     (test-cp0-expansion eqv? '(logior) 0)
     (test-cp0-expansion eqv?
       '(logior #x1212121212121212121212121)
       #x1212121212121212121212121)
     (test-cp0-expansion eqv?
       '(logior #x1212121212121212121212121
                #x2222222222222222222222222
                #x0103010301030103010301030)
       #x3333333333333333333333333)
     (test-cp0-expansion eqv?
       '(logior #b1010111 #b1001011 -1 #b1011110 #b1000111)
       -1)
     (test-cp0-expansion eqv?
       '(logior #b1010111 #b1001011 0 #b1011110 #b1000111)
       #b1011111))

(mat logor
     (error? (logor (void) 0))
     (error? (logor 0 (void)))
     (error? (logor 'a 17))
     (error? (logor 17 'a))
     (error? (logor 25 "oops"))
     (error? (logor "oops" 25))
     (error? (logor 25 3.4))
     (error? (logor 3.4 25))
     (error? (logor 0 3/4))
     (error? (logor 3/4 0))
     (error? (logor 0 1+1i))
     (error? (logor 1+1i 0))
     (error? (logor 1 3.4-2.3i))
     (error? (logor 3.4-2.3i 1))
     (error? (logor 3.0 4.0))
     (eqv? (logor 0 0) 0)
     (eqv? (logor -1 0) -1)
     (eqv? (logor #xfffffffffffffffffffffffff 0)
           #xfffffffffffffffffffffffff)
     (eqv? (logor 0 -1) -1)
     (eqv? (logor 0 #xfffffffffffffffffffffffff)
           #xfffffffffffffffffffffffff)
     (eqv? (logor 20 -1) -1)
     (eqv? (logor #xfffffffffffffffffffffffff -1) -1)
     (eqv? (logor #x1111111111111111111111111 -1) -1)
     (eqv? (logor (- (expt 2 300) 167) -1) -1)
     (eqv? (logor (- 167 (expt 2 300)) -1) -1)
     (eqv? (logor (- (expt 2 300) 167) (- (expt 2 300) 167))
           (- (expt 2 300) 167))
     (eqv? (logor (- 167 (expt 2 300)) (- 167 (expt 2 300)))
           (- 167 (expt 2 300)))
     (eqv? (logor #x1111111111111111111111111 #x2222222222222222222222222)
           #x3333333333333333333333333)
     (eqv? (logor #x1212121212121212121212121 #x2222222222222222222222222)
           #x3232323232323232323232323)
     (eqv? (logor #x-1212121212121212121212121
                  #x-2222222222222222222222222)
           #x-202020202020202020202021)
     (eqv? (logor #x-3333333333333333333333333
                  #x-2222222222222222222222222)
           #x-2222222222222222222222221)
     (eqv? (logor #x-123456789abcdeffedca987654321
                  #x-fedca987654321123456789abcdef)
           #x-12140000000000122442181214121)
     (eqv? (logor #x-123456789abcdeffedca987654321
                  #x-fedca987654321123456789abcdef)
           #x-12140000000000122442181214121)
     (eqv? (logor #x-123456789abcdeffedca987654321
                  #xfedca987654321123456789abcdef)
           #x-2056789ABCDEEDC988806440201)
     (eqv? (logor #x2B225D27F49C1FED301B89103 #x-F2D8DD782236F835A1A50858)
           #x-40D80D0022360024A0050855)
     (eqv? (logor #x2B225D27F49C1FED301B89103 #x1F366567)
           #x2B225D27F49C1FED31FBEF567)
     (eqv? (logor #x2B225D27F49C1FED301B89103 #x-717D004) #x-6074001)
     (eqv? (logor #x-F2D8DD782236F835A1A50858 #x1F366567)
           #x-F2D8DD782236F835A0810811)
     (eqv? (logor #x-F2D8DD782236F835A1A50858 #x-717D004) #x-1050004)
     (eqv? (logor #x1F366567 #x2B225D27F49C1FED301B89103)
           #x2B225D27F49C1FED31FBEF567)
     (eqv? (logor #x-717D004 #x2B225D27F49C1FED301B89103) #x-6074001)
     (eqv? (logor #x1F366567 #x-F2D8DD782236F835A1A50858)
           #x-F2D8DD782236F835A0810811)
     (eqv? (logor #x-717D004 #x-F2D8DD782236F835A1A50858) #x-1050004)
     (eqv? (logor) 0)
     (eqv? (logor #x1212121212121212121212121) #x1212121212121212121212121)
     (eqv? (logor #x1212121212121212121212121
                  #x2222222222222222222222222
                  #x0103010301030103010301030)
           #x3333333333333333333333333)
     (eqv? (logor #b1010111 #b1001011 -1 #b1011110 #b1000111) -1)
     (eqv? (logor #b1010111 #b1001011 0 #b1011110 #b1000111) #b1011111)
     (test-cp0-expansion eqv? '(logor 0 0) 0)
     (test-cp0-expansion eqv? '(logor -1 0) -1)
     (test-cp0-expansion eqv?
       '(logor #xfffffffffffffffffffffffff 0)
       #xfffffffffffffffffffffffff)
     (test-cp0-expansion eqv? '(logor 0 -1) -1)
     (test-cp0-expansion eqv?
       '(logor 0 #xfffffffffffffffffffffffff)
       #xfffffffffffffffffffffffff)
     (test-cp0-expansion eqv? '(logor 20 -1) -1)
     (test-cp0-expansion eqv? '(logor #xfffffffffffffffffffffffff -1) -1)
     (test-cp0-expansion eqv? '(logor #x1111111111111111111111111 -1) -1)
     (test-cp0-expansion eqv? '(logor (- (expt 2 300) 167) -1) -1)
     (test-cp0-expansion eqv? '(logor (- 167 (expt 2 300)) -1) -1)
     (test-cp0-expansion eqv?
       '(logor (- (expt 2 300) 167) (- (expt 2 300) 167))
       (- (expt 2 300) 167))
     (test-cp0-expansion eqv?
       '(logor (- 167 (expt 2 300)) (- 167 (expt 2 300)))
       (- 167 (expt 2 300)))
     (test-cp0-expansion eqv?
       '(logor #x1111111111111111111111111 #x2222222222222222222222222)
       #x3333333333333333333333333)
     (test-cp0-expansion eqv?
       '(logor #x1212121212121212121212121 #x2222222222222222222222222)
       #x3232323232323232323232323)
     (test-cp0-expansion eqv?
       '(logor #x-1212121212121212121212121 #x-2222222222222222222222222)
       #x-202020202020202020202021)
     (test-cp0-expansion eqv?
       '(logor #x-3333333333333333333333333 #x-2222222222222222222222222)
       #x-2222222222222222222222221)
     (test-cp0-expansion eqv?
       '(logor #x-123456789abcdeffedca987654321
               #x-fedca987654321123456789abcdef)
       #x-12140000000000122442181214121)
     (test-cp0-expansion eqv?
       '(logor #x-123456789abcdeffedca987654321
               #x-fedca987654321123456789abcdef)
       #x-12140000000000122442181214121)
     (test-cp0-expansion eqv?
       '(logor #x-123456789abcdeffedca987654321
               #xfedca987654321123456789abcdef)
       #x-2056789ABCDEEDC988806440201)
     (test-cp0-expansion eqv?
       '(logor #x2B225D27F49C1FED301B89103 #x-F2D8DD782236F835A1A50858)
       #x-40D80D0022360024A0050855)
     (test-cp0-expansion eqv?
       '(logor #x2B225D27F49C1FED301B89103 #x1F366567)
       #x2B225D27F49C1FED31FBEF567)
     (test-cp0-expansion eqv?
       '(logor #x2B225D27F49C1FED301B89103 #x-717D004)
       #x-6074001)
     (test-cp0-expansion eqv?
       '(logor #x-F2D8DD782236F835A1A50858 #x1F366567)
       #x-F2D8DD782236F835A0810811)
     (test-cp0-expansion eqv?
       '(logor #x-F2D8DD782236F835A1A50858 #x-717D004)
       #x-1050004)
     (test-cp0-expansion eqv?
       '(logor #x1F366567 #x2B225D27F49C1FED301B89103)
       #x2B225D27F49C1FED31FBEF567)
     (test-cp0-expansion eqv?
       '(logor #x-717D004 #x2B225D27F49C1FED301B89103)
       #x-6074001)
     (test-cp0-expansion eqv?
       '(logor #x1F366567 #x-F2D8DD782236F835A1A50858)
       #x-F2D8DD782236F835A0810811)
     (test-cp0-expansion eqv?
       '(logor #x-717D004 #x-F2D8DD782236F835A1A50858)
       #x-1050004)
     (test-cp0-expansion eqv? '(logor) 0)
     (test-cp0-expansion eqv?
       '(logor #x1212121212121212121212121)
       #x1212121212121212121212121)
     (test-cp0-expansion eqv?
       '(logor #x1212121212121212121212121
               #x2222222222222222222222222
               #x0103010301030103010301030)
       #x3333333333333333333333333)
     (test-cp0-expansion eqv?
       '(logor #b1010111 #b1001011 -1 #b1011110 #b1000111)
       -1)
     (test-cp0-expansion eqv?
       '(logor #b1010111 #b1001011 0 #b1011110 #b1000111)
       #b1011111))

(mat bitwise-ior
     ; same as logor
     (error? (bitwise-ior (void) 0))
     (error? (bitwise-ior 0 (void)))
     (error? (bitwise-ior 'a 17))
     (error? (bitwise-ior 17 'a))
     (error? (bitwise-ior 25 "oops"))
     (error? (bitwise-ior "oops" 25))
     (error? (bitwise-ior 25 3.4))
     (error? (bitwise-ior 3.4 25))
     (error? (bitwise-ior 0 3/4))
     (error? (bitwise-ior 3/4 0))
     (error? (bitwise-ior 0 1+1i))
     (error? (bitwise-ior 1+1i 0))
     (error? (bitwise-ior 1 3.4-2.3i))
     (error? (bitwise-ior 3.4-2.3i 1))
     (error? (bitwise-ior 3.0 4.0))
     (eqv? (bitwise-ior 0 0) 0)
     (eqv? (bitwise-ior -1 0) -1)
     (eqv? (bitwise-ior #xfffffffffffffffffffffffff 0)
           #xfffffffffffffffffffffffff)
     (eqv? (bitwise-ior 0 -1) -1)
     (eqv? (bitwise-ior 0 #xfffffffffffffffffffffffff)
           #xfffffffffffffffffffffffff)
     (eqv? (bitwise-ior 20 -1) -1)
     (eqv? (bitwise-ior #xfffffffffffffffffffffffff -1) -1)
     (eqv? (bitwise-ior #x1111111111111111111111111 -1) -1)
     (eqv? (bitwise-ior (- (expt 2 300) 167) -1) -1)
     (eqv? (bitwise-ior (- 167 (expt 2 300)) -1) -1)
     (eqv? (bitwise-ior (- (expt 2 300) 167) (- (expt 2 300) 167))
           (- (expt 2 300) 167))
     (eqv? (bitwise-ior (- 167 (expt 2 300)) (- 167 (expt 2 300)))
           (- 167 (expt 2 300)))
     (eqv? (bitwise-ior
             #x1111111111111111111111111
             #x2222222222222222222222222)
           #x3333333333333333333333333)
     (eqv? (bitwise-ior
             #x1212121212121212121212121
             #x2222222222222222222222222)
           #x3232323232323232323232323)
     (eqv? (bitwise-ior
             #x-1212121212121212121212121
             #x-2222222222222222222222222)
           #x-202020202020202020202021)
     (eqv? (bitwise-ior
             #x-3333333333333333333333333
             #x-2222222222222222222222222)
           #x-2222222222222222222222221)
     (eqv? (bitwise-ior
             #x-123456789abcdeffedca987654321
             #x-fedca987654321123456789abcdef)
           #x-12140000000000122442181214121)
     (eqv? (bitwise-ior
             #x-123456789abcdeffedca987654321
             #x-fedca987654321123456789abcdef)
           #x-12140000000000122442181214121)
     (eqv? (bitwise-ior
             #x-123456789abcdeffedca987654321
             #xfedca987654321123456789abcdef)
           #x-2056789ABCDEEDC988806440201)
     (eqv? (bitwise-ior
             #x2B225D27F49C1FED301B89103
             #x-F2D8DD782236F835A1A50858)
           #x-40D80D0022360024A0050855)
     (eqv? (bitwise-ior #x2B225D27F49C1FED301B89103 #x1F366567)
           #x2B225D27F49C1FED31FBEF567)
     (eqv? (bitwise-ior #x2B225D27F49C1FED301B89103 #x-717D004) #x-6074001)
     (eqv? (bitwise-ior #x-F2D8DD782236F835A1A50858 #x1F366567)
           #x-F2D8DD782236F835A0810811)
     (eqv? (bitwise-ior #x-F2D8DD782236F835A1A50858 #x-717D004) #x-1050004)
     (eqv? (bitwise-ior #x1F366567 #x2B225D27F49C1FED301B89103)
           #x2B225D27F49C1FED31FBEF567)
     (eqv? (bitwise-ior #x-717D004 #x2B225D27F49C1FED301B89103) #x-6074001)
     (eqv? (bitwise-ior #x1F366567 #x-F2D8DD782236F835A1A50858)
           #x-F2D8DD782236F835A0810811)
     (eqv? (bitwise-ior #x-717D004 #x-F2D8DD782236F835A1A50858) #x-1050004)
     (eqv? (bitwise-ior) 0)
     (eqv? (bitwise-ior #x1212121212121212121212121)
           #x1212121212121212121212121)
     (eqv? (bitwise-ior
             #x1212121212121212121212121
             #x2222222222222222222222222
             #x0103010301030103010301030)
           #x3333333333333333333333333)
     (eqv? (bitwise-ior #b1010111 #b1001011 -1 #b1011110 #b1000111) -1)
     (eqv? (bitwise-ior #b1010111 #b1001011 0 #b1011110 #b1000111)
           #b1011111)
     (test-cp0-expansion eqv? '(bitwise-ior 0 0) 0)
     (test-cp0-expansion eqv? '(bitwise-ior -1 0) -1)
     (test-cp0-expansion eqv?
       '(bitwise-ior #xfffffffffffffffffffffffff 0)
       #xfffffffffffffffffffffffff)
     (test-cp0-expansion eqv? '(bitwise-ior 0 -1) -1)
     (test-cp0-expansion eqv?
       '(bitwise-ior 0 #xfffffffffffffffffffffffff)
       #xfffffffffffffffffffffffff)
     (test-cp0-expansion eqv? '(bitwise-ior 20 -1) -1)
     (test-cp0-expansion eqv?
       '(bitwise-ior #xfffffffffffffffffffffffff -1)
       -1)
     (test-cp0-expansion eqv?
       '(bitwise-ior #x1111111111111111111111111 -1)
       -1)
     (test-cp0-expansion eqv? '(bitwise-ior (- (expt 2 300) 167) -1) -1)
     (test-cp0-expansion eqv? '(bitwise-ior (- 167 (expt 2 300)) -1) -1)
     (test-cp0-expansion eqv?
       '(bitwise-ior (- (expt 2 300) 167) (- (expt 2 300) 167))
       (- (expt 2 300) 167))
     (test-cp0-expansion eqv?
       '(bitwise-ior (- 167 (expt 2 300)) (- 167 (expt 2 300)))
       (- 167 (expt 2 300)))
     (test-cp0-expansion eqv?
       '(bitwise-ior
          #x1111111111111111111111111
          #x2222222222222222222222222)
       #x3333333333333333333333333)
     (test-cp0-expansion eqv?
       '(bitwise-ior
          #x1212121212121212121212121
          #x2222222222222222222222222)
       #x3232323232323232323232323)
     (test-cp0-expansion eqv?
       '(bitwise-ior
          #x-1212121212121212121212121
          #x-2222222222222222222222222)
       #x-202020202020202020202021)
     (test-cp0-expansion eqv?
       '(bitwise-ior
          #x-3333333333333333333333333
          #x-2222222222222222222222222)
       #x-2222222222222222222222221)
     (test-cp0-expansion eqv?
       '(bitwise-ior
          #x-123456789abcdeffedca987654321
          #x-fedca987654321123456789abcdef)
       #x-12140000000000122442181214121)
     (test-cp0-expansion eqv?
       '(bitwise-ior
          #x-123456789abcdeffedca987654321
          #x-fedca987654321123456789abcdef)
       #x-12140000000000122442181214121)
     (test-cp0-expansion eqv?
       '(bitwise-ior
          #x-123456789abcdeffedca987654321
          #xfedca987654321123456789abcdef)
       #x-2056789ABCDEEDC988806440201)
     (test-cp0-expansion eqv?
       '(bitwise-ior
          #x2B225D27F49C1FED301B89103
          #x-F2D8DD782236F835A1A50858)
       #x-40D80D0022360024A0050855)
     (test-cp0-expansion eqv?
       '(bitwise-ior #x2B225D27F49C1FED301B89103 #x1F366567)
       #x2B225D27F49C1FED31FBEF567)
     (test-cp0-expansion eqv?
       '(bitwise-ior #x2B225D27F49C1FED301B89103 #x-717D004)
       #x-6074001)
     (test-cp0-expansion eqv?
       '(bitwise-ior #x-F2D8DD782236F835A1A50858 #x1F366567)
       #x-F2D8DD782236F835A0810811)
     (test-cp0-expansion eqv?
       '(bitwise-ior #x-F2D8DD782236F835A1A50858 #x-717D004)
       #x-1050004)
     (test-cp0-expansion eqv?
       '(bitwise-ior #x1F366567 #x2B225D27F49C1FED301B89103)
       #x2B225D27F49C1FED31FBEF567)
     (test-cp0-expansion eqv?
       '(bitwise-ior #x-717D004 #x2B225D27F49C1FED301B89103)
       #x-6074001)
     (test-cp0-expansion eqv?
       '(bitwise-ior #x1F366567 #x-F2D8DD782236F835A1A50858)
       #x-F2D8DD782236F835A0810811)
     (test-cp0-expansion eqv?
       '(bitwise-ior #x-717D004 #x-F2D8DD782236F835A1A50858)
       #x-1050004)
     (test-cp0-expansion eqv? '(bitwise-ior) 0)
     (test-cp0-expansion eqv?
       '(bitwise-ior #x1212121212121212121212121)
       #x1212121212121212121212121)
     (test-cp0-expansion eqv?
       '(bitwise-ior
          #x1212121212121212121212121
          #x2222222222222222222222222
          #x0103010301030103010301030)
       #x3333333333333333333333333)
     (test-cp0-expansion eqv?
       '(bitwise-ior #b1010111 #b1001011 -1 #b1011110 #b1000111)
       -1)
     (test-cp0-expansion eqv?
       '(bitwise-ior #b1010111 #b1001011 0 #b1011110 #b1000111)
       #b1011111))

(mat logxor
     (error? (logxor (void) 0))
     (error? (logxor 0 (void)))
     (error? (logxor 'a 17))
     (error? (logxor 17 'a))
     (error? (logxor 25 "oops"))
     (error? (logxor "oops" 25))
     (error? (logxor 25 3.4))
     (error? (logxor 3.4 25))
     (error? (logxor 0 3/4))
     (error? (logxor 3/4 0))
     (error? (logxor 0 1+1i))
     (error? (logxor 1+1i 0))
     (error? (logxor 1 3.4-2.3i))
     (error? (logxor 3.4-2.3i 1))
     (error? (logxor 3.0 4.0))
     (eqv? (logxor 0 0) 0)
     (eqv? (logxor -1 0) -1)
     (eqv? (logxor #xfffffffffffffffffffffffff 0)
           #xfffffffffffffffffffffffff)
     (eqv? (logxor 0 -1) -1)
     (eqv? (logxor 0 #xfffffffffffffffffffffffff)
           #xfffffffffffffffffffffffff)
     (eqv? (logxor 20 -1) -21)
     (eqv? (logxor #xfffffffffffffffffffffffff -1)
           #x-10000000000000000000000000)
     (eqv? (logxor #x1111111111111111111111111 -1)
           #x-1111111111111111111111112)
     (eqv? (logxor (- (expt 2 100) 167) -1) #x-FFFFFFFFFFFFFFFFFFFFFFF5A)
     (eqv? (logxor (- 167 (expt 2 100)) -1) #xFFFFFFFFFFFFFFFFFFFFFFF58)
     (eqv? (logxor (- (expt 2 300) 167) (- (expt 2 300) 167)) 0)
     (eqv? (logxor (- 167 (expt 2 300)) (- 167 (expt 2 300))) 0)
     (eqv? (logxor #x1111111111111111111111111 #x2222222222222222222222222)
           #x3333333333333333333333333)
     (eqv? (logxor #x1212121212121212121212121 #x2222222222222222222222222)
           #x3030303030303030303030303)
     (eqv? (logxor #x-1212121212121212121212121
                   #x-2222222222222222222222222)
           #x3030303030303030303030301)
     (eqv? (logxor #x-3333333333333333333333333
                   #x-2222222222222222222222222)
           #x1111111111111111111111113)
     (eqv? (logxor #x-123456789abcdeffedca987654321
                   #x-fedca987654321123456789abcdef)
           #xECE8FFFFFFFFFFEDD99CE0ECE8ECE)
     (eqv? (logxor #x-123456789abcdeffedca987654321
                   #x-fedca987654321123456789abcdef)
           #xECE8FFFFFFFFFFEDD99CE0ECE8ECE)
     (eqv? (logxor #x-123456789abcdeffedca987654321
                   #xfedca987654321123456789abcdef)
           #x-ECE8FFFFFFFFFFEDD99CE0ECE8ED0)
     (eqv? (logxor #x2B225D27F49C1FED301B89103 #x-F2D8DD782236F835A1A50858)
           #x-240FD0F076BF706E6A01D9955)
     (eqv? (logxor #x2B225D27F49C1FED301B89103 #x1F366567)
           #x2B225D27F49C1FED31E8EF464)
     (eqv? (logxor #x2B225D27F49C1FED301B89103 #x-717D004)
           #x-2B225D27F49C1FED306AF4101)
     (eqv? (logxor #x-F2D8DD782236F835A1A50858 #x1F366567)
           #x-F2D8DD782236F835BE936D31)
     (eqv? (logxor #x-F2D8DD782236F835A1A50858 #x-717D004)
           #xF2D8DD782236F835A6B2D854)
     (eqv? (logxor #x1F366567 #x2B225D27F49C1FED301B89103)
           #x2B225D27F49C1FED31E8EF464)
     (eqv? (logxor #x-717D004 #x2B225D27F49C1FED301B89103)
           #x-2B225D27F49C1FED306AF4101)
     (eqv? (logxor #x1F366567 #x-F2D8DD782236F835A1A50858)
           #x-F2D8DD782236F835BE936D31)
     (eqv? (logxor #x-717D004 #x-F2D8DD782236F835A1A50858)
           #xF2D8DD782236F835A6B2D854)
     (eqv? (logxor) 0)
     (eqv? (logxor #x1212121212121212121212121)
           #x1212121212121212121212121)
     (eqv? (logxor #x1212121212121212121212121
                   #x2222222222222222222222222
                   #x0103010301030103010301030)
           #x3133313331333133313331333)
     (eqv? (logxor #b1010111 #b1001011 -1 #b1011110 #b1000111) -6)
     (eqv? (logxor #b1010111 #b1001011 0 #b1011110 #b1000111) 5)
     (test-cp0-expansion eqv? '(logxor 0 0) 0)
     (test-cp0-expansion eqv? '(logxor -1 0) -1)
     (test-cp0-expansion eqv?
       '(logxor #xfffffffffffffffffffffffff 0)
       #xfffffffffffffffffffffffff)
     (test-cp0-expansion eqv? '(logxor 0 -1) -1)
     (test-cp0-expansion eqv?
       '(logxor 0 #xfffffffffffffffffffffffff)
       #xfffffffffffffffffffffffff)
     (test-cp0-expansion eqv? '(logxor 20 -1) -21)
     (test-cp0-expansion eqv?
       '(logxor #xfffffffffffffffffffffffff -1)
       #x-10000000000000000000000000)
     (test-cp0-expansion eqv?
       '(logxor #x1111111111111111111111111 -1)
       #x-1111111111111111111111112)
     (test-cp0-expansion eqv?
       '(logxor (- (expt 2 100) 167) -1)
       #x-FFFFFFFFFFFFFFFFFFFFFFF5A)
     (test-cp0-expansion eqv?
       '(logxor (- 167 (expt 2 100)) -1)
       #xFFFFFFFFFFFFFFFFFFFFFFF58)
     (test-cp0-expansion eqv?
       '(logxor (- (expt 2 300) 167) (- (expt 2 300) 167))
       0)
     (test-cp0-expansion eqv?
       '(logxor (- 167 (expt 2 300)) (- 167 (expt 2 300)))
       0)
     (test-cp0-expansion eqv?
       '(logxor #x1111111111111111111111111 #x2222222222222222222222222)
       #x3333333333333333333333333)
     (test-cp0-expansion eqv?
       '(logxor #x1212121212121212121212121 #x2222222222222222222222222)
       #x3030303030303030303030303)
     (test-cp0-expansion eqv?
       '(logxor #x-1212121212121212121212121 #x-2222222222222222222222222)
       #x3030303030303030303030301)
     (test-cp0-expansion eqv?
       '(logxor #x-3333333333333333333333333 #x-2222222222222222222222222)
       #x1111111111111111111111113)
     (test-cp0-expansion eqv?
       '(logxor #x-123456789abcdeffedca987654321
                #x-fedca987654321123456789abcdef)
       #xECE8FFFFFFFFFFEDD99CE0ECE8ECE)
     (test-cp0-expansion eqv?
       '(logxor #x-123456789abcdeffedca987654321
                #x-fedca987654321123456789abcdef)
       #xECE8FFFFFFFFFFEDD99CE0ECE8ECE)
     (test-cp0-expansion eqv?
       '(logxor #x-123456789abcdeffedca987654321
                #xfedca987654321123456789abcdef)
       #x-ECE8FFFFFFFFFFEDD99CE0ECE8ED0)
     (test-cp0-expansion eqv?
       '(logxor #x2B225D27F49C1FED301B89103 #x-F2D8DD782236F835A1A50858)
       #x-240FD0F076BF706E6A01D9955)
     (test-cp0-expansion eqv?
       '(logxor #x2B225D27F49C1FED301B89103 #x1F366567)
       #x2B225D27F49C1FED31E8EF464)
     (test-cp0-expansion eqv?
       '(logxor #x2B225D27F49C1FED301B89103 #x-717D004)
       #x-2B225D27F49C1FED306AF4101)
     (test-cp0-expansion eqv?
       '(logxor #x-F2D8DD782236F835A1A50858 #x1F366567)
       #x-F2D8DD782236F835BE936D31)
     (test-cp0-expansion eqv?
       '(logxor #x-F2D8DD782236F835A1A50858 #x-717D004)
       #xF2D8DD782236F835A6B2D854)
     (test-cp0-expansion eqv?
       '(logxor #x1F366567 #x2B225D27F49C1FED301B89103)
       #x2B225D27F49C1FED31E8EF464)
     (test-cp0-expansion eqv?
       '(logxor #x-717D004 #x2B225D27F49C1FED301B89103)
       #x-2B225D27F49C1FED306AF4101)
     (test-cp0-expansion eqv?
       '(logxor #x1F366567 #x-F2D8DD782236F835A1A50858)
       #x-F2D8DD782236F835BE936D31)
     (test-cp0-expansion eqv?
       '(logxor #x-717D004 #x-F2D8DD782236F835A1A50858)
       #xF2D8DD782236F835A6B2D854)
     (test-cp0-expansion eqv? '(logxor) 0)
     (test-cp0-expansion eqv?
       '(logxor #x1212121212121212121212121)
       #x1212121212121212121212121)
     (test-cp0-expansion eqv?
       '(logxor #x1212121212121212121212121
                #x2222222222222222222222222
                #x0103010301030103010301030)
       #x3133313331333133313331333)
     (test-cp0-expansion eqv?
       '(logxor #b1010111 #b1001011 -1 #b1011110 #b1000111)
       -6)
     (test-cp0-expansion eqv?
       '(logxor #b1010111 #b1001011 0 #b1011110 #b1000111)
       5))

(mat bitwise-xor
     (error? (bitwise-xor (void) 0))
     (error? (bitwise-xor 0 (void)))
     (error? (bitwise-xor 'a 17))
     (error? (bitwise-xor 17 'a))
     (error? (bitwise-xor 25 "oops"))
     (error? (bitwise-xor "oops" 25))
     (error? (bitwise-xor 25 3.4))
     (error? (bitwise-xor 3.4 25))
     (error? (bitwise-xor 0 3/4))
     (error? (bitwise-xor 3/4 0))
     (error? (bitwise-xor 0 1+1i))
     (error? (bitwise-xor 1+1i 0))
     (error? (bitwise-xor 1 3.4-2.3i))
     (error? (bitwise-xor 3.4-2.3i 1))
     (error? (bitwise-xor 3.0 4.0))
     (eqv? (bitwise-xor 0 0) 0)
     (eqv? (bitwise-xor -1 0) -1)
     (eqv? (bitwise-xor #xfffffffffffffffffffffffff 0)
           #xfffffffffffffffffffffffff)
     (eqv? (bitwise-xor 0 -1) -1)
     (eqv? (bitwise-xor 0 #xfffffffffffffffffffffffff)
           #xfffffffffffffffffffffffff)
     (eqv? (bitwise-xor 20 -1) -21)
     (eqv? (bitwise-xor #xfffffffffffffffffffffffff -1)
           #x-10000000000000000000000000)
     (eqv? (bitwise-xor #x1111111111111111111111111 -1)
           #x-1111111111111111111111112)
     (eqv? (bitwise-xor (- (expt 2 100) 167) -1)
           #x-FFFFFFFFFFFFFFFFFFFFFFF5A)
     (eqv? (bitwise-xor (- 167 (expt 2 100)) -1)
           #xFFFFFFFFFFFFFFFFFFFFFFF58)
     (eqv? (bitwise-xor (- (expt 2 300) 167) (- (expt 2 300) 167)) 0)
     (eqv? (bitwise-xor (- 167 (expt 2 300)) (- 167 (expt 2 300))) 0)
     (eqv? (bitwise-xor
             #x1111111111111111111111111
             #x2222222222222222222222222)
           #x3333333333333333333333333)
     (eqv? (bitwise-xor
             #x1212121212121212121212121
             #x2222222222222222222222222)
           #x3030303030303030303030303)
     (eqv? (bitwise-xor
             #x-1212121212121212121212121
             #x-2222222222222222222222222)
           #x3030303030303030303030301)
     (eqv? (bitwise-xor
             #x-3333333333333333333333333
             #x-2222222222222222222222222)
           #x1111111111111111111111113)
     (eqv? (bitwise-xor
             #x-123456789abcdeffedca987654321
             #x-fedca987654321123456789abcdef)
           #xECE8FFFFFFFFFFEDD99CE0ECE8ECE)
     (eqv? (bitwise-xor
             #x-123456789abcdeffedca987654321
             #x-fedca987654321123456789abcdef)
           #xECE8FFFFFFFFFFEDD99CE0ECE8ECE)
     (eqv? (bitwise-xor
             #x-123456789abcdeffedca987654321
             #xfedca987654321123456789abcdef)
           #x-ECE8FFFFFFFFFFEDD99CE0ECE8ED0)
     (eqv? (bitwise-xor
             #x2B225D27F49C1FED301B89103
             #x-F2D8DD782236F835A1A50858)
           #x-240FD0F076BF706E6A01D9955)
     (eqv? (bitwise-xor #x2B225D27F49C1FED301B89103 #x1F366567)
           #x2B225D27F49C1FED31E8EF464)
     (eqv? (bitwise-xor #x2B225D27F49C1FED301B89103 #x-717D004)
           #x-2B225D27F49C1FED306AF4101)
     (eqv? (bitwise-xor #x-F2D8DD782236F835A1A50858 #x1F366567)
           #x-F2D8DD782236F835BE936D31)
     (eqv? (bitwise-xor #x-F2D8DD782236F835A1A50858 #x-717D004)
           #xF2D8DD782236F835A6B2D854)
     (eqv? (bitwise-xor #x1F366567 #x2B225D27F49C1FED301B89103)
           #x2B225D27F49C1FED31E8EF464)
     (eqv? (bitwise-xor #x-717D004 #x2B225D27F49C1FED301B89103)
           #x-2B225D27F49C1FED306AF4101)
     (eqv? (bitwise-xor #x1F366567 #x-F2D8DD782236F835A1A50858)
           #x-F2D8DD782236F835BE936D31)
     (eqv? (bitwise-xor #x-717D004 #x-F2D8DD782236F835A1A50858)
           #xF2D8DD782236F835A6B2D854)
     (eqv? (bitwise-xor) 0)
     (eqv? (bitwise-xor #x1212121212121212121212121)
           #x1212121212121212121212121)
     (eqv? (bitwise-xor
             #x1212121212121212121212121
             #x2222222222222222222222222
             #x0103010301030103010301030)
           #x3133313331333133313331333)
     (eqv? (bitwise-xor #b1010111 #b1001011 -1 #b1011110 #b1000111) -6)
     (eqv? (bitwise-xor #b1010111 #b1001011 0 #b1011110 #b1000111) 5)
     (test-cp0-expansion eqv? '(bitwise-xor 0 0) 0)
     (test-cp0-expansion eqv? '(bitwise-xor -1 0) -1)
     (test-cp0-expansion eqv?
       '(bitwise-xor #xfffffffffffffffffffffffff 0)
       #xfffffffffffffffffffffffff)
     (test-cp0-expansion eqv? '(bitwise-xor 0 -1) -1)
     (test-cp0-expansion eqv?
       '(bitwise-xor 0 #xfffffffffffffffffffffffff)
       #xfffffffffffffffffffffffff)
     (test-cp0-expansion eqv? '(bitwise-xor 20 -1) -21)
     (test-cp0-expansion eqv?
       '(bitwise-xor #xfffffffffffffffffffffffff -1)
       #x-10000000000000000000000000)
     (test-cp0-expansion eqv?
       '(bitwise-xor #x1111111111111111111111111 -1)
       #x-1111111111111111111111112)
     (test-cp0-expansion eqv?
       '(bitwise-xor (- (expt 2 100) 167) -1)
       #x-FFFFFFFFFFFFFFFFFFFFFFF5A)
     (test-cp0-expansion eqv?
       '(bitwise-xor (- 167 (expt 2 100)) -1)
       #xFFFFFFFFFFFFFFFFFFFFFFF58)
     (test-cp0-expansion eqv?
       '(bitwise-xor (- (expt 2 300) 167) (- (expt 2 300) 167))
       0)
     (test-cp0-expansion eqv?
       '(bitwise-xor (- 167 (expt 2 300)) (- 167 (expt 2 300)))
       0)
     (test-cp0-expansion eqv?
       '(bitwise-xor
          #x1111111111111111111111111
          #x2222222222222222222222222)
       #x3333333333333333333333333)
     (test-cp0-expansion eqv?
       '(bitwise-xor
          #x1212121212121212121212121
          #x2222222222222222222222222)
       #x3030303030303030303030303)
     (test-cp0-expansion eqv?
       '(bitwise-xor
          #x-1212121212121212121212121
          #x-2222222222222222222222222)
       #x3030303030303030303030301)
     (test-cp0-expansion eqv?
       '(bitwise-xor
          #x-3333333333333333333333333
          #x-2222222222222222222222222)
       #x1111111111111111111111113)
     (test-cp0-expansion eqv?
       '(bitwise-xor
          #x-123456789abcdeffedca987654321
          #x-fedca987654321123456789abcdef)
       #xECE8FFFFFFFFFFEDD99CE0ECE8ECE)
     (test-cp0-expansion eqv?
       '(bitwise-xor
          #x-123456789abcdeffedca987654321
          #x-fedca987654321123456789abcdef)
       #xECE8FFFFFFFFFFEDD99CE0ECE8ECE)
     (test-cp0-expansion eqv?
       '(bitwise-xor
          #x-123456789abcdeffedca987654321
          #xfedca987654321123456789abcdef)
       #x-ECE8FFFFFFFFFFEDD99CE0ECE8ED0)
     (test-cp0-expansion eqv?
       '(bitwise-xor
          #x2B225D27F49C1FED301B89103
          #x-F2D8DD782236F835A1A50858)
       #x-240FD0F076BF706E6A01D9955)
     (test-cp0-expansion eqv?
       '(bitwise-xor #x2B225D27F49C1FED301B89103 #x1F366567)
       #x2B225D27F49C1FED31E8EF464)
     (test-cp0-expansion eqv?
       '(bitwise-xor #x2B225D27F49C1FED301B89103 #x-717D004)
       #x-2B225D27F49C1FED306AF4101)
     (test-cp0-expansion eqv?
       '(bitwise-xor #x-F2D8DD782236F835A1A50858 #x1F366567)
       #x-F2D8DD782236F835BE936D31)
     (test-cp0-expansion eqv?
       '(bitwise-xor #x-F2D8DD782236F835A1A50858 #x-717D004)
       #xF2D8DD782236F835A6B2D854)
     (test-cp0-expansion eqv?
       '(bitwise-xor #x1F366567 #x2B225D27F49C1FED301B89103)
       #x2B225D27F49C1FED31E8EF464)
     (test-cp0-expansion eqv?
       '(bitwise-xor #x-717D004 #x2B225D27F49C1FED301B89103)
       #x-2B225D27F49C1FED306AF4101)
     (test-cp0-expansion eqv?
       '(bitwise-xor #x1F366567 #x-F2D8DD782236F835A1A50858)
       #x-F2D8DD782236F835BE936D31)
     (test-cp0-expansion eqv?
       '(bitwise-xor #x-717D004 #x-F2D8DD782236F835A1A50858)
       #xF2D8DD782236F835A6B2D854)
     (test-cp0-expansion eqv? '(bitwise-xor) 0)
     (test-cp0-expansion eqv?
       '(bitwise-xor #x1212121212121212121212121)
       #x1212121212121212121212121)
     (test-cp0-expansion eqv?
       '(bitwise-xor
          #x1212121212121212121212121
          #x2222222222222222222222222
          #x0103010301030103010301030)
       #x3133313331333133313331333)
     (test-cp0-expansion eqv?
       '(bitwise-xor #b1010111 #b1001011 -1 #b1011110 #b1000111)
       -6)
     (test-cp0-expansion eqv?
       '(bitwise-xor #b1010111 #b1001011 0 #b1011110 #b1000111)
       5))

(mat logtest
     (error? (logtest))
     (error? (logtest 1))
     (error? (logtest 1 2 3))
     (error? (logtest 3.4 5))
     (error? (logtest 5 "3"))
     (eqv? (logtest (+ (most-positive-fixnum) 1) 0) #f)
     (eqv? (logtest (+ (most-positive-fixnum) 6)
                    (+ (most-positive-fixnum) 8))
           #t)
     (eqv? (logtest (- (most-negative-fixnum) 1) 0) #f)
     (eqv? (logtest 1 (- (most-negative-fixnum) 1)) #t)
     (eqv? (logtest 750 -1) #t)
     (eqv? (logtest -1 -6) #t)
     (eqv? (logtest 0 -1) #f)
     (eqv? (logtest -1 0) #f)
     (eqv? (logtest #b1000101001 #b0111010110) #f)
     (eqv? (logtest #b1000101001 #b0111110110) #t)
     (eqv? (logtest #b1010101001 #b0111010110) #t)
     (eqv? (logtest #x100010100110001010011000101001
                    #x011101011001110101100111010110)
           #f)
     (eqv? (logtest #x101010100110001010011000101001
                    #x011101011001110101100111010110)
           #t)
     (eqv? (logtest #x100010100110001010011000101001
                    #x011101011101110101100111010110)
           #t)
     (eqv? (logtest (most-positive-fixnum) 3) #t)
     (eqv? (logtest (most-negative-fixnum) 3) #f)
     (eqv? (logtest (most-negative-fixnum) (most-negative-fixnum)) #t)
     (eqv? (logtest (most-negative-fixnum) (most-positive-fixnum)) #f)
     (eqv? (let ([n (ash (most-positive-fixnum) 1)])
             (do ([i 1000 (fx- i 1)]
                  [a #t (and a (logtest (- (random n)) (- (random n))))])
                 ((fx= i 0) a)))
           #t)
     (eqv? (let ([n1 (ash (most-positive-fixnum) 400)]
                 [n2 (ash (most-positive-fixnum) 100)])
             (do ([i 1000 (fx- i 1)]
                  [a #t
                     (and a
                          (logtest (- (random n1)) (- (random n1)))
                          (logtest (- (random n1)) (- (random n2)))
                          (logtest (- (random n2)) (- (random n1))))])
                 ((fx= i 0) a)))
           #t)
     (eqv? (logtest (ash 1 256) (ash 1 255)) #f)
     (eqv? (logtest (ash 1 256) (ash 3 255)) #t)
     (eqv? (logtest (ash 1 256) (- (ash 3 100))) #t)
     (eqv? (logtest (- 1 (ash 1 256)) (ash 3 100)) #f)
     (eqv? (logtest (- 1 (ash 1 256)) (+ (ash 3 100) 1)) #t)
     (eqv? (logtest (- 1 (ash 1 256)) (ash 1 255)) #f)
     (eqv? (logtest (- 1 (ash 1 256)) (ash 1 256)) #t)
     (eqv? (logtest (- 1 (ash 1 256)) (ash 1 257)) #t)
     (eqv? (logtest (- 1 (ash 1 255)) (ash 1 254)) #f)
     (eqv? (logtest (- 1 (ash 1 255)) (ash 1 255)) #t)
     (eqv? (logtest (- 1 (ash 1 255)) (ash 1 256)) #t)
     (eqv? (logtest (- 1 (ash 1 254)) (ash 1 253)) #f)
     (eqv? (logtest (- 1 (ash 1 254)) (ash 1 254)) #t)
     (eqv? (logtest (- 1 (ash 1 254)) (ash 1 255)) #t)

     ; make sure we've properly labeled logtest an arith-pred in primvars.ss
     (begin
       (define ($logtest-foo x y)
         (if (logtest x y) 'yes 'no))
       (equal? (list ($logtest-foo 3 4) ($logtest-foo 3 3)) '(no yes))))

(mat bitwise-if
     (error? (bitwise-if))
     (error? (bitwise-if 0))
     (error? (bitwise-if 0 0))
     (error? (bitwise-if 0 0 0 0))
     (error? (bitwise-if 'a 0 0))
     (error? (bitwise-if 0 3.4 0))
     (error? (bitwise-if 0 0 '(a)))
     (eqv? (bitwise-if 0 0 0) 0)
     (eqv? (bitwise-if 0 -1 0) 0)
     (eqv? (bitwise-if 0 0 -1) -1)
     (eqv? (bitwise-if #b10101010 0 -1) (bitwise-not #b10101010))
     (eqv? (bitwise-if #b10101010 -1 0) #b10101010)
     (eqv? (bitwise-if
             #b10101010110011001101011010110101101011010110101010101011100111111000010101000111001110001101010011
             #b11111110000000111111100000001111111000000011111110000000111111100000001111111000000011111110000000
             #b11001100110011110011001100111100110011001111001100110011110011001100111100110011001111001100110011)
           #b11101110000000111111000100001101111000001011101110010000110111100100101101110000000011001100100000)
     (let ([n (expt (+ (greatest-fixnum) 1) 2)])
       (define r6rs-bitwise-if
         (lambda (ei1 ei2 ei3)
           (bitwise-ior (bitwise-and ei1 ei2)
             (bitwise-and (bitwise-not ei1) ei3))))
       (let f ([i 10000])
         (unless (fx= i 0)
                 (let ([x (random n)]
                       [y (random n)]
                       [z (random n)]
                       [kx (random (+ (most-positive-fixnum) 1))]
                       [ky (random (+ (most-positive-fixnum) 1))]
                       [kz (random (+ (most-positive-fixnum) 1))])
                   (unless (and (= (bitwise-if x y z) (r6rs-bitwise-if x y z))
                                (= (bitwise-if (bitwise-not x) y z)
                                   (r6rs-bitwise-if (bitwise-not x) y z))
                                (= (bitwise-if (bitwise-not x) y (bitwise-not z))
                                   (r6rs-bitwise-if
                                     (bitwise-not x)
                                     y
                                     (bitwise-not z)))
                                (= (bitwise-if x (bitwise-not y) z)
                                   (r6rs-bitwise-if x (bitwise-not y) z))
                                (= (bitwise-if (bitwise-not x)
                                     (bitwise-not y)
                                     (bitwise-not z))
                                   (r6rs-bitwise-if (bitwise-not x)
                                     (bitwise-not y)
                                     (bitwise-not z)))
                                (= (bitwise-if x ky z) (r6rs-bitwise-if x ky z))
                                (= (bitwise-if x ky kz) (r6rs-bitwise-if x ky kz))
                                (= (bitwise-if kx y z) (r6rs-bitwise-if kx y z))
                                (= (bitwise-if kx (bitwise-not y) z)
                                   (r6rs-bitwise-if kx (bitwise-not y) z))
                                (= (bitwise-if (bitwise-not kx) (bitwise-not y) z)
                                   (r6rs-bitwise-if (bitwise-not kx)
                                     (bitwise-not y)
                                     z)))
                           (errorf #f
                                   "failed for ~s, ~s, ~s, ~s, ~s, ~s"
                                   x
                                   y
                                   z
                                   kx
                                   ky
                                   kz)))
                 (f (fx- i 1))))
       #t))

(mat logbit?
     (error? (logbit?))
     (error? (logbit? 1))
     (error? (logbit? 1 2 3))
     (error? (logbit? 3.4 5))
     (error? (logbit? 5 "3"))
     (error? (logbit? -1 -1))
     (let ()
       (define (f x b)
         (let f ([i 0])
           (or (> i 100000)
               (and (eq? (logbit? i x) b) (f (fx+ i 7))))))
       (and (f 0 #f) (f -1 #t)))
     (eqv? (do ([i 0 (fx+ i 1)] [a #t (and a (logbit? i -1))])
               ((fx> i (integer-length (most-positive-fixnum))) a))
           #t)
     (eqv? (do ([i 0 (fx+ i 1)]
                [a #t (and a (logbit? i (most-positive-fixnum)))])
               ((fx= i (integer-length (most-positive-fixnum))) a))
           #t)
     (eqv? (logbit? (integer-length (most-positive-fixnum))
                    (most-positive-fixnum))
           #f)
     (eqv? (do ([i 0 (fx+ i 1)]
                [a #f (or a (logbit? i (+ (most-positive-fixnum) 1)))])
               ((fx= i (integer-length (most-positive-fixnum))) a))
           #f)
     (eqv? (logbit? (integer-length (most-positive-fixnum))
                    (+ (most-positive-fixnum) 1))
           #t)
     (eqv? (do ([i (fx+ (integer-length (most-positive-fixnum)) 1)
                   (fx+ i 1)]
                [a #f (or a (logbit? i (+ (most-positive-fixnum) 1)))])
               ((fx= i (* (integer-length (most-positive-fixnum)) 10)) a))
           #f)
     (eqv? (do ([i 0 (fx+ i 1)]
                [a #t (and a (logbit? i (- (most-negative-fixnum) 1)))])
               ((fx= i (integer-length (most-positive-fixnum))) a))
           #t)
     (eqv? (logbit? (integer-length (most-positive-fixnum))
                    (- (most-negative-fixnum) 1))
           #f)
     (eqv? (do ([i (fx+ (integer-length (most-positive-fixnum)) 1)
                   (fx+ i 1)]
                [a #t (and a (logbit? i (- (most-negative-fixnum) 1)))])
               ((fx= i (* (integer-length (most-positive-fixnum)) 10)) a))
           #t)
     (eqv? (logbit? 0 #b0111010110) #f)
     (eqv? (logbit? 4 #b0111010110) #t)
     (eqv? (logbit? 8 #b0111010110) #t)
     (eqv? (logbit? 9 #b0111010110) #f)

     (eqv? (logbit? 0 #x42310521068980111010110) #f)
     (eqv? (logbit? 4 #x42310521068980111010110) #t)
     (eqv? (logbit? 85 #x42310521068980111010110) #t)
     (eqv? (logbit? 86 #x42310521068980111010110) #f)
     (eqv? (logbit? 90 #x42310521068980111010110) #t)
     (eqv? (logbit? 91 #x42310521068980111010110) #f)
     (eqv? (logbit? 1000 #x42310521068980111010110) #f)

     (eqv? (logbit? 0 #x-55555555555555555555555555) #t)
     (eqv? (logbit? 1 #x-55555555555555555555555555) #t)
     (eqv? (logbit? 2 #x-55555555555555555555555555) #f)
     (eqv? (logbit? 100 #x-55555555555555555555555555) #f)
     (eqv? (logbit? 101 #x-55555555555555555555555555) #t)
     (eqv? (logbit? 102 #x-55555555555555555555555555) #f)
     (eqv? (logbit? 103 #x-55555555555555555555555555) #t)
     (eqv? (logbit? 1000 #x-55555555555555555555555555) #t)

     (eqv? (logbit? 31 (ash 1 32)) #f)
     (eqv? (logbit? 32 (ash 1 32)) #t)
     (eqv? (logbit? 33 (ash 1 32)) #f)
     (eqv? (logbit? 30 (ash 1 31)) #f)
     (eqv? (logbit? 31 (ash 1 31)) #t)
     (eqv? (logbit? 32 (ash 1 31)) #f)
     (eqv? (logbit? 63 (ash 1 64)) #f)
     (eqv? (logbit? 64 (ash 1 64)) #t)
     (eqv? (logbit? 65 (ash 1 64)) #f)
     (eqv? (logbit? 62 (ash 1 63)) #f)
     (eqv? (logbit? 63 (ash 1 63)) #t)
     (eqv? (logbit? 64 (ash 1 63)) #f)

     (eqv? (logbit? 255 (ash 1 256)) #f)
     (eqv? (logbit? 256 (ash 1 256)) #t)
     (eqv? (logbit? 257 (ash 1 256)) #f)
     (eqv? (logbit? 254 (ash 1 255)) #f)
     (eqv? (logbit? 255 (ash 1 255)) #t)
     (eqv? (logbit? 256 (ash 1 255)) #f)

     (equal? (let ([x (- 1 (ash 1 256))])
               (list (logbit? 0 x)
                     (do ([i 1 (fx+ i 1)] [a #f (or a (logbit? i x))]) ((fx= i 256) a))
                     (do ([i 256 (fx+ i 1)] [a #t (and a (logbit? i x))]) ((fx= i 1000) a))))
             '(#t #f #t))
     (equal? (let ([x (- (ash 1 256))])
               (list (do ([i 0 (fx+ i 1)] [a #f (or a (logbit? i x))])
                         ((fx= i 256) a))
                     (do ([i 256 (fx+ i 1)] [a #t (and a (logbit? i x))])
                         ((fx= i 1000) a))))
             '(#f #t))

     (eqv? (logbit? (integer-length (most-positive-fixnum)) #b0111010110)
           #f)
     (eqv? (logbit? 0 -6) #f)
     (eqv? (logbit? 1 -6) #t)
     (eqv? (logbit? 2 -6) #f)
     (eqv? (do ([i 3 (fx+ i 1)] [a #t (and a (logbit? i -6))])
               ((fx= i (integer-length (most-positive-fixnum))) a))
           #t)
     ; check to see if we can look as far to the left as we please ...
     (eqv? (logbit? (+ (integer-length (most-positive-fixnum)) 1) -1) #t)
     (eqv? (logbit? (expt (integer-length (most-positive-fixnum)) 2)
                    (most-positive-fixnum))
           #f)
     (eqv? (logbit? (expt (integer-length (most-positive-fixnum)) 2) -1)
           #t)

     ; make sure we've properly labeled logbit? an arith-pred in primvars.ss
     (begin
       (define ($logbit?-foo x y)
         (if (logbit? x y) 'yes 'no))
       (equal? (list ($logbit?-foo 2 4) ($logbit?-foo 3 3)) '(yes no))))

(mat bitwise-bit-set?
     ; same as logbit?
     (error? (bitwise-bit-set?))
     (error? (bitwise-bit-set? 3))
     (error? (bitwise-bit-set? 3 4 5))
     (error? (bitwise-bit-set? 3.0 4))
     (error? (bitwise-bit-set? "hi" 4))
     (error? (bitwise-bit-set? 3 4/3))
     (error? (bitwise-bit-set? 3 'a))
     (error? (bitwise-bit-set? 3 -3))
     (let ()
       (define (f x b)
         (let f ([i 0])
           (or (> i 100000)
               (and (eq? (bitwise-bit-set? x i) b)
                    (f (fx+ i 7))))))
       (and (f 0 #f) (f -1 #t)))
     (eqv? (do ([i 0 (fx+ i 1)] [a #t (and a (bitwise-bit-set? -1 i))])
               ((fx> i (integer-length (most-positive-fixnum))) a))
           #t)
     (eqv? (do ([i 0 (fx+ i 1)]
                [a #t (and a (bitwise-bit-set? (most-positive-fixnum) 1))])
               ((fx= i (integer-length (most-positive-fixnum))) a))
           #t)
     (eqv? (bitwise-bit-set? (most-positive-fixnum)
             (integer-length (most-positive-fixnum)))
           #f)
     (eqv? (do ([i 0 (fx+ i 1)]
                [a #f
                   (or a
                       (bitwise-bit-set? (+ (most-positive-fixnum) 1) i))])
               ((fx= i (integer-length (most-positive-fixnum))) a))
           #f)
     (eqv? (bitwise-bit-set? (+ (most-positive-fixnum) 1)
             (integer-length (most-positive-fixnum)))
           #t)
     (eqv? (do ([i (fx+ (integer-length (most-positive-fixnum)) 1)
                   (fx+ i 1)]
                [a #f
                   (or a
                       (bitwise-bit-set? (+ (most-positive-fixnum) 1) i))])
               ((fx= i (* (integer-length (most-positive-fixnum)) 10)) a))
           #f)
     (eqv? (do ([i 0 (fx+ i 1)]
                [a #t
                   (and a
                        (bitwise-bit-set? (- (most-negative-fixnum) 1) i))])
               ((fx= i (integer-length (most-positive-fixnum))) a))
           #t)
     (eqv? (bitwise-bit-set? (- (most-negative-fixnum) 1)
             (integer-length (most-positive-fixnum)))
           #f)
     (eqv? (do ([i (fx+ (integer-length (most-positive-fixnum)) 1)
                   (fx+ i 1)]
                [a #t
                   (and a
                        (bitwise-bit-set? (- (most-negative-fixnum) 1) i))])
               ((fx= i (* (integer-length (most-positive-fixnum)) 10)) a))
           #t)
     (eqv? (bitwise-bit-set? #b0111010110 0) #f)
     (eqv? (bitwise-bit-set? #b0111010110 4) #t)
     (eqv? (bitwise-bit-set? #b0111010110 8) #t)
     (eqv? (bitwise-bit-set? #b0111010110 9) #f)

     (eqv? (bitwise-bit-set? #x42310521068980111010110 0) #f)
     (eqv? (bitwise-bit-set? #x42310521068980111010110 4) #t)
     (eqv? (bitwise-bit-set? #x42310521068980111010110 85) #t)
     (eqv? (bitwise-bit-set? #x42310521068980111010110 86) #f)
     (eqv? (bitwise-bit-set? #x42310521068980111010110 90) #t)
     (eqv? (bitwise-bit-set? #x42310521068980111010110 91) #f)
     (eqv? (bitwise-bit-set? #x42310521068980111010110 1000) #f)

     (eqv? (bitwise-bit-set? #x-55555555555555555555555555 0) #t)
     (eqv? (bitwise-bit-set? #x-55555555555555555555555555 1) #t)
     (eqv? (bitwise-bit-set? #x-55555555555555555555555555 2) #f)
     (eqv? (bitwise-bit-set? #x-55555555555555555555555555 100) #f)
     (eqv? (bitwise-bit-set? #x-55555555555555555555555555 101) #t)
     (eqv? (bitwise-bit-set? #x-55555555555555555555555555 102) #f)
     (eqv? (bitwise-bit-set? #x-55555555555555555555555555 103) #t)
     (eqv? (bitwise-bit-set? #x-55555555555555555555555555 1000) #t)

     (eqv? (bitwise-bit-set? (ash 1 32) 31) #f)
     (eqv? (bitwise-bit-set? (ash 1 32) 32) #t)
     (eqv? (bitwise-bit-set? (ash 1 32) 33) #f)
     (eqv? (bitwise-bit-set? (ash 1 31) 30) #f)
     (eqv? (bitwise-bit-set? (ash 1 31) 31) #t)
     (eqv? (bitwise-bit-set? (ash 1 31) 32) #f)
     (eqv? (bitwise-bit-set? (ash 1 64) 63) #f)
     (eqv? (bitwise-bit-set? (ash 1 64) 64) #t)
     (eqv? (bitwise-bit-set? (ash 1 64) 65) #f)
     (eqv? (bitwise-bit-set? (ash 1 63) 62) #f)
     (eqv? (bitwise-bit-set? (ash 1 63) 63) #t)
     (eqv? (bitwise-bit-set? (ash 1 63) 64) #f)

     (eqv? (bitwise-bit-set? (ash 1 256) 255) #f)
     (eqv? (bitwise-bit-set? (ash 1 256) 256) #t)
     (eqv? (bitwise-bit-set? (ash 1 256) 257) #f)
     (eqv? (bitwise-bit-set? (ash 1 255) 254) #f)
     (eqv? (bitwise-bit-set? (ash 1 255) 255) #t)
     (eqv? (bitwise-bit-set? (ash 1 255) 256) #f)

     (equal? (let ([x (- 1 (ash 1 256))])
               (list (bitwise-bit-set? x 0)
                     (do ([i 1 (fx+ i 1)] [a #f (or a (bitwise-bit-set? x i))]) ((fx= i 256) a))
                     (do ([i 256 (fx+ i 1)] [a #t (and a (bitwise-bit-set? x i))]) ((fx= i 1000) a))))
             '(#t #f #t))
     (equal? (let ([x (- (ash 1 256))])
               (list (do ([i 0 (fx+ i 1)]
                          [a #f (or a (bitwise-bit-set? x i))])
                         ((fx= i 256) a))
                     (do ([i 256 (fx+ i 1)]
                          [a #t (and a (bitwise-bit-set? x i))])
                         ((fx= i 1000) a))))
             '(#f #t))

     (eqv? (bitwise-bit-set? #b0111010110
             (integer-length (most-positive-fixnum)))
           #f)
     (eqv? (bitwise-bit-set? -6 0) #f)
     (eqv? (bitwise-bit-set? -6 1) #t)
     (eqv? (bitwise-bit-set? -6 2) #f)
     (eqv? (do ([i 3 (fx+ i 1)] [a #t (and a (bitwise-bit-set? -6 i))])
               ((fx= i (integer-length (most-positive-fixnum))) a))
           #t)
     ; check to see if we can look as far to the left as we please ...
     (eqv? (bitwise-bit-set? -1
             (+ (integer-length (most-positive-fixnum)) 1))
           #t)
     (eqv? (bitwise-bit-set? (most-positive-fixnum)
             (expt (integer-length (most-positive-fixnum)) 2))
           #f)
     (eqv? (bitwise-bit-set? -1
             (expt (integer-length (most-positive-fixnum)) 2))
           #t)

     ; make sure we've properly labeled bitwise-bit-set? an arith-pred in primvars.ss
     (begin
       (define ($bitwise-bit-set?-foo x y)
         (if (bitwise-bit-set? y x) 'yes 'no))
       (equal? (list ($bitwise-bit-set?-foo 2 4)
                     ($bitwise-bit-set?-foo 3 3))
               '(yes no))))

(mat logbit0
     (error? (logbit0))
     (error? (logbit0 1))
     (error? (logbit0 1 2 3))
     (error? (logbit0 3.4 5))
     (error? (logbit0 5 "3"))
     (error? (logbit0 -1 -1))
     (eqv? (logbit0 0 (+ (most-positive-fixnum) 2))
           (+ (most-positive-fixnum) 1))
     (eqv? (logbit0 0 (- (most-negative-fixnum) 1))
           (- (most-negative-fixnum) 2))
     (eqv? (logbit0 (integer-length (most-positive-fixnum)) -1)
           (- -1 (expt 2 (integer-length (most-positive-fixnum)))))
     (eqv? (logbit0 2 0) 0)
     (eqv? (logbit0 2 -1) -5)
     (eqv? (logbit0 3 #b10101010) #b10100010)
     (eqv? (logbit0 4 #b10101010) #b10101010)
     (andmap values
       (let ([p? (lambda (i) (fx= (logbit0 i -1) (fx- -1 (expt 2 i))))])
         (let f ([i 0])
           (if (fx= i (integer-length (most-positive-fixnum)))
               '()
               (cons (p? i) (f (fx+ i 1)))))))
     (let ([p? (lambda (n i)
                 (fx= (logbit0 i n) (fxlogand (lognot (fxsll 1 i)) n)))])
       (let g ([j 1000])
         (or (fx= j 0)
             (let ([n (+ (random (+ (- (most-positive-fixnum) (most-negative-fixnum))
                                    1))
                         (most-negative-fixnum))])
               (let f ([i 0])
                 (if (fx= i (integer-length (most-positive-fixnum)))
                     (g (fx- j 1))
                     (and (p? n i) (f (fx+ i 1)))))))))

     (eqv? (logbit0 31 (- (ash 1 32) 1)) (- (ash 1 31) 1))
     (eqv? (logbit0 32 (- (ash 1 32) 1)) (- (ash 1 32) 1))
     (eqv? (logbit0 33 (- (ash 1 32) 1)) (- (ash 1 32) 1))
     (eqv? (logbit0 31 (ash 1 32)) (ash 1 32))
     (eqv? (logbit0 32 (ash 1 32)) 0)
     (eqv? (logbit0 31 (- (ash 1 33) 1)) (- (ash 1 33) (ash 1 31) 1))
     (eqv? (logbit0 32 (- (ash 1 33) 1)) (- (ash 1 32) 1))
     (eqv? (logbit0 33 (- (ash 1 33) 1)) (- (ash 1 33) 1))

     (eqv? (logbit0 63 (- (ash 1 64) 1)) (- (ash 1 63) 1))
     (eqv? (logbit0 64 (- (ash 1 64) 1)) (- (ash 1 64) 1))
     (eqv? (logbit0 65 (- (ash 1 64) 1)) (- (ash 1 64) 1))
     (eqv? (logbit0 63 (ash 1 64)) (ash 1 64))
     (eqv? (logbit0 64 (ash 1 64)) 0)
     (eqv? (logbit0 63 (- (ash 1 65) 1)) (- (ash 1 65) (ash 1 63) 1))
     (eqv? (logbit0 64 (- (ash 1 65) 1)) (- (ash 1 64) 1))
     (eqv? (logbit0 65 (- (ash 1 65) 1)) (- (ash 1 65) 1))

     (eqv? (logbit0 255 (- (ash 1 256) 1)) (- (ash 1 255) 1))
     (eqv? (logbit0 256 (- (ash 1 256) 1)) (- (ash 1 256) 1))
     (eqv? (logbit0 257 (- (ash 1 256) 1)) (- (ash 1 256) 1))
     (eqv? (logbit0 255 (ash 1 256)) (ash 1 256))
     (eqv? (logbit0 256 (ash 1 256)) 0)
     (eqv? (logbit0 255 (- (ash 1 257) 1)) (- (ash 1 257) (ash 1 255) 1))
     (eqv? (logbit0 256 (- (ash 1 257) 1)) (- (ash 1 256) 1))
     (eqv? (logbit0 257 (- (ash 1 257) 1)) (- (ash 1 257) 1))

     ; two's comp rep'n of #x-32B225D27F49C1FED301B89103 is
     ; ...FCD4DDA2D80B63E012CFE476EFD
     (eqv? (logbit0 0 #x-32B225D27F49C1FED301B89103)
           #x-32B225D27F49C1FED301B89104)
     (eqv? (logbit0 1 #x-32B225D27F49C1FED301B89103)
           #x-32B225D27F49C1FED301B89103)
     (eqv? (logbit0 2 #x-32B225D27F49C1FED301B89103)
           #x-32B225D27F49C1FED301B89107)
     (eqv? (logbit0 31 #x-32B225D27F49C1FED301B89103)
           #x-32B225D27F49C1FED381B89103)
     (eqv? (logbit0 32 #x-32B225D27F49C1FED301B89103)
           #x-32B225D27F49C1FED301B89103)
     (eqv? (logbit0 63 #x-32B225D27F49C1FED301B89103)
           #x-32B225D27FC9C1FED301B89103)
     (eqv? (logbit0 64 #x-32B225D27F49C1FED301B89103)
           #x-32B225D27F49C1FED301B89103)
     (eqv? (logbit0 99 #x-32B225D27F49C1FED301B89103)
           #x-3AB225D27F49C1FED301B89103)
     (eqv? (logbit0 100 #x-32B225D27F49C1FED301B89103)
           #x-32B225D27F49C1FED301B89103)
     (eqv? (logbit0 101 #x-32B225D27F49C1FED301B89103)
           #x-32B225D27F49C1FED301B89103)
     (eqv? (logbit0 102 #x-32B225D27F49C1FED301B89103)
           #x-72B225D27F49C1FED301B89103)
     (eqv? (logbit0 103 #x-32B225D27F49C1FED301B89103)
           #x-B2B225D27F49C1FED301B89103)
     (eqv? (logbit0 104 #x-32B225D27F49C1FED301B89103)
           #x-132B225D27F49C1FED301B89103)
     (eqv? (logbit0 1000 #x-32B225D27F49C1FED301B89103)
           #x-10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000032B225D27F49C1FED301B89103)

     (eqv? (logbit0 0 #x-CD4DDA2D80B63E012CFE476EFD)
           #x-CD4DDA2D80B63E012CFE476EFE)
     (eqv? (logbit0 1 #x-CD4DDA2D80B63E012CFE476EFD)
           #x-CD4DDA2D80B63E012CFE476EFF)
     (eqv? (logbit0 2 #x-CD4DDA2D80B63E012CFE476EFD)
           #x-CD4DDA2D80B63E012CFE476EFD)
     (eqv? (logbit0 31 #x-CD4DDA2D80B63E012CFE476EFD)
           #x-CD4DDA2D80B63E012CFE476EFD)
     (eqv? (logbit0 32 #x-CD4DDA2D80B63E012CFE476EFD)
           #x-CD4DDA2D80B63E012DFE476EFD)
     (eqv? (logbit0 63 #x-CD4DDA2D80B63E012CFE476EFD)
           #x-CD4DDA2D80B63E012CFE476EFD)
     (eqv? (logbit0 64 #x-CD4DDA2D80B63E012CFE476EFD)
           #x-CD4DDA2D81B63E012CFE476EFD)
     (eqv? (logbit0 99 #x-CD4DDA2D80B63E012CFE476EFD)
           #x-CD4DDA2D80B63E012CFE476EFD)
     (eqv? (logbit0 100 #x-CD4DDA2D80B63E012CFE476EFD)
           #x-DD4DDA2D80B63E012CFE476EFD)
     (eqv? (logbit0 101 #x-CD4DDA2D80B63E012CFE476EFD)
           #x-ED4DDA2D80B63E012CFE476EFD)
     (eqv? (logbit0 102 #x-CD4DDA2D80B63E012CFE476EFD)
           #x-CD4DDA2D80B63E012CFE476EFD)
     (eqv? (logbit0 103 #x-CD4DDA2D80B63E012CFE476EFD)
           #x-CD4DDA2D80B63E012CFE476EFD)
     (eqv? (logbit0 104 #x-CD4DDA2D80B63E012CFE476EFD)
           #x-1CD4DDA2D80B63E012CFE476EFD)
     (eqv? (logbit0 1000 #x-CD4DDA2D80B63E012CFE476EFD)
           #x-100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000CD4DDA2D80B63E012CFE476EFD)

     (andmap values
       (let ([p? (lambda (i) (= (logbit0 i -1) (- -1 (expt 2 i))))])
         (let f ([i 0])
           (if (fx= i 1000) '() (cons (p? i) (f (fx+ i 1)))))))
     (let ([p? (lambda (n i)
                 (= (logbit0 i n) (logand (lognot (ash 1 i)) n)))])
       (let g ([j 1000])
         (or (fx= j 0)
             (let ([n (+ (random (+ (- (ash (most-positive-fixnum) 5)
                                       (ash (most-negative-fixnum) 5))
                                    1))
                         (ash (most-negative-fixnum) 5))])
               (let f ([i 0])
                 (if (fx= i
                          (* (integer-length (ash (most-negative-fixnum) 5))
                             2))
                     (g (fx- j 1))
                     (and (p? n i) (f (fx+ i 1))))))))))

(mat logbit1
     (error? (logbit1))
     (error? (logbit1 1))
     (error? (logbit1 1 2 3))
     (error? (logbit1 3.4 5))
     (error? (logbit1 5 "3"))
     (error? (logbit1 -1 -1))
     (eqv? (logbit1 0 (+ (most-positive-fixnum) 1))
           (+ (most-positive-fixnum) 2))
     (eqv? (logbit1 0 (- (most-negative-fixnum) 2))
           (- (most-negative-fixnum) 1))
     (eqv? (logbit1 (integer-length (most-positive-fixnum)) 0)
           (ash 1 (integer-length (most-positive-fixnum))))
     (eqv? (logbit1 (integer-length (most-positive-fixnum)) 0)
           (+ (most-positive-fixnum) 1))
     (eqv? (logbit1 2 0) 4)
     (eqv? (logbit1 2 -1) -1)
     (eqv? (logbit1 (expt 2 20) -75) -75)
     (eqv? (logbit1 1000 -75) -75)
     (eqv? (logbit1 3 #b10101010) #b10101010)
     (eqv? (logbit1 4 #b10101010) #b10111010)
     (andmap values
       (let ([p? (lambda (i) (fx= (logbit1 i 0) (ash 1 i)))])
         (let f ([i 0])
           (if (fx= i (integer-length (most-positive-fixnum)))
               '()
               (cons (p? i) (f (fx+ i 1)))))))
     (let ([p? (lambda (n i) (fx= (logbit1 i n) (fxlogor (fxsll 1 i) n)))])
       (let g ([j 1000])
         (or (fx= j 0)
             (let ([n (+ (random (+ (- (most-positive-fixnum) (most-negative-fixnum))
                                    1))
                         (most-negative-fixnum))])
               (let f ([i 0])
                 (if (fx= i (integer-length (most-positive-fixnum)))
                     (g (fx- j 1))
                     (and (p? n i) (f (fx+ i 1)))))))))

     (eqv? (logbit1 31 (ash 1 32)) (ash 3 31))
     (eqv? (logbit1 32 (ash 1 32)) (ash 1 32))
     (eqv? (logbit1 33 (ash 1 32)) (ash 3 32))
     (eqv? (logbit1 30 (ash 1 31)) (ash 3 30))
     (eqv? (logbit1 31 (ash 1 31)) (ash 1 31))
     (eqv? (logbit1 32 (ash 1 31)) (ash 3 31))
     (eqv? (logbit1 63 (ash 1 64)) (ash 3 63))
     (eqv? (logbit1 64 (ash 1 64)) (ash 1 64))
     (eqv? (logbit1 65 (ash 1 64)) (ash 3 64))
     (eqv? (logbit1 62 (ash 1 63)) (ash 3 62))
     (eqv? (logbit1 63 (ash 1 63)) (ash 1 63))
     (eqv? (logbit1 64 (ash 1 63)) (ash 3 63))

     (eqv? (logbit1 255 (ash 1 256)) (ash 3 255))
     (eqv? (logbit1 256 (ash 1 256)) (ash 1 256))
     (eqv? (logbit1 257 (ash 1 256)) (ash 3 256))
     (eqv? (logbit1 254 (ash 1 255)) (ash 3 254))
     (eqv? (logbit1 255 (ash 1 255)) (ash 1 255))
     (eqv? (logbit1 256 (ash 1 255)) (ash 3 255))

     ; two's comp rep'n of #x-32B225D27F49C1FED301B89103 is
     ; ...FCD4DDA2D80B63E012CFE476EFD
     (eqv? (logbit1 0 #x-32B225D27F49C1FED301B89103)
           #x-32B225D27F49C1FED301B89103)
     (eqv? (logbit1 1 #x-32B225D27F49C1FED301B89103)
           #x-32B225D27F49C1FED301B89101)
     (eqv? (logbit1 2 #x-32B225D27F49C1FED301B89103)
           #x-32B225D27F49C1FED301B89103)
     (eqv? (logbit1 31 #x-32B225D27F49C1FED301B89103)
           #x-32B225D27F49C1FED301B89103)
     (eqv? (logbit1 32 #x-32B225D27F49C1FED301B89103)
           #x-32B225D27F49C1FED201B89103)
     (eqv? (logbit1 63 #x-32B225D27F49C1FED301B89103)
           #x-32B225D27F49C1FED301B89103)
     (eqv? (logbit1 64 #x-32B225D27F49C1FED301B89103)
           #x-32B225D27E49C1FED301B89103)
     (eqv? (logbit1 99 #x-32B225D27F49C1FED301B89103)
           #x-32B225D27F49C1FED301B89103)
     (eqv? (logbit1 100 #x-32B225D27F49C1FED301B89103)
           #x-22B225D27F49C1FED301B89103)
     (eqv? (logbit1 101 #x-32B225D27F49C1FED301B89103)
           #x-12B225D27F49C1FED301B89103)
     (eqv? (logbit1 102 #x-32B225D27F49C1FED301B89103)
           #x-32B225D27F49C1FED301B89103)
     (eqv? (logbit1 103 #x-32B225D27F49C1FED301B89103)
           #x-32B225D27F49C1FED301B89103)
     (eqv? (logbit1 104 #x-32B225D27F49C1FED301B89103)
           #x-32B225D27F49C1FED301B89103)
     (eqv? (logbit1 1000 #x-32B225D27F49C1FED301B89103)
           #x-32B225D27F49C1FED301B89103)

     (eqv? (logbit1 0 #x-CD4DDA2D80B63E012CFE476EFD)
           #x-CD4DDA2D80B63E012CFE476EFD)
     (eqv? (logbit1 1 #x-CD4DDA2D80B63E012CFE476EFD)
           #x-CD4DDA2D80B63E012CFE476EFD)
     (eqv? (logbit1 2 #x-CD4DDA2D80B63E012CFE476EFD)
           #x-CD4DDA2D80B63E012CFE476EF9)
     (eqv? (logbit1 31 #x-CD4DDA2D80B63E012CFE476EFD)
           #x-CD4DDA2D80B63E012C7E476EFD)
     (eqv? (logbit1 32 #x-CD4DDA2D80B63E012CFE476EFD)
           #x-CD4DDA2D80B63E012CFE476EFD)
     (eqv? (logbit1 63 #x-CD4DDA2D80B63E012CFE476EFD)
           #x-CD4DDA2D80363E012CFE476EFD)
     (eqv? (logbit1 64 #x-CD4DDA2D80B63E012CFE476EFD)
           #x-CD4DDA2D80B63E012CFE476EFD)
     (eqv? (logbit1 99 #x-CD4DDA2D80B63E012CFE476EFD)
           #x-C54DDA2D80B63E012CFE476EFD)
     (eqv? (logbit1 100 #x-CD4DDA2D80B63E012CFE476EFD)
           #x-CD4DDA2D80B63E012CFE476EFD)
     (eqv? (logbit1 101 #x-CD4DDA2D80B63E012CFE476EFD)
           #x-CD4DDA2D80B63E012CFE476EFD)
     (eqv? (logbit1 102 #x-CD4DDA2D80B63E012CFE476EFD)
           #x-8D4DDA2D80B63E012CFE476EFD)
     (eqv? (logbit1 103 #x-CD4DDA2D80B63E012CFE476EFD)
           #x-4D4DDA2D80B63E012CFE476EFD)
     (eqv? (logbit1 104 #x-CD4DDA2D80B63E012CFE476EFD)
           #x-CD4DDA2D80B63E012CFE476EFD)
     (eqv? (logbit1 1000 #x-CD4DDA2D80B63E012CFE476EFD)
           #x-CD4DDA2D80B63E012CFE476EFD)
     (andmap values
       (let ([p? (lambda (i) (= (logbit1 i 0) (ash 1 i)))])
         (let f ([i 0])
           (if (fx= i 1000) '() (cons (p? i) (f (fx+ i 1)))))))
     (let ([p? (lambda (n i) (= (logbit1 i n) (logor (ash 1 i) n)))])
       (let g ([j 1000])
         (or (fx= j 0)
             (let ([n (+ (random (+ (- (ash (most-positive-fixnum) 5)
                                       (ash (most-negative-fixnum) 5))
                                    1))
                         (ash (most-negative-fixnum) 5))])
               (let f ([i 0])
                 (if (fx= i
                          (* (integer-length (ash (most-negative-fixnum) 5))
                             2))
                     (g (fx- j 1))
                     (and (p? n i) (f (fx+ i 1))))))))))

(mat bitwise-copy-bit
     ; adapted from logbit0 and logbit1 above
     (error? (bitwise-copy-bit))
     (error? (bitwise-copy-bit 1))
     (error? (bitwise-copy-bit 1 2))
     (error? (bitwise-copy-bit 1 2 0 4))
     (error? (bitwise-copy-bit 3.4 5 0))
     (error? (bitwise-copy-bit 1 'a 0))
     (error? (bitwise-copy-bit 1 -2 0))
     (error? (bitwise-copy-bit 1 2 2))
     (error? (bitwise-copy-bit 1 2 -1))
     (error? (bitwise-copy-bit 1 2 'a))
     (eqv? (bitwise-copy-bit (+ (most-positive-fixnum) 2) 0 0)
           (+ (most-positive-fixnum) 1))
     (eqv? (bitwise-copy-bit (- (most-negative-fixnum) 1) 0 0)
           (- (most-negative-fixnum) 2))
     (eqv? (bitwise-copy-bit -1 (integer-length (most-positive-fixnum)) 0)
           (- -1 (expt 2 (integer-length (most-positive-fixnum)))))
     (eqv? (bitwise-copy-bit 0 2 0) 0)
     (eqv? (bitwise-copy-bit -1 2 0) -5)
     (eqv? (bitwise-copy-bit 170 3 0) 162)
     (eqv? (bitwise-copy-bit 170 4 0) 170)
     (andmap values
       (let ([p? (lambda (i)
                   (fx= (bitwise-copy-bit -1 i 0) (fx- -1 (expt 2 i))))])
         (let f ([i 0])
           (if (fx= i (integer-length (most-positive-fixnum)))
               '()
               (cons (p? i) (f (fx+ i 1)))))))
     (let ([p? (lambda (n i)
                 (fx= (bitwise-copy-bit n i 0)
                      (fxlogand (lognot (fxsll 1 i)) n)))])
       (let g ([j 1000])
         (or (fx= j 0)
             (let ([n (+ (random (+ (- (most-positive-fixnum) (most-negative-fixnum))
                                    1))
                         (most-negative-fixnum))])
               (let f ([i 0])
                 (if (fx= i (integer-length (most-positive-fixnum)))
                     (g (fx- j 1))
                     (and (p? n i) (f (fx+ i 1)))))))))
     (eqv? (bitwise-copy-bit (- (ash 1 32) 1) 31 0) (- (ash 1 31) 1))
     (eqv? (bitwise-copy-bit (- (ash 1 32) 1) 32 0) (- (ash 1 32) 1))
     (eqv? (bitwise-copy-bit (- (ash 1 32) 1) 33 0) (- (ash 1 32) 1))
     (eqv? (bitwise-copy-bit (ash 1 32) 31 0) (ash 1 32))
     (eqv? (bitwise-copy-bit (ash 1 32) 32 0) 0)
     (eqv? (bitwise-copy-bit (- (ash 1 33) 1) 31 0)
           (- (ash 1 33) (ash 1 31) 1))
     (eqv? (bitwise-copy-bit (- (ash 1 33) 1) 32 0) (- (ash 1 32) 1))
     (eqv? (bitwise-copy-bit (- (ash 1 33) 1) 33 0) (- (ash 1 33) 1))
     (eqv? (bitwise-copy-bit (- (ash 1 64) 1) 63 0) (- (ash 1 63) 1))
     (eqv? (bitwise-copy-bit (- (ash 1 64) 1) 64 0) (- (ash 1 64) 1))
     (eqv? (bitwise-copy-bit (- (ash 1 64) 1) 65 0) (- (ash 1 64) 1))
     (eqv? (bitwise-copy-bit (ash 1 64) 63 0) (ash 1 64))
     (eqv? (bitwise-copy-bit (ash 1 64) 64 0) 0)
     (eqv? (bitwise-copy-bit (- (ash 1 65) 1) 63 0)
           (- (ash 1 65) (ash 1 63) 1))
     (eqv? (bitwise-copy-bit (- (ash 1 65) 1) 64 0) (- (ash 1 64) 1))
     (eqv? (bitwise-copy-bit (- (ash 1 65) 1) 65 0) (- (ash 1 65) 1))
     (eqv? (bitwise-copy-bit (- (ash 1 256) 1) 255 0) (- (ash 1 255) 1))
     (eqv? (bitwise-copy-bit (- (ash 1 256) 1) 256 0) (- (ash 1 256) 1))
     (eqv? (bitwise-copy-bit (- (ash 1 256) 1) 257 0) (- (ash 1 256) 1))
     (eqv? (bitwise-copy-bit (ash 1 256) 255 0) (ash 1 256))
     (eqv? (bitwise-copy-bit (ash 1 256) 256 0) 0)
     (eqv? (bitwise-copy-bit (- (ash 1 257) 1) 255 0)
           (- (ash 1 257) (ash 1 255) 1))
     (eqv? (bitwise-copy-bit (- (ash 1 257) 1) 256 0) (- (ash 1 256) 1))
     (eqv? (bitwise-copy-bit (- (ash 1 257) 1) 257 0) (- (ash 1 257) 1))
     (eqv? (bitwise-copy-bit #x-32b225d27f49c1fed301b89103 0 0)
           #x-32b225d27f49c1fed301b89104)
     (eqv? (bitwise-copy-bit #x-32b225d27f49c1fed301b89103 1 0)
           #x-32b225d27f49c1fed301b89103)
     (eqv? (bitwise-copy-bit #x-32b225d27f49c1fed301b89103 2 0)
           #x-32b225d27f49c1fed301b89107)
     (eqv? (bitwise-copy-bit #x-32b225d27f49c1fed301b89103 31 0)
           #x-32b225d27f49c1fed381b89103)
     (eqv? (bitwise-copy-bit #x-32b225d27f49c1fed301b89103 32 0)
           #x-32b225d27f49c1fed301b89103)
     (eqv? (bitwise-copy-bit #x-32b225d27f49c1fed301b89103 63 0)
           #x-32b225d27fc9c1fed301b89103)
     (eqv? (bitwise-copy-bit #x-32b225d27f49c1fed301b89103 64 0)
           #x-32b225d27f49c1fed301b89103)
     (eqv? (bitwise-copy-bit #x-32b225d27f49c1fed301b89103 99 0)
           #x-3ab225d27f49c1fed301b89103)
     (eqv? (bitwise-copy-bit #x-32b225d27f49c1fed301b89103 100 0)
           #x-32b225d27f49c1fed301b89103)
     (eqv? (bitwise-copy-bit #x-32b225d27f49c1fed301b89103 101 0)
           #x-32b225d27f49c1fed301b89103)
     (eqv? (bitwise-copy-bit #x-32b225d27f49c1fed301b89103 102 0)
           #x-72b225d27f49c1fed301b89103)
     (eqv? (bitwise-copy-bit #x-32b225d27f49c1fed301b89103 103 0)
           #x-b2b225d27f49c1fed301b89103)
     (eqv? (bitwise-copy-bit #x-32b225d27f49c1fed301b89103 104 0)
           #x-132b225d27f49c1fed301b89103)
     (eqv? (bitwise-copy-bit #x-32b225d27f49c1fed301b89103 1000 0)
           #x-10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000032b225d27f49c1fed301b89103)
     (eqv? (bitwise-copy-bit #x-cd4dda2d80b63e012cfe476efd 0 0)
           #x-cd4dda2d80b63e012cfe476efe)
     (eqv? (bitwise-copy-bit #x-cd4dda2d80b63e012cfe476efd 1 0)
           #x-cd4dda2d80b63e012cfe476eff)
     (eqv? (bitwise-copy-bit #x-cd4dda2d80b63e012cfe476efd 2 0)
           #x-cd4dda2d80b63e012cfe476efd)
     (eqv? (bitwise-copy-bit #x-cd4dda2d80b63e012cfe476efd 31 0)
           #x-cd4dda2d80b63e012cfe476efd)
     (eqv? (bitwise-copy-bit #x-cd4dda2d80b63e012cfe476efd 32 0)
           #x-cd4dda2d80b63e012dfe476efd)
     (eqv? (bitwise-copy-bit #x-cd4dda2d80b63e012cfe476efd 63 0)
           #x-cd4dda2d80b63e012cfe476efd)
     (eqv? (bitwise-copy-bit #x-cd4dda2d80b63e012cfe476efd 64 0)
           #x-cd4dda2d81b63e012cfe476efd)
     (eqv? (bitwise-copy-bit #x-cd4dda2d80b63e012cfe476efd 99 0)
           #x-cd4dda2d80b63e012cfe476efd)
     (eqv? (bitwise-copy-bit #x-cd4dda2d80b63e012cfe476efd 100 0)
           #x-dd4dda2d80b63e012cfe476efd)
     (eqv? (bitwise-copy-bit #x-cd4dda2d80b63e012cfe476efd 101 0)
           #x-ed4dda2d80b63e012cfe476efd)
     (eqv? (bitwise-copy-bit #x-cd4dda2d80b63e012cfe476efd 102 0)
           #x-cd4dda2d80b63e012cfe476efd)
     (eqv? (bitwise-copy-bit #x-cd4dda2d80b63e012cfe476efd 103 0)
           #x-cd4dda2d80b63e012cfe476efd)
     (eqv? (bitwise-copy-bit #x-cd4dda2d80b63e012cfe476efd 104 0)
           #x-1cd4dda2d80b63e012cfe476efd)
     (eqv? (bitwise-copy-bit #x-cd4dda2d80b63e012cfe476efd 1000 0)
           #x-100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000cd4dda2d80b63e012cfe476efd)
     (andmap values
       (let ([p? (lambda (i)
                   (= (bitwise-copy-bit -1 i 0) (- -1 (expt 2 i))))])
         (let f ([i 0])
           (if (fx= i 1000) '() (cons (p? i) (f (fx+ i 1)))))))
     (let ([p? (lambda (n i)
                 (= (bitwise-copy-bit n i 0) (logand (lognot (ash 1 i)) n)))])
       (let g ([j 1000])
         (or (fx= j 0)
             (let ([n (+ (random (+ (- (ash (most-positive-fixnum) 5)
                                       (ash (most-negative-fixnum) 5))
                                    1))
                         (ash (most-negative-fixnum) 5))])
               (let f ([i 0])
                 (if (fx= i
                          (* (integer-length (ash (most-negative-fixnum) 5))
                             2))
                     (g (fx- j 1))
                     (and (p? n i) (f (fx+ i 1)))))))))
     (eqv? (bitwise-copy-bit (+ (most-positive-fixnum) 1) 0 1)
           (+ (most-positive-fixnum) 2))
     (eqv? (bitwise-copy-bit (- (most-negative-fixnum) 2) 0 1)
           (- (most-negative-fixnum) 1))
     (eqv? (bitwise-copy-bit 0 (integer-length (most-positive-fixnum)) 1)
           (ash 1 (integer-length (most-positive-fixnum))))
     (eqv? (bitwise-copy-bit 0 (integer-length (most-positive-fixnum)) 1)
           (+ (most-positive-fixnum) 1))
     (eqv? (bitwise-copy-bit 0 2 1) 4)
     (eqv? (bitwise-copy-bit -1 2 1) -1)
     (eqv? (bitwise-copy-bit -75 (expt 2 20) 1) -75)
     (eqv? (bitwise-copy-bit -75 1000 1) -75)
     (eqv? (bitwise-copy-bit 170 3 1) 170)
     (eqv? (bitwise-copy-bit 170 4 1) 186)
     (andmap values
       (let ([p? (lambda (i) (fx= (bitwise-copy-bit 0 i 1) (ash 1 i)))])
         (let f ([i 0])
           (if (fx= i (integer-length (most-positive-fixnum)))
               '()
               (cons (p? i) (f (fx+ i 1)))))))
     (let ([p? (lambda (n i)
                 (fx= (bitwise-copy-bit n i 1) (fxlogor (fxsll 1 i) n)))])
       (let g ([j 1000])
         (or (fx= j 0)
             (let ([n (+ (random (+ (- (most-positive-fixnum) (most-negative-fixnum))
                                    1))
                         (most-negative-fixnum))])
               (let f ([i 0])
                 (if (fx= i (integer-length (most-positive-fixnum)))
                     (g (fx- j 1))
                     (and (p? n i) (f (fx+ i 1)))))))))
     (eqv? (bitwise-copy-bit (ash 1 32) 31 1) (ash 3 31))
     (eqv? (bitwise-copy-bit (ash 1 32) 32 1) (ash 1 32))
     (eqv? (bitwise-copy-bit (ash 1 32) 33 1) (ash 3 32))
     (eqv? (bitwise-copy-bit (ash 1 31) 30 1) (ash 3 30))
     (eqv? (bitwise-copy-bit (ash 1 31) 31 1) (ash 1 31))
     (eqv? (bitwise-copy-bit (ash 1 31) 32 1) (ash 3 31))
     (eqv? (bitwise-copy-bit (ash 1 64) 63 1) (ash 3 63))
     (eqv? (bitwise-copy-bit (ash 1 64) 64 1) (ash 1 64))
     (eqv? (bitwise-copy-bit (ash 1 64) 65 1) (ash 3 64))
     (eqv? (bitwise-copy-bit (ash 1 63) 62 1) (ash 3 62))
     (eqv? (bitwise-copy-bit (ash 1 63) 63 1) (ash 1 63))
     (eqv? (bitwise-copy-bit (ash 1 63) 64 1) (ash 3 63))
     (eqv? (bitwise-copy-bit (ash 1 256) 255 1) (ash 3 255))
     (eqv? (bitwise-copy-bit (ash 1 256) 256 1) (ash 1 256))
     (eqv? (bitwise-copy-bit (ash 1 256) 257 1) (ash 3 256))
     (eqv? (bitwise-copy-bit (ash 1 255) 254 1) (ash 3 254))
     (eqv? (bitwise-copy-bit (ash 1 255) 255 1) (ash 1 255))
     (eqv? (bitwise-copy-bit (ash 1 255) 256 1) (ash 3 255))
     (eqv? (bitwise-copy-bit #x-32b225d27f49c1fed301b89103 0 1)
           #x-32b225d27f49c1fed301b89103)
     (eqv? (bitwise-copy-bit #x-32b225d27f49c1fed301b89103 1 1)
           #x-32b225d27f49c1fed301b89101)
     (eqv? (bitwise-copy-bit #x-32b225d27f49c1fed301b89103 2 1)
           #x-32b225d27f49c1fed301b89103)
     (eqv? (bitwise-copy-bit #x-32b225d27f49c1fed301b89103 31 1)
           #x-32b225d27f49c1fed301b89103)
     (eqv? (bitwise-copy-bit #x-32b225d27f49c1fed301b89103 32 1)
           #x-32b225d27f49c1fed201b89103)
     (eqv? (bitwise-copy-bit #x-32b225d27f49c1fed301b89103 63 1)
           #x-32b225d27f49c1fed301b89103)
     (eqv? (bitwise-copy-bit #x-32b225d27f49c1fed301b89103 64 1)
           #x-32b225d27e49c1fed301b89103)
     (eqv? (bitwise-copy-bit #x-32b225d27f49c1fed301b89103 99 1)
           #x-32b225d27f49c1fed301b89103)
     (eqv? (bitwise-copy-bit #x-32b225d27f49c1fed301b89103 100 1)
           #x-22b225d27f49c1fed301b89103)
     (eqv? (bitwise-copy-bit #x-32b225d27f49c1fed301b89103 101 1)
           #x-12b225d27f49c1fed301b89103)
     (eqv? (bitwise-copy-bit #x-32b225d27f49c1fed301b89103 102 1)
           #x-32b225d27f49c1fed301b89103)
     (eqv? (bitwise-copy-bit #x-32b225d27f49c1fed301b89103 103 1)
           #x-32b225d27f49c1fed301b89103)
     (eqv? (bitwise-copy-bit #x-32b225d27f49c1fed301b89103 104 1)
           #x-32b225d27f49c1fed301b89103)
     (eqv? (bitwise-copy-bit #x-32b225d27f49c1fed301b89103 1000 1)
           #x-32b225d27f49c1fed301b89103)
     (eqv? (bitwise-copy-bit #x-cd4dda2d80b63e012cfe476efd 0 1)
           #x-cd4dda2d80b63e012cfe476efd)
     (eqv? (bitwise-copy-bit #x-cd4dda2d80b63e012cfe476efd 1 1)
           #x-cd4dda2d80b63e012cfe476efd)
     (eqv? (bitwise-copy-bit #x-cd4dda2d80b63e012cfe476efd 2 1)
           #x-cd4dda2d80b63e012cfe476ef9)
     (eqv? (bitwise-copy-bit #x-cd4dda2d80b63e012cfe476efd 31 1)
           #x-cd4dda2d80b63e012c7e476efd)
     (eqv? (bitwise-copy-bit #x-cd4dda2d80b63e012cfe476efd 32 1)
           #x-cd4dda2d80b63e012cfe476efd)
     (eqv? (bitwise-copy-bit #x-cd4dda2d80b63e012cfe476efd 63 1)
           #x-cd4dda2d80363e012cfe476efd)
     (eqv? (bitwise-copy-bit #x-cd4dda2d80b63e012cfe476efd 64 1)
           #x-cd4dda2d80b63e012cfe476efd)
     (eqv? (bitwise-copy-bit #x-cd4dda2d80b63e012cfe476efd 99 1)
           #x-c54dda2d80b63e012cfe476efd)
     (eqv? (bitwise-copy-bit #x-cd4dda2d80b63e012cfe476efd 100 1)
           #x-cd4dda2d80b63e012cfe476efd)
     (eqv? (bitwise-copy-bit #x-cd4dda2d80b63e012cfe476efd 101 1)
           #x-cd4dda2d80b63e012cfe476efd)
     (eqv? (bitwise-copy-bit #x-cd4dda2d80b63e012cfe476efd 102 1)
           #x-8d4dda2d80b63e012cfe476efd)
     (eqv? (bitwise-copy-bit #x-cd4dda2d80b63e012cfe476efd 103 1)
           #x-4d4dda2d80b63e012cfe476efd)
     (eqv? (bitwise-copy-bit #x-cd4dda2d80b63e012cfe476efd 104 1)
           #x-cd4dda2d80b63e012cfe476efd)
     (eqv? (bitwise-copy-bit #x-cd4dda2d80b63e012cfe476efd 1000 1)
           #x-cd4dda2d80b63e012cfe476efd)
     (andmap values
       (let ([p? (lambda (i) (= (bitwise-copy-bit 0 i 1) (ash 1 i)))])
         (let f ([i 0])
           (if (fx= i 1000) '() (cons (p? i) (f (fx+ i 1)))))))
     (let ([p? (lambda (n i)
                 (= (bitwise-copy-bit n i 1) (logor (ash 1 i) n)))])
       (let g ([j 1000])
         (or (fx= j 0)
             (let ([n (+ (random (+ (- (ash (most-positive-fixnum) 5)
                                       (ash (most-negative-fixnum) 5))
                                    1))
                         (ash (most-negative-fixnum) 5))])
               (let f ([i 0])
                 (if (fx= i
                          (* (integer-length (ash (most-negative-fixnum) 5))
                             2))
                     (g (fx- j 1))
                     (and (p? n i) (f (fx+ i 1))))))))))


(mat real->flonum
     (error? (real->flonum))
     (error? (real->flonum 3 4))
     (error? (real->flonum 'a))
     (error? (real->flonum 3+4i))
     (= (real->flonum (most-positive-fixnum))
        (* (most-positive-fixnum) 1.0))
     (= (real->flonum (+ (most-positive-fixnum) 1))
        (+ (most-positive-fixnum) 1.0))
     (= (real->flonum #e1e10000) +inf.0)
     (= (real->flonum #e-1e10000) -inf.0)
     (= (real->flonum 0) 0.0)
     (= (real->flonum 1) 1.0)
     (= (real->flonum -1) -1.0)
     (= (real->flonum 4.5) 4.5)
     (= (real->flonum 3/4) .75)
     (= (real->flonum -3/4) -.75)
     (= (real->flonum -3/4) -.75))

(mat div-and-mod
     ; div-and-mod
     (error? (div-and-mod 3 0))
     (error? (div-and-mod (+ (most-positive-fixnum) 1) 0))
     (error? (div-and-mod 3/5 0))
     (error? (div-and-mod 'a 17))
     (error? (div-and-mod 17 '(a)))
     ; div
     (error? (div 3 0))
     (error? (div (+ (most-positive-fixnum) 1) 0))
     (error? (div 3/5 0))
     (error? (div 'a 17))
     (error? (div 17 '(a)))
     ; mod
     (error? (mod 3 0))
     (error? (mod (+ (most-positive-fixnum) 1) 0))
     (error? (mod 3/5 0))
     (error? (mod 'a 17))
     (error? (mod 17 '(a)))
     ; div-and-mod
     (begin
       (define $d&m div-and-mod)
       (define ($dmpair x y)
         (if (and (eq? y 0) (exact? x))
             #f
             (call-with-values (lambda () ($d&m x y)) cons)))
       (define ($dmpairs x y)
         (list ($dmpair x y)
               ($dmpair (- x) y)
               ($dmpair x (- y))
               ($dmpair (- x) (- y))
               ($dmpair y x)
               ($dmpair (- y) x)
               ($dmpair y (- x))
               ($dmpair (- y) (- x))))
       (define ($dmequal? x y)
         (cond
           [(pair? x)
            (and (pair? y)
                 ($dmequal? (car x) (car y))
                 ($dmequal? (cdr x) (cdr y)))]
           [(number? x)
            (and (number? y)
                 (if (inexact? x)
                     (and (inexact? y) (== x y))
                     (and (exact? y) (= x y))))]
           [else (eq? x y)]))
       #t)
     ($dmequal? ($dmpairs 0 1)
       '((0 . 0) (0 . 0) (0 . 0) (0 . 0) #f #f #f #f))
     ($dmequal? ($dmpairs 24 8)
       '((3 . 0)
         (-3 . 0)
         (-3 . 0)
         (3 . 0)
         (0 . 8)
         (-1 . 16)
         (0 . 8)
         (1 . 16)))
     ($dmequal? ($dmpairs 0 (expt (most-positive-fixnum) 3))
       '((0 . 0) (0 . 0) (0 . 0) (0 . 0) #f #f #f #f))
     ($dmequal? ($dmpairs 0 1.0)
       '((0.0 . 0.0)
         (0.0 . 0.0)
         (-0.0 . 0.0)
         (-0.0 . 0.0)
         (+inf.0 . +nan.0)
         (-inf.0 . +nan.0)
         (+inf.0 . +nan.0)
         (-inf.0 . +nan.0)))
     ($dmequal? ($dmpairs 0 3/4)
       '((0 . 0) (0 . 0) (0 . 0) (0 . 0) #f #f #f #f))
     ($dmequal? ($dmpairs 0.0 1)
       '((0.0 . 0.0)
         (-0.0 . 0.0)
         (-0.0 . 0.0)
         (0.0 . 0.0)
         (+inf.0 . +nan.0)
         (-inf.0 . +nan.0)
         (-inf.0 . +nan.0)
         (+inf.0 . +nan.0)))
     ($dmequal? ($dmpairs 0.0 (* (most-positive-fixnum) 7))
       '((0.0 . 0.0)
         (-0.0 . 0.0)
         (-0.0 . 0.0)
         (0.0 . 0.0)
         (+inf.0 . +nan.0)
         (-inf.0 . +nan.0)
         (-inf.0 . +nan.0)
         (+inf.0 . +nan.0)))
     ($dmequal? ($dmpairs 0.0 3.5)
       '((0.0 . 0.0)
         (-0.0 . 0.0)
         (-0.0 . 0.0)
         (0.0 . 0.0)
         (+inf.0 . +nan.0)
         (-inf.0 . +nan.0)
         (-inf.0 . +nan.0)
         (+inf.0 . +nan.0)))
     ($dmequal? ($dmpairs 0.0 3/4)
       '((0.0 . 0.0)
         (-0.0 . 0.0)
         (-0.0 . 0.0)
         (0.0 . 0.0)
         (+inf.0 . +nan.0)
         (-inf.0 . +nan.0)
         (-inf.0 . +nan.0)
         (+inf.0 . +nan.0)))
     ($dmequal? ; fixnum, fixnum
       ($dmpairs 3 1000)
       '((0 . 3)
         (-1 . 997)
         (0 . 3)
         (1 . 997)
         (333 . 1)
         (-334 . 2)
         (-333 . 1)
         (334 . 2)))
     ($dmequal? ; fixnum, fixnum overflow case
       ($dmpair (most-negative-fixnum) -1)
       (cons (- (most-negative-fixnum)) 0))
     ($dmequal? ; fixnum, bignum
       ($dmpairs 3 (expt (most-positive-fixnum) 3))
       (case (fixnum-width)
         [(30)
          '((0 . 3)
            (-1 . 154742504045981407517868028)
            (0 . 3)
            (1 . 154742504045981407517868028)
            (51580834681993802505956010 . 1)
            (-51580834681993802505956011 . 2)
            (-51580834681993802505956010 . 1)
            (51580834681993802505956011 . 2))]
         [(61)
          '((0 . 3)
            (-1 . 1532495540865888854370663039795561568366082455163109372)
            (0 . 3)
            (1 . 1532495540865888854370663039795561568366082455163109372)
            (510831846955296284790221013265187189455360818387703125 . 0)
            (-510831846955296284790221013265187189455360818387703125 . 0)
            (-510831846955296284790221013265187189455360818387703125 . 0)
            (510831846955296284790221013265187189455360818387703125 . 0))]
         [else
          (errorf #f "mat does not handle fixnum width")]))
     ($dmequal? ; fixnum, flonum
       ($dmpairs 3 15.5)
       '((0.0 . 3.0)
         (-1.0 . 12.5)
         (-0.0 . 3.0)
         (1.0 . 12.5)
         (5.0 . 0.5)
         (-6.0 . 2.5)
         (-5.0 . 0.5)
         (6.0 . 2.5)))
     ($dmequal? ; fixnum, ratnum
       ($dmpairs 3 32/7)
       '((0 . 3)
         (-1 . 11/7)
         (0 . 3)
         (1 . 11/7)
         (1 . 11/7)
         (-2 . 10/7)
         (-1 . 11/7)
         (2 . 10/7)))
     ($dmequal? ; bignum, flonum
       ($dmpairs (+ (most-positive-fixnum) 16) 0.25)
       (case (fixnum-width)
         [(30)
          '((2147483708.0 . 0.0)
            (-2147483708.0 . 0.0)
            (-2147483708.0 . 0.0)
            (2147483708.0 . 0.0)
            (0.0 . 0.25)
            (-1.0 . 536870926.75)
            (-0.0 . 0.25)
            (1.0 . 536870926.75))]
         [(61)
          '((4.611686018427388e18 . 0.0)
            (-4.611686018427388e18 . 0.0)
            (-4.611686018427388e18 . 0.0)
            (4.611686018427388e18 . 0.0)
            (0.0 . 0.25)
            (-1.0 . 1.152921504606847e18)
            (-0.0 . 0.25)
            (1.0 . 1.152921504606847e18))]
         [else
          (errorf #f "mat does not handle fixnum width")]))
     ($dmequal? ; bignum, ratnum
       ($dmpairs (+ (most-positive-fixnum) 16) 3/11)
       (case (fixnum-width)
         [(30)
          '((1968526732 . 1/11)
            (-1968526733 . 2/11)
            (-1968526732 . 1/11)
            (1968526733 . 2/11)
            (0 . 3/11)
            (-1 . 5905580194/11)
            (0 . 3/11)
            (1 . 5905580194/11))]
         [(61)
          '((4227378850225105633 . 2/11)
            (-4227378850225105634 . 1/11)
            (-4227378850225105633 . 2/11)
            (4227378850225105634 . 1/11)
            (0 . 3/11)
            (-1 . 12682136550675316898/11)
            (0 . 3/11)
            (1 . 12682136550675316898/11))]
         [else
          (errorf #f "mat does not handle fixnum width")]))
     ($dmequal? ; flonum, flonum
       ($dmpairs 3.5 11.25)
       '((0.0 . 3.5)
         (-1.0 . 7.75)
         (-0.0 . 3.5)
         (1.0 . 7.75)
         (3.0 . 0.75)
         (-4.0 . 2.75)
         (-3.0 . 0.75)
         (4.0 . 2.75)))
     ($dmequal? ; flonum, ratnum
       ($dmpairs 3.5 23/2)
       '((0.0 . 3.5)
         (-1.0 . 8.0)
         (-0.0 . 3.5)
         (1.0 . 8.0)
         (3.0 . 1.0)
         (-4.0 . 2.5)
         (-3.0 . 1.0)
         (4.0 . 2.5)))
     ($dmequal? ; ratnum, ratnum
       ($dmpairs 3/5 23/7)
       '((0 . 3/5)
         (-1 . 94/35)
         (0 . 3/5)
         (1 . 94/35)
         (5 . 2/7)
         (-6 . 11/35)
         (-5 . 2/7)
         (6 . 11/35)))
     ; div with mod
     (begin
       (set! $d&m
         (lambda (x y) (values (div x y) (mod x y))))
       #t)
     ($dmequal? ($dmpairs 0 1)
       '((0 . 0) (0 . 0) (0 . 0) (0 . 0) #f #f #f #f))
     ($dmequal? ($dmpairs 24 8)
       '((3 . 0)
         (-3 . 0)
         (-3 . 0)
         (3 . 0)
         (0 . 8)
         (-1 . 16)
         (0 . 8)
         (1 . 16)))
     ($dmequal? ($dmpairs 0 (expt (most-positive-fixnum) 3))
       '((0 . 0) (0 . 0) (0 . 0) (0 . 0) #f #f #f #f))
     ($dmequal? ($dmpairs 0 1.0)
       '((0.0 . 0.0)
         (0.0 . 0.0)
         (-0.0 . 0.0)
         (-0.0 . 0.0)
         (+inf.0 . +nan.0)
         (-inf.0 . +nan.0)
         (+inf.0 . +nan.0)
         (-inf.0 . +nan.0)))
     ($dmequal? ($dmpairs 0 3/4)
       '((0 . 0) (0 . 0) (0 . 0) (0 . 0) #f #f #f #f))
     ($dmequal? ($dmpairs 0.0 1)
       '((0.0 . 0.0)
         (-0.0 . 0.0)
         (-0.0 . 0.0)
         (0.0 . 0.0)
         (+inf.0 . +nan.0)
         (-inf.0 . +nan.0)
         (-inf.0 . +nan.0)
         (+inf.0 . +nan.0)))
     ($dmequal? ($dmpairs 0.0 (* (most-positive-fixnum) 7))
       '((0.0 . 0.0)
         (-0.0 . 0.0)
         (-0.0 . 0.0)
         (0.0 . 0.0)
         (+inf.0 . +nan.0)
         (-inf.0 . +nan.0)
         (-inf.0 . +nan.0)
         (+inf.0 . +nan.0)))
     ($dmequal? ($dmpairs 0.0 3.5)
       '((0.0 . 0.0)
         (-0.0 . 0.0)
         (-0.0 . 0.0)
         (0.0 . 0.0)
         (+inf.0 . +nan.0)
         (-inf.0 . +nan.0)
         (-inf.0 . +nan.0)
         (+inf.0 . +nan.0)))
     ($dmequal? ($dmpairs 0.0 3/4)
       '((0.0 . 0.0)
         (-0.0 . 0.0)
         (-0.0 . 0.0)
         (0.0 . 0.0)
         (+inf.0 . +nan.0)
         (-inf.0 . +nan.0)
         (-inf.0 . +nan.0)
         (+inf.0 . +nan.0)))
     ($dmequal? ; fixnum, fixnum
       ($dmpairs 3 1000)
       '((0 . 3)
         (-1 . 997)
         (0 . 3)
         (1 . 997)
         (333 . 1)
         (-334 . 2)
         (-333 . 1)
         (334 . 2)))
     ($dmequal? ; fixnum, fixnum overflow case
       ($dmpair (most-negative-fixnum) -1)
       (cons (- (most-negative-fixnum)) 0))
     ($dmequal? ; fixnum, bignum
       ($dmpairs 3 (expt (most-positive-fixnum) 3))
       (case (fixnum-width)
         [(30)
          '((0 . 3)
            (-1 . 154742504045981407517868028)
            (0 . 3)
            (1 . 154742504045981407517868028)
            (51580834681993802505956010 . 1)
            (-51580834681993802505956011 . 2)
            (-51580834681993802505956010 . 1)
            (51580834681993802505956011 . 2))]
         [(61)
          '((0 . 3)
            (-1 . 1532495540865888854370663039795561568366082455163109372)
            (0 . 3)
            (1 . 1532495540865888854370663039795561568366082455163109372)
            (510831846955296284790221013265187189455360818387703125 . 0)
            (-510831846955296284790221013265187189455360818387703125 . 0)
            (-510831846955296284790221013265187189455360818387703125 . 0)
            (510831846955296284790221013265187189455360818387703125 . 0))]
         [else
          (errorf #f "mat does not handle fixnum width")]))
     ($dmequal? ; fixnum, flonum
       ($dmpairs 3 15.5)
       '((0.0 . 3.0)
         (-1.0 . 12.5)
         (-0.0 . 3.0)
         (1.0 . 12.5)
         (5.0 . 0.5)
         (-6.0 . 2.5)
         (-5.0 . 0.5)
         (6.0 . 2.5)))
     ($dmequal? ; fixnum, ratnum
       ($dmpairs 3 32/7)
       '((0 . 3)
         (-1 . 11/7)
         (0 . 3)
         (1 . 11/7)
         (1 . 11/7)
         (-2 . 10/7)
         (-1 . 11/7)
         (2 . 10/7)))
     ($dmequal? ; bignum, flonum
       ($dmpairs (+ (most-positive-fixnum) 16) 0.25)
       (case (fixnum-width)
         [(30)
          '((2147483708.0 . 0.0)
            (-2147483708.0 . 0.0)
            (-2147483708.0 . 0.0)
            (2147483708.0 . 0.0)
            (0.0 . 0.25)
            (-1.0 . 536870926.75)
            (-0.0 . 0.25)
            (1.0 . 536870926.75))]
         [(61)
          '((4.611686018427388e18 . 0.0)
            (-4.611686018427388e18 . 0.0)
            (-4.611686018427388e18 . 0.0)
            (4.611686018427388e18 . 0.0)
            (0.0 . 0.25)
            (-1.0 . 1.152921504606847e18)
            (-0.0 . 0.25)
            (1.0 . 1.152921504606847e18))]
         [else
          (errorf #f "mat does not handle fixnum width")]))
     ($dmequal? ; bignum, ratnum
       ($dmpairs (+ (most-positive-fixnum) 16) 3/11)
       (case (fixnum-width)
         [(30)
          '((1968526732 . 1/11)
            (-1968526733 . 2/11)
            (-1968526732 . 1/11)
            (1968526733 . 2/11)
            (0 . 3/11)
            (-1 . 5905580194/11)
            (0 . 3/11)
            (1 . 5905580194/11))]
         [(61)
          '((4227378850225105633 . 2/11)
            (-4227378850225105634 . 1/11)
            (-4227378850225105633 . 2/11)
            (4227378850225105634 . 1/11)
            (0 . 3/11)
            (-1 . 12682136550675316898/11)
            (0 . 3/11)
            (1 . 12682136550675316898/11))]
         [else
          (errorf #f "mat does not handle fixnum width")]))
     ($dmequal? ; flonum, flonum
       ($dmpairs 3.5 11.25)
       '((0.0 . 3.5)
         (-1.0 . 7.75)
         (-0.0 . 3.5)
         (1.0 . 7.75)
         (3.0 . 0.75)
         (-4.0 . 2.75)
         (-3.0 . 0.75)
         (4.0 . 2.75)))
     ($dmequal? ; flonum, ratnum
       ($dmpairs 3.5 23/2)
       '((0.0 . 3.5)
         (-1.0 . 8.0)
         (-0.0 . 3.5)
         (1.0 . 8.0)
         (3.0 . 1.0)
         (-4.0 . 2.5)
         (-3.0 . 1.0)
         (4.0 . 2.5)))
     ($dmequal? ; ratnum, ratnum
       ($dmpairs 3/5 23/7)
       '((0 . 3/5)
         (-1 . 94/35)
         (0 . 3/5)
         (1 . 94/35)
         (5 . 2/7)
         (-6 . 11/35)
         (-5 . 2/7)
         (6 . 11/35))))

(mat div0-and-mod0
     ; div0-and-mod0
     (error? (div0-and-mod0 3 0))
     (error? (div0-and-mod0 (+ (most-positive-fixnum) 1) 0))
     (error? (div0-and-mod0 3/5 0))
     (error? (div0-and-mod0 'a 17))
     (error? (div0-and-mod0 17 '(a)))
     ; div0
     (error? (div0 3 0))
     (error? (div0 (+ (most-positive-fixnum) 1) 0))
     (error? (div0 3/5 0))
     (error? (div0 'a 17))
     (error? (div0 17 '(a)))
     ; mod0
     (error? (mod0 3 0))
     (error? (mod0 (+ (most-positive-fixnum) 1) 0))
     (error? (mod0 3/5 0))
     (error? (mod0 'a 17))
     (error? (mod0 17 '(a)))
     ; div0-and-mod0
     (begin
       (define $d&m div0-and-mod0)
       (define ($dmpair x y)
         (if (and (eq? y 0) (exact? x))
             #f
             (call-with-values (lambda () ($d&m x y)) cons)))
       (define ($dmpairs x y)
         (list ($dmpair x y)
               ($dmpair (- x) y)
               ($dmpair x (- y))
               ($dmpair (- x) (- y))
               ($dmpair y x)
               ($dmpair (- y) x)
               ($dmpair y (- x))
               ($dmpair (- y) (- x))))
       #t)
     ($dmequal? ($dmpairs 0 1)
       '((0 . 0) (0 . 0) (0 . 0) (0 . 0) #f #f #f #f))
     ($dmequal? ($dmpairs 0 (expt (most-positive-fixnum) 3))
       '((0 . 0) (0 . 0) (0 . 0) (0 . 0) #f #f #f #f))
     ($dmequal? ($dmpairs 0 1.0)
       '((0.0 . 0.0)
         (0.0 . 0.0)
         (-0.0 . 0.0)
         (-0.0 . 0.0)
         (+inf.0 . +nan.0)
         (-inf.0 . +nan.0)
         (+inf.0 . +nan.0)
         (-inf.0 . +nan.0)))
     ($dmequal? ($dmpairs 0 3/4)
       '((0 . 0) (0 . 0) (0 . 0) (0 . 0) #f #f #f #f))
     ($dmequal? ($dmpairs 0.0 1)
       '((0.0 . 0.0)
         (-0.0 . 0.0)
         (-0.0 . 0.0)
         (0.0 . 0.0)
         (+inf.0 . +nan.0)
         (-inf.0 . +nan.0)
         (-inf.0 . +nan.0)
         (+inf.0 . +nan.0)))
     ($dmequal? ($dmpairs 0.0 (* (most-positive-fixnum) 7))
       '((0.0 . 0.0)
         (-0.0 . 0.0)
         (-0.0 . 0.0)
         (0.0 . 0.0)
         (+inf.0 . +nan.0)
         (-inf.0 . +nan.0)
         (-inf.0 . +nan.0)
         (+inf.0 . +nan.0)))
     ($dmequal? ($dmpairs 0.0 3.5)
       '((0.0 . 0.0)
         (-0.0 . 0.0)
         (-0.0 . 0.0)
         (0.0 . 0.0)
         (+inf.0 . +nan.0)
         (-inf.0 . +nan.0)
         (-inf.0 . +nan.0)
         (+inf.0 . +nan.0)))
     ($dmequal? ($dmpairs 0.0 3/4)
       '((0.0 . 0.0)
         (-0.0 . 0.0)
         (-0.0 . 0.0)
         (0.0 . 0.0)
         (+inf.0 . +nan.0)
         (-inf.0 . +nan.0)
         (-inf.0 . +nan.0)
         (+inf.0 . +nan.0)))
     ($dmequal? ; fixnum, fixnum
       ($dmpairs 3 1000)
       '((0 . 3)
         (0 . -3)
         (0 . 3)
         (0 . -3)
         (333 . 1)
         (-333 . -1)
         (-333 . 1)
         (333 . -1)))
     ($dmequal? ; fixnum, fixnum overflow case
       ($dmpair (most-negative-fixnum) -1)
       (cons (- (most-negative-fixnum)) 0))
     ($dmequal? ; fixnum, bignum
       ($dmpairs 3 (expt (most-positive-fixnum) 3))
       (case (fixnum-width)
         [(30)
          '((0 . 3)
            (0 . -3)
            (0 . 3)
            (0 . -3)
            (51580834681993802505956010 . 1)
            (-51580834681993802505956010 . -1)
            (-51580834681993802505956010 . 1)
            (51580834681993802505956010 . -1))]
         [(61)
          '((0 . 3)
            (0 . -3)
            (0 . 3)
            (0 . -3)
            (510831846955296284790221013265187189455360818387703125 . 0)
            (-510831846955296284790221013265187189455360818387703125 . 0)
            (-510831846955296284790221013265187189455360818387703125 . 0)
            (510831846955296284790221013265187189455360818387703125 . 0))]
         [else
          (errorf #f "mat does not handle fixnum width")]))
     ($dmequal? ; fixnum, flonum
       ($dmpairs 3 15.5)
       '((0.0 . 3.0)
         (0.0 . -3.0)
         (-0.0 . 3.0)
         (0.0 . -3.0)
         (5.0 . 0.5)
         (-5.0 . -0.5)
         (-5.0 . 0.5)
         (5.0 . -0.5)))
     ($dmequal? ; fixnum, ratnum
       ($dmpairs 3 32/7)
       '((1 . -11/7)
         (-1 . 11/7)
         (-1 . -11/7)
         (1 . 11/7)
         (2 . -10/7)
         (-2 . 10/7)
         (-2 . -10/7)
         (2 . 10/7)))
     ($dmequal? ; bignum, flonum
       ($dmpairs (+ (most-positive-fixnum) 16) 0.25)
       (case (fixnum-width)
         [(30)
          '((2147483708.0 . 0.0)
            (-2147483708.0 . 0.0)
            (-2147483708.0 . 0.0)
            (2147483708.0 . 0.0)
            (0.0 . 0.25)
            (0.0 . -0.25)
            (-0.0 . 0.25)
            (0.0 . -0.25))]
         [(61)
          '((4.611686018427388e18 . 0.0)
            (-4.611686018427388e18 . 0.0)
            (-4.611686018427388e18 . 0.0)
            (4.611686018427388e18 . 0.0)
            (0.0 . 0.25)
            (0.0 . 0.0)
            (-0.0 . 0.25)
            (0.0 . 0.0))]
         [else
          (errorf #f "mat does not handle fixnum width")]))
     ($dmequal? ; bignum, ratnum
       ($dmpairs (+ (most-positive-fixnum) 16) 3/11)
       (case (fixnum-width)
         [(30)
          '((1968526732 . 1/11)
            (-1968526732 . -1/11)
            (-1968526732 . 1/11)
            (1968526732 . -1/11)
            (0 . 3/11)
            (0 . -3/11)
            (0 . 3/11)
            (0 . -3/11))]
         [(61)
          '((4227378850225105634 . -1/11)
            (-4227378850225105634 . 1/11)
            (-4227378850225105634 . -1/11)
            (4227378850225105634 . 1/11)
            (0 . 3/11)
            (0 . -3/11)
            (0 . 3/11)
            (0 . -3/11))]
         [else
          (errorf #f "mat does not handle fixnum width")]))
     ($dmequal? ; flonum, flonum
       ($dmpairs 3.5 11.25)
       '((0.0 . 3.5)
         (0.0 . -3.5)
         (-0.0 . 3.5)
         (0.0 . -3.5)
         (3.0 . 0.75)
         (-3.0 . -0.75)
         (-3.0 . 0.75)
         (3.0 . -0.75)))
     ($dmequal? ; flonum, ratnum
       ($dmpairs 3.5 23/2)
       '((0.0 . 3.5)
         (0.0 . -3.5)
         (-0.0 . 3.5)
         (0.0 . -3.5)
         (3.0 . 1.0)
         (-3.0 . -1.0)
         (-3.0 . 1.0)
         (3.0 . -1.0)))
     ($dmequal? ; ratnum, ratnum
       ($dmpairs 3/5 23/7)
       '((0 . 3/5)
         (0 . -3/5)
         (0 . 3/5)
         (0 . -3/5)
         (5 . 2/7)
         (-5 . -2/7)
         (-5 . 2/7)
         (5 . -2/7)))
     ; div0 with mod0
     (begin
       (set! $d&m
         (lambda (x y) (values (div0 x y) (mod0 x y))))
       #t)
     ($dmequal? ($dmpairs 0 1)
       '((0 . 0) (0 . 0) (0 . 0) (0 . 0) #f #f #f #f))
     ($dmequal? ($dmpairs 0 (expt (most-positive-fixnum) 3))
       '((0 . 0) (0 . 0) (0 . 0) (0 . 0) #f #f #f #f))
     ($dmequal? ($dmpairs 0 1.0)
       '((0.0 . 0.0)
         (0.0 . 0.0)
         (-0.0 . 0.0)
         (-0.0 . 0.0)
         (+inf.0 . +nan.0)
         (-inf.0 . +nan.0)
         (+inf.0 . +nan.0)
         (-inf.0 . +nan.0)))
     ($dmequal? ($dmpairs 0 3/4)
       '((0 . 0) (0 . 0) (0 . 0) (0 . 0) #f #f #f #f))
     ($dmequal? ($dmpairs 0.0 1)
       '((0.0 . 0.0)
         (-0.0 . 0.0)
         (-0.0 . 0.0)
         (0.0 . 0.0)
         (+inf.0 . +nan.0)
         (-inf.0 . +nan.0)
         (-inf.0 . +nan.0)
         (+inf.0 . +nan.0)))
     ($dmequal? ($dmpairs 0.0 (* (most-positive-fixnum) 7))
       '((0.0 . 0.0)
         (-0.0 . 0.0)
         (-0.0 . 0.0)
         (0.0 . 0.0)
         (+inf.0 . +nan.0)
         (-inf.0 . +nan.0)
         (-inf.0 . +nan.0)
         (+inf.0 . +nan.0)))
     ($dmequal? ($dmpairs 0.0 3.5)
       '((0.0 . 0.0)
         (-0.0 . 0.0)
         (-0.0 . 0.0)
         (0.0 . 0.0)
         (+inf.0 . +nan.0)
         (-inf.0 . +nan.0)
         (-inf.0 . +nan.0)
         (+inf.0 . +nan.0)))
     ($dmequal? ($dmpairs 0.0 3/4)
       '((0.0 . 0.0)
         (-0.0 . 0.0)
         (-0.0 . 0.0)
         (0.0 . 0.0)
         (+inf.0 . +nan.0)
         (-inf.0 . +nan.0)
         (-inf.0 . +nan.0)
         (+inf.0 . +nan.0)))
     ($dmequal? ; fixnum, fixnum
       ($dmpairs 3 1000)
       '((0 . 3)
         (0 . -3)
         (0 . 3)
         (0 . -3)
         (333 . 1)
         (-333 . -1)
         (-333 . 1)
         (333 . -1)))
     ($dmequal? ; fixnum, fixnum overflow case
       ($dmpair (most-negative-fixnum) -1)
       (cons (- (most-negative-fixnum)) 0))
     ($dmequal? ; fixnum, bignum
       ($dmpairs 3 (expt (most-positive-fixnum) 3))
       (case (fixnum-width)
         [(30)
          '((0 . 3)
            (0 . -3)
            (0 . 3)
            (0 . -3)
            (51580834681993802505956010 . 1)
            (-51580834681993802505956010 . -1)
            (-51580834681993802505956010 . 1)
            (51580834681993802505956010 . -1))]
         [(61)
          '((0 . 3)
            (0 . -3)
            (0 . 3)
            (0 . -3)
            (510831846955296284790221013265187189455360818387703125 . 0)
            (-510831846955296284790221013265187189455360818387703125 . 0)
            (-510831846955296284790221013265187189455360818387703125 . 0)
            (510831846955296284790221013265187189455360818387703125 . 0))]
         [else
          (errorf #f "mat does not handle fixnum width")]))
     ($dmequal? ; fixnum, flonum
       ($dmpairs 3 15.5)
       '((0.0 . 3.0)
         (0.0 . -3.0)
         (-0.0 . 3.0)
         (0.0 . -3.0)
         (5.0 . 0.5)
         (-5.0 . -0.5)
         (-5.0 . 0.5)
         (5.0 . -0.5)))
     ($dmequal? ; fixnum, ratnum
       ($dmpairs 3 32/7)
       '((1 . -11/7)
         (-1 . 11/7)
         (-1 . -11/7)
         (1 . 11/7)
         (2 . -10/7)
         (-2 . 10/7)
         (-2 . -10/7)
         (2 . 10/7)))
     ($dmequal? ; bignum, flonum
       ($dmpairs (+ (most-positive-fixnum) 16) 0.25)
       (case (fixnum-width)
         [(30)
          '((2147483708.0 . 0.0)
            (-2147483708.0 . 0.0)
            (-2147483708.0 . 0.0)
            (2147483708.0 . 0.0)
            (0.0 . 0.25)
            (0.0 . -0.25)
            (-0.0 . 0.25)
            (0.0 . -0.25))]
         [(61)
          '((4.611686018427388e18 . 0.0)
            (-4.611686018427388e18 . 0.0)
            (-4.611686018427388e18 . 0.0)
            (4.611686018427388e18 . 0.0)
            (0.0 . 0.25)
            (0.0 . 0.0)
            (-0.0 . 0.25)
            (0.0 . 0.0))]
         [else
          (errorf #f "mat does not handle fixnum width")]))
     ($dmequal? ; bignum, ratnum
       ($dmpairs (+ (most-positive-fixnum) 16) 3/11)
       (case (fixnum-width)
         [(30)
          '((1968526732 . 1/11)
            (-1968526732 . -1/11)
            (-1968526732 . 1/11)
            (1968526732 . -1/11)
            (0 . 3/11)
            (0 . -3/11)
            (0 . 3/11)
            (0 . -3/11))]
         [(61)
          '((4227378850225105634 . -1/11)
            (-4227378850225105634 . 1/11)
            (-4227378850225105634 . -1/11)
            (4227378850225105634 . 1/11)
            (0 . 3/11)
            (0 . -3/11)
            (0 . 3/11)
            (0 . -3/11))]
         [else
          (errorf #f "mat does not handle fixnum width")]))
     ($dmequal? ; flonum, flonum
       ($dmpairs 3.5 11.25)
       '((0.0 . 3.5)
         (0.0 . -3.5)
         (-0.0 . 3.5)
         (0.0 . -3.5)
         (3.0 . 0.75)
         (-3.0 . -0.75)
         (-3.0 . 0.75)
         (3.0 . -0.75)))
     ($dmequal? ; flonum, ratnum
       ($dmpairs 3.5 23/2)
       '((0.0 . 3.5)
         (0.0 . -3.5)
         (-0.0 . 3.5)
         (0.0 . -3.5)
         (3.0 . 1.0)
         (-3.0 . -1.0)
         (-3.0 . 1.0)
         (3.0 . -1.0)))
     ($dmequal? ; ratnum, ratnum
       ($dmpairs 3/5 23/7)
       '((0 . 3/5)
         (0 . -3/5)
         (0 . 3/5)
         (0 . -3/5)
         (5 . 2/7)
         (-5 . -2/7)
         (-5 . 2/7)
         (5 . -2/7))))
;;; 5-4.ms
;;; Copyright 1984-2017 Cisco Systems, Inc.
;;; 
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;; 
;;; http://www.apache.org/licenses/LICENSE-2.0
;;; 
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

(mat char=?/char-ci=?
     (error? (char=?))
     (error? (char=? 'a))
     (error? (char=? #\a 'a))
     (error? (char=? #\a 'a #\b))
     (error? (char=? 'a #\b #\a))
     (error? (char=? #\a #\c 'a #\b))
     (error? (char-ci=?))
     (error? (char-ci=? 'a))
     (error? (char-ci=? #\a 'a))
     (error? (char-ci=? #\a 'a #\b))
     (error? (char-ci=? 'a #\b #\a))
     (error? (char-ci=? #\a #\c 'a #\b))
     (char=? #\a #\a)
     (char-ci=? #\a #\a)
     (not (char=? #\a #\b))
     (not (char-ci=? #\a #\b))
     (not (char=? #\b #\a))
     (not (char-ci=? #\b #\a))
     (not (char=? #\a #\A))
     (char-ci=? #\a #\A)
     (char=? #\a)
     (char=? #\a #\a #\a #\a)
     (not (char=? #\a #\b #\c #\d))
     (not (char=? #\z #\t #\m #\d))
     (not (char=? #\a #\t #\m #\d))
     (not (char=? #\a #\A #\a #\A))
     (not (char=? #\a #\B #\C #\d))
     (not (char=? #\Z #\t #\m #\D))
     (char-ci=? #\a)
     (char-ci=? #\a #\a #\a #\a)
     (not (char-ci=? #\a #\b #\c #\d))
     (not (char-ci=? #\z #\t #\m #\d))
     (not (char-ci=? #\a #\t #\m #\d))
     (char-ci=? #\a #\A #\a #\A)
     (not (char-ci=? #\a #\B #\C #\d))
     (not (char-ci=? #\Z #\t #\m #\D))
     (guard (c [#t #t]) (char=? #\3 #\4 (error #f "oops")))
     (guard (c [#t #t]) (char=? #\3 (error #f "oops") #\4))
     (guard (c [#t #t]) (char=? (error #f "oops") #\3 #\4))
     (guard (c [#t #t]) (not (char=? (error #f "oops"))))
     (guard (c [#t #t]) (char-ci=? #\3 #\4 (error #f "oops")))
     (guard (c [#t #t]) (char-ci=? #\3 (error #f "oops") #\4))
     (guard (c [#t #t]) (char-ci=? (error #f "oops") #\3 #\4))
     (guard (c [#t #t]) (not (char-ci=? (error #f "oops")))))

(mat char<?/char-ci<?
     (error? (char<?))
     (error? (char<? 'a))
     (error? (char<? #\a 'a))
     (error? (char<? #\a 'a #\b))
     (error? (char<? 'a #\b #\a))
     (error? (char<? #\a #\c 'a #\b))
     (error? (char-ci<?))
     (error? (char-ci<? 'a))
     (error? (char-ci<? #\a 'a))
     (error? (char-ci<? #\a 'a #\b))
     (error? (char-ci<? 'a #\b #\a))
     (error? (char-ci<? #\a #\c 'a #\b))
     (not (char<? #\a #\a))
     (not (char-ci<? #\a #\a))
     (char<? #\a #\b)
     (char-ci<? #\a #\b)
     (not (char<? #\b #\a))
     (not (char-ci<? #\b #\a))
     (char<? #\A #\a)
     (not (char-ci<? #\A #\a))
     (char<? #\a)
     (not (char<? #\a #\a #\a #\a))
     (char<? #\a #\b #\c #\d)
     (not (char<? #\z #\t #\m #\d))
     (not (char<? #\a #\t #\m #\d))
     (not (char<? #\a #\A #\a #\A))
     (not (char<? #\a #\B #\C #\d))
     (not (char<? #\Z #\t #\m #\D))
     (char-ci<? #\a)
     (not (char-ci<? #\a #\a #\a #\a))
     (char-ci<? #\a #\b #\c #\d)
     (not (char-ci<? #\z #\t #\m #\d))
     (not (char-ci<? #\a #\t #\m #\d))
     (not (char-ci<? #\a #\A #\a #\A))
     (char-ci<? #\a #\B #\C #\d)
     (not (char-ci<? #\Z #\t #\m #\D))
     (guard (c [#t #t]) (char<? #\4 #\3 (error #f "oops")))
     (guard (c [#t #t]) (char<? #\4 (error #f "oops") #\3))
     (guard (c [#t #t]) (char<? (error #f "oops") #\4 #\3))
     (guard (c [#t #t]) (not (char<? (error #f "oops"))))
     (guard (c [#t #t]) (char-ci<? #\4 #\3 (error #f "oops")))
     (guard (c [#t #t]) (char-ci<? #\4 (error #f "oops") #\3))
     (guard (c [#t #t]) (char-ci<? (error #f "oops") #\4 #\3))
     (guard (c [#t #t]) (not (char-ci<? (error #f "oops")))))

(mat char>?/char-ci>?
     (error? (char>?))
     (error? (char>? 'a))
     (error? (char>? #\a 'a))
     (error? (char>? #\a 'a #\b))
     (error? (char>? 'a #\b #\a))
     (error? (char>? #\a #\c 'a #\b))
     (error? (char-ci>?))
     (error? (char-ci>? 'a))
     (error? (char-ci>? #\a 'a))
     (error? (char-ci>? #\a 'a #\b))
     (error? (char-ci>? 'a #\b #\a))
     (error? (char-ci>? #\a #\c 'a #\b))
     (not (char>? #\a #\a))
     (not (char-ci>? #\a #\b))
     (char>? #\b #\a)
     (char-ci>? #\b #\a)
     (char>? #\a #\A)
     (not (char-ci>? #\a #\A))
     (char>? #\a)
     (not (char>? #\a #\a #\a #\a))
     (not (char>? #\a #\b #\c #\d))
     (char>? #\z #\t #\m #\d)
     (not (char>? #\a #\t #\m #\d))
     (not (char>? #\a #\A #\a #\A))
     (not (char>? #\a #\B #\C #\d))
     (not (char>? #\Z #\t #\m #\D))
     (char-ci>? #\a)
     (not (char-ci>? #\a #\a #\a #\a))
     (not (char-ci>? #\a #\b #\c #\d))
     (char-ci>? #\z #\t #\m #\d)
     (not (char-ci>? #\a #\t #\m #\d))
     (not (char-ci>? #\a #\A #\a #\A))
     (not (char-ci>? #\a #\B #\C #\d))
     (char-ci>? #\Z #\t #\m #\D)
     (guard (c [#t #t]) (char>? #\3 #\4 (error #f "oops")))
     (guard (c [#t #t]) (char>? #\3 (error #f "oops") #\4))
     (guard (c [#t #t]) (char>? (error #f "oops") #\3 #\4))
     (guard (c [#t #t]) (not (char>? (error #f "oops"))))
     (guard (c [#t #t]) (char-ci>? #\3 #\4 (error #f "oops")))
     (guard (c [#t #t]) (char-ci>? #\3 (error #f "oops") #\4))
     (guard (c [#t #t]) (char-ci>? (error #f "oops") #\3 #\4))
     (guard (c [#t #t]) (not (char-ci>? (error #f "oops")))))

(mat char<=?/char-ci<=?
     (error? (char<=?))
     (error? (char<=? 'a))
     (error? (char<=? #\a 'a))
     (error? (char<=? #\a 'a #\b))
     (error? (char<=? 'a #\b #\a))
     (error? (char<=? #\a #\c 'a #\b))
     (error? (char-ci<=?))
     (error? (char-ci<=? 'a))
     (error? (char-ci<=? #\a 'a))
     (error? (char-ci<=? #\a 'a #\b))
     (error? (char-ci<=? 'a #\b #\a))
     (error? (char-ci<=? #\a #\c 'a #\b))
     (char<=? #\a #\a)
     (char-ci<=? #\a #\a)
     (char<=? #\a #\b)
     (char-ci<=? #\a #\b)
     (not (char<=? #\b #\a))
     (not (char-ci<=? #\b #\a))
     (not (char<=? #\a #\A))
     (char-ci<=? #\a #\A)
     (char<=? #\a)
     (char<=? #\a #\a #\a #\a)
     (char<=? #\a #\b #\c #\d)
     (not (char<=? #\z #\t #\m #\d))
     (not (char<=? #\a #\t #\m #\d))
     (not (char<=? #\a #\A #\a #\A))
     (not (char<=? #\a #\B #\C #\d))
     (not (char<=? #\Z #\t #\m #\D))
     (char-ci<=? #\a)
     (char-ci<=? #\a #\a #\a #\a)
     (char-ci<=? #\a #\b #\c #\d)
     (not (char-ci<=? #\z #\t #\m #\d))
     (not (char-ci<=? #\a #\t #\m #\d))
     (char-ci<=? #\a #\A #\a #\A)
     (char-ci<=? #\a #\B #\C #\d)
     (not (char-ci<=? #\Z #\t #\m #\D))
     (guard (c [#t #t]) (char<=? #\4 #\3 (error #f "oops")))
     (guard (c [#t #t]) (char<=? #\4 (error #f "oops") #\3))
     (guard (c [#t #t]) (char<=? (error #f "oops") #\4 #\3))
     (guard (c [#t #t]) (not (char<=? (error #f "oops"))))
     (guard (c [#t #t]) (char-ci<=? #\4 #\3 (error #f "oops")))
     (guard (c [#t #t]) (char-ci<=? #\4 (error #f "oops") #\3))
     (guard (c [#t #t]) (char-ci<=? (error #f "oops") #\4 #\3))
     (guard (c [#t #t]) (not (char-ci<=? (error #f "oops")))))

(mat char>=?/char-ci>=?
     (error? (char>=?))
     (error? (char>=? 'a))
     (error? (char>=? #\a 'a))
     (error? (char>=? #\a 'a #\b))
     (error? (char>=? 'a #\b #\a))
     (error? (char>=? #\a #\c 'a #\b))
     (error? (char-ci>=?))
     (error? (char-ci>=? 'a))
     (error? (char-ci>=? #\a 'a))
     (error? (char-ci>=? #\a 'a #\b))
     (error? (char-ci>=? 'a #\b #\a))
     (error? (char-ci>=? #\a #\c 'a #\b))
     (char>=? #\a #\a)
     (char-ci>=? #\a #\a)
     (not (char>=? #\a #\b))
     (not (char-ci>=? #\a #\b))
     (char>=? #\b #\a)
     (char-ci>=? #\b #\a)
     (not (char>=? #\A #\a))
     (char-ci>=? #\A #\a)
     (char>=? #\a)
     (char>=? #\a #\a #\a #\a)
     (not (char>=? #\a #\b #\c #\d))
     (char>=? #\z #\t #\m #\d)
     (not (char>=? #\a #\t #\m #\d))
     (not (char>=? #\a #\A #\a #\A))
     (not (char>=? #\a #\B #\C #\d))
     (not (char>=? #\Z #\t #\m #\D))
     (char-ci>=? #\a)
     (char-ci>=? #\a #\a #\a #\a)
     (not (char-ci>=? #\a #\b #\c #\d))
     (char-ci>=? #\z #\t #\m #\d)
     (not (char-ci>=? #\a #\t #\m #\d))
     (char-ci>=? #\a #\A #\a #\A)
     (not (char-ci>=? #\a #\B #\C #\d))
     (char-ci>=? #\Z #\t #\m #\D)
     (guard (c [#t #t]) (char>=? #\3 #\4 (error #f "oops")))
     (guard (c [#t #t]) (char>=? #\3 (error #f "oops") #\4))
     (guard (c [#t #t]) (char>=? (error #f "oops") #\3 #\4))
     (guard (c [#t #t]) (not (char>=? (error #f "oops"))))
     (guard (c [#t #t]) (char-ci>=? #\3 #\4 (error #f "oops")))
     (guard (c [#t #t]) (char-ci>=? #\3 (error #f "oops") #\4))
     (guard (c [#t #t]) (char-ci>=? (error #f "oops") #\3 #\4))
     (guard (c [#t #t]) (not (char-ci>=? (error #f "oops")))))

(mat r6rs:char=?/r6rs:char-ci=?
     (error? (r6rs:char=?))
     (error? (r6rs:char=? 'a))
     (error? (r6rs:char=? #\a 'a))
     (error? (r6rs:char=? #\a 'a #\b))
     (error? (r6rs:char=? 'a #\b #\a))
     (error? (r6rs:char=? #\a #\c 'a #\b))
     (error? (r6rs:char-ci=?))
     (error? (r6rs:char-ci=? 'a))
     (error? (r6rs:char-ci=? #\a 'a))
     (error? (r6rs:char-ci=? #\a 'a #\b))
     (error? (r6rs:char-ci=? 'a #\b #\a))
     (error? (r6rs:char-ci=? #\a #\c 'a #\b))
     (r6rs:char=? #\a #\a)
     (r6rs:char-ci=? #\a #\a)
     (not (r6rs:char=? #\a #\b))
     (not (r6rs:char-ci=? #\a #\b))
     (not (r6rs:char=? #\b #\a))
     (not (r6rs:char-ci=? #\b #\a))
     (not (r6rs:char=? #\a #\A))
     (r6rs:char-ci=? #\a #\A)
     (r6rs:char=? #\a #\a #\a #\a)
     (not (r6rs:char=? #\a #\b #\c #\d))
     (not (r6rs:char=? #\z #\t #\m #\d))
     (not (r6rs:char=? #\a #\t #\m #\d))
     (not (r6rs:char=? #\a #\A #\a #\A))
     (not (r6rs:char=? #\a #\B #\C #\d))
     (not (r6rs:char=? #\Z #\t #\m #\D))
     (r6rs:char-ci=? #\a #\a #\a #\a)
     (not (r6rs:char-ci=? #\a #\b #\c #\d))
     (not (r6rs:char-ci=? #\z #\t #\m #\d))
     (not (r6rs:char-ci=? #\a #\t #\m #\d))
     (r6rs:char-ci=? #\a #\A #\a #\A)
     (not (r6rs:char-ci=? #\a #\B #\C #\d))
     (not (r6rs:char-ci=? #\Z #\t #\m #\D))
     (guard (c [#t #t]) (r6rs:char=? #\3 #\4 (error #f "oops")))
     (guard (c [#t #t]) (r6rs:char=? #\3 (error #f "oops") #\4))
     (guard (c [#t #t]) (r6rs:char=? (error #f "oops") #\3 #\4))
     (guard (c [#t #t]) (not (r6rs:char=? (error #f "oops"))))
     (guard (c [#t #t]) (r6rs:char-ci=? #\3 #\4 (error #f "oops")))
     (guard (c [#t #t]) (r6rs:char-ci=? #\3 (error #f "oops") #\4))
     (guard (c [#t #t]) (r6rs:char-ci=? (error #f "oops") #\3 #\4))
     (guard (c [#t #t]) (not (r6rs:char-ci=? (error #f "oops")))))

(mat r6rs:char<?/r6rs:char-ci<?
     (error? (r6rs:char<?))
     (error? (r6rs:char<? 'a))
     (error? (r6rs:char<? #\a 'a))
     (error? (r6rs:char<? #\a 'a #\b))
     (error? (r6rs:char<? 'a #\b #\a))
     (error? (r6rs:char<? #\a #\c 'a #\b))
     (error? (r6rs:char-ci<?))
     (error? (r6rs:char-ci<? 'a))
     (error? (r6rs:char-ci<? #\a 'a))
     (error? (r6rs:char-ci<? #\a 'a #\b))
     (error? (r6rs:char-ci<? 'a #\b #\a))
     (error? (r6rs:char-ci<? #\a #\c 'a #\b))
     (not (r6rs:char<? #\a #\a))
     (not (r6rs:char-ci<? #\a #\a))
     (r6rs:char<? #\a #\b)
     (r6rs:char-ci<? #\a #\b)
     (not (r6rs:char<? #\b #\a))
     (not (r6rs:char-ci<? #\b #\a))
     (r6rs:char<? #\A #\a)
     (not (r6rs:char-ci<? #\A #\a))
     (not (r6rs:char<? #\a #\a #\a #\a))
     (r6rs:char<? #\a #\b #\c #\d)
     (not (r6rs:char<? #\z #\t #\m #\d))
     (not (r6rs:char<? #\a #\t #\m #\d))
     (not (r6rs:char<? #\a #\A #\a #\A))
     (not (r6rs:char<? #\a #\B #\C #\d))
     (not (r6rs:char<? #\Z #\t #\m #\D))
     (not (r6rs:char-ci<? #\a #\a #\a #\a))
     (r6rs:char-ci<? #\a #\b #\c #\d)
     (not (r6rs:char-ci<? #\z #\t #\m #\d))
     (not (r6rs:char-ci<? #\a #\t #\m #\d))
     (not (r6rs:char-ci<? #\a #\A #\a #\A))
     (r6rs:char-ci<? #\a #\B #\C #\d)
     (not (r6rs:char-ci<? #\Z #\t #\m #\D))
     (guard (c [#t #t]) (r6rs:char<? #\4 #\3 (error #f "oops")))
     (guard (c [#t #t]) (r6rs:char<? #\4 (error #f "oops") #\3))
     (guard (c [#t #t]) (r6rs:char<? (error #f "oops") #\4 #\3))
     (guard (c [#t #t]) (not (r6rs:char<? (error #f "oops"))))
     (guard (c [#t #t]) (r6rs:char-ci<? #\4 #\3 (error #f "oops")))
     (guard (c [#t #t]) (r6rs:char-ci<? #\4 (error #f "oops") #\3))
     (guard (c [#t #t]) (r6rs:char-ci<? (error #f "oops") #\4 #\3))
     (guard (c [#t #t]) (not (r6rs:char-ci<? (error #f "oops")))))

(mat r6rs:char>?/r6rs:char-ci>?
     (error? (r6rs:char>?))
     (error? (r6rs:char>? 'a))
     (error? (r6rs:char>? #\a 'a))
     (error? (r6rs:char>? #\a 'a #\b))
     (error? (r6rs:char>? 'a #\b #\a))
     (error? (r6rs:char>? #\a #\c 'a #\b))
     (error? (r6rs:char-ci>?))
     (error? (r6rs:char-ci>? 'a))
     (error? (r6rs:char-ci>? #\a 'a))
     (error? (r6rs:char-ci>? #\a 'a #\b))
     (error? (r6rs:char-ci>? 'a #\b #\a))
     (error? (r6rs:char-ci>? #\a #\c 'a #\b))
     (not (r6rs:char>? #\a #\a))
     (not (r6rs:char-ci>? #\a #\b))
     (r6rs:char>? #\b #\a)
     (r6rs:char-ci>? #\b #\a)
     (r6rs:char>? #\a #\A)
     (not (r6rs:char-ci>? #\a #\A))
     (not (r6rs:char>? #\a #\a #\a #\a))
     (not (r6rs:char>? #\a #\b #\c #\d))
     (r6rs:char>? #\z #\t #\m #\d)
     (not (r6rs:char>? #\a #\t #\m #\d))
     (not (r6rs:char>? #\a #\A #\a #\A))
     (not (r6rs:char>? #\a #\B #\C #\d))
     (not (r6rs:char>? #\Z #\t #\m #\D))
     (not (r6rs:char-ci>? #\a #\a #\a #\a))
     (not (r6rs:char-ci>? #\a #\b #\c #\d))
     (r6rs:char-ci>? #\z #\t #\m #\d)
     (not (r6rs:char-ci>? #\a #\t #\m #\d))
     (not (r6rs:char-ci>? #\a #\A #\a #\A))
     (not (r6rs:char-ci>? #\a #\B #\C #\d))
     (r6rs:char-ci>? #\Z #\t #\m #\D)
     (guard (c [#t #t]) (r6rs:char>? #\3 #\4 (error #f "oops")))
     (guard (c [#t #t]) (r6rs:char>? #\3 (error #f "oops") #\4))
     (guard (c [#t #t]) (r6rs:char>? (error #f "oops") #\3 #\4))
     (guard (c [#t #t]) (not (r6rs:char>? (error #f "oops"))))
     (guard (c [#t #t]) (r6rs:char-ci>? #\3 #\4 (error #f "oops")))
     (guard (c [#t #t]) (r6rs:char-ci>? #\3 (error #f "oops") #\4))
     (guard (c [#t #t]) (r6rs:char-ci>? (error #f "oops") #\3 #\4))
     (guard (c [#t #t]) (not (r6rs:char-ci>? (error #f "oops")))))

(mat r6rs:char<=?/r6rs:char-ci<=?
     (error? (r6rs:char<=?))
     (error? (r6rs:char<=? 'a))
     (error? (r6rs:char<=? #\a 'a))
     (error? (r6rs:char<=? #\a 'a #\b))
     (error? (r6rs:char<=? 'a #\b #\a))
     (error? (r6rs:char<=? #\a #\c 'a #\b))
     (error? (r6rs:char-ci<=?))
     (error? (r6rs:char-ci<=? 'a))
     (error? (r6rs:char-ci<=? #\a 'a))
     (error? (r6rs:char-ci<=? #\a 'a #\b))
     (error? (r6rs:char-ci<=? 'a #\b #\a))
     (error? (r6rs:char-ci<=? #\a #\c 'a #\b))
     (r6rs:char<=? #\a #\a)
     (r6rs:char-ci<=? #\a #\a)
     (r6rs:char<=? #\a #\b)
     (r6rs:char-ci<=? #\a #\b)
     (not (r6rs:char<=? #\b #\a))
     (not (r6rs:char-ci<=? #\b #\a))
     (not (r6rs:char<=? #\a #\A))
     (r6rs:char-ci<=? #\a #\A)
     (r6rs:char<=? #\a #\a #\a #\a)
     (r6rs:char<=? #\a #\b #\c #\d)
     (not (r6rs:char<=? #\z #\t #\m #\d))
     (not (r6rs:char<=? #\a #\t #\m #\d))
     (not (r6rs:char<=? #\a #\A #\a #\A))
     (not (r6rs:char<=? #\a #\B #\C #\d))
     (not (r6rs:char<=? #\Z #\t #\m #\D))
     (r6rs:char-ci<=? #\a #\a #\a #\a)
     (r6rs:char-ci<=? #\a #\b #\c #\d)
     (not (r6rs:char-ci<=? #\z #\t #\m #\d))
     (not (r6rs:char-ci<=? #\a #\t #\m #\d))
     (r6rs:char-ci<=? #\a #\A #\a #\A)
     (r6rs:char-ci<=? #\a #\B #\C #\d)
     (not (r6rs:char-ci<=? #\Z #\t #\m #\D))
     (guard (c [#t #t]) (r6rs:char<=? #\4 #\3 (error #f "oops")))
     (guard (c [#t #t]) (r6rs:char<=? #\4 (error #f "oops") #\3))
     (guard (c [#t #t]) (r6rs:char<=? (error #f "oops") #\4 #\3))
     (guard (c [#t #t]) (not (r6rs:char<=? (error #f "oops"))))
     (guard (c [#t #t]) (r6rs:char-ci<=? #\4 #\3 (error #f "oops")))
     (guard (c [#t #t]) (r6rs:char-ci<=? #\4 (error #f "oops") #\3))
     (guard (c [#t #t]) (r6rs:char-ci<=? (error #f "oops") #\4 #\3))
     (guard (c [#t #t]) (not (r6rs:char-ci<=? (error #f "oops")))))

(mat r6rs:char>=?/r6rs:char-ci>=?
     (error? (r6rs:char>=?))
     (error? (r6rs:char>=? 'a))
     (error? (r6rs:char>=? #\a 'a))
     (error? (r6rs:char>=? #\a 'a #\b))
     (error? (r6rs:char>=? 'a #\b #\a))
     (error? (r6rs:char>=? #\a #\c 'a #\b))
     (error? (r6rs:char-ci>=?))
     (error? (r6rs:char-ci>=? 'a))
     (error? (r6rs:char-ci>=? #\a 'a))
     (error? (r6rs:char-ci>=? #\a 'a #\b))
     (error? (r6rs:char-ci>=? 'a #\b #\a))
     (error? (r6rs:char-ci>=? #\a #\c 'a #\b))
     (r6rs:char>=? #\a #\a)
     (r6rs:char-ci>=? #\a #\a)
     (not (r6rs:char>=? #\a #\b))
     (not (r6rs:char-ci>=? #\a #\b))
     (r6rs:char>=? #\b #\a)
     (r6rs:char-ci>=? #\b #\a)
     (not (r6rs:char>=? #\A #\a))
     (r6rs:char-ci>=? #\A #\a)
     (r6rs:char>=? #\a #\a #\a #\a)
     (not (r6rs:char>=? #\a #\b #\c #\d))
     (r6rs:char>=? #\z #\t #\m #\d)
     (not (r6rs:char>=? #\a #\t #\m #\d))
     (not (r6rs:char>=? #\a #\A #\a #\A))
     (not (r6rs:char>=? #\a #\B #\C #\d))
     (not (r6rs:char>=? #\Z #\t #\m #\D))
     (r6rs:char-ci>=? #\a #\a #\a #\a)
     (not (r6rs:char-ci>=? #\a #\b #\c #\d))
     (r6rs:char-ci>=? #\z #\t #\m #\d)
     (not (r6rs:char-ci>=? #\a #\t #\m #\d))
     (r6rs:char-ci>=? #\a #\A #\a #\A)
     (not (r6rs:char-ci>=? #\a #\B #\C #\d))
     (r6rs:char-ci>=? #\Z #\t #\m #\D)
     (guard (c [#t #t]) (r6rs:char>=? #\3 #\4 (error #f "oops")))
     (guard (c [#t #t]) (r6rs:char>=? #\3 (error #f "oops") #\4))
     (guard (c [#t #t]) (r6rs:char>=? (error #f "oops") #\3 #\4))
     (guard (c [#t #t]) (not (r6rs:char>=? (error #f "oops"))))
     (guard (c [#t #t]) (r6rs:char-ci>=? #\3 #\4 (error #f "oops")))
     (guard (c [#t #t]) (r6rs:char-ci>=? #\3 (error #f "oops") #\4))
     (guard (c [#t #t]) (r6rs:char-ci>=? (error #f "oops") #\3 #\4))
     (guard (c [#t #t]) (not (r6rs:char-ci>=? (error #f "oops")))))

(mat char-alphabetic?
     (error? (char-alphabetic?))
     (error? (char-alphabetic? #\a #\b))
     (error? (char-alphabetic? 'a))
     (char-alphabetic? #\z)
     (not (char-alphabetic? #\3))
     (char-alphabetic? #\A)
     (not (char-alphabetic? #\space)))

(mat char-numeric?
     (error? (char-numeric?))
     (error? (char-numeric? #\a #\b))
     (error? (char-numeric? 'a))
     (not (char-numeric? #\k))
     (char-numeric? #\0)
     (char-numeric? #\4)
     (char-numeric? #\9)
     (not (char-numeric? #\newline)))

(mat char-lower-case?
     (error? (char-lower-case?))
     (error? (char-lower-case? #\a #\b))
     (error? (char-lower-case? 'a))
     (char-lower-case? #\z)
     (not (char-lower-case? #\A)))

(mat char-upper-case?
     (error? (char-upper-case?))
     (error? (char-upper-case? #\a #\b))
     (error? (char-upper-case? 'a))
     (char-upper-case? #\A)
     (not (char-upper-case? #\z)))

(mat char-title-case?
     (error? (char-title-case?))
     (error? (char-title-case? #\a #\b))
     (error? (char-title-case? 'a))
     (char-title-case? #\x01C5)
     (not (char-title-case? #\z)))

(mat char-general-category
     (error? (char-general-category))
     (error? (char-general-category #\a #\b))
     (error? (char-general-category 'a))
     (eq? (char-general-category #\A) 'Lu)
     (eq? (char-general-category #\z) 'Ll))

(mat char-whitespace?
     (error? (char-whitespace?))
     (error? (char-whitespace? #\a #\b))
     (error? (char-whitespace? 'a))
     (char-whitespace? #\space)
     (char-whitespace? #\return)
     (not (char-whitespace? #\F))
     (char-whitespace? #\newline)
     (char-whitespace? #\tab)
     (not (char-whitespace? #\%))
     (char-whitespace? #\page)
     (not (char-whitespace? #\3))
     (char-whitespace? #\linefeed))

(mat char-upcase
     (error? (char-upcase))
     (error? (char-upcase #\a #\b))
     (error? (char-upcase 'a))
     (eqv? (char-upcase #\a) #\A)
     (eqv? (char-upcase #\Z) #\Z))

(mat char-titlecase
     (error? (char-titlecase))
     (error? (char-titlecase #\a #\b))
     (error? (char-titlecase 'a))
     (eqv? (char-titlecase #\a) #\A)
     (eqv? (char-titlecase #\Z) #\Z))

(mat char-downcase
     (error? (char-downcase))
     (error? (char-downcase #\a #\b))
     (error? (char-downcase 'a))
     (eqv? (char-downcase #\a) #\a)
     (eqv? (char-downcase #\Z) #\z))

(mat char-foldcase
     (error? (char-foldcase))
     (error? (char-foldcase #\a #\b))
     (error? (char-foldcase 'a))
     (eqv? (char-foldcase #\a) #\a)
     (eqv? (char-foldcase #\Z) #\z))

(mat integer->char
     (error? (integer->char))
     (error? (integer->char 17 3))
     (error? (integer->char 'a))
     (error? (integer->char #f))
     (error? (integer->char #\a))
     (error? (integer->char -1))
     (error? (integer->char (+ (most-positive-fixnum) 1)))
     (error? (integer->char (- (most-negative-fixnum) 1)))
     (error? (integer->char #xD800))
     (error? (integer->char #xD900))
     (error? (integer->char #xDA00))
     (error? (integer->char #xDB00))
     (error? (integer->char #xDC00))
     (error? (integer->char #xDD00))
     (error? (integer->char #xDE00))
     (error? (integer->char #xDF00))
     (error? (integer->char #xDFFF))
     (error? (integer->char #x110000))
     (error? (integer->char #x120000))
     (error? (integer->char #x7fffffff))
     (eqv? (integer->char #x20) #\space)
     (eqv? (integer->char #x41) #\A)
     (eqv? (integer->char #x61) #\a)
     (eqv? (integer->char #x7f) #\rubout)
     (eqv? (integer->char #xD7FF) #\xD7FF)
     (eqv? (integer->char #xE000) #\xE000)
     (eqv? (integer->char #x10FFFF) #\x10FFFF))

(mat char->integer
     (error? (char->integer))
     (error? (char->integer #\a #\b))
     (error? (char->integer 'a))
     (error? (char->integer #x20))
     (eqv? (char->integer #\1) #x31)
     (eqv? (char->integer #\z) #x7a)
     (eqv? (char->integer #\~) #x7e)
     (eqv? (char->integer #\nul) #x00)
     (eqv? (char->integer #\backspace) #x08)
     (eqv? (char->integer #\return) #x0d)
     (eqv? (char->integer #\page) #x0c)
     (eqv? (char->integer #\linefeed) #x0a)
     (eqv? (char->integer #\newline) #x0a)
     (eqv? (char->integer #\rubout) #x7f)
     (eqv? (char->integer #\space) #x20)
     (eqv? (char->integer #\tab) #x09)
     (begin
       (do ([i 0 (fx+ i 1)])
           ((fx>= i #xD800))
           (unless (eqv? (char->integer (integer->char i)) i)
                   (errorf #f "failed for ~s" i)))
       (do ([i #xE000 (fx+ i 1)])
           ((fx>= i #x110000))
           (unless (eqv? (char->integer (integer->char i)) i)
                   (errorf #f "failed for ~s" i)))
       #t))

(mat string-for-each
     (error? ; invalid number of arguments
             (string-for-each))
     (error? ; invalid number of arguments
             (string-for-each '#()))
     (error? ; invalid number of arguments
             (string-for-each +))
     (error? ; non procedure ""
             (string-for-each "" ""))
     (error? ; non procedure ""
             (string-for-each "" "" ""))
     (error? ; non procedure ""
             (string-for-each "" "" "" '()))
     (error? ; non procedure ""
             (string-for-each "" "" "" "" ""))
     (error? ; non string 3
             (string-for-each + 3))
     (error? ; non string (3)
             (string-for-each + "" '(3)))
     (error? ; non string (3)
             (string-for-each + "" "" '(3)))
     (error? ; non string (3)
             (string-for-each + "" "" '(3) ""))
     (error? ; non string 7
             (string-for-each + 7 "" "" "" ""))
     (error? ; lengths differ
             (string-for-each + "" "x"))
     (error? ; lengths differ
             (string-for-each + "" "" "x"))
     (error? ; lengths differ
             (string-for-each + "" "" "x" ""))
     (error? ; lengths differ
             (string-for-each + "y" "" "x" ""))
     (error? ; lengths differ
             (string-for-each + "y" "" "" "" ""))
     (equal? (string-for-each + "") (void))
     (equal? (string-for-each + "" "") (void))
     (equal? (string-for-each + "" "" "") (void))
     (equal? (string-for-each + "" "" "" "" "") (void))
     (equal? (let ([ls '()])
               (string-for-each
                 (lambda (x) (set! ls (cons x ls)))
                 "abcdef")
               ls)
             '(#\f #\e #\d #\c #\b #\a))
     (equal? (let ([ls '()])
               (string-for-each
                 (lambda (x y)
                   (set! ls (cons (cons x y) ls)))
                 "abcdef"
                 "327654")
               ls)
             '((#\f . #\4)
               (#\e . #\5)
               (#\d . #\6)
               (#\c . #\7)
               (#\b . #\2)
               (#\a . #\3)))
     (equal? (let ([ls '()])
               (string-for-each
                 (lambda r (set! ls (cons r ls)))
                 "abcdef"
                 "327654"
                 "!@#$%^")
               ls)
             '((#\f #\4 #\^)
               (#\e #\5 #\%)
               (#\d #\6 #\$)
               (#\c #\7 #\#)
               (#\b #\2 #\@)
               (#\a #\3 #\!)))
     (equal? (let ([ls '()])
               (string-for-each
                 (lambda r (set! ls (cons r ls)))
                 "abcdef"
                 "327654"
                 "!@#$%^"
                 "hello!"
                 "hello?"
                 "3.1415")
               (map list->string ls))
             '("f4^!?5" "e5%oo1" "d6$ll4" "c7#ll1" "b2@ee." "a3!hh3"))
     (begin
       (define ($string-for-each-f1 p x1 x2 x3 x4 x5)
         (begin
           (string-for-each p "")
           (string-for-each p "" x1)
           (string-for-each p "" x1 x2)
           (string-for-each p "" x1 x2 x3)
           (string-for-each p "" x1 x2 x3 x4)
           (string-for-each p "" x1 x2 x3 x4 x5)
           (string-for-each p x1 "")
           (string-for-each p x1 "" x2)
           (string-for-each p x1 "" x2 x3)
           (string-for-each p x1 "" x2 x3 x4)
           (string-for-each p x1 "" x2 x3 x4 x5)
           (string-for-each p x1 x2 "")
           (string-for-each p x1 x2 "" x3)
           (string-for-each p x1 x2 "" x3 x4)
           (string-for-each p x1 x2 "" x3 x4 x5)
           (string-for-each p x1 x2 x3 "")
           (string-for-each p x1 x2 x3 "" x4)
           (string-for-each p x1 x2 x3 "" x4 x5)
           (string-for-each p x1 x2 x3 x4 "")
           (string-for-each p x1 x2 x3 x4 "" x5)
           (string-for-each p x1 x2 x3 x4 x5 "")))
       (procedure? $string-for-each-f1))
     (equal? (let ([ls '()])
               (define q
                 (lambda args
                   (set! ls (cons (reverse args) ls))))
               ($string-for-each-f1 q "" "" "" "" "")
               (reverse ls))
             '())
     (begin
       (define ($string-for-each-f1 p x1 x2 x3 x4 x5)
         (begin
           (string-for-each p "a")
           (string-for-each p "a" x1)
           (string-for-each p "a" x1 x2)
           (string-for-each p "a" x1 x2 x3)
           (string-for-each p "a" x1 x2 x3 x4)
           (string-for-each p "a" x1 x2 x3 x4 x5)
           (string-for-each p x1 "a")
           (string-for-each p x1 "a" x2)
           (string-for-each p x1 "a" x2 x3)
           (string-for-each p x1 "a" x2 x3 x4)
           (string-for-each p x1 "a" x2 x3 x4 x5)
           (string-for-each p x1 x2 "a")
           (string-for-each p x1 x2 "a" x3)
           (string-for-each p x1 x2 "a" x3 x4)
           (string-for-each p x1 x2 "a" x3 x4 x5)
           (string-for-each p x1 x2 x3 "a")
           (string-for-each p x1 x2 x3 "a" x4)
           (string-for-each p x1 x2 x3 "a" x4 x5)
           (string-for-each p x1 x2 x3 x4 "a")
           (string-for-each p x1 x2 x3 x4 "a" x5)
           (string-for-each p x1 x2 x3 x4 x5 "a")))
       (procedure? $string-for-each-f1))
     (equal? (let ([ls '()])
               (define q
                 (lambda args
                   (set! ls (cons (reverse args) ls))))
               ($string-for-each-f1 q "1" "f" "k" "p" "u")
               (map list->string (reverse ls)))
             '("a" "1a"
                   "f1a"
                   "kf1a"
                   "pkf1a"
                   "upkf1a"
                   "a1"
                   "fa1"
                   "kfa1"
                   "pkfa1"
                   "upkfa1"
                   "af1"
                   "kaf1"
                   "pkaf1"
                   "upkaf1"
                   "akf1"
                   "pakf1"
                   "upakf1"
                   "apkf1"
                   "uapkf1"
                   "aupkf1"))
     (begin
       (define ($string-for-each-f1 p x1 x2 x3 x4 x5)
         (begin
           (string-for-each p "ab")
           (string-for-each p "ab" x1)
           (string-for-each p "ab" x1 x2)
           (string-for-each p "ab" x1 x2 x3)
           (string-for-each p "ab" x1 x2 x3 x4)
           (string-for-each p "ab" x1 x2 x3 x4 x5)
           (string-for-each p x1 "ab")
           (string-for-each p x1 "ab" x2)
           (string-for-each p x1 "ab" x2 x3)
           (string-for-each p x1 "ab" x2 x3 x4)
           (string-for-each p x1 "ab" x2 x3 x4 x5)
           (string-for-each p x1 x2 "ab")
           (string-for-each p x1 x2 "ab" x3)
           (string-for-each p x1 x2 "ab" x3 x4)
           (string-for-each p x1 x2 "ab" x3 x4 x5)
           (string-for-each p x1 x2 x3 "ab")
           (string-for-each p x1 x2 x3 "ab" x4)
           (string-for-each p x1 x2 x3 "ab" x4 x5)
           (string-for-each p x1 x2 x3 x4 "ab")
           (string-for-each p x1 x2 x3 x4 "ab" x5)
           (string-for-each p x1 x2 x3 x4 x5 "ab")))
       (procedure? $string-for-each-f1))
     (equal? (let ([ls '()])
               (define q
                 (lambda args
                   (set! ls (cons (reverse args) ls))))
               ($string-for-each-f1 q "12" "fg" "kl" "pq" "uv")
               (map list->string (reverse ls)))
             '("a" "b"
                   "1a"
                   "2b"
                   "f1a"
                   "g2b"
                   "kf1a"
                   "lg2b"
                   "pkf1a"
                   "qlg2b"
                   "upkf1a"
                   "vqlg2b"
                   "a1"
                   "b2"
                   "fa1"
                   "gb2"
                   "kfa1"
                   "lgb2"
                   "pkfa1"
                   "qlgb2"
                   "upkfa1"
                   "vqlgb2"
                   "af1"
                   "bg2"
                   "kaf1"
                   "lbg2"
                   "pkaf1"
                   "qlbg2"
                   "upkaf1"
                   "vqlbg2"
                   "akf1"
                   "blg2"
                   "pakf1"
                   "qblg2"
                   "upakf1"
                   "vqblg2"
                   "apkf1"
                   "bqlg2"
                   "uapkf1"
                   "vbqlg2"
                   "aupkf1"
                   "bvqlg2"))
     (begin
       (define ($string-for-each-f1 p x1 x2 x3 x4 x5)
         (begin
           (string-for-each p "abc")
           (string-for-each p "abc" x1)
           (string-for-each p "abc" x1 x2)
           (string-for-each p "abc" x1 x2 x3)
           (string-for-each p "abc" x1 x2 x3 x4)
           (string-for-each p "abc" x1 x2 x3 x4 x5)
           (string-for-each p x1 "abc")
           (string-for-each p x1 "abc" x2)
           (string-for-each p x1 "abc" x2 x3)
           (string-for-each p x1 "abc" x2 x3 x4)
           (string-for-each p x1 "abc" x2 x3 x4 x5)
           (string-for-each p x1 x2 "abc")
           (string-for-each p x1 x2 "abc" x3)
           (string-for-each p x1 x2 "abc" x3 x4)
           (string-for-each p x1 x2 "abc" x3 x4 x5)
           (string-for-each p x1 x2 x3 "abc")
           (string-for-each p x1 x2 x3 "abc" x4)
           (string-for-each p x1 x2 x3 "abc" x4 x5)
           (string-for-each p x1 x2 x3 x4 "abc")
           (string-for-each p x1 x2 x3 x4 "abc" x5)
           (string-for-each p x1 x2 x3 x4 x5 "abc")))
       (procedure? $string-for-each-f1))
     (equal? (let ([ls '()])
               (define q
                 (lambda args
                   (set! ls (cons (reverse args) ls))))
               ($string-for-each-f1 q "123" "fgh" "klm" "pqr" "uvw")
               (map list->string (reverse ls)))
       '("a" "b"
             "c"
             "1a"
             "2b"
             "3c"
             "f1a"
             "g2b"
             "h3c"
             "kf1a"
             "lg2b"
             "mh3c"
             "pkf1a"
             "qlg2b"
             "rmh3c"
             "upkf1a"
             "vqlg2b"
             "wrmh3c"
             "a1"
             "b2"
             "c3"
             "fa1"
             "gb2"
             "hc3"
             "kfa1"
             "lgb2"
             "mhc3"
             "pkfa1"
             "qlgb2"
             "rmhc3"
             "upkfa1"
             "vqlgb2"
             "wrmhc3"
             "af1"
             "bg2"
             "ch3"
             "kaf1"
             "lbg2"
             "mch3"
             "pkaf1"
             "qlbg2"
             "rmch3"
             "upkaf1"
             "vqlbg2"
             "wrmch3"
             "akf1"
             "blg2"
             "cmh3"
             "pakf1"
             "qblg2"
             "rcmh3"
             "upakf1"
             "vqblg2"
             "wrcmh3"
             "apkf1"
             "bqlg2"
             "crmh3"
             "uapkf1"
             "vbqlg2"
             "wcrmh3"
             "aupkf1"
             "bvqlg2"
             "cwrmh3"))
     (begin
       (define ($string-for-each-f1 p x1 x2 x3 x4 x5)
         (begin
           (string-for-each p "abcd")
           (string-for-each p "abcd" x1)
           (string-for-each p "abcd" x1 x2)
           (string-for-each p "abcd" x1 x2 x3)
           (string-for-each p "abcd" x1 x2 x3 x4)
           (string-for-each p "abcd" x1 x2 x3 x4 x5)
           (string-for-each p x1 "abcd")
           (string-for-each p x1 "abcd" x2)
           (string-for-each p x1 "abcd" x2 x3)
           (string-for-each p x1 "abcd" x2 x3 x4)
           (string-for-each p x1 "abcd" x2 x3 x4 x5)
           (string-for-each p x1 x2 "abcd")
           (string-for-each p x1 x2 "abcd" x3)
           (string-for-each p x1 x2 "abcd" x3 x4)
           (string-for-each p x1 x2 "abcd" x3 x4 x5)
           (string-for-each p x1 x2 x3 "abcd")
           (string-for-each p x1 x2 x3 "abcd" x4)
           (string-for-each p x1 x2 x3 "abcd" x4 x5)
           (string-for-each p x1 x2 x3 x4 "abcd")
           (string-for-each p x1 x2 x3 x4 "abcd" x5)
           (string-for-each p x1 x2 x3 x4 x5 "abcd")))
       (procedure? $string-for-each-f1))
     (equal? (let ([ls '()])
               (define q
                 (lambda args
                   (set! ls (cons (reverse args) ls))))
               ($string-for-each-f1 q "1234" "fghi" "klmn" "pqrs" "uvwx")
               (map list->string (reverse ls)))
       '("a" "b"
             "c"
             "d"
             "1a"
             "2b"
             "3c"
             "4d"
             "f1a"
             "g2b"
             "h3c"
             "i4d"
             "kf1a"
             "lg2b"
             "mh3c"
             "ni4d"
             "pkf1a"
             "qlg2b"
             "rmh3c"
             "sni4d"
             "upkf1a"
             "vqlg2b"
             "wrmh3c"
             "xsni4d"
             "a1"
             "b2"
             "c3"
             "d4"
             "fa1"
             "gb2"
             "hc3"
             "id4"
             "kfa1"
             "lgb2"
             "mhc3"
             "nid4"
             "pkfa1"
             "qlgb2"
             "rmhc3"
             "snid4"
             "upkfa1"
             "vqlgb2"
             "wrmhc3"
             "xsnid4"
             "af1"
             "bg2"
             "ch3"
             "di4"
             "kaf1"
             "lbg2"
             "mch3"
             "ndi4"
             "pkaf1"
             "qlbg2"
             "rmch3"
             "sndi4"
             "upkaf1"
             "vqlbg2"
             "wrmch3"
             "xsndi4"
             "akf1"
             "blg2"
             "cmh3"
             "dni4"
             "pakf1"
             "qblg2"
             "rcmh3"
             "sdni4"
             "upakf1"
             "vqblg2"
             "wrcmh3"
             "xsdni4"
             "apkf1"
             "bqlg2"
             "crmh3"
             "dsni4"
             "uapkf1"
             "vbqlg2"
             "wcrmh3"
             "xdsni4"
             "aupkf1"
             "bvqlg2"
             "cwrmh3"
             "dxsni4"))
     (begin
       (define ($string-for-each-f1 p x1 x2 x3 x4 x5)
         (begin
           (string-for-each p "abcde")
           (string-for-each p "abcde" x1)
           (string-for-each p "abcde" x1 x2)
           (string-for-each p "abcde" x1 x2 x3)
           (string-for-each p "abcde" x1 x2 x3 x4)
           (string-for-each p "abcde" x1 x2 x3 x4 x5)
           (string-for-each p x1 "abcde")
           (string-for-each p x1 "abcde" x2)
           (string-for-each p x1 "abcde" x2 x3)
           (string-for-each p x1 "abcde" x2 x3 x4)
           (string-for-each p x1 "abcde" x2 x3 x4 x5)
           (string-for-each p x1 x2 "abcde")
           (string-for-each p x1 x2 "abcde" x3)
           (string-for-each p x1 x2 "abcde" x3 x4)
           (string-for-each p x1 x2 "abcde" x3 x4 x5)
           (string-for-each p x1 x2 x3 "abcde")
           (string-for-each p x1 x2 x3 "abcde" x4)
           (string-for-each p x1 x2 x3 "abcde" x4 x5)
           (string-for-each p x1 x2 x3 x4 "abcde")
           (string-for-each p x1 x2 x3 x4 "abcde" x5)
           (string-for-each p x1 x2 x3 x4 x5 "abcde")))
       (procedure? $string-for-each-f1))
     (equal? (let ([ls '()])
               (define q
                 (lambda args
                   (set! ls (cons (reverse args) ls))))
               ($string-for-each-f1
                 q
                 "12345"
                 "fghij"
                 "klmno"
                 "pqrst"
                 "uvwxy")
               (map list->string (reverse ls)))
       '("a" "b"
             "c"
             "d"
             "e"
             "1a"
             "2b"
             "3c"
             "4d"
             "5e"
             "f1a"
             "g2b"
             "h3c"
             "i4d"
             "j5e"
             "kf1a"
             "lg2b"
             "mh3c"
             "ni4d"
             "oj5e"
             "pkf1a"
             "qlg2b"
             "rmh3c"
             "sni4d"
             "toj5e"
             "upkf1a"
             "vqlg2b"
             "wrmh3c"
             "xsni4d"
             "ytoj5e"
             "a1"
             "b2"
             "c3"
             "d4"
             "e5"
             "fa1"
             "gb2"
             "hc3"
             "id4"
             "je5"
             "kfa1"
             "lgb2"
             "mhc3"
             "nid4"
             "oje5"
             "pkfa1"
             "qlgb2"
             "rmhc3"
             "snid4"
             "toje5"
             "upkfa1"
             "vqlgb2"
             "wrmhc3"
             "xsnid4"
             "ytoje5"
             "af1"
             "bg2"
             "ch3"
             "di4"
             "ej5"
             "kaf1"
             "lbg2"
             "mch3"
             "ndi4"
             "oej5"
             "pkaf1"
             "qlbg2"
             "rmch3"
             "sndi4"
             "toej5"
             "upkaf1"
             "vqlbg2"
             "wrmch3"
             "xsndi4"
             "ytoej5"
             "akf1"
             "blg2"
             "cmh3"
             "dni4"
             "eoj5"
             "pakf1"
             "qblg2"
             "rcmh3"
             "sdni4"
             "teoj5"
             "upakf1"
             "vqblg2"
             "wrcmh3"
             "xsdni4"
             "yteoj5"
             "apkf1"
             "bqlg2"
             "crmh3"
             "dsni4"
             "etoj5"
             "uapkf1"
             "vbqlg2"
             "wcrmh3"
             "xdsni4"
             "yetoj5"
             "aupkf1"
             "bvqlg2"
             "cwrmh3"
             "dxsni4"
             "eytoj5"))
     ; check for proper tail recursion
     (equal? (list (let ([s (statistics)])
                     (let ([k 100000] [str "abc"])
                       (let ([n k] [m 0])
                         (define (f)
                           (unless (fx= n 0)
                                   (string-for-each foo str)))
                         (define (foo x)
                           (set! m (+ m 1))
                           (when (char=? x
                                   (string-ref str (fx- (string-length str) 1)))
                                 (set! n (- n 1))
                                 (f)
                                 17))
                         ; blow tail recursion here
                         (f)
                         (list (> (sstats-bytes (sstats-difference (statistics) s))
                                  10000)
                               (eqv? n 0)
                               (eqv? m (* k (string-length str)))))))
                   (let ([s (statistics)])
                     (let ([k 100000] [str "abc"])
                       (let ([n k] [m 0])
                         (define (f)
                           (unless (fx= n 0)
                                   (string-for-each foo str)))
                         (define (foo x)
                           (set! m (+ m 1))
                           (when (char=? x
                                   (string-ref str (fx- (string-length str) 1)))
                                 (set! n (- n 1))
                                 (f)))
                         (f)
                         (list (<= 0
                                   (sstats-bytes (sstats-difference (statistics) s))
                                   1000)
                               (eqv? n 0)
                               (eqv? m (* k (string-length str))))))))
             '((#t #t #t) (#t #t #t))))

(mat string-xcase-errors
     (error? (string-upcase))
     (error? (string-upcase "hello" "goodbye"))
     (error? (string-upcase 'ouch))
     (error? (string-downcase))
     (error? (string-downcase "hello" "goodbye"))
     (error? (string-downcase 'ouch))
     (error? (string-titlecase))
     (error? (string-titlecase "hello" "goodbye"))
     (error? (string-titlecase 'ouch))
     (error? (string-foldcase))
     (error? (string-foldcase "hello" "goodbye"))
     (error? (string-foldcase 'ouch)))

(mat normalization-tests
     (error? (string-normalize-nfd))
     (error? (string-normalize-nfd "hello" "goodbye"))
     (error? (string-normalize-nfd 'ouch))
     (error? (string-normalize-nfkd))
     (error? (string-normalize-nfkd "hello" "goodbye"))
     (error? (string-normalize-nfkd 'ouch))
     (error? (string-normalize-nfc))
     (error? (string-normalize-nfc "hello" "goodbye"))
     (error? (string-normalize-nfc 'ouch))
     (error? (string-normalize-nfkc))
     (error? (string-normalize-nfkc "hello" "goodbye"))
     (error? (string-normalize-nfkc 'ouch))
     (begin (load "../unicode/unicode-data.ss") #t)
     (let ()
       (import (unicode-data))
       (define (split str)
         (remove ""
           (let f ([i 0] [n (string-length str)])
             (cond
               [(= i n) (list (substring str 0 n))]
               [(char=? (string-ref str i) #\space)
                (cons (substring str 0 i)
                      (split (substring str (+ i 1) n)))]
               [else (f (add1 i) n)]))))

       (define (conv x)
         (list->string
           (map (lambda (x) (integer->char (string->number x 16)))
                (split x))))

       (let ([data (map (lambda (x) (map conv (list-head x 5)))
                        (filter (lambda (x) (>= (length x) 5))
                                (get-unicode-data
                                  "../unicode/UNIDATA/NormalizationTest.txt")))])
         (define NFD string-normalize-nfd)
         (define NFKD string-normalize-nfkd)
         (define NFC string-normalize-nfc)
         (define NFKC string-normalize-nfkc)

         (printf "found ~s tests\n" (length data))

         ; test 1
         (for-each
           (lambda (x testno)
             (apply (lambda (c1 c2 c3 c4 c5)
                      (unless (and (string=? c2 (NFC c1) (NFC c2) (NFC c3))
                                   (string=? c4 (NFC c4) (NFC c5)))
                              (parameterize ([print-unicode #f])
                                (printf "test 1[~s] failed for ~s\n" testno x)
                                (printf "       c2 = ~s\n" c2)
                                (printf "  NFC(c1) = ~s\n" (NFC c1))
                                (printf "  NFC(c2) = ~s\n" (NFC c2))
                                (printf "  NFC(c3) = ~s\n" (NFC c3))
                                (printf "       c4 = ~s\n" c4)
                                (printf "  NFC(c4) = ~s\n" (NFC c4))
                                (printf "  NFC(c5) = ~s\n" (NFC c5))
                                (errorf #f "test 1 failed: see make output"))))
                    x))
           data
           (enumerate data))

         ; test 2
         (for-each
           (lambda (x testno)
             (apply (lambda (c1 c2 c3 c4 c5)
                      (unless (and (string=? c3 (NFD c1) (NFD c2) (NFD c3))
                                   (string=? c5 (NFD c4) (NFD c5)))
                              (parameterize ([print-unicode #f])
                                (printf "test 2[~s] failed for ~s\n" testno x)
                                (printf "       c3 = ~s\n" c3)
                                (printf "  NFD(c1) = ~s\n" (NFD c1))
                                (printf "  NFD(c2) = ~s\n" (NFD c2))
                                (printf "  NFD(c3) = ~s\n" (NFD c3))
                                (printf "       c5 = ~s\n" c5)
                                (printf "  NFD(c4) = ~s\n" (NFD c4))
                                (printf "  NFD(c5) = ~s\n" (NFD c5))
                                (errorf #f "test 2 failed: see make output"))))
                    x))
           data
           (enumerate data))

         ; test 3
         (for-each
           (lambda (x testno)
             (apply (lambda (c1 c2 c3 c4 c5)
                      (unless (string=? c4
                                (NFKC c1)
                                (NFKC c2)
                                (NFKC c3)
                                (NFKC c4)
                                (NFKC c5))
                              (parameterize ([print-unicode #f])
                                (printf "test 3[~s] failed for ~s\n" testno x)
                                (printf "       c4 = ~s\n" c4)
                                (printf "  NFKC(c1) = ~s\n" (NFKC c1))
                                (printf "  NFKC(c2) = ~s\n" (NFKC c2))
                                (printf "  NFKC(c3) = ~s\n" (NFKC c3))
                                (printf "  NFKC(c4) = ~s\n" (NFKC c4))
                                (printf "  NFKC(c5) = ~s\n" (NFKC c5))
                                (errorf #f "test 3 failed: see make output"))))
                    x))
           data
           (enumerate data))

         ; test 4
         (for-each
           (lambda (x testno)
             (apply (lambda (c1 c2 c3 c4 c5)
                      (unless (string=? c5
                                (NFKD c1)
                                (NFKD c2)
                                (NFKD c3)
                                (NFKD c4)
                                (NFKD c5))
                              (parameterize ([print-unicode #f])
                                (printf "test 4[~s] failed for ~s\n" testno x)
                                (printf "       c5 = ~s\n" c5)
                                (printf "  NFKD(c1) = ~s\n" (NFKD c1))
                                (printf "  NFKD(c2) = ~s\n" (NFKD c2))
                                (printf "  NFKD(c3) = ~s\n" (NFKD c3))
                                (printf "  NFKD(c4) = ~s\n" (NFKD c4))
                                (printf "  NFKD(c5) = ~s\n" (NFKD c5))
                                (errorf #f "test 4 failed: see make output"))))
                    x))
           data
           (enumerate data)))
       #t))

(mat r6rs-unicode-tests
     ; from Flatt's R6RS test suite
     (begin (define test equal?) (test test equal?))

     (test (char-upcase #\i) #\I)
     (test (char-downcase #\i) #\i)
     (test (char-titlecase #\i) #\I)
     (test (char-foldcase #\i) #\i)
     (test (char-upcase #\xDF) #\xDF)
     (test (char-downcase #\xDF) #\xDF)
     (test (char-titlecase #\xDF) #\xDF)
     (test (char-foldcase #\xDF) #\xDF)
     (test (char-upcase #\x3A3) #\x3A3)
     (test (char-downcase #\x3A3) #\x3C3)
     (test (char-titlecase #\x3A3) #\x3A3)
     (test (char-foldcase #\x3A3) #\x3C3)

     (test (char-upcase #\x3C2) #\x3A3)
     (test (char-downcase #\x3C2) #\x3C2)
     (test (char-titlecase #\x3C2) #\x3A3)
     (test (char-foldcase #\x3C2) #\x3C3)

     (test (char-ci<? #\z #\Z) #f)
     (test (char-ci<? #\Z #\z) #f)
     (test (char-ci<? #\a #\Z) #t)
     (test (char-ci<? #\Z #\a) #f)
     (test (char-ci<=? #\z #\Z) #t)
     (test (char-ci<=? #\Z #\z) #t)
     (test (char-ci<=? #\a #\Z) #t)
     (test (char-ci<=? #\Z #\a) #f)
     (test (char-ci=? #\z #\a) #f)
     (test (char-ci=? #\z #\Z) #t)
     (test (char-ci=? #\x3C2 #\x3C3) #t)
     (test (char-ci>? #\z #\Z) #f)
     (test (char-ci>? #\Z #\z) #f)
     (test (char-ci>? #\a #\Z) #f)
     (test (char-ci>? #\Z #\a) #t)
     (test (char-ci>=? #\Z #\z) #t)
     (test (char-ci>=? #\z #\Z) #t)
     (test (char-ci>=? #\z #\Z) #t)
     (test (char-ci>=? #\a #\z) #f)

     (test (char-alphabetic? #\a) #t)
     (test (char-alphabetic? #\1) #f)
     (test (char-numeric? #\1) #t)
     (test (char-numeric? #\a) #f)
     (test (char-whitespace? #\space) #t)
     (test (char-whitespace? #\x00A0) #t)
     (test (char-whitespace? #\a) #f)
     (test (char-upper-case? #\a) #f)
     (test (char-upper-case? #\A) #t)
     (test (char-upper-case? #\x3A3) #t)
     (test (char-lower-case? #\a) #t)
     (test (char-lower-case? #\A) #f)
     (test (char-lower-case? #\x3C3) #t)
     (test (char-lower-case? #\x00AA) #t)
     (test (char-title-case? #\a) #f)
     (test (char-title-case? #\A) #f)
     (test (char-title-case? #\I) #f)
     (test (char-title-case? #\x01C5) #t)

     (test (char-general-category #\a) 'Ll)
     (test (char-general-category #\space) 'Zs)
     (test (char-general-category #\x10FFFF) 'Cn)

     (test (string-upcase "Hi") "HI")
     (test (string-upcase "HI") "HI")
     (test (string-downcase "Hi") "hi")
     (test (string-downcase "hi") "hi")
     (test (string-foldcase "Hi") "hi")
     (test (string-foldcase "HI") "hi")
     (test (string-foldcase "hi") "hi")

     (test (string-upcase "Stra\xDF;e") "STRASSE")
     (test (string-downcase "Stra\xDF;e") "stra\xDF;e")
     (test (string-foldcase "Stra\xDF;e") "strasse")
     (test (string-downcase "STRASSE") "strasse")
     (test (string-downcase "\x3A3;") "\x3C3;")

     (test (string-upcase "\x39E;\x391;\x39F;\x3A3;")
           "\x39E;\x391;\x39F;\x3A3;")
     (test (string-downcase "\x39E;\x391;\x39F;\x3A3;")
           "\x3BE;\x3B1;\x3BF;\x3C2;")
     (test (string-downcase "\x39E;\x391;\x39F;\x3A3;\x3A3;")
           "\x3BE;\x3B1;\x3BF;\x3C3;\x3C2;")
     (test (string-downcase "\x39E;\x391;\x39F;\x3A3; \x3A3;")
           "\x3BE;\x3B1;\x3BF;\x3C2; \x3C3;")
     (test (string-foldcase "\x39E;\x391;\x39F;\x3A3;")
           "\x3BE;\x3B1;\x3BF;\x3C3;")
     (test (string-upcase "\x3BE;\x3B1;\x3BF;\x3C3;")
           "\x39E;\x391;\x39F;\x3A3;")
     (test (string-upcase "\x3BE;\x3B1;\x3BF;\x3C2;")
           "\x39E;\x391;\x39F;\x3A3;")

     (test (string-titlecase "kNock KNoCK") "Knock Knock")
     (test (string-titlecase "who's there?") "Who's There?")
     (test (string-titlecase "r6rs") "R6rs")
     ; this example appears to be wrong in R6RS (Sept 2007 version)
     (test (string-titlecase "R6RS") "R6rs")
     ; this one, too

     (test (string-downcase "A\x3A3;'x") "a\x3C3;'x")
     ; ' is a MidLetter

     (test (string-ci<? "a" "Z") #t)
     (test (string-ci<? "A" "z") #t)
     (test (string-ci<? "Z" "a") #f)
     (test (string-ci<? "z" "A") #f)
     (test (string-ci<? "z" "Z") #f)
     (test (string-ci<? "Z" "z") #f)
     (test (string-ci>? "a" "Z") #f)
     (test (string-ci>? "A" "z") #f)
     (test (string-ci>? "Z" "a") #t)
     (test (string-ci>? "z" "A") #t)
     (test (string-ci>? "z" "Z") #f)
     (test (string-ci>? "Z" "z") #f)
     (test (string-ci=? "z" "Z") #t)
     (test (string-ci=? "z" "a") #f)
     (test (string-ci=? "Stra\xDF;e" "Strasse") #t)
     (test (string-ci=? "Stra\xDF;e" "STRASSE") #t)
     (test (string-ci=?
             "\x39E;\x391;\x39F;\x3A3;"
             "\x3BE;\x3B1;\x3BF;\x3C2;")
           #t)
     (test (string-ci=?
             "\x39E;\x391;\x39F;\x3A3;"
             "\x3BE;\x3B1;\x3BF;\x3C3;")
           #t)
     (test (string-ci<=? "a" "Z") #t)
     (test (string-ci<=? "A" "z") #t)
     (test (string-ci<=? "Z" "a") #f)
     (test (string-ci<=? "z" "A") #f)
     (test (string-ci<=? "z" "Z") #t)
     (test (string-ci<=? "Z" "z") #t)
     (test (string-ci>=? "a" "Z") #f)
     (test (string-ci>=? "A" "z") #f)
     (test (string-ci>=? "Z" "a") #t)
     (test (string-ci>=? "z" "A") #t)
     (test (string-ci>=? "z" "Z") #t)
     (test (string-ci>=? "Z" "z") #t)

     (test (string-normalize-nfd "\xE9;") "\x65;\x301;")
     (test (string-normalize-nfc "\xE9;") "\xE9;")
     (test (string-normalize-nfd "\x65;\x301;") "\x65;\x301;")
     (test (string-normalize-nfc "\x65;\x301;") "\xE9;")

     (test (string-normalize-nfkd "\xE9;") "\x65;\x301;")
     (test (string-normalize-nfkc "\xE9;") "\xE9;")
     (test (string-normalize-nfkd "\x65;\x301;") "\x65;\x301;")
     (test (string-normalize-nfkc "\x65;\x301;") "\xE9;"))

(mat unicode-tests.sch
     ; adapted from Clinger's unicode-tests.sch
     ; Copyright 2006 William D Clinger.
     ;
     ; Permission to copy this software, in whole or in part, to use this
     ; software for any lawful purpose, and to redistribute this software
     ; is granted subject to the restriction that all copies made of this
     ; software must include this copyright and permission notice in full.
     ;
     ; I also request that you send me a copy of any improvements that you
     ; make to this software so that they may be incorporated within it to
     ; the benefit of the Scheme community.

     (begin
       (define es-zed (integer->char #x00df))
       (define final-sigma (integer->char #x03c2))
       (define lower-sigma (integer->char #x03c3))
       (define upper-sigma (integer->char #x03a3))
       (define upper-chi (integer->char #x03a7))
       (define upper-alpha (integer->char #x0391))
       (define upper-omicron (integer->char #x039f))
       (define lower-chi (integer->char #x03c7))
       (define lower-alpha (integer->char #x03b1))
       (define lower-omicron (integer->char #x03bf))
       (define strasse (string #\S #\t #\r #\a es-zed #\e))
       (define upper-chaos
         (string upper-chi upper-alpha upper-omicron upper-sigma))
       (define final-chaos
         (string lower-chi lower-alpha lower-omicron final-sigma))
       (define lower-chaos
         (string lower-chi lower-alpha lower-omicron lower-sigma))
       ; Given a unary predicate on characters, returns a sorted
       ; list of all characters that satisfy the predicate.
       (define (filter-all-chars p?)
         (do ((i 0 (+ i 1))
              (chars '()
                (if (and (not (<= #xd800 i #xdfff)) (p? (integer->char i)))
                    (cons (integer->char i) chars)
                    chars)))
             ((= i #x110000) (reverse chars))))
       ; Given a list of characters, prints its length and returns 0.
       (define (report chars n)
         (display "  ")
         (display (length chars))
         (display " characters")
         (if (not (= n (length chars)))
             (begin
               (display " but expected ")
               (write n)
               (display " in Unicode 5.0.0")))
         (newline)
         0)
       (define-syntax test
         (syntax-rules (=> error)
           [(test name exp => result) (equal? exp result)]))
       ; According to SRFI 77, this is a complete list of all code points
       ; above 127 in Unicode 4.1 whose Unicode general category is
       ; Ps, Pe, Pi, Pf, Zs, Zp, Zl, Cc, or Cf.
       ;
       ; In Unicode 5.0, the general category of
       ; #\x23B4 (TOP SQUARE BRACKET)
       ; and
       ; #\x23B5 (BOTTOM SQUARE BRACKET)
       ; was changed from Ps and Pe to So.
       ; rkd: Unicode 5.1 adds
       ; #x2064 #x27EC #x27ED #x27EE #x27EF #x2E20 #x2E21 #x2E22
       ; #x2E23 #x2E24 #x2E25 #x2E26 #x2E27 #x2E28 #x2E29
       ; rkd: Unicode 7.0 adds:
       ; #x604 #x605 #x61C #x2066 #x2067 #x2068 #x2069 #x2308 #x2309
       ; #x230A #x230B #x2E42 #x110BD #x1BCA0 #x1BCA1 #x1BCA2 #x1BCA3
       ; rkd: Unicode 7.0 removes:
       ; #x17B4 #x17B5
       (define excluded-code-points-above-127
         '(#x80 #x81
                #x82
                #x83
                #x84
                #x85
                #x86
                #x87
                #x88
                #x89
                #x8A
                #x8B
                #x8C
                #x8D
                #x8E
                #x8F
                #x90
                #x91
                #x92
                #x93
                #x94
                #x95
                #x96
                #x97
                #x98
                #x99
                #x9A
                #x9B
                #x9C
                #x9D
                #x9E
                #x9F
                #xA0
                #xAB
                #xAD
                #xBB
                #x600
                #x601
                #x602
                #x603
                #x604
                #x605
                #x61C
                ; Unicode 7.0
                #x6DD
                #x70F
                #xF3A
                #xF3B
                #xF3C
                #xF3D
                #x1680
                #x169B
                #x169C
                #;
                #x17B4
                #;
                #x17B5
                ; Unicode 7.0
                #x180E
                #x2000
                #x2001
                #x2002
                #x2003
                #x2004
                #x2005
                #x2006
                #x2007
                #x2008
                #x2009
                #x200A
                #x200B
                #x200C
                #x200D
                #x200E
                #x200F
                #x2018
                #x2019
                #x201A
                #x201B
                #x201C
                #x201D
                #x201E
                #x201F
                #x2028
                #x2029
                #x202A
                #x202B
                #x202C
                #x202D
                #x202E
                #x202F
                #x2039
                #x203A
                #x2045
                #x2046
                #x205F
                #x2060
                #x2061
                #x2062
                #x2063
                #x2064
                ; Unicode 5.1
                #x2066
                #x2067
                #x2068
                #x2069
                ; Unicode 7.0
                #x206A
                #x206B
                #x206C
                #x206D
                #x206E
                #x206F
                #x207D
                #x207E
                #x208D
                #x208E
                #x2308
                #x2309
                #x230A
                #x230B
                ; Unicode 7.0
                #x2329
                #x232A
                ;       #x23B4 #x23B5 ; see note above for Unicode 5.0
                #x2768
                #x2769
                #x276A
                #x276B
                #x276C
                #x276D
                #x276E
                #x276F
                #x2770
                #x2771
                #x2772
                #x2773
                #x2774
                #x2775
                #x27C5
                #x27C6
                #x27E6
                #x27E7
                #x27E8
                #x27E9
                #x27EA
                #x27EB
                #x27EC
                #x27ED
                #x27EE
                #x27EF
                ; Unicode 5.1
                #x2983
                #x2984
                #x2985
                #x2986
                #x2987
                #x2988
                #x2989
                #x298A
                #x298B
                #x298C
                #x298D
                #x298E
                #x298F
                #x2990
                #x2991
                #x2992
                #x2993
                #x2994
                #x2995
                #x2996
                #x2997
                #x2998
                #x29D8
                #x29D9
                #x29DA
                #x29DB
                #x29FC
                #x29FD
                #x2E02
                #x2E03
                #x2E04
                #x2E05
                #x2E09
                #x2E0A
                #x2E0C
                #x2E0D
                #x2E1C
                #x2E1D
                #x2E20
                #x2E21
                #x2E22
                #x2E23
                #x2E24
                #x2E25
                #x2E26
                #x2E27
                ; Unicode 5.1
                #x2E28
                #x2E29
                ; Unicode 5.1
                #x2E42
                ; Unicode 7.0
                #x3000
                #x3008
                #x3009
                #x300A
                #x300B
                #x300C
                #x300D
                #x300E
                #x300F
                #x3010
                #x3011
                #x3014
                #x3015
                #x3016
                #x3017
                #x3018
                #x3019
                #x301A
                #x301B
                #x301D
                #x301E
                #x301F
                #xFD3E
                #xFD3F
                #xFE17
                #xFE18
                #xFE35
                #xFE36
                #xFE37
                #xFE38
                #xFE39
                #xFE3A
                #xFE3B
                #xFE3C
                #xFE3D
                #xFE3E
                #xFE3F
                #xFE40
                #xFE41
                #xFE42
                #xFE43
                #xFE44
                #xFE47
                #xFE48
                #xFE59
                #xFE5A
                #xFE5B
                #xFE5C
                #xFE5D
                #xFE5E
                #xFEFF
                #xFF08
                #xFF09
                #xFF3B
                #xFF3D
                #xFF5B
                #xFF5D
                #xFF5F
                #xFF60
                #xFF62
                #xFF63
                #xFFF9
                #xFFFA
                #xFFFB
                #x110BD
                #x1BCA0
                #x1BCA1
                #x1BCA2
                #x1BCA3
                ; Unicode 7.0
                #x1D173
                #x1D174
                #x1D175
                #x1D176
                #x1D177
                #x1D178
                #x1D179
                #x1D17A
                #xE0001
                #xE0020
                #xE0021
                #xE0022
                #xE0023
                #xE0024
                #xE0025
                #xE0026
                #xE0027
                #xE0028
                #xE0029
                #xE002A
                #xE002B
                #xE002C
                #xE002D
                #xE002E
                #xE002F
                #xE0030
                #xE0031
                #xE0032
                #xE0033
                #xE0034
                #xE0035
                #xE0036
                #xE0037
                #xE0038
                #xE0039
                #xE003A
                #xE003B
                #xE003C
                #xE003D
                #xE003E
                #xE003F
                #xE0040
                #xE0041
                #xE0042
                #xE0043
                #xE0044
                #xE0045
                #xE0046
                #xE0047
                #xE0048
                #xE0049
                #xE004A
                #xE004B
                #xE004C
                #xE004D
                #xE004E
                #xE004F
                #xE0050
                #xE0051
                #xE0052
                #xE0053
                #xE0054
                #xE0055
                #xE0056
                #xE0057
                #xE0058
                #xE0059
                #xE005A
                #xE005B
                #xE005C
                #xE005D
                #xE005E
                #xE005F
                #xE0060
                #xE0061
                #xE0062
                #xE0063
                #xE0064
                #xE0065
                #xE0066
                #xE0067
                #xE0068
                #xE0069
                #xE006A
                #xE006B
                #xE006C
                #xE006D
                #xE006E
                #xE006F
                #xE0070
                #xE0071
                #xE0072
                #xE0073
                #xE0074
                #xE0075
                #xE0076
                #xE0077
                #xE0078
                #xE0079
                #xE007A
                #xE007B
                #xE007C
                #xE007D
                #xE007E
                #xE007F))
       #t)

     (test type1 (integer->char 32) => #\space)
     (test type2 (char->integer (integer->char 5000)) => 5000)
     ;(test type3 (integer->char #xd800) => error)

     (test comp1 (char<? #\z es-zed) => #t)
     (test comp2 (char<? #\z #\Z) => #f)
     (test comp3 (char-ci<? #\z #\Z) => #f)
     (test comp4 (char-ci=? #\z #\Z) => #t)
     (test comp5 (char-ci=? final-sigma lower-sigma) => #t)

     (test case1 (char-upcase #\i) => #\I)
     (test case2 (char-downcase #\i) => #\i)
     (test case3 (char-titlecase #\i) => #\I)
     (test case4 (char-foldcase #\i) => #\i)

     (test case5 (char-upcase es-zed) => es-zed)
     (test case6 (char-downcase es-zed) => es-zed)
     (test case7 (char-titlecase es-zed) => es-zed)
     (test case8 (char-foldcase es-zed) => es-zed)

     (test case9 (char-upcase upper-sigma) => upper-sigma)
     (test case10 (char-downcase upper-sigma) => lower-sigma)
     (test case11 (char-titlecase upper-sigma) => upper-sigma)
     (test case12 (char-foldcase upper-sigma) => lower-sigma)

     (test case13 (char-upcase final-sigma) => upper-sigma)
     (test case14 (char-downcase final-sigma) => final-sigma)
     (test case15 (char-titlecase final-sigma) => upper-sigma)
     (test case16 (char-foldcase final-sigma) => lower-sigma)

     (test cat1 (char-general-category #\a) => 'Ll)
     (test cat2 (char-general-category #\space) => 'Zs)
     (test cat3 (char-general-category (integer->char #x10FFFF)) => 'Cn)

     (test alpha1 (char-alphabetic? #\a) => #t)
     (test numer1 (char-numeric? #\1) => #t)
     (test white1 (char-whitespace? #\space) => #t)
     (test white2 (char-whitespace? (integer->char #x00A0)) => #t)
     (test upper1 (char-upper-case? upper-sigma) => #t)
     (test lower1 (char-lower-case? lower-sigma) => #t)
     (test lower2 (char-lower-case? (integer->char #x00AA)) => #t)
     (test title1 (char-title-case? #\I) => #f)
     (test title2 (char-title-case? (integer->char #x01C5)) => #t)

     ; 01/30/15 rkd: modified to print the exceptions
     (test excluded
           (let f ((i 128)
                   (excluded excluded-code-points-above-127)
                   (okay? #t))
             (if (= i #x110000)
                 okay?
                 (if (and (not (null? excluded)) (> i (car excluded)))
                     (begin
                       (printf "missed excluded char \\x~x\n"
                               (car excluded))
                       (f i (cdr excluded) #f))
                     (let ([excluded?
                             (and (not (<= #xd800 i #xdfff))
                                  (memq (char-general-category (integer->char i))
                                        '(Ps Pe Pi Pf Zs Zp Zl Cc Cf)))])
                       (if excluded?
                           (if (and (not (null? excluded))
                                    (eqv? i (car excluded)))
                               (f (+ i 1) (cdr excluded) okay?)
                               (begin
                                 (printf "excluding non-excluded char \\x~x\n" i)
                                 (f (+ i 1) excluded #f)))
                           (f (+ i 1) excluded okay?))))))
           =>
           #t)

     (test upcase (filter-all-chars (lambda (c) (char-upcase c) #f)) => '())

     (test downcase
           (filter-all-chars (lambda (c) (char-downcase c) #f))
           =>
           '())

     (test titlecase
           (filter-all-chars (lambda (c) (char-titlecase c) #f))
           =>
           '())

     (test foldcase
           (filter-all-chars (lambda (c) (char-foldcase c) #f))
           =>
           '())

     (test general-category
           (report (filter-all-chars
                     (lambda (c) (char-general-category c)))
                   1112064)
           =>
           0)

     (test alphabetic?
           (report (filter-all-chars char-alphabetic?) 93217)
           =>
           0)

     (test numeric? (report (filter-all-chars char-numeric?) 282) => 0)

     (test whitespace?
           (report (filter-all-chars char-whitespace?) 26)
           =>
           0)

     (test upper-case?
           (report (filter-all-chars char-upper-case?) 1362)
           =>
           0)

     (test lower-case?
           (report (filter-all-chars char-lower-case?) 1791)
           =>
           0)

     (test title-case?
           (report (filter-all-chars char-title-case?) 31)
           =>
           0)

     (test scomp1 (string<? "z" (string es-zed)) => #t)
     (test scomp2 (string<? "z" "zz") => #t)
     (test scomp3 (string<? "z" "Z") => #f)
     (test scomp4 (string=? strasse "Strasse") => #f)

     (test sup1 (string-upcase "Hi") => "HI")
     (test sdown1 (string-downcase "Hi") => "hi")
     (test sfold1 (string-foldcase "Hi") => "hi")

     (test sup2 (string-upcase strasse) => "STRASSE")
     (test sdown2
           (string-downcase strasse)
           =>
           (string-append "s" (substring strasse 1 6)))
     (test sfold2 (string-foldcase strasse) => "strasse")
     (test sdown3 (string-downcase "STRASSE") => "strasse")

     (test chaos1 (string-upcase upper-chaos) => upper-chaos)
     (test chaos2
           (string-downcase (string upper-sigma))
           =>
           (string lower-sigma))
     (test chaos3 (string-downcase upper-chaos) => final-chaos)
     (test chaos4
           (string-downcase
             (string-append upper-chaos (string upper-sigma)))
           =>
           (string-append (substring lower-chaos 0 3)
             (string lower-sigma final-sigma)))
     (test chaos5
           (string-downcase
             (string-append upper-chaos (string #\space upper-sigma)))
           =>
           (string-append final-chaos (string #\space lower-sigma)))
     (test chaos6
           (string-foldcase
             (string-append upper-chaos (string upper-sigma)))
           =>
           (string-append lower-chaos (string lower-sigma)))
     (test chaos7 (string-upcase final-chaos) => upper-chaos)
     (test chaos8 (string-upcase lower-chaos) => upper-chaos)

     (test stitle1 (string-titlecase "kNock KNoCK") => "Knock Knock")
     (test stitle2 (string-titlecase "who's there?") => "Who's There?")
     (test stitle3 (string-titlecase "r6rs") => "R6rs")
     (test stitle4 (string-titlecase "R6RS") => "R6rs")

     (test norm1
           (string-normalize-nfd (string #\xE9))
           =>
           (string #\x65 #\x301))
     (test norm2 (string-normalize-nfc (string #\xE9)) => (string #\xE9))
     (test norm3
           (string-normalize-nfd (string #\x65 #\x301))
           =>
           (string #\x65 #\x301))
     (test norm4
           (string-normalize-nfc (string #\x65 #\x301))
           =>
           (string #\xE9))

     (test sci1 (string-ci<? "z" "Z") => #f)
     (test sci2 (string-ci=? "z" "Z") => #t)
     (test sci3 (string-ci=? strasse "Strasse") => #t)
     (test sci4 (string-ci=? strasse "STRASSE") => #t)
     (test sci5 (string-ci=? upper-chaos lower-chaos) => #t)

     ; eliminate macro binding for test so it doesn't screw up later mats
     (begin (define test) #t))

(mat string-titlecase
     (equal? (string-titlecase "ciao12") "Ciao12")
     (equal? (string-titlecase "ciao123") "Ciao123")
     (equal? (string-titlecase "ciao123 futzmo") "Ciao123 Futzmo")
     (equal? (string-titlecase "ciao123 futzmo.  goobar") "Ciao123 Futzmo.  Goobar")
     (equal? (string-titlecase "ciao123 futzmo.  goob33ar") "Ciao123 Futzmo.  Goob33ar")
     (equal? (string-titlecase "ciao123 futzmo.  33ar") "Ciao123 Futzmo.  33Ar"))
;;; 5-5.ms
;;; Copyright 1984-2017 Cisco Systems, Inc.
;;; 
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;; 
;;; http://www.apache.org/licenses/LICENSE-2.0
;;; 
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

(mat string=?/string-ci=?
     (error? (string=?))
     (error? (string=? 'a))
     (error? (string=? "hi" 'a))
     (error? (string=? "hi" 'a "ho"))
     (error? (string=? 'a "hi" "ho"))
     (error? (string=? "hi" "ho" 'a "he"))
     (error? (string-ci=?))
     (error? (string-ci=? 'a))
     (error? (string-ci=? "hi" 'a))
     (error? (string-ci=? "hi" 'a "ho"))
     (error? (string-ci=? 'a "hi" "ho"))
     (error? (string-ci=? "hi" "ho" 'a "he"))
     (string=? "abc" "abc")
     (string-ci=? "abc" "abc")
     (not (string=? "Abc" "abc"))
     (string-ci=? "Abc" "abc")
     (not (string=? "abc" "abc "))
     (not (string-ci=? "abc" "abc "))
     (not (string=? "abc " "abc"))
     (not (string-ci=? "abc " "abc"))
     (string=? "a")
     (string=? "a" "a" "a")
     (not (string=? "a" "b" "c"))
     (not (string=? "c" "b" "a"))
     (not (string=? "b" "c" "a"))
     (not (string=? "A" "a" "A"))
     (not (string=? "a" "B" "c"))
     (not (string=? "C" "b" "A"))
     (string-ci=? "a")
     (string-ci=? "a" "a" "a")
     (not (string-ci=? "a" "b" "c"))
     (not (string-ci=? "c" "b" "a"))
     (not (string-ci=? "b" "c" "a"))
     (string-ci=? "A" "a" "A")
     (not (string-ci=? "a" "B" "c"))
     (not (string-ci=? "C" "b" "A")))

(mat string<?/string-ci<?
     (error? (string<?))
     (error? (string<? 'a))
     (error? (string<? "hi" 'a))
     (error? (string<? "hi" 'a "ho"))
     (error? (string<? 'a "hi" "ho"))
     (error? (string<? "hi" "ho" 'a "he"))
     (error? (string-ci<?))
     (error? (string-ci<? 'a))
     (error? (string-ci<? "hi" 'a))
     (error? (string-ci<? "hi" 'a "ho"))
     (error? (string-ci<? 'a "hi" "ho"))
     (error? (string-ci<? "hi" "ho" 'a "he"))
     (not (string<? "abc" "abc"))
     (not (string-ci<? "abc" "abc"))
     (string<? "Abc" "abc")
     (not (string-ci<? "aBc" "AbC"))
     (string<? "abc" "abc ")
     (string-ci<? "aBc" "AbC ")
     (not (string<? "abc " "abc"))
     (not (string-ci<? "aBc " "AbC"))
     (string<? "a")
     (not (string<? "a" "a" "a"))
     (string<? "a" "b" "c")
     (not (string<? "c" "b" "a"))
     (not (string<? "b" "c" "a"))
     (not (string<? "A" "a" "A"))
     (not (string<? "a" "B" "c"))
     (not (string<? "C" "b" "A"))
     (string-ci<? "a")
     (not (string-ci<? "a" "a" "a"))
     (string-ci<? "a" "b" "c")
     (not (string-ci<? "c" "b" "a"))
     (not (string-ci<? "b" "c" "a"))
     (not (string-ci<? "A" "a" "A"))
     (string-ci<? "a" "B" "c")
     (not (string-ci<? "C" "b" "A")))

(mat string>?/string-ci>?
     (error? (string>?))
     (error? (string>? 'a))
     (error? (string>? "hi" 'a))
     (error? (string>? "hi" 'a "ho"))
     (error? (string>? 'a "hi" "ho"))
     (error? (string>? "hi" "ho" 'a "he"))
     (error? (string-ci>?))
     (error? (string-ci>? 'a))
     (error? (string-ci>? "hi" 'a))
     (error? (string-ci>? "hi" 'a "ho"))
     (error? (string-ci>? 'a "hi" "ho"))
     (error? (string-ci>? "hi" "ho" 'a "he"))
     (not (string>? "abc" "abc"))
     (not (string-ci>? "abc" "abc"))
     (string>? "abc" "Abc")
     (not (string-ci>? "aBc" "AbC"))
     (not (string>? "abc" "abc "))
     (not (string-ci>? "aBc" "AbC "))
     (string>? "abc " "abc")
     (string-ci>? "aBc " "AbC")
     (string>? "a")
     (not (string>? "a" "a" "a"))
     (not (string>? "a" "b" "c"))
     (string>? "c" "b" "a")
     (not (string>? "b" "c" "a"))
     (not (string>? "A" "a" "A"))
     (not (string>? "a" "B" "c"))
     (not (string>? "C" "b" "A"))
     (string-ci>? "a")
     (not (string-ci>? "a" "a" "a"))
     (not (string-ci>? "a" "b" "c"))
     (string-ci>? "c" "b" "a")
     (not (string-ci>? "b" "c" "a"))
     (not (string-ci>? "A" "a" "A"))
     (not (string-ci>? "a" "B" "c"))
     (string-ci>? "C" "b" "A"))

(mat string<=?/string-ci<=?
     (error? (string<=?))
     (error? (string<=? 'a))
     (error? (string<=? "hi" 'a))
     (error? (string<=? "hi" 'a "ho"))
     (error? (string<=? 'a "hi" "ho"))
     (error? (string<=? "hi" "ho" 'a "he"))
     (error? (string-ci<=?))
     (error? (string-ci<=? 'a))
     (error? (string-ci<=? "hi" 'a))
     (error? (string-ci<=? "hi" 'a "ho"))
     (error? (string-ci<=? 'a "hi" "ho"))
     (error? (string-ci<=? "hi" "ho" 'a "he"))
     (string<=? "abc" "abc")
     (string-ci<=? "abc" "abc")
     (not (string<=? "abc" "Abc"))
     (string-ci<=? "aBc" "AbC")
     (string<=? "abc" "abc ")
     (string-ci<=? "aBc" "AbC ")
     (not (string<=? "abc " "abc"))
     (not (string-ci<=? "aBc " "AbC"))
     (string<=? "a")
     (string<=? "a" "a" "a")
     (string<=? "a" "b" "c")
     (not (string<=? "c" "b" "a"))
     (not (string<=? "b" "c" "a"))
     (not (string<=? "A" "a" "A"))
     (not (string<=? "a" "B" "c"))
     (not (string<=? "C" "b" "A"))
     (string-ci<=? "a")
     (string-ci<=? "a" "a" "a")
     (string-ci<=? "a" "b" "c")
     (not (string-ci<=? "c" "b" "a"))
     (not (string-ci<=? "b" "c" "a"))
     (string-ci<=? "A" "a" "A")
     (string-ci<=? "a" "B" "c")
     (not (string-ci<=? "C" "b" "A")))

(mat string>=?/string-ci>=?
     (error? (string>=?))
     (error? (string>=? 'a))
     (error? (string>=? "hi" 'a))
     (error? (string>=? "hi" 'a "ho"))
     (error? (string>=? 'a "hi" "ho"))
     (error? (string>=? "hi" "ho" 'a "he"))
     (error? (string-ci>=?))
     (error? (string-ci>=? 'a))
     (error? (string-ci>=? "hi" 'a))
     (error? (string-ci>=? "hi" 'a "ho"))
     (error? (string-ci>=? 'a "hi" "ho"))
     (error? (string-ci>=? "hi" "ho" 'a "he"))
     (string>=? "abc" "abc")
     (string-ci>=? "abc" "abc")
     (not (string>=? "Abc" "abc"))
     (string-ci>=? "aBc" "AbC")
     (not (string>=? "abc" "abc "))
     (not (string-ci>=? "aBc" "AbC "))
     (string>=? "abc " "abc")
     (string-ci>=? "aBc " "AbC")
     (string>=? "a")
     (string>=? "a" "a" "a")
     (not (string>=? "a" "b" "c"))
     (string>=? "c" "b" "a")
     (not (string>=? "b" "c" "a"))
     (not (string>=? "A" "a" "A"))
     (not (string>=? "a" "B" "c"))
     (not (string>=? "C" "b" "A"))
     (string-ci>=? "a")
     (string-ci>=? "a" "a" "a")
     (not (string-ci>=? "a" "b" "c"))
     (string-ci>=? "c" "b" "a")
     (not (string-ci>=? "b" "c" "a"))
     (string-ci>=? "A" "a" "A")
     (not (string-ci>=? "a" "B" "c"))
     (string-ci>=? "C" "b" "A"))

(mat r6rs:string=?/r6rs:string-ci=?
     (error? (r6rs:string=?))
     (error? (r6rs:string=? 'a))
     (error? (r6rs:string=? "hi" 'a))
     (error? (r6rs:string=? "hi" 'a "ho"))
     (error? (r6rs:string=? 'a "hi" "ho"))
     (error? (r6rs:string=? "hi" "ho" 'a "he"))
     (error? (r6rs:string-ci=?))
     (error? (r6rs:string-ci=? 'a))
     (error? (r6rs:string-ci=? "hi" 'a))
     (error? (r6rs:string-ci=? "hi" 'a "ho"))
     (error? (r6rs:string-ci=? 'a "hi" "ho"))
     (error? (r6rs:string-ci=? "hi" "ho" 'a "he"))
     (r6rs:string=? "abc" "abc")
     (r6rs:string-ci=? "abc" "abc")
     (not (r6rs:string=? "Abc" "abc"))
     (r6rs:string-ci=? "Abc" "abc")
     (not (r6rs:string=? "abc" "abc "))
     (not (r6rs:string-ci=? "abc" "abc "))
     (not (r6rs:string=? "abc " "abc"))
     (not (r6rs:string-ci=? "abc " "abc"))
     (r6rs:string=? "a" "a" "a")
     (not (r6rs:string=? "a" "b" "c"))
     (not (r6rs:string=? "c" "b" "a"))
     (not (r6rs:string=? "b" "c" "a"))
     (not (r6rs:string=? "A" "a" "A"))
     (not (r6rs:string=? "a" "B" "c"))
     (not (r6rs:string=? "C" "b" "A"))
     (r6rs:string-ci=? "a" "a" "a")
     (not (r6rs:string-ci=? "a" "b" "c"))
     (not (r6rs:string-ci=? "c" "b" "a"))
     (not (r6rs:string-ci=? "b" "c" "a"))
     (r6rs:string-ci=? "A" "a" "A")
     (not (r6rs:string-ci=? "a" "B" "c"))
     (not (r6rs:string-ci=? "C" "b" "A")))

(mat r6rs:string<?/r6rs:string-ci<?
     (error? (r6rs:string<?))
     (error? (r6rs:string<? 'a))
     (error? (r6rs:string<? "hi" 'a))
     (error? (r6rs:string<? "hi" 'a "ho"))
     (error? (r6rs:string<? 'a "hi" "ho"))
     (error? (r6rs:string<? "hi" "ho" 'a "he"))
     (error? (r6rs:string-ci<?))
     (error? (r6rs:string-ci<? 'a))
     (error? (r6rs:string-ci<? "hi" 'a))
     (error? (r6rs:string-ci<? "hi" 'a "ho"))
     (error? (r6rs:string-ci<? 'a "hi" "ho"))
     (error? (r6rs:string-ci<? "hi" "ho" 'a "he"))
     (not (r6rs:string<? "abc" "abc"))
     (not (r6rs:string-ci<? "abc" "abc"))
     (r6rs:string<? "Abc" "abc")
     (not (r6rs:string-ci<? "aBc" "AbC"))
     (r6rs:string<? "abc" "abc ")
     (r6rs:string-ci<? "aBc" "AbC ")
     (not (r6rs:string<? "abc " "abc"))
     (not (r6rs:string-ci<? "aBc " "AbC"))
     (not (r6rs:string<? "a" "a" "a"))
     (r6rs:string<? "a" "b" "c")
     (not (r6rs:string<? "c" "b" "a"))
     (not (r6rs:string<? "b" "c" "a"))
     (not (r6rs:string<? "A" "a" "A"))
     (not (r6rs:string<? "a" "B" "c"))
     (not (r6rs:string<? "C" "b" "A"))
     (not (r6rs:string-ci<? "a" "a" "a"))
     (r6rs:string-ci<? "a" "b" "c")
     (not (r6rs:string-ci<? "c" "b" "a"))
     (not (r6rs:string-ci<? "b" "c" "a"))
     (not (r6rs:string-ci<? "A" "a" "A"))
     (r6rs:string-ci<? "a" "B" "c")
     (not (r6rs:string-ci<? "C" "b" "A")))

(mat r6rs:string>?/r6rs:string-ci>?
     (error? (r6rs:string>?))
     (error? (r6rs:string>? 'a))
     (error? (r6rs:string>? "hi" 'a))
     (error? (r6rs:string>? "hi" 'a "ho"))
     (error? (r6rs:string>? 'a "hi" "ho"))
     (error? (r6rs:string>? "hi" "ho" 'a "he"))
     (error? (r6rs:string-ci>?))
     (error? (r6rs:string-ci>? 'a))
     (error? (r6rs:string-ci>? "hi" 'a))
     (error? (r6rs:string-ci>? "hi" 'a "ho"))
     (error? (r6rs:string-ci>? 'a "hi" "ho"))
     (error? (r6rs:string-ci>? "hi" "ho" 'a "he"))
     (not (r6rs:string>? "abc" "abc"))
     (not (r6rs:string-ci>? "abc" "abc"))
     (r6rs:string>? "abc" "Abc")
     (not (r6rs:string-ci>? "aBc" "AbC"))
     (not (r6rs:string>? "abc" "abc "))
     (not (r6rs:string-ci>? "aBc" "AbC "))
     (r6rs:string>? "abc " "abc")
     (r6rs:string-ci>? "aBc " "AbC")
     (not (r6rs:string>? "a" "a" "a"))
     (not (r6rs:string>? "a" "b" "c"))
     (r6rs:string>? "c" "b" "a")
     (not (r6rs:string>? "b" "c" "a"))
     (not (r6rs:string>? "A" "a" "A"))
     (not (r6rs:string>? "a" "B" "c"))
     (not (r6rs:string>? "C" "b" "A"))
     (not (r6rs:string-ci>? "a" "a" "a"))
     (not (r6rs:string-ci>? "a" "b" "c"))
     (r6rs:string-ci>? "c" "b" "a")
     (not (r6rs:string-ci>? "b" "c" "a"))
     (not (r6rs:string-ci>? "A" "a" "A"))
     (not (r6rs:string-ci>? "a" "B" "c"))
     (r6rs:string-ci>? "C" "b" "A"))

(mat r6rs:string<=?/r6rs:string-ci<=?
     (error? (r6rs:string<=?))
     (error? (r6rs:string<=? 'a))
     (error? (r6rs:string<=? "hi" 'a))
     (error? (r6rs:string<=? "hi" 'a "ho"))
     (error? (r6rs:string<=? 'a "hi" "ho"))
     (error? (r6rs:string<=? "hi" "ho" 'a "he"))
     (error? (r6rs:string-ci<=?))
     (error? (r6rs:string-ci<=? 'a))
     (error? (r6rs:string-ci<=? "hi" 'a))
     (error? (r6rs:string-ci<=? "hi" 'a "ho"))
     (error? (r6rs:string-ci<=? 'a "hi" "ho"))
     (error? (r6rs:string-ci<=? "hi" "ho" 'a "he"))
     (r6rs:string<=? "abc" "abc")
     (r6rs:string-ci<=? "abc" "abc")
     (not (r6rs:string<=? "abc" "Abc"))
     (r6rs:string-ci<=? "aBc" "AbC")
     (r6rs:string<=? "abc" "abc ")
     (r6rs:string-ci<=? "aBc" "AbC ")
     (not (r6rs:string<=? "abc " "abc"))
     (not (r6rs:string-ci<=? "aBc " "AbC"))
     (r6rs:string<=? "a" "a" "a")
     (r6rs:string<=? "a" "b" "c")
     (not (r6rs:string<=? "c" "b" "a"))
     (not (r6rs:string<=? "b" "c" "a"))
     (not (r6rs:string<=? "A" "a" "A"))
     (not (r6rs:string<=? "a" "B" "c"))
     (not (r6rs:string<=? "C" "b" "A"))
     (r6rs:string-ci<=? "a" "a" "a")
     (r6rs:string-ci<=? "a" "b" "c")
     (not (r6rs:string-ci<=? "c" "b" "a"))
     (not (r6rs:string-ci<=? "b" "c" "a"))
     (r6rs:string-ci<=? "A" "a" "A")
     (r6rs:string-ci<=? "a" "B" "c")
     (not (r6rs:string-ci<=? "C" "b" "A")))

(mat r6rs:string>=?/r6rs:string-ci>=?
     (error? (r6rs:string>=?))
     (error? (r6rs:string>=? 'a))
     (error? (r6rs:string>=? "hi" 'a))
     (error? (r6rs:string>=? "hi" 'a "ho"))
     (error? (r6rs:string>=? 'a "hi" "ho"))
     (error? (r6rs:string>=? "hi" "ho" 'a "he"))
     (error? (r6rs:string-ci>=?))
     (error? (r6rs:string-ci>=? 'a))
     (error? (r6rs:string-ci>=? "hi" 'a))
     (error? (r6rs:string-ci>=? "hi" 'a "ho"))
     (error? (r6rs:string-ci>=? 'a "hi" "ho"))
     (error? (r6rs:string-ci>=? "hi" "ho" 'a "he"))
     (r6rs:string>=? "abc" "abc")
     (r6rs:string-ci>=? "abc" "abc")
     (not (r6rs:string>=? "Abc" "abc"))
     (r6rs:string-ci>=? "aBc" "AbC")
     (not (r6rs:string>=? "abc" "abc "))
     (not (r6rs:string-ci>=? "aBc" "AbC "))
     (r6rs:string>=? "abc " "abc")
     (r6rs:string-ci>=? "aBc " "AbC")
     (r6rs:string>=? "a" "a" "a")
     (not (r6rs:string>=? "a" "b" "c"))
     (r6rs:string>=? "c" "b" "a")
     (not (r6rs:string>=? "b" "c" "a"))
     (not (r6rs:string>=? "A" "a" "A"))
     (not (r6rs:string>=? "a" "B" "c"))
     (not (r6rs:string>=? "C" "b" "A"))
     (r6rs:string-ci>=? "a" "a" "a")
     (not (r6rs:string-ci>=? "a" "b" "c"))
     (r6rs:string-ci>=? "c" "b" "a")
     (not (r6rs:string-ci>=? "b" "c" "a"))
     (r6rs:string-ci>=? "A" "a" "A")
     (not (r6rs:string-ci>=? "a" "B" "c"))
     (r6rs:string-ci>=? "C" "b" "A"))

(mat string
     (error? (string 'a))
     (error? (string #\a 'a))
     (error? (string #\a #\b 'a))
     (equal? (string #\a #\b #\c) "abc")
     (equal? (string #\a (string-ref "b" 0) #\c) "abc")
     (equal? (let ([x #\a]) (string x (string-ref "b" 0) #\c)) "abc")
     (eq? (string) ""))

(mat make-string
     (error? (make-string))
     (error? (make-string 2 #\a #\b))
     (error? (make-string 3 'a))
     (error? (make-string 'a 3))
     (eqv? (make-string 0) "")
     (eqv? (make-string (- 4 4)) (string))
     (eqv? (string-length (make-string 3)) 3)
     (eqv? (string-length (make-string (+ 3 4))) 7)
     (eqv? (string-length (make-string 1000)) 1000)
     (string=? (make-string 10 #\a) "aaaaaaaaaa")
     (string=? (make-string (- 4 1) #\a) "aaa")
     (string=? (make-string (- 4 1) (string-ref "b" 0)) "bbb")
     (andmap char? (string->list (make-string 20))))

(mat string-length
     (error? (string-length))
     (error? (string-length "hi" "there"))
     (error? (string-length 'a))
     (eqv? (string-length "abc") 3)
     (eqv? (string-length "") 0))

(mat $string-ref-check?
     (let ([s (make-string 3)]
           [imm-s (string->immutable-string (make-string 3))]
           [not-s (make-vector 3)])
       (let ([i-1 -1]
             [i0 0]
             [i1 1]
             [i2 2]
             [i3 3]
             [ifalse #f]
             [ibig (+ (most-positive-fixnum) 1)])
         (and (not (#%$string-ref-check? not-s i0))
              (not (#%$string-ref-check? s ifalse))
              (not (#%$string-ref-check? s i-1))
              (not (#%$string-ref-check? imm-s i-1))
              (#%$string-ref-check? s 0)
              (#%$string-ref-check? s 1)
              (#%$string-ref-check? s 2)
              (#%$string-ref-check? imm-s 0)
              (#%$string-ref-check? imm-s 1)
              (#%$string-ref-check? imm-s 2)
              (#%$string-ref-check? s i0)
              (#%$string-ref-check? s i1)
              (#%$string-ref-check? s i2)
              (#%$string-ref-check? imm-s i0)
              (#%$string-ref-check? imm-s i1)
              (#%$string-ref-check? imm-s i2)
              (not (#%$string-ref-check? s 3))
              (not (#%$string-ref-check? s i3))
              (not (#%$string-ref-check? s ibig))
              (not (#%$string-ref-check? imm-s 3))
              (not (#%$string-ref-check? imm-s i3))
              (not (#%$string-ref-check? imm-s ibig))))))

(mat string-ref
     (error? (string-ref))
     (error? (string-ref "hi"))
     (error? (string-ref "hi" 3 4))
     (error? (string-ref 'a 3))
     (error? (string-ref "hi" 'a))
     (error? (string-ref "hi" -1))
     (error? (string-ref "hi" 2))
     (eqv? (string-ref "abc" 0) #\a)
     (eqv? (string-ref "abc" 1) #\b)
     (eqv? (string-ref "abc" 2) #\c))

(mat string-set!
     (error? (string-set!))
     (error? (string-set! "hi"))
     (error? (string-set! "hi" 1))
     (error? (string-set! "hi" 3 #\a #\b))
     (error? (string-set! 'a 3 #\a))
     (error? (string-set! "hi" 'a #\a))
     (error? (string-set! "hi" 3 'a))
     (error? (string-set! "hi" -1 #\a))
     (error? (string-set! "hi" 2 #\a))
     (let ((s (string #\a #\b #\c)))
       (and (begin (string-set! s 0 #\x) (equal? s "xbc"))
            (begin (string-set! s 1 #\y) (equal? s "xyc"))
            (begin (string-set! s 2 #\z) (equal? s "xyz")))))

(mat string-copy
     ; incorrect argument count
     (error? (string-copy))
     (error? (string-copy "hi" "there"))

     ; not a string
     (error? (string-copy 'a))
     (error? (if (string-copy '(a b c)) #f #t))

     (equal? (string-copy "") "")
     (equal? (string-copy "abc") "abc")
     (let* ((x1 (string #\1 #\2 #\3)) (x2 (string-copy x1)))
       (and (equal? x2 x1) (not (eq? x2 x1)))))

(mat string-copy!
     (begin
       (define $s1 (string #\1 #\2 #\3 #\4))
       (define $s2
         (string #\a #\b #\c #\d #\e #\f #\g #\h #\i))
       (and (string? $s1)
            (string? $s2)
            (eqv? (string-length $s1) 4)
            (eqv? (string-length $s2) 9)))

     ; wrong number of arguments
     (error? (string-copy!))
     (error? (string-copy! $s2))
     (error? (string-copy! $s2 3))
     (error? (string-copy! $s2 3 $s1))
     (error? (string-copy! $s2 3 $s1 1))
     (error? (if (string-copy! $s2 3 $s1 1 2 3) #f #t))

     ; not string
     (error? (string-copy! 0 0 $s2 0 0))
     (error? (if (string-copy! $s1 0 (bytevector 1 2 3) 0 0) #f #t))

     ; bad index
     (error? (string-copy! $s1 -1 $s2 0 0))
     (error? (string-copy! $s1 0 $s2 -1 0))
     (error? (string-copy! $s1 'a $s2 0 0))
     (error? (string-copy! $s1 0 $s2 0.0 0))
     (error? (string-copy! $s1 (+ (most-positive-fixnum) 1) $s2 0 0))
     (error? (if (string-copy! $s1 0 $s2 (+ (most-positive-fixnum) 1) 0)
                 #f
                 #t))

     ; bad count
     (error? (string-copy! $s1 0 $s2 0 -1))
     (error? (string-copy! $s1 0 $s2 0 (+ (most-positive-fixnum) 1)))
     (error? (if (string-copy! $s1 0 $s2 0 'a) #f #t))

     ; beyond end
     (error? (string-copy! $s1 0 $s2 0 5))
     (error? (string-copy! $s2 0 $s1 0 5))
     (error? (string-copy! $s1 1 $s2 0 4))
     (error? (string-copy! $s2 0 $s1 1 4))
     (error? (string-copy! $s1 2 $s2 0 3))
     (error? (string-copy! $s2 0 $s1 2 3))
     (error? (string-copy! $s1 3 $s2 0 2))
     (error? (string-copy! $s2 0 $s1 3 2))
     (error? (string-copy! $s1 4 $s2 0 1))
     (error? (string-copy! $s2 0 $s1 4 1))
     (error? (string-copy! $s2 0 $s1 0 500))
     (error? (if (string-copy! $s2 500 $s1 0 0) #f #t))

     ; make sure no damage done
     (and (string? $s1)
          (string? $s2)
          (equal? $s1 "1234")
          (equal? $s2 "abcdefghi"))

     (begin
       (string-copy! $s2 3 $s1 1 2)
       (and (equal? $s1 "1de4") (equal? $s2 "abcdefghi")))
     (begin
       (string-copy! $s2 6 $s1 2 2)
       (and (equal? $s1 "1dgh") (equal? $s2 "abcdefghi")))
     (begin
       (string-copy! $s2 0 $s1 4 0)
       (and (equal? $s1 "1dgh") (equal? $s2 "abcdefghi")))
     (begin
       (string-copy! $s2 3 $s1 4 0)
       (and (equal? $s1 "1dgh") (equal? $s2 "abcdefghi")))
     (begin
       (string-copy! $s2 3 $s2 4 0)
       (and (equal? $s1 "1dgh") (equal? $s2 "abcdefghi")))
     (begin
       (string-copy! $s2 2 $s1 1 3)
       (and (equal? $s1 "1cde") (equal? $s2 "abcdefghi")))
     (begin
       (string-copy! $s1 0 $s2 3 4)
       (and (equal? $s1 "1cde") (equal? $s2 "abc1cdehi")))
     (begin
       (string-copy! $s2 0 $s2 3 5)
       (and (equal? $s1 "1cde") (equal? $s2 "abcabc1ci")))
     (begin
       (string-copy! $s2 4 $s2 2 5)
       (and (equal? $s1 "1cde") (equal? $s2 "abbc1cici")))
     (begin
       (string-copy! $s2 1 $s2 1 7)
       (and (equal? $s1 "1cde") (equal? $s2 "abbc1cici"))))

(mat string-truncate!
     (begin
       (define $s
         (string #\a #\b #\c #\d #\e #\f #\g #\h #\i))
       (and (string? $s)
            (fx= (string-length $s) 9)
            (string=? $s "abcdefghi")))

     ; wrong number of arguments
     (error? (string-truncate!))
     (error? (string-truncate! $s))
     (error? (string-truncate! $s 3 15))

     ; not string
     (error? (string-truncate! 0 0))
     (error? (if (string-truncate! (bytevector 1 2 3) 2) #f #t))

     ; bad length
     (error? (string-truncate! $s -1))
     (error? (string-truncate! $s 10))
     (error? (string-truncate! $s 1000))
     (error? (string-truncate! $s (+ (most-positive-fixnum) 1)))
     (error? (string-truncate! $s 'a))

     (begin
       (string-truncate! $s 9)
       (and (string? $s)
            (fx= (string-length $s) 9)
            (string=? $s "abcdefghi")))

     (begin
       (string-truncate! $s 8)
       (and (string? $s)
            (fx= (string-length $s) 8)
            (string=? $s "abcdefgh")))

     (begin
       (string-truncate! $s 6)
       (and (string? $s)
            (fx= (string-length $s) 6)
            (string=? $s "abcdef")))

     (begin
       (string-truncate! $s 3)
       (and (string? $s)
            (fx= (string-length $s) 3)
            (string=? $s "abc")))

     (begin
       (define $s2 (string-truncate! $s 0))
       (and (eqv? $s2 "")
            (string? $s)
            (fx= (string-length $s) 3)
            (string=? $s "abc"))))

(mat string-append
     (error? (string-append 'a))
     (error? (string-append "hi" 'b))
     (error? (string-append "hi" 'b "there"))
     (error? (string-copy 'a))
     (eqv? (string-append) "")
     (let ([x (make-string 10 #\space)])
       (and (equal? x "          ")
            (not (eq? x (string-append x)))))
     (equal? (string-append "abc") "abc")
     (equal? (string-append "abc" "xyz") "abcxyz")
     (equal? (string-append "hi " "there " "mom") "hi there mom")
     (equal? (string-append "" "there") "there")
     (equal? (string-append "hi " "") "hi ")
     (eqv? (string-append "" "") ""))

(mat substring
     (error? (substring))
     (error? (substring "hi"))
     (error? (substring "hi" 0))
     (error? (substring "hi" 0 2 3))
     (error? (substring "hi" 0 3))
     (error? (substring "hi" -1 2))
     (error? (substring "hi" 'a 2))
     (error? (substring 'a 0 1))
     (error? (substring "hi" 0 'a))
     (error? (substring "hi" 1 0))
     (equal? (substring "hi there" 0 1) "h")
     (equal? (substring "hi there" 3 6) "the")
     (equal? (substring "hi there" 5 5) "")
     (equal? (substring "hi there" 0 8) "hi there")
     (eqv? (substring "" 0 0) ""))

(mat string-fill!
     (error? (string-fill!))
     (error? (string-fill! "hi"))
     (error? (string-fill! "hi" #\a #\b))
     (error? (string-fill! "hi" 'a))
     (error? (string-fill! 'a #\a))
     (let ([s (string #\a #\b #\c)])
       (and (equal? s "abc")
            (begin (string-fill! s #\*) (equal? s "***"))))
     ; test for bug filling beyond the end of the string
     (eqv? (let* ((s1 (make-string 3 #\a)) (s2 (make-string 3 #\b)))
             (string-fill! s1 #\*)
             (string-ref s2 0))
           #\b))

(mat substring-fill!
     (error? (substring-fill!))
     (error? (substring-fill! "hi"))
     (error? (substring-fill! "hi" 0))
     (error? (substring-fill! "hi" 0 2))
     (error? (substring-fill! "hi" 0 3 #\a))
     (error? (substring-fill! "hi" -1 3 #\a))
     (error? (substring-fill! 'a 0 1 #\a))
     (error? (substring-fill! "hi" 0 'a #\a))
     (error? (substring-fill! "hi" 1 0 #\a))
     (let ([s (string-copy "hitme!")])
       (substring-fill! s 0 5 #\a)
       (equal? s "aaaaa!"))
     (let ([s ""]) (substring-fill! s 0 0 #\a) (eqv? s ""))
     (let ([s (string-copy "ABCDE")])
       (and (begin (substring-fill! s 0 0 #\$) (equal? s "ABCDE"))
            (begin (substring-fill! s 2 5 #\$) (equal? s "AB$$$"))
            (begin (substring-fill! s 0 3 #\&) (equal? s "&&&$$")))))

(mat list->string
     (error? (list->string))
     (error? (list->string '(#\a #\b) '(#\c #\d)))
     (error? (list->string 'a))
     (error? (list->string '(a b)))
     (error? (list->string '(#\a #\b . #\c)))
     (error? (list->string
               (let ([ls (list #\a #\b #\c)])
                 (set-cdr! (cddr ls) (cdr ls))
                 ls)))
     (equal? (list->string '(#\a #\b #\c)) "abc")
     (equal? (list->string '()) ""))

(mat string->list
     (error? (string->list))
     (error? (string->list "ab" "cd"))
     (error? (string->list 'a))
     (equal? (string->list "abc") '(#\a #\b #\c))
     (equal? (string->list "") '()))

(mat string->immutable-string
     (begin
       (define immutable-abc-string
         (string->immutable-string (string #\a #\b #\c)))
       #t)

     (immutable-string? immutable-abc-string)
     (not (mutable-string? immutable-abc-string))
     (equal? "abc" immutable-abc-string)
     (eq? immutable-abc-string
          (string->immutable-string immutable-abc-string))
     (not (immutable-string? (make-string 5)))
     (mutable-string? (make-string 5))
     (immutable-string? (string->immutable-string (string)))
     (not (mutable-string? (string->immutable-string (string))))
     (not (immutable-string? (string)))
     (mutable-string? (string))
     (not (immutable-string? (string-copy immutable-abc-string)))

     (error? (string-set! immutable-abc-string 0 #\a))
     (error? (string-fill! immutable-abc-string #\a))
     (error? (substring-fill! immutable-abc-string 0 1 #\a))
     (error? (string-copy! "xyz" 0 immutable-abc-string 0 3))
     (error? (string-truncate! immutable-abc-string 1)))
;;; bytevector.ms
;;; Copyright 1984-2017 Cisco Systems, Inc.
;;; 
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;; 
;;; http://www.apache.org/licenses/LICENSE-2.0
;;; 
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

(mat native-endianness
     ; wrong argument count
     (error? (native-endianness 'big))

     (and (memq (native-endianness) '(big little)) #t)
     (eq? (native-endianness)
          (case (machine-type)
            [(i3le ti3le
                   i3nt
                   ti3nt
                   a6nt
                   ta6nt
                   i3ob
                   ti3ob
                   i3fb
                   ti3fb
                   i3nb
                   ti3nb
                   i3osx
                   ti3osx
                   a6le
                   ta6le
                   a6nb
                   ta6nb
                   a6osx
                   ta6osx
                   a6fb
                   ta6fb
                   a6ob
                   ta6ob
                   a6s2
                   ta6s2
                   i3s2
                   ti3s2
                   i3qnx
                   ti3qnx
                   arm32le
                   tarm32le) 'little]
            [(ppc32le tppc32le) 'big]
            [else (errorf #f "unrecognized machine type")])))

(mat endianness
     ; invalid endianness
     (error? (endianness spam))
     (error? (endianness 'big))
     (error? (endianness "little"))

     ; invalid syntax
     (error? (endianness))
     (error? (endianness . big))
     (error? (endianness big little))

     (eq? (endianness big) 'big)
     (eq? (endianness little) 'little)
     (eq? (let ([big 'large]) (endianness big)) 'big)
     (eq? (let ([little 'small]) (endianness little)) 'little))

(mat make-bytevector
     ; wrong argument count
     (error? (make-bytevector))
     (error? (make-bytevector 0 0 0))

     ; invalid size
     (error? (make-bytevector -1))
     (error? (make-bytevector -1 0))
     (error? (make-bytevector (+ (most-positive-fixnum) 1)))
     (error? (make-bytevector (+ (most-positive-fixnum) 1) -1))
     (error? (begin (make-bytevector 'a -1) #f))

     ; invalid fill
     (error? (make-bytevector 3 'a))
     (error? (make-bytevector 10 256))
     (error? (make-bytevector 10 -129))
     (error? (make-bytevector 10 (+ (most-positive-fixnum) 1)))
     (error? (begin (make-bytevector 10 (- (most-negative-fixnum) 1)) #f))

     (eqv? (bytevector-length (make-bytevector 10)) 10)
     (eqv? (let ([n 11]) (bytevector-length (make-bytevector n))) 11)
     (eqv? (bytevector-length (make-bytevector 100)) 100)
     (eqv? (bytevector-length (make-bytevector (+ 100 17))) 117)
     (eq? (make-bytevector 0) #vu8())
     (let ([x (make-bytevector 10)])
       (and (= (bytevector-length x) 10)
            (andmap fixnum? (bytevector->s8-list x))))
     (do ([n -128 (fx+ n 1)])
         ((fx= n 128) #t)
         (let ([v (make-bytevector 3)])
           (unless (and (fixnum? (bytevector-s8-ref v 0))
                        (fixnum? (bytevector-s8-ref v 1))
                        (fixnum? (bytevector-s8-ref v 2)))
                   (errorf #f "wrong value for ~s" n))))
     (do ([q 10000 (fx- q 1)])
         ((fx= q 0) #t)
         (do ([n -128 (fx+ n 1)])
             ((fx= n 128) #t)
             (let ([v (make-bytevector 3 n)])
               (unless (and (eqv? (bytevector-s8-ref v 0) n)
                            (eqv? (bytevector-s8-ref v 1) n)
                            (eqv? (bytevector-s8-ref v 2) n))
                       (errorf #f "wrong value for ~s" n)))))
     (do ([q 10000 (fx- q 1)])
         ((fx= q 0) #t)
         (do ([n 0 (fx+ n 1)])
             ((fx= n 255) #t)
             (let ([v (make-bytevector 3 n)])
               (unless (and (eqv? (bytevector-u8-ref v 0) n)
                            (eqv? (bytevector-u8-ref v 1) n)
                            (eqv? (bytevector-u8-ref v 2) n))
                       (errorf #f "wrong value for ~s" n))))))

(mat bytevector
     ; invalid value
     (error? (bytevector 3 4 256))
     (error? (bytevector 3 4 -129))
     (error? (bytevector 3 4 500))
     (error? (bytevector 3 4 -500))
     (error? (bytevector 3 4 1e100))
     (error? (begin (bytevector 3 4 #e1e100) #f))

     (eqv? (bytevector) #vu8())
     (equal? (bytevector 7 7 7 7 7 7 7 7 7 7) (make-bytevector 10 7))
     (equal? (bytevector 2 2) (make-bytevector (- 4 2) (+ 1 1)))
     (eqv? (bytevector) (make-bytevector (- 4 4) (+ 1 1)))
     (eqv? (bytevector) (make-bytevector (- 4 4) (+ 1 1)))
     (equal? (bytevector 1) #vu8(1))
     (equal? (bytevector -1) #vu8(255))
     (equal? (bytevector -1 2) #vu8(255 2))
     (equal? (bytevector 2 -1) #vu8(2 255))
     (equal? (letrec-syntax
               ([z (syntax-rules ()
                     [(_) (list (bytevector))]
                     [(_ x ... y) (cons (bytevector x ... y) (z x ...))])])
               (z 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17))
       '(#vu8(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17)
         #vu8(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16)
         #vu8(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15)
         #vu8(1 2 3 4 5 6 7 8 9 10 11 12 13 14)
         #vu8(1 2 3 4 5 6 7 8 9 10 11 12 13)
         #vu8(1 2 3 4 5 6 7 8 9 10 11 12)
         #vu8(1 2 3 4 5 6 7 8 9 10 11)
         #vu8(1 2 3 4 5 6 7 8 9 10)
         #vu8(1 2 3 4 5 6 7 8 9)
         #vu8(1 2 3 4 5 6 7 8)
         #vu8(1 2 3 4 5 6 7)
         #vu8(1 2 3 4 5 6)
         #vu8(1 2 3 4 5)
         #vu8(1 2 3 4)
         #vu8(1 2 3)
         #vu8(1 2)
         #vu8(1)
         #vu8()))
     (equal? (letrec-syntax
               ([z (syntax-rules ()
                     [(_) (list (bytevector))]
                     [(_ x ... y) (cons (bytevector x ... y) (z x ...))])])
               (z -1
                  -2
                  -3
                  -4
                  -5
                  -6
                  -7
                  -8
                  -9
                  -10
                  -11
                  -12
                  -13
                  -14
                  -15
                  -16
                  -17))
       '(#vu8(255 254 253 252 251 250 249 248 247 246 245 244 243 242 241
              240 239)
         #vu8(255 254 253 252 251 250 249 248 247 246 245 244 243 242 241
              240)
         #vu8(255 254 253 252 251 250 249 248 247 246 245 244 243 242 241)
         #vu8(255 254 253 252 251 250 249 248 247 246 245 244 243 242)
         #vu8(255 254 253 252 251 250 249 248 247 246 245 244 243)
         #vu8(255 254 253 252 251 250 249 248 247 246 245 244)
         #vu8(255 254 253 252 251 250 249 248 247 246 245)
         #vu8(255 254 253 252 251 250 249 248 247 246)
         #vu8(255 254 253 252 251 250 249 248 247)
         #vu8(255 254 253 252 251 250 249 248)
         #vu8(255 254 253 252 251 250 249)
         #vu8(255 254 253 252 251 250)
         #vu8(255 254 253 252 251)
         #vu8(255 254 253 252)
         #vu8(255 254 253)
         #vu8(255 254)
         #vu8(255)
         #vu8()))
     (equal? (let ([a 1]
                   [c -3]
                   [d -4]
                   [e 5]
                   [f 6]
                   [h -8]
                   [k 11]
                   [l -12]
                   [p -16]
                   [q 17])
               (letrec-syntax
                 ([z (syntax-rules ()
                       [(_) (list (bytevector))]
                       [(_ x ... y) (cons (bytevector x ... y) (z x ...))])])
                 (z a 2 c d e f -7 h 9 -10 k l -13 -14 15 p q)))
       '(#vu8(1 2 253 252 5 6 249 248 9 246 11 244 243 242 15 240 17)
         #vu8(1 2 253 252 5 6 249 248 9 246 11 244 243 242 15 240)
         #vu8(1 2 253 252 5 6 249 248 9 246 11 244 243 242 15)
         #vu8(1 2 253 252 5 6 249 248 9 246 11 244 243 242)
         #vu8(1 2 253 252 5 6 249 248 9 246 11 244 243)
         #vu8(1 2 253 252 5 6 249 248 9 246 11 244)
         #vu8(1 2 253 252 5 6 249 248 9 246 11)
         #vu8(1 2 253 252 5 6 249 248 9 246)
         #vu8(1 2 253 252 5 6 249 248 9)
         #vu8(1 2 253 252 5 6 249 248)
         #vu8(1 2 253 252 5 6 249)
         #vu8(1 2 253 252 5 6)
         #vu8(1 2 253 252 5)
         #vu8(1 2 253 252)
         #vu8(1 2 253)
         #vu8(1 2)
         #vu8(1)
         #vu8()))
     (equal? (let ([a -1]
                   [c 3]
                   [d 4]
                   [e -5]
                   [f -6]
                   [h 8]
                   [k -11]
                   [l 12]
                   [p 16]
                   [q -17])
               (letrec-syntax
                 ([z (syntax-rules ()
                       [(_) (list (bytevector))]
                       [(_ x ... y) (cons (bytevector x ... y) (z x ...))])])
                 (z a -2 c d e f 7 h -9 10 k l 13 14 -15 p q)))
       '(#vu8(255 254 3 4 251 250 7 8 247 10 245 12 13 14 241 16 239)
         #vu8(255 254 3 4 251 250 7 8 247 10 245 12 13 14 241 16)
         #vu8(255 254 3 4 251 250 7 8 247 10 245 12 13 14 241)
         #vu8(255 254 3 4 251 250 7 8 247 10 245 12 13 14)
         #vu8(255 254 3 4 251 250 7 8 247 10 245 12 13)
         #vu8(255 254 3 4 251 250 7 8 247 10 245 12)
         #vu8(255 254 3 4 251 250 7 8 247 10 245)
         #vu8(255 254 3 4 251 250 7 8 247 10)
         #vu8(255 254 3 4 251 250 7 8 247)
         #vu8(255 254 3 4 251 250 7 8)
         #vu8(255 254 3 4 251 250 7)
         #vu8(255 254 3 4 251 250)
         #vu8(255 254 3 4 251)
         #vu8(255 254 3 4)
         #vu8(255 254 3)
         #vu8(255 254)
         #vu8(255)
         #vu8()))
     (equal? (apply bytevector (make-list 20000 #xc7))
             (u8-list->bytevector (make-list 20000 #xc7)))
     (let ([n0 1] [n1 -2] [n4 5])
       (let ([x (bytevector n0 n1 3 -4 n4)])
         (and (bytevector? x)
              (equal? (bytevector->s8-list x) '(1 -2 3 -4 5))
              (equal? (bytevector->u8-list x) '(1 254 3 252 5))
              (eqv? (bytevector-s8-ref x 0) 1)
              (eqv? (bytevector-u8-ref x 0) 1)
              (eqv? (bytevector-s8-ref x 1) -2)
              (eqv? (bytevector-u8-ref x 1) 254)
              (eqv? (bytevector-s8-ref x 2) 3)
              (eqv? (bytevector-u8-ref x 2) 3)
              (eqv? (bytevector-s8-ref x 3) -4)
              (eqv? (bytevector-u8-ref x 3) 252)
              (eqv? (bytevector-s8-ref x 4) 5)
              (eqv? (bytevector-u8-ref x 4) 5))))
     (begin
       (define $bv-f
         (lambda (a b c d e f g h i j k l m n o p q r s t u v w x y z)
           (letrec-syntax
             ([foo (syntax-rules ()
                     [(_) (list (bytevector))]
                     [(_ x ... y) (cons (bytevector x ... y) (foo x ...))])])
             (foo a b c d e f g h i j k l m n o p q r s t u v w x y z))))
       #t)
     (equal? ($bv-f 101
                    -102
                    103
                    -104
                    -105
                    106
                    107
                    -108
                    -109
                    -110
                    111
                    112
                    113
                    114
                    -115
                    -116
                    -117
                    -118
                    119
                    120
                    121
                    -122
                    -123
                    124
                    -125
                    126)
       '(#vu8(101 154 103 152 151 106 107 148 147 146 111 112 113 114 141
              140 139 138 119 120 121 134 133 124 131 126)
         #vu8(101 154 103 152 151 106 107 148 147 146 111 112 113 114 141
              140 139 138 119 120 121 134 133 124 131)
         #vu8(101 154 103 152 151 106 107 148 147 146 111 112 113 114 141
              140 139 138 119 120 121 134 133 124)
         #vu8(101 154 103 152 151 106 107 148 147 146 111 112 113 114 141
              140 139 138 119 120 121 134 133)
         #vu8(101 154 103 152 151 106 107 148 147 146 111 112 113 114 141
              140 139 138 119 120 121 134)
         #vu8(101 154 103 152 151 106 107 148 147 146 111 112 113 114 141
              140 139 138 119 120 121)
         #vu8(101 154 103 152 151 106 107 148 147 146 111 112 113 114 141
              140 139 138 119 120)
         #vu8(101 154 103 152 151 106 107 148 147 146 111 112 113 114 141
              140 139 138 119)
         #vu8(101 154 103 152 151 106 107 148 147 146 111 112 113 114 141
              140 139 138)
         #vu8(101 154 103 152 151 106 107 148 147 146 111 112 113 114 141
              140 139)
         #vu8(101 154 103 152 151 106 107 148 147 146 111 112 113 114 141
              140)
         #vu8(101 154 103 152 151 106 107 148 147 146 111 112 113 114 141)
         #vu8(101 154 103 152 151 106 107 148 147 146 111 112 113 114)
         #vu8(101 154 103 152 151 106 107 148 147 146 111 112 113)
         #vu8(101 154 103 152 151 106 107 148 147 146 111 112)
         #vu8(101 154 103 152 151 106 107 148 147 146 111)
         #vu8(101 154 103 152 151 106 107 148 147 146)
         #vu8(101 154 103 152 151 106 107 148 147)
         #vu8(101 154 103 152 151 106 107 148)
         #vu8(101 154 103 152 151 106 107)
         #vu8(101 154 103 152 151 106)
         #vu8(101 154 103 152 151)
         #vu8(101 154 103 152)
         #vu8(101 154 103)
         #vu8(101 154)
         #vu8(101)
         #vu8()))
     (begin
       (define $bv-g
         (lambda (a c e g i k m o q s u w y)
           (letrec-syntax
             ([foo (syntax-rules ()
                     [(_) (list (bytevector))]
                     [(_ x ... y) (cons (bytevector x ... y) (foo x ...))])])
             (foo a
                  -102
                  c
                  -104
                  e
                  106
                  g
                  -108
                  i
                  -110
                  k
                  112
                  m
                  114
                  o
                  -116
                  q
                  -118
                  s
                  120
                  u
                  -122
                  w
                  124
                  y
                  126))))
       #t)
     (equal? ($bv-g 101
                    103
                    -105
                    107
                    -109
                    111
                    113
                    -115
                    -117
                    119
                    121
                    -123
                    -125)
       '(#vu8(101 154 103 152 151 106 107 148 147 146 111 112 113 114 141
              140 139 138 119 120 121 134 133 124 131 126)
         #vu8(101 154 103 152 151 106 107 148 147 146 111 112 113 114 141
              140 139 138 119 120 121 134 133 124 131)
         #vu8(101 154 103 152 151 106 107 148 147 146 111 112 113 114 141
              140 139 138 119 120 121 134 133 124)
         #vu8(101 154 103 152 151 106 107 148 147 146 111 112 113 114 141
              140 139 138 119 120 121 134 133)
         #vu8(101 154 103 152 151 106 107 148 147 146 111 112 113 114 141
              140 139 138 119 120 121 134)
         #vu8(101 154 103 152 151 106 107 148 147 146 111 112 113 114 141
              140 139 138 119 120 121)
         #vu8(101 154 103 152 151 106 107 148 147 146 111 112 113 114 141
              140 139 138 119 120)
         #vu8(101 154 103 152 151 106 107 148 147 146 111 112 113 114 141
              140 139 138 119)
         #vu8(101 154 103 152 151 106 107 148 147 146 111 112 113 114 141
              140 139 138)
         #vu8(101 154 103 152 151 106 107 148 147 146 111 112 113 114 141
              140 139)
         #vu8(101 154 103 152 151 106 107 148 147 146 111 112 113 114 141
              140)
         #vu8(101 154 103 152 151 106 107 148 147 146 111 112 113 114 141)
         #vu8(101 154 103 152 151 106 107 148 147 146 111 112 113 114)
         #vu8(101 154 103 152 151 106 107 148 147 146 111 112 113)
         #vu8(101 154 103 152 151 106 107 148 147 146 111 112)
         #vu8(101 154 103 152 151 106 107 148 147 146 111)
         #vu8(101 154 103 152 151 106 107 148 147 146)
         #vu8(101 154 103 152 151 106 107 148 147)
         #vu8(101 154 103 152 151 106 107 148)
         #vu8(101 154 103 152 151 106 107)
         #vu8(101 154 103 152 151 106)
         #vu8(101 154 103 152 151)
         #vu8(101 154 103 152)
         #vu8(101 154 103)
         #vu8(101 154)
         #vu8(101)
         #vu8()))
     (begin
       (define $bv-h
         (lambda (b d f h j l n p r t v x z)
           (letrec-syntax
             ([foo (syntax-rules ()
                     [(_) (list (bytevector))]
                     [(_ x ... y) (cons (bytevector x ... y) (foo x ...))])])
             (foo 101
                  b
                  103
                  d
                  -105
                  f
                  107
                  h
                  -109
                  j
                  111
                  l
                  113
                  n
                  -115
                  p
                  -117
                  r
                  119
                  t
                  121
                  v
                  -123
                  x
                  -125
                  z))))
       #t)
     (equal? ($bv-h -102
                    -104
                    106
                    -108
                    -110
                    112
                    114
                    -116
                    -118
                    120
                    -122
                    124
                    126)
       '(#vu8(101 154 103 152 151 106 107 148 147 146 111 112 113 114 141
              140 139 138 119 120 121 134 133 124 131 126)
         #vu8(101 154 103 152 151 106 107 148 147 146 111 112 113 114 141
              140 139 138 119 120 121 134 133 124 131)
         #vu8(101 154 103 152 151 106 107 148 147 146 111 112 113 114 141
              140 139 138 119 120 121 134 133 124)
         #vu8(101 154 103 152 151 106 107 148 147 146 111 112 113 114 141
              140 139 138 119 120 121 134 133)
         #vu8(101 154 103 152 151 106 107 148 147 146 111 112 113 114 141
              140 139 138 119 120 121 134)
         #vu8(101 154 103 152 151 106 107 148 147 146 111 112 113 114 141
              140 139 138 119 120 121)
         #vu8(101 154 103 152 151 106 107 148 147 146 111 112 113 114 141
              140 139 138 119 120)
         #vu8(101 154 103 152 151 106 107 148 147 146 111 112 113 114 141
              140 139 138 119)
         #vu8(101 154 103 152 151 106 107 148 147 146 111 112 113 114 141
              140 139 138)
         #vu8(101 154 103 152 151 106 107 148 147 146 111 112 113 114 141
              140 139)
         #vu8(101 154 103 152 151 106 107 148 147 146 111 112 113 114 141
              140)
         #vu8(101 154 103 152 151 106 107 148 147 146 111 112 113 114 141)
         #vu8(101 154 103 152 151 106 107 148 147 146 111 112 113 114)
         #vu8(101 154 103 152 151 106 107 148 147 146 111 112 113)
         #vu8(101 154 103 152 151 106 107 148 147 146 111 112)
         #vu8(101 154 103 152 151 106 107 148 147 146 111)
         #vu8(101 154 103 152 151 106 107 148 147 146)
         #vu8(101 154 103 152 151 106 107 148 147)
         #vu8(101 154 103 152 151 106 107 148)
         #vu8(101 154 103 152 151 106 107)
         #vu8(101 154 103 152 151 106)
         #vu8(101 154 103 152 151)
         #vu8(101 154 103 152)
         #vu8(101 154 103)
         #vu8(101 154)
         #vu8(101)
         #vu8()))
     (begin
       (define $bv-i-ls* '())
       (define $bv-i
         (lambda (b d f h j l n p r t v x z)
           (define this)
           (define (init!)
             (set! $bv-i-ls* (cons '() $bv-i-ls*))
             (set! this 0))
           (define (bump!)
             (set! this (fx+ this 1))
             (set-car! $bv-i-ls* (cons this (car $bv-i-ls*))))
           (define-syntax plink
             (syntax-rules () [(_ x) (begin (bump!) x)]))
           (letrec-syntax
             ([foo (syntax-rules ()
                     [(_) (list (bytevector))]
                     [(_ x ... y)
                      (cons (begin
                              (init!)
                              (bytevector (plink x) ... (plink y)))
                            (foo x ...))])])
             (foo 101
                  b
                  103
                  d
                  -105
                  f
                  107
                  h
                  -109
                  j
                  111
                  l
                  113
                  n
                  -115
                  p
                  -117
                  r
                  119
                  t
                  121
                  v
                  -123
                  x
                  -125
                  z))))
       #t)
     (equal? ($bv-i -102
                    -104
                    106
                    -108
                    -110
                    112
                    114
                    -116
                    -118
                    120
                    -122
                    124
                    126)
       '(#vu8(101 154 103 152 151 106 107 148 147 146 111 112 113 114 141
              140 139 138 119 120 121 134 133 124 131 126)
         #vu8(101 154 103 152 151 106 107 148 147 146 111 112 113 114 141
              140 139 138 119 120 121 134 133 124 131)
         #vu8(101 154 103 152 151 106 107 148 147 146 111 112 113 114 141
              140 139 138 119 120 121 134 133 124)
         #vu8(101 154 103 152 151 106 107 148 147 146 111 112 113 114 141
              140 139 138 119 120 121 134 133)
         #vu8(101 154 103 152 151 106 107 148 147 146 111 112 113 114 141
              140 139 138 119 120 121 134)
         #vu8(101 154 103 152 151 106 107 148 147 146 111 112 113 114 141
              140 139 138 119 120 121)
         #vu8(101 154 103 152 151 106 107 148 147 146 111 112 113 114 141
              140 139 138 119 120)
         #vu8(101 154 103 152 151 106 107 148 147 146 111 112 113 114 141
              140 139 138 119)
         #vu8(101 154 103 152 151 106 107 148 147 146 111 112 113 114 141
              140 139 138)
         #vu8(101 154 103 152 151 106 107 148 147 146 111 112 113 114 141
              140 139)
         #vu8(101 154 103 152 151 106 107 148 147 146 111 112 113 114 141
              140)
         #vu8(101 154 103 152 151 106 107 148 147 146 111 112 113 114 141)
         #vu8(101 154 103 152 151 106 107 148 147 146 111 112 113 114)
         #vu8(101 154 103 152 151 106 107 148 147 146 111 112 113)
         #vu8(101 154 103 152 151 106 107 148 147 146 111 112)
         #vu8(101 154 103 152 151 106 107 148 147 146 111)
         #vu8(101 154 103 152 151 106 107 148 147 146)
         #vu8(101 154 103 152 151 106 107 148 147)
         #vu8(101 154 103 152 151 106 107 148)
         #vu8(101 154 103 152 151 106 107)
         #vu8(101 154 103 152 151 106)
         #vu8(101 154 103 152 151)
         #vu8(101 154 103 152)
         #vu8(101 154 103)
         #vu8(101 154)
         #vu8(101)
         #vu8()))
     (equal? (sort (lambda (ls1 ls2) (fx<= (length ls1) (length ls2)))
                   $bv-i-ls*)
       '((1)
         (2 1)
         (3 2 1)
         (4 3 2 1)
         (5 4 3 2 1)
         (6 5 4 3 2 1)
         (7 6 5 4 3 2 1)
         (8 7 6 5 4 3 2 1)
         (9 8 7 6 5 4 3 2 1)
         (10 9 8 7 6 5 4 3 2 1)
         (11 10 9 8 7 6 5 4 3 2 1)
         (12 11 10 9 8 7 6 5 4 3 2 1)
         (13 12 11 10 9 8 7 6 5 4 3 2 1)
         (14 13 12 11 10 9 8 7 6 5 4 3 2 1)
         (15 14 13 12 11 10 9 8 7 6 5 4 3 2 1)
         (16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1)
         (17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1)
         (18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1)
         (19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1)
         (20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1)
         (21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1)
         (22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1)
         (23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1)
         (24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1)
         (25 24
             23
             22
             21
             20
             19
             18
             17
             16
             15
             14
             13
             12
             11
             10
             9
             8
             7
             6
             5
             4
             3
             2
             1)
         (26 25
             24
             23
             22
             21
             20
             19
             18
             17
             16
             15
             14
             13
             12
             11
             10
             9
             8
             7
             6
             5
             4
             3
             2
             1))))

(mat bytevector-syntax
     (eq? #vu8() '#vu8())
     (eq? '#0vu8() #vu8())
     (equal? '(#vu8(1 2 3) #3vu8(1 2 3) #6vu8(1 2 3))
             (list (bytevector 1 2 3)
                   (bytevector 1 2 3)
                   (bytevector 1 2 3 3 3 3)))
     (let ([x (with-input-from-string "#10vu8()" read)])
       (and (= (bytevector-length x) 10)
            (andmap fixnum? (bytevector->u8-list x)))))

(mat bytevector-length
     ; wrong argument count
     (error? (bytevector-length))
     (error? (begin (bytevector-length #vu8() '#vu8()) #f))

     ; not a bytevector
     (error? (bytevector-length '(a b c)))
     (error? (begin (bytevector-length '(a b c)) #f))

     (eqv? (bytevector-length #vu8(3 252 5)) 3)
     (eqv? (bytevector-length '#100vu8(5 4 3)) 100)
     (eqv? (bytevector-length #vu8()) 0))

(mat $bytevector-ref-check?
     (let ([bv (make-bytevector 3)]
           [imm-bv (bytevector->immutable-bytevector (make-bytevector 3))]
           [not-bv (make-fxvector 3)])
       (let ([i-1 -1]
             [i0 0]
             [i1 1]
             [i2 2]
             [i3 3]
             [ifalse #f]
             [ibig (+ (most-positive-fixnum) 1)])
         (and (not (#%$bytevector-ref-check? 8 not-bv i0))
              (not (#%$bytevector-ref-check? 8 bv ifalse))
              (not (#%$bytevector-ref-check? 8 bv i-1))
              (not (#%$bytevector-ref-check? 8 imm-bv i-1))
              (#%$bytevector-ref-check? 8 bv 0)
              (#%$bytevector-ref-check? 8 bv 1)
              (#%$bytevector-ref-check? 8 bv 2)
              (#%$bytevector-ref-check? 8 imm-bv 0)
              (#%$bytevector-ref-check? 8 imm-bv 1)
              (#%$bytevector-ref-check? 8 imm-bv 2)
              (#%$bytevector-ref-check? 8 bv i0)
              (#%$bytevector-ref-check? 8 bv i1)
              (#%$bytevector-ref-check? 8 bv i2)
              (#%$bytevector-ref-check? 8 imm-bv i0)
              (#%$bytevector-ref-check? 8 imm-bv i1)
              (#%$bytevector-ref-check? 8 imm-bv i2)
              (not (#%$bytevector-ref-check? 8 bv 3))
              (not (#%$bytevector-ref-check? 8 bv i3))
              (not (#%$bytevector-ref-check? 8 bv ibig))
              (not (#%$bytevector-ref-check? 8 imm-bv 3))
              (not (#%$bytevector-ref-check? 8 imm-bv i3))
              (not (#%$bytevector-ref-check? 8 imm-bv ibig)))))
     (let ([n 128])
       (let ([bv (make-bytevector n)]
             [imm-bv (bytevector->immutable-bytevector (make-bytevector n))]
             [not-bv (make-fxvector n)])
         (and (let ([i 0])
                (and (not (#%$bytevector-ref-check? 8 not-bv i))
                     (not (#%$bytevector-ref-check? 16 not-bv i))
                     (not (#%$bytevector-ref-check? 32 not-bv i))
                     (not (#%$bytevector-ref-check? 64 not-bv i))))
              (let f ([i -1])
                (or (fx< i -8)
                    (and (not (#%$bytevector-ref-check? 8 bv i))
                         (not (#%$bytevector-ref-check? 16 bv i))
                         (not (#%$bytevector-ref-check? 32 bv i))
                         (not (#%$bytevector-ref-check? 64 bv i))
                         (not (#%$bytevector-ref-check? 8 imm-bv i))
                         (not (#%$bytevector-ref-check? 16 imm-bv i))
                         (not (#%$bytevector-ref-check? 32 imm-bv i))
                         (not (#%$bytevector-ref-check? 64 imm-bv i))
                         (f (fx* i 2)))))
              (let f ([i 0])
                (or (fx= i n)
                    (and (#%$bytevector-ref-check? 8 bv i)
                         (if (and (fx= (modulo i 2) 0) (fx<= (fx+ i 2) n))
                             (and (#%$bytevector-ref-check? 16 bv i)
                                  (#%$bytevector-ref-check? 16 imm-bv i))
                             (not (or (#%$bytevector-ref-check? 16 bv i)
                                      (#%$bytevector-ref-check? 16 imm-bv i))))
                         (if (and (fx= (modulo i 4) 0) (fx<= (fx+ i 4) n))
                             (and (#%$bytevector-ref-check? 32 bv i)
                                  (#%$bytevector-ref-check? 32 imm-bv i))
                             (not (or (#%$bytevector-ref-check? 32 bv i)
                                      (#%$bytevector-ref-check? 32 imm-bv i))))
                         (if (and (fx= (modulo i 8) 0) (fx<= (fx+ i 8) n))
                             (and (#%$bytevector-ref-check? 64 bv i)
                                  (#%$bytevector-ref-check? 64 imm-bv i))
                             (not (or (#%$bytevector-ref-check? 64 bv i)
                                      (#%$bytevector-ref-check? 64 imm-bv i))))
                         (f (fx+ i 1)))))
              (let ([i n])
                (and (not (#%$bytevector-ref-check? 8 bv i))
                     (not (#%$bytevector-ref-check? 16 bv i))
                     (not (#%$bytevector-ref-check? 32 bv i))
                     (not (#%$bytevector-ref-check? 64 bv i))
                     (not (#%$bytevector-ref-check? 8 imm-bv i))
                     (not (#%$bytevector-ref-check? 16 imm-bv i))
                     (not (#%$bytevector-ref-check? 32 imm-bv i))
                     (not (#%$bytevector-ref-check? 64 imm-bv i))))
              (let ([i (+ (most-positive-fixnum) 1)])
                (and (not (#%$bytevector-ref-check? 8 bv i))
                     (not (#%$bytevector-ref-check? 16 bv i))
                     (not (#%$bytevector-ref-check? 32 bv i))
                     (not (#%$bytevector-ref-check? 64 bv i))
                     (not (#%$bytevector-ref-check? 8 imm-bv i))
                     (not (#%$bytevector-ref-check? 16 imm-bv i))
                     (not (#%$bytevector-ref-check? 32 imm-bv i))
                     (not (#%$bytevector-ref-check? 64 imm-bv i))))))))

(mat bytevector-s8-ref
     ; wrong argument count
     (error? (bytevector-s8-ref))
     (error? (bytevector-s8-ref #vu8(3 252 5)))
     (error? (begin (bytevector-s8-ref #vu8(3 252 5) 0 5) #f))

     ; not a bytevector
     (error? (bytevector-s8-ref '#(3 -4 5) 2))
     (error? (begin (bytevector-s8-ref '(3 -4 5) 2) #f))

     ; invalid index
     (error? (bytevector-s8-ref #vu8(3 252 5) 3))
     (error? (bytevector-s8-ref #vu8(3 252 5) -1))
     (error? (begin (bytevector-s8-ref #vu8(3 252 5) 'a) #f))

     (eqv? (bytevector-s8-ref #vu8(3 252 5) 0) 3)
     (eqv? (bytevector-s8-ref #vu8(3 252 5) 1) -4)
     (eqv? (bytevector-s8-ref #vu8(3 252 5) 2) 5)
     (do ([n -128 (fx+ n 1)])
         ((fx= n 128) #t)
         (unless (eqv? (bytevector-s8-ref (bytevector 15 n 35) 1) n)
                 (errorf #f "wrong value for ~s" n)))
     (do ([n 128 (fx+ n 1)])
         ((fx= n 256) #t)
         (unless (eqv? (bytevector-s8-ref (bytevector 15 n 35) 1)
                       (- n 256))
                 (errorf #f "wrong value for ~s" n))))

(mat bytevector-u8-ref
     ; wrong argument count
     (error? (bytevector-u8-ref))
     (error? (bytevector-u8-ref #vu8(3 252 5)))
     (error? (begin (bytevector-u8-ref #vu8(3 252 5) 0 5) #f))

     ; not a bytevector
     (error? (bytevector-u8-ref '#(3 -4 5) 2))
     (error? (begin (bytevector-u8-ref '(3 -4 5) 2) #f))

     ; invalid index
     (error? (bytevector-u8-ref #vu8(3 252 5) 3))
     (error? (bytevector-u8-ref #vu8(3 252 5) -1))
     (error? (begin (bytevector-u8-ref #vu8(3 252 5) 'a) #f))

     (eqv? (bytevector-u8-ref #vu8(3 252 5) 0) 3)
     (eqv? (bytevector-u8-ref #vu8(3 252 5) 1) 252)
     (eqv? (bytevector-u8-ref #vu8(3 252 5) 2) 5)
     (do ([n -128 (fx+ n 1)])
         ((fx= n 0) #t)
         (unless (eqv? (bytevector-u8-ref (bytevector 15 n 35) 1)
                       (+ 256 n))
                 (errorf #f "wrong value for ~s" n)))
     (do ([n 0 (fx+ n 1)])
         ((fx= n 256) #t)
         (unless (eqv? (bytevector-u8-ref (bytevector 15 n 35) 1) n)
                 (errorf #f "wrong value for ~s" n))))

(mat bytevector-s8-set!
     (begin
       (define $v1 (bytevector 3 4 5))
       (and (bytevector? $v1) (equal? $v1 #vu8(3 4 5))))

     ; wrong argument count
     (error? (bytevector-s8-set!))
     (error? (bytevector-s8-set! $v1))
     (error? (bytevector-s8-set! $v1 2))
     (error? (begin (bytevector-s8-set! $v1 2 3 4) #f))

     ; not a bytevector
     (error? (bytevector-s8-set! (list 3 4 5) 2 3))
     (error? (begin (bytevector-s8-set! (list 3 4 5) 2 3) #f))

     ; invalid index
     (error? (bytevector-s8-set! $v1 3 3))
     (error? (bytevector-s8-set! $v1 -1 3))
     (error? (begin (bytevector-s8-set! $v1 'a 3) #f))

     ; invalid value
     (error? (bytevector-s8-set! $v1 2 -129))
     (error? (bytevector-s8-set! $v1 2 128))
     (error? (begin (bytevector-s8-set! $v1 0 'd) #f))

     ; make sure no damage done
     (and (bytevector? $v1) (equal? $v1 #vu8(3 4 5)))

     (let ((v (bytevector 3 4 5)))
       (and (begin (bytevector-s8-set! v 0 33) (equal? v #vu8(33 4 5)))
            (begin (bytevector-s8-set! v 1 -44) (equal? v #vu8(33 212 5)))
            (begin (bytevector-s8-set! v 2 55) (equal? v #vu8(33 212 55)))))
     (let ([v (bytevector 3 4 5)])
       (do ([n -128 (fx+ n 1)])
           ((fx= n 128) #t)
           (bytevector-s8-set! v 1 n)
           (unless (and (eqv? (bytevector-s8-ref v 0) 3)
                        (eqv? (bytevector-s8-ref v 1) n)
                        (eqv? (bytevector-s8-ref v 2) 5))
                   (errorf #f "wrong value for ~s" n)))))

(mat bytevector-u8-set!
     (begin
       (define $v1 (bytevector 3 4 5))
       (and (bytevector? $v1) (equal? $v1 #vu8(3 4 5))))

     ; wrong argument count
     (error? (bytevector-u8-set!))
     (error? (bytevector-u8-set! $v1))
     (error? (bytevector-u8-set! $v1 2))
     (error? (begin (bytevector-u8-set! $v1 2 3 4) #f))

     ; not a bytevector
     (error? (bytevector-u8-set! (list 3 4 5) 2 3))
     (error? (begin (bytevector-u8-set! (list 3 4 5) 2 3) #f))

     ; invalid index
     (error? (bytevector-u8-set! $v1 3 3))
     (error? (bytevector-u8-set! $v1 -1 3))
     (error? (begin (bytevector-u8-set! $v1 'a 3) #f))

     ; invalid value
     (error? (bytevector-u8-set! $v1 2 -1))
     (error? (bytevector-u8-set! $v1 0 256))
     (error? (begin (bytevector-u8-set! $v1 0 'd) #f))

     ; make sure no damage done
     (and (bytevector? $v1) (equal? $v1 #vu8(3 4 5)))

     (let ((v (bytevector 3 4 5)))
       (and (begin (bytevector-u8-set! v 0 33) (equal? v #vu8(33 4 5)))
            (begin (bytevector-u8-set! v 1 128) (equal? v #vu8(33 128 5)))
            (begin (bytevector-u8-set! v 2 55) (equal? v #vu8(33 128 55)))))
     (let ([v (bytevector 3 4 5)])
       (do ([n 0 (fx+ n 1)])
           ((fx= n 256) #t)
           (bytevector-u8-set! v 1 n)
           (unless (and (eqv? (bytevector-u8-ref v 0) 3)
                        (eqv? (bytevector-u8-ref v 1) n)
                        (eqv? (bytevector-u8-ref v 2) 5))
                   (errorf #f "wrong value for ~s" n)))))

(module (big-endian->signed
          little-endian->signed
          native->signed
          big-endian->unsigned
          little-endian->unsigned
          native->unsigned)
  (define (signed n) (if (>= n 128) (- n 256) n))

  (define (big-endian->signed . args)
    (let f ([args (cdr args)] [a (signed (car args))])
      (if (null? args)
          a
          (f (cdr args) (logor (ash a 8) (car args))))))

  (define (little-endian->signed . args)
    (let f ([args args])
      (if (null? (cdr args))
          (signed (car args))
          (logor (ash (f (cdr args)) 8) (car args)))))

  (define (native->signed . args)
    (case (native-endianness)
      [(big) (apply big-endian->signed args)]
      [(little) (apply little-endian->signed args)]
      [else
       (errorf 'native->signed "unhandled endianness ~s"
               (native-endianness))]))

  (define (big-endian->unsigned . args)
    (let f ([args (cdr args)] [a (car args)])
      (if (null? args)
          a
          (f (cdr args) (logor (ash a 8) (car args))))))

  (define (little-endian->unsigned . args)
    (let f ([args args])
      (if (null? args)
          0
          (logor (ash (f (cdr args)) 8) (car args)))))

  (define (native->unsigned . args)
    (case (native-endianness)
      [(big) (apply big-endian->unsigned args)]
      [(little) (apply little-endian->unsigned args)]
      [else
       (errorf 'native->unsigned "unhandled endianness ~s"
               (native-endianness))])))

(mat bytevector-s16-native-ref
     ; wrong argument count
     (error? (bytevector-s16-native-ref))
     (error? (bytevector-s16-native-ref #vu8(3 252 5)))
     (error? (begin (bytevector-s16-native-ref #vu8(3 252 5) 0 0) #f))

     ; not a bytevector
     (error? (bytevector-s16-native-ref '#(3 252 5) 0))
     (error? (begin (bytevector-s16-native-ref '#(3 252 5) 0) #f))

     ; invalid index
     (error? (bytevector-s16-native-ref #vu8(3 252 5) -1))
     (error? (bytevector-s16-native-ref #vu8(3 252 5) 1))
     (error? (bytevector-s16-native-ref #vu8(3 252 5) 2))
     (error? (bytevector-s16-native-ref #vu8(3 252 5) 3))
     (error? (begin (bytevector-s16-native-ref #vu8(3 252 5) 4.0) #f))

     (eqv? (bytevector-s16-native-ref #vu8(3 252 5) 0)
           (native->signed 3 252))
     (equal? (let ([v #vu8(3 252 5 17 23 55 250 89 200 201 128)] [i 4])
               (list (bytevector-s16-native-ref v 0)
                     (bytevector-s16-native-ref v 2)
                     (bytevector-s16-native-ref v 4)
                     (bytevector-s16-native-ref v i)
                     (bytevector-s16-native-ref v 6)
                     (bytevector-s16-native-ref v 8)))
             (list (native->signed 3 252)
                   (native->signed 5 17)
                   (native->signed 23 55)
                   (native->signed 23 55)
                   (native->signed 250 89)
                   (native->signed 200 201)))

     (test-cp0-expansion eqv?
       '(bytevector-s16-native-ref #vu8(3 252 5) 0)
       (native->signed 3 252))
     (equal? ;; list doesn't get inlined, so take if off the front of the list
       (cdr (parameterize
              ([optimize-level 2]
               [enable-cp0 #t]
               [#%$suppress-primitive-inlining #f])
              (expand/optimize
                '(let ([v #vu8(3 252 5 17 23 55 250 89 200 201 128)] [i 4])
                   (list (bytevector-s16-native-ref v 0)
                         (bytevector-s16-native-ref v 2)
                         (bytevector-s16-native-ref v 4)
                         (bytevector-s16-native-ref v i)
                         (bytevector-s16-native-ref v 6)
                         (bytevector-s16-native-ref v 8))))))
       (list (native->signed 3 252)
             (native->signed 5 17)
             (native->signed 23 55)
             (native->signed 23 55)
             (native->signed 250 89)
             (native->signed 200 201)))

     (do ([i 0 (fx+ i 1)])
         ((fx= i (expt 2 8)) #t)
         (do ([j 0 (fx+ j 1)])
             ((fx= j (expt 2 8)))
             (unless (eqv? (bytevector-s16-native-ref (bytevector i j) 0)
                           (native->signed i j))
                     (errorf #f "failed for ~s and ~s" i j)))))

(mat bytevector-u16-native-ref
     ; wrong argument count
     (error? (bytevector-u16-native-ref))
     (error? (bytevector-u16-native-ref #vu8(3 252 5)))
     (error? (begin (bytevector-u16-native-ref #vu8(3 252 5) 0 0) #f))

     ; not a bytevector
     (error? (bytevector-u16-native-ref '#(3 252 5) 0))
     (error? (begin (bytevector-u16-native-ref '#(3 252 5) 0) #f))

     ; invalid index
     (error? (bytevector-u16-native-ref #vu8(3 252 5) -1))
     (error? (bytevector-u16-native-ref #vu8(3 252 5) 1))
     (error? (bytevector-u16-native-ref #vu8(3 252 5) 2))
     (error? (bytevector-u16-native-ref #vu8(3 252 5) 3))
     (error? (begin (bytevector-u16-native-ref #vu8(3 252 5) 4.0) #f))

     (eqv? (bytevector-u16-native-ref #vu8(3 252 5) 0)
           (native->unsigned 3 252))
     (equal? (let ([v #vu8(3 252 5 17 23 55 250 89 200 201 128)] [i 4])
               (list (bytevector-u16-native-ref v 0)
                     (bytevector-u16-native-ref v 2)
                     (bytevector-u16-native-ref v 4)
                     (bytevector-u16-native-ref v i)
                     (bytevector-u16-native-ref v 6)
                     (bytevector-u16-native-ref v 8)))
             (list (native->unsigned 3 252)
                   (native->unsigned 5 17)
                   (native->unsigned 23 55)
                   (native->unsigned 23 55)
                   (native->unsigned 250 89)
                   (native->unsigned 200 201)))

     (test-cp0-expansion eqv?
       '(bytevector-u16-native-ref #vu8(3 252 5) 0)
       (native->unsigned 3 252))
     (equal? ;; list doesn't get inlined, so take if off the front of the list
       (cdr (parameterize
              ([optimize-level 2]
               [enable-cp0 #t]
               [#%$suppress-primitive-inlining #f])
              (expand/optimize
                '(let ([v #vu8(3 252 5 17 23 55 250 89 200 201 128)] [i 4])
                   (list (bytevector-u16-native-ref v 0)
                         (bytevector-u16-native-ref v 2)
                         (bytevector-u16-native-ref v 4)
                         (bytevector-u16-native-ref v i)
                         (bytevector-u16-native-ref v 6)
                         (bytevector-u16-native-ref v 8))))))
       (list (native->unsigned 3 252)
             (native->unsigned 5 17)
             (native->unsigned 23 55)
             (native->unsigned 23 55)
             (native->unsigned 250 89)
             (native->unsigned 200 201)))

     (do ([i 0 (fx+ i 1)])
         ((fx= i (expt 2 8)) #t)
         (do ([j 0 (fx+ j 1)])
             ((fx= j (expt 2 8)))
             (unless (eqv? (bytevector-u16-native-ref (bytevector i j) 0)
                           (native->unsigned i j))
                     (errorf #f "failed for ~s and ~s" i j)))))

(mat bytevector-s16-native-set!
     (begin
       (define $v1 (make-bytevector 11 #xad))
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad))))

     ; wrong argument count
     (error? (bytevector-s16-native-set!))
     (error? (bytevector-s16-native-set! $v1))
     (error? (bytevector-s16-native-set! $v1 0))
     (error? (begin (bytevector-s16-native-set! $v1 0 0 15) #f))

     ; not a bytevector
     (error? (bytevector-s16-native-set! (make-vector 10) 0 0))
     (error? (begin (bytevector-s16-native-set! (make-vector 10) 0 0) #f))

     ; invalid index
     (error? (bytevector-s16-native-set! $v1 -1 0))
     (error? (bytevector-s16-native-set! $v1 1 0))
     (error? (bytevector-s16-native-set! $v1 3 0))
     (error? (bytevector-s16-native-set! $v1 5 0))
     (error? (bytevector-s16-native-set! $v1 7 0))
     (error? (bytevector-s16-native-set! $v1 9 0))
     (error? (bytevector-s16-native-set! $v1 11 0))
     (error? (begin (bytevector-s16-native-set! $v1 'q 0) #f))

     ; invalid value
     (error? (bytevector-s16-native-set! $v1 0 #x8000))
     (error? (bytevector-s16-native-set! $v1 2 #x-8001))
     (error? (begin (bytevector-s16-native-set! $v1 4 "hello") #f))

     ; make sure no damage done
     (and (bytevector? $v1)
          (equal? $v1
            #vu8(#xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad)))

     (begin
       (bytevector-s16-native-set! $v1 0 -1)
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#xff #xff #xad #xad #xad #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-s16-native-set! $v1 0 (native->signed #x80 #x00))
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#x80 #x00 #xad #xad #xad #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-s16-native-set! $v1 0 (native->signed #x00 #x80))
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#x00 #x80 #xad #xad #xad #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-s16-native-set! $v1 0 (native->signed #x7f #xff))
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#x7f #xff #xad #xad #xad #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-s16-native-set! $v1 0 (native->signed #xff #x7f))
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#xff #x7f #xad #xad #xad #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-s16-native-set! $v1 0 (native->signed #xff #xff))
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#xff #xff #xad #xad #xad #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-s16-native-set! $v1 0 #x0000)
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(0 0 #xad #xad #xad #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-s16-native-set! $v1 2 (native->signed #xf3 #x45))
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(0 0 #xf3 #x45 #xad #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-s16-native-set! $v1 4 (native->signed #x23 #xc7))
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(0 0 #xf3 #x45 #x23 #xc7 #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-s16-native-set! $v1 6 (native->signed #x3a #x1c))
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(0 0 #xf3 #x45 #x23 #xc7 #x3a #x1c #xad #xad #xad))))
     (begin
       (bytevector-s16-native-set! $v1 8 (native->signed #xe3 #xd7))
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(0 0 #xf3 #x45 #x23 #xc7 #x3a #x1c #xe3 #xd7 #xad))))

     (let ([v (bytevector #xc7 #xc7)])
       (do ([i 0 (fx+ i 1)])
           ((fx= i (expt 2 8)) #t)
           (do ([j 0 (fx+ j 1)])
               ((fx= j (expt 2 8)))
               (bytevector-s16-native-set! v 0 (native->signed i j))
               (unless (equal? v (bytevector i j))
                       (errorf #f "failed for ~s and ~s" i j))))))

(mat bytevector-u16-native-set!
     (begin
       (define $v1 (make-bytevector 11 #xad))
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad))))

     ; wrong argument count
     (error? (bytevector-u16-native-set!))
     (error? (bytevector-u16-native-set! $v1))
     (error? (bytevector-u16-native-set! $v1 0))
     (error? (begin (bytevector-u16-native-set! $v1 0 0 15) #f))

     ; not a bytevector
     (error? (bytevector-u16-native-set! (make-vector 10) 0 0))
     (error? (begin (bytevector-u16-native-set! (make-vector 10) 0 0) #f))

     ; invalid index
     (error? (bytevector-u16-native-set! $v1 -1 0))
     (error? (bytevector-u16-native-set! $v1 1 0))
     (error? (bytevector-u16-native-set! $v1 3 0))
     (error? (bytevector-u16-native-set! $v1 5 0))
     (error? (bytevector-u16-native-set! $v1 7 0))
     (error? (bytevector-u16-native-set! $v1 9 0))
     (error? (bytevector-u16-native-set! $v1 11 0))
     (error? (begin (bytevector-u16-native-set! $v1 'q 0) #f))

     ; invalid value
     (error? (bytevector-u16-native-set! $v1 0 #x10000))
     (error? (bytevector-u16-native-set! $v1 2 #x-1))
     (error? (begin (bytevector-u16-native-set! $v1 4 "hello") #f))

     ; make sure no damage done
     (and (bytevector? $v1)
          (equal? $v1
            #vu8(#xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad)))

     (begin
       (bytevector-u16-native-set! $v1 0 #xffff)
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#xff #xff #xad #xad #xad #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-u16-native-set! $v1 0 (native->unsigned #x80 #x00))
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#x80 #x00 #xad #xad #xad #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-u16-native-set! $v1 0 (native->unsigned #x00 #x80))
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#x00 #x80 #xad #xad #xad #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-u16-native-set! $v1 0 (native->unsigned #x7f #xff))
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#x7f #xff #xad #xad #xad #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-u16-native-set! $v1 0 (native->unsigned #xff #x7f))
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#xff #x7f #xad #xad #xad #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-u16-native-set! $v1 0 (native->unsigned #xff #xff))
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#xff #xff #xad #xad #xad #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-u16-native-set! $v1 0 #x0000)
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(0 0 #xad #xad #xad #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-u16-native-set! $v1 2 (native->unsigned #xf3 #x45))
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(0 0 #xf3 #x45 #xad #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-u16-native-set! $v1 4 (native->unsigned #x23 #xc7))
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(0 0 #xf3 #x45 #x23 #xc7 #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-u16-native-set! $v1 6 (native->unsigned #x3a #x1c))
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(0 0 #xf3 #x45 #x23 #xc7 #x3a #x1c #xad #xad #xad))))
     (begin
       (bytevector-u16-native-set! $v1 8 (native->unsigned #xe3 #xd7))
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(0 0 #xf3 #x45 #x23 #xc7 #x3a #x1c #xe3 #xd7 #xad))))

     (let ([v (bytevector #xc7 #xc7)])
       (do ([i 0 (fx+ i 1)])
           ((fx= i (expt 2 8)) #t)
           (do ([j 0 (fx+ j 1)])
               ((fx= j (expt 2 8)))
               (bytevector-u16-native-set! v 0 (native->unsigned i j))
               (unless (equal? v (bytevector i j))
                       (errorf #f "failed for ~s and ~s" i j))))))

(mat bytevector-s16-ref
     ; wrong argument count
     (error? (bytevector-s16-ref))
     (error? (bytevector-s16-ref #vu8(3 252 5)))
     (error? (begin (bytevector-s16-ref #vu8(3 252 5) 0 0 'big) #f))

     ; not a bytevector
     (error? (bytevector-s16-ref '#(3 252 5) 0 'big))
     (error? (begin (bytevector-s16-ref '#(3 252 5) 0 'big) #f))

     ; invalid index
     (error? (bytevector-s16-ref #vu8(3 252 5) -1 (native-endianness)))
     (error? (bytevector-s16-ref #vu8(3 252 5) 2 'big))
     (error? (bytevector-s16-ref #vu8(3 252 5) 3 'little))
     (error? (begin (bytevector-s16-ref #vu8(3 252 5) 4.0 'big) #f))

     ; invalid endianness
     (error? (bytevector-s16-ref #vu8(3 252 5) 0 'bigger))
     (error? (bytevector-s16-ref #vu8(3 252 5) 0 "little"))
     (error? (begin (bytevector-s16-ref #vu8(3 252 5) 0 #t) #f))

     ; aligned accesses, endianness native
     (eqv? (bytevector-s16-ref #vu8(3 252 5) 0 (native-endianness))
           (native->signed 3 252))
     (equal? (let ([v #vu8(3 252 5 17 23 55 250 89 200 201 128)] [i 4])
               (list (bytevector-s16-ref v 0 (native-endianness))
                     (bytevector-s16-ref v 2 (native-endianness))
                     (bytevector-s16-ref v 4 (native-endianness))
                     (bytevector-s16-ref v i (native-endianness))
                     (bytevector-s16-ref v 6 (native-endianness))
                     (bytevector-s16-ref v 8 (native-endianness))))
             (list (native->signed 3 252)
                   (native->signed 5 17)
                   (native->signed 23 55)
                   (native->signed 23 55)
                   (native->signed 250 89)
                   (native->signed 200 201)))

     (do ([i 0 (fx+ i 1)])
         ((fx= i (expt 2 8)) #t)
         (do ([j 0 (fx+ j 1)])
             ((fx= j (expt 2 8)))
             (unless (eqv? (bytevector-s16-ref
                             (bytevector i j)
                             0
                             (native-endianness))
                           (native->signed i j))
                     (errorf #f "failed for ~s and ~s" i j))))

     ; aligned accesses, endianness big
     (eqv? (bytevector-s16-ref #vu8(3 252 5) 0 'big)
           (big-endian->signed 3 252))
     (equal? (let ([v #vu8(3 252 5 17 23 55 250 89 200 201 128)] [i 4])
               (list (bytevector-s16-ref v 0 'big)
                     (bytevector-s16-ref v 2 'big)
                     (bytevector-s16-ref v 4 'big)
                     (bytevector-s16-ref v i 'big)
                     (bytevector-s16-ref v 6 'big)
                     (bytevector-s16-ref v 8 'big)))
             (list (big-endian->signed 3 252)
                   (big-endian->signed 5 17)
                   (big-endian->signed 23 55)
                   (big-endian->signed 23 55)
                   (big-endian->signed 250 89)
                   (big-endian->signed 200 201)))

     (do ([i 0 (fx+ i 1)])
         ((fx= i (expt 2 8)) #t)
         (do ([j 0 (fx+ j 1)])
             ((fx= j (expt 2 8)))
             (unless (eqv? (bytevector-s16-ref (bytevector i j) 0 'big)
                           (big-endian->signed i j))
                     (errorf #f "failed for ~s and ~s" i j))))

     ; aligned accesses, endianness little
     (eqv? (bytevector-s16-ref #vu8(3 252 5) 0 'little)
           (little-endian->signed 3 252))
     (equal? (let ([v #vu8(3 252 5 17 23 55 250 89 200 201 128)] [i 4])
               (list (bytevector-s16-ref v 0 'little)
                     (bytevector-s16-ref v 2 'little)
                     (bytevector-s16-ref v 4 'little)
                     (bytevector-s16-ref v i 'little)
                     (bytevector-s16-ref v 6 'little)
                     (bytevector-s16-ref v 8 'little)))
             (list (little-endian->signed 3 252)
                   (little-endian->signed 5 17)
                   (little-endian->signed 23 55)
                   (little-endian->signed 23 55)
                   (little-endian->signed 250 89)
                   (little-endian->signed 200 201)))

     (do ([i 0 (fx+ i 1)])
         ((fx= i (expt 2 8)) #t)
         (do ([j 0 (fx+ j 1)])
             ((fx= j (expt 2 8)))
             (unless (eqv? (bytevector-s16-ref (bytevector i j) 0 'little)
                           (little-endian->signed i j))
                     (errorf #f "failed for ~s and ~s" i j))))

     ; unaligned accesses, endianness mixed
     (eqv? (bytevector-s16-ref #vu8(3 252 5) 1 (native-endianness))
           (native->signed 252 5))
     (equal? (let ([v #vu8(3 252 5 17 23 55 250 89 200 201 128)] [i 5])
               (list (bytevector-s16-ref v 1 (native-endianness))
                     (bytevector-s16-ref v 3 'little)
                     (bytevector-s16-ref v 5 'big)
                     (bytevector-s16-ref v i 'big)
                     (bytevector-s16-ref v 7 'little)
                     (bytevector-s16-ref v 9 (native-endianness))))
             (list (native->signed 252 5)
                   (little-endian->signed 17 23)
                   (big-endian->signed 55 250)
                   (big-endian->signed 55 250)
                   (little-endian->signed 89 200)
                   (native->signed 201 128)))

     (do ([i 0 (fx+ i 1)])
         ((fx= i (expt 2 8)) #t)
         (do ([j 0 (fx+ j 1)])
             ((fx= j (expt 2 8)))
             (unless (eqv? (bytevector-s16-ref (bytevector 0 i j) 1 'little)
                           (little-endian->signed i j))
                     (errorf #f "failed for ~s and ~s (little)" i j))
             (unless (eqv? (bytevector-s16-ref (bytevector 0 i j) 1 'big)
                           (big-endian->signed i j))
                     (errorf #f "failed for ~s and ~s (big)" i j))
             (unless (eqv? (bytevector-s16-ref
                             (bytevector 0 i j)
                             1
                             (native-endianness))
                           (native->signed i j))
                     (errorf #f "failed for ~s and ~s (native)" i j)))))

(mat bytevector-u16-ref
     ; wrong argument count
     (error? (bytevector-u16-ref))
     (error? (bytevector-u16-ref #vu8(3 252 5)))
     (error? (begin (bytevector-u16-ref #vu8(3 252 5) 0 0 'big) #f))

     ; not a bytevector
     (error? (bytevector-u16-ref '#(3 252 5) 0 'big))
     (error? (begin (bytevector-u16-ref '#(3 252 5) 0 'big) #f))

     ; invalid index
     (error? (bytevector-u16-ref #vu8(3 252 5) -1 (native-endianness)))
     (error? (bytevector-u16-ref #vu8(3 252 5) 2 'little))
     (error? (bytevector-u16-ref #vu8(3 252 5) 3 'big))
     (error? (begin (bytevector-u16-ref #vu8(3 252 5) 4.0 'little) #f))

     ; invalid endianness
     (error? (bytevector-u16-ref #vu8(3 252 5) 0 'bigger))
     (error? (bytevector-u16-ref #vu8(3 252 5) 0 "little"))
     (error? (begin (bytevector-u16-ref #vu8(3 252 5) 0 #t) #f))

     ; aligned accesses, endianness native
     (eqv? (bytevector-u16-ref #vu8(3 252 5) 0 (native-endianness))
           (native->unsigned 3 252))
     (equal? (let ([v #vu8(3 252 5 17 23 55 250 89 200 201 128)] [i 4])
               (list (bytevector-u16-ref v 0 (native-endianness))
                     (bytevector-u16-ref v 2 (native-endianness))
                     (bytevector-u16-ref v 4 (native-endianness))
                     (bytevector-u16-ref v i (native-endianness))
                     (bytevector-u16-ref v 6 (native-endianness))
                     (bytevector-u16-ref v 8 (native-endianness))))
             (list (native->unsigned 3 252)
                   (native->unsigned 5 17)
                   (native->unsigned 23 55)
                   (native->unsigned 23 55)
                   (native->unsigned 250 89)
                   (native->unsigned 200 201)))

     (do ([i 0 (fx+ i 1)])
         ((fx= i (expt 2 8)) #t)
         (do ([j 0 (fx+ j 1)])
             ((fx= j (expt 2 8)))
             (unless (eqv? (bytevector-u16-ref
                             (bytevector i j)
                             0
                             (native-endianness))
                           (native->unsigned i j))
                     (errorf #f "failed for ~s and ~s" i j))))

     ; aligned accesses, endianness big
     (eqv? (bytevector-u16-ref #vu8(3 252 5) 0 'big)
           (big-endian->unsigned 3 252))
     (equal? (let ([v #vu8(3 252 5 17 23 55 250 89 200 201 128)] [i 4])
               (list (bytevector-u16-ref v 0 'big)
                     (bytevector-u16-ref v 2 'big)
                     (bytevector-u16-ref v 4 'big)
                     (bytevector-u16-ref v i 'big)
                     (bytevector-u16-ref v 6 'big)
                     (bytevector-u16-ref v 8 'big)))
             (list (big-endian->unsigned 3 252)
                   (big-endian->unsigned 5 17)
                   (big-endian->unsigned 23 55)
                   (big-endian->unsigned 23 55)
                   (big-endian->unsigned 250 89)
                   (big-endian->unsigned 200 201)))

     (do ([i 0 (fx+ i 1)])
         ((fx= i (expt 2 8)) #t)
         (do ([j 0 (fx+ j 1)])
             ((fx= j (expt 2 8)))
             (unless (eqv? (bytevector-u16-ref (bytevector i j) 0 'big)
                           (big-endian->unsigned i j))
                     (errorf #f "failed for ~s and ~s" i j))))

     ; aligned accesses, endianness little
     (eqv? (bytevector-u16-ref #vu8(3 252 5) 0 'little)
           (little-endian->unsigned 3 252))
     (equal? (let ([v #vu8(3 252 5 17 23 55 250 89 200 201 128)] [i 4])
               (list (bytevector-u16-ref v 0 'little)
                     (bytevector-u16-ref v 2 'little)
                     (bytevector-u16-ref v 4 'little)
                     (bytevector-u16-ref v i 'little)
                     (bytevector-u16-ref v 6 'little)
                     (bytevector-u16-ref v 8 'little)))
             (list (little-endian->unsigned 3 252)
                   (little-endian->unsigned 5 17)
                   (little-endian->unsigned 23 55)
                   (little-endian->unsigned 23 55)
                   (little-endian->unsigned 250 89)
                   (little-endian->unsigned 200 201)))

     (do ([i 0 (fx+ i 1)])
         ((fx= i (expt 2 8)) #t)
         (do ([j 0 (fx+ j 1)])
             ((fx= j (expt 2 8)))
             (unless (eqv? (bytevector-u16-ref (bytevector i j) 0 'little)
                           (little-endian->unsigned i j))
                     (errorf #f "failed for ~s and ~s" i j))))

     ; unaligned accesses, endianness mixed
     (eqv? (bytevector-u16-ref #vu8(3 252 5) 1 (native-endianness))
           (native->unsigned 252 5))
     (equal? (let ([v #vu8(3 252 5 17 23 55 250 89 200 201 128)] [i 5])
               (list (bytevector-u16-ref v 1 (native-endianness))
                     (bytevector-u16-ref v 3 'little)
                     (bytevector-u16-ref v 5 'big)
                     (bytevector-u16-ref v i 'big)
                     (bytevector-u16-ref v 7 'little)
                     (bytevector-u16-ref v 9 (native-endianness))))
             (list (native->unsigned 252 5)
                   (little-endian->unsigned 17 23)
                   (big-endian->unsigned 55 250)
                   (big-endian->unsigned 55 250)
                   (little-endian->unsigned 89 200)
                   (native->unsigned 201 128)))

     (do ([i 0 (fx+ i 1)])
         ((fx= i (expt 2 8)) #t)
         (do ([j 0 (fx+ j 1)])
             ((fx= j (expt 2 8)))
             (unless (eqv? (bytevector-u16-ref (bytevector 0 i j) 1 'little)
                           (little-endian->unsigned i j))
                     (errorf #f "failed for ~s and ~s (little)" i j))
             (unless (eqv? (bytevector-u16-ref (bytevector 0 i j) 1 'big)
                           (big-endian->unsigned i j))
                     (errorf #f "failed for ~s and ~s (big)" i j))
             (unless (eqv? (bytevector-u16-ref
                             (bytevector 0 i j)
                             1
                             (native-endianness))
                           (native->unsigned i j))
                     (errorf #f "failed for ~s and ~s (native)" i j)))))

(mat bytevector-s16-set!
     (begin
       (define $v1 (make-bytevector 11 #xad))
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad))))

     ; wrong argument count
     (error? (bytevector-s16-set!))
     (error? (bytevector-s16-set! $v1))
     (error? (bytevector-s16-set! $v1 0 0))
     (error? (begin (bytevector-s16-set! $v1 0 0 0 (native-endianness)) #f))

     ; not a bytevector
     (error? (bytevector-s16-set! (make-vector 10) 0 0 'big))
     (error? (begin (bytevector-s16-set! (make-vector 10) 0 0 'big) #f))

     ; invalid index
     (error? (bytevector-s16-set! $v1 -1 0 (native-endianness)))
     (error? (bytevector-s16-set! $v1 10 0 (native-endianness)))
     (error? (bytevector-s16-set! $v1 11 0 'big))
     (error? (begin (bytevector-s16-set! $v1 'q 0 'little) #f))

     ; invalid value
     (error? (bytevector-s16-set! $v1 0 #x8000 (native-endianness)))
     (error? (bytevector-s16-set! $v1 1 #x8000 (native-endianness)))
     (error? (bytevector-s16-set! $v1 2 #x-8001 'big))
     (error? (bytevector-s16-set! $v1 3 #x-8001 'big))
     (error? (bytevector-s16-set! $v1 4 "hello" 'little))
     (error? (begin (bytevector-s16-set! $v1 5 "hello" 'little) #f))

     ; invalid endianness
     (error? (bytevector-s16-set! $v1 0 0 'bigger))
     (error? (bytevector-s16-set! $v1 0 0 "little"))
     (error? (begin (bytevector-s16-set! $v1 0 0 #t) #f))

     ; make sure no damage done
     (and (bytevector? $v1)
          (equal? $v1
            #vu8(#xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad)))

     ; aligned accesses, endianness native
     (begin
       (bytevector-s16-set! $v1 0 -1 (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#xff #xff #xad #xad #xad #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-s16-set!
         $v1
         0
         (native->signed #x80 #x00)
         (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#x80 #x00 #xad #xad #xad #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-s16-set!
         $v1
         0
         (native->signed #x00 #x80)
         (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#x00 #x80 #xad #xad #xad #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-s16-set!
         $v1
         0
         (native->signed #x7f #xff)
         (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#x7f #xff #xad #xad #xad #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-s16-set!
         $v1
         0
         (native->signed #xff #x7f)
         (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#xff #x7f #xad #xad #xad #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-s16-set!
         $v1
         0
         (native->signed #xff #xff)
         (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#xff #xff #xad #xad #xad #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-s16-set! $v1 0 #x0000 (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(0 0 #xad #xad #xad #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-s16-set!
         $v1
         2
         (native->signed #xf3 #x45)
         (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(0 0 #xf3 #x45 #xad #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-s16-set!
         $v1
         4
         (native->signed #x23 #xc7)
         (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(0 0 #xf3 #x45 #x23 #xc7 #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-s16-set!
         $v1
         6
         (native->signed #x3a #x1c)
         (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(0 0 #xf3 #x45 #x23 #xc7 #x3a #x1c #xad #xad #xad))))
     (begin
       (bytevector-s16-set!
         $v1
         8
         (native->signed #xe3 #xd7)
         (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(0 0 #xf3 #x45 #x23 #xc7 #x3a #x1c #xe3 #xd7 #xad))))

     (let ([v (bytevector #xc7 #xc7)])
       (do ([i 0 (fx+ i 1)])
           ((fx= i (expt 2 8)) #t)
           (do ([j 0 (fx+ j 1)])
               ((fx= j (expt 2 8)))
               (bytevector-s16-set!
                 v
                 0
                 (native->signed i j)
                 (native-endianness))
               (unless (equal? v (bytevector i j))
                       (errorf #f "failed for ~s and ~s" i j)))))

     ; aligned accesses, endianness little
     (begin
       (define $v1 (make-bytevector 11 #xad))
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad))))

     (begin
       (bytevector-s16-set! $v1 0 -1 'little)
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#xff #xff #xad #xad #xad #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-s16-set!
         $v1
         0
         (little-endian->signed #x80 #x00)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#x80 #x00 #xad #xad #xad #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-s16-set!
         $v1
         0
         (little-endian->signed #x00 #x80)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#x00 #x80 #xad #xad #xad #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-s16-set!
         $v1
         0
         (little-endian->signed #x7f #xff)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#x7f #xff #xad #xad #xad #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-s16-set!
         $v1
         0
         (little-endian->signed #xff #x7f)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#xff #x7f #xad #xad #xad #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-s16-set!
         $v1
         0
         (little-endian->signed #xff #xff)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#xff #xff #xad #xad #xad #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-s16-set! $v1 0 #x0000 'little)
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(0 0 #xad #xad #xad #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-s16-set!
         $v1
         2
         (little-endian->signed #xf3 #x45)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(0 0 #xf3 #x45 #xad #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-s16-set!
         $v1
         4
         (little-endian->signed #x23 #xc7)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(0 0 #xf3 #x45 #x23 #xc7 #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-s16-set!
         $v1
         6
         (little-endian->signed #x3a #x1c)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(0 0 #xf3 #x45 #x23 #xc7 #x3a #x1c #xad #xad #xad))))
     (begin
       (bytevector-s16-set!
         $v1
         8
         (little-endian->signed #xe3 #xd7)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(0 0 #xf3 #x45 #x23 #xc7 #x3a #x1c #xe3 #xd7 #xad))))

     (let ([v (bytevector #xc7 #xc7)])
       (do ([i 0 (fx+ i 1)])
           ((fx= i (expt 2 8)) #t)
           (do ([j 0 (fx+ j 1)])
               ((fx= j (expt 2 8)))
               (bytevector-s16-set!
                 v
                 0
                 (little-endian->signed i j)
                 'little)
               (unless (equal? v (bytevector i j))
                       (errorf #f "failed for ~s and ~s" i j)))))

     ; aligned accesses, endianness big
     (begin
       (define $v1 (make-bytevector 11 #xad))
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad))))

     (begin
       (bytevector-s16-set! $v1 0 -1 'big)
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#xff #xff #xad #xad #xad #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-s16-set! $v1 0 (big-endian->signed #x80 #x00) 'big)
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#x80 #x00 #xad #xad #xad #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-s16-set! $v1 0 (big-endian->signed #x00 #x80) 'big)
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#x00 #x80 #xad #xad #xad #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-s16-set! $v1 0 (big-endian->signed #x7f #xff) 'big)
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#x7f #xff #xad #xad #xad #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-s16-set! $v1 0 (big-endian->signed #xff #x7f) 'big)
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#xff #x7f #xad #xad #xad #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-s16-set! $v1 0 (big-endian->signed #xff #xff) 'big)
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#xff #xff #xad #xad #xad #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-s16-set! $v1 0 #x0000 'big)
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(0 0 #xad #xad #xad #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-s16-set! $v1 2 (big-endian->signed #xf3 #x45) 'big)
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(0 0 #xf3 #x45 #xad #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-s16-set! $v1 4 (big-endian->signed #x23 #xc7) 'big)
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(0 0 #xf3 #x45 #x23 #xc7 #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-s16-set! $v1 6 (big-endian->signed #x3a #x1c) 'big)
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(0 0 #xf3 #x45 #x23 #xc7 #x3a #x1c #xad #xad #xad))))
     (begin
       (bytevector-s16-set! $v1 8 (big-endian->signed #xe3 #xd7) 'big)
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(0 0 #xf3 #x45 #x23 #xc7 #x3a #x1c #xe3 #xd7 #xad))))

     (let ([v (bytevector #xc7 #xc7)])
       (do ([i 0 (fx+ i 1)])
           ((fx= i (expt 2 8)) #t)
           (do ([j 0 (fx+ j 1)])
               ((fx= j (expt 2 8)))
               (bytevector-s16-set! v 0 (big-endian->signed i j) 'big)
               (unless (equal? v (bytevector i j))
                       (errorf #f "failed for ~s and ~s" i j)))))

     ; unaligned accesses, endianness mixed
     (begin
       (define $v1 (make-bytevector 11 #xad))
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad))))

     (begin
       (bytevector-s16-set! $v1 1 -1 'big)
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#xad #xff #xff #xad #xad #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-s16-set!
         $v1
         1
         (native->signed #x80 #x00)
         (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#xad #x80 #x00 #xad #xad #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-s16-set!
         $v1
         1
         (little-endian->signed #x00 #x80)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#xad #x00 #x80 #xad #xad #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-s16-set!
         $v1
         1
         (little-endian->signed #x7f #xff)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#xad #x7f #xff #xad #xad #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-s16-set!
         $v1
         1
         (native->signed #xff #x7f)
         (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#xad #xff #x7f #xad #xad #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-s16-set! $v1 1 (big-endian->signed #xff #xff) 'big)
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#xad #xff #xff #xad #xad #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-s16-set! $v1 1 #x0000 (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#xad #x00 #x00 #xad #xad #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-s16-set! $v1 3 (big-endian->signed #xf3 #x45) 'big)
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#xad #x00 #x00 #xf3 #x45 #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-s16-set!
         $v1
         5
         (little-endian->signed #x23 #xc7)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#xad #x00 #x00 #xf3 #x45 #x23 #xc7 #xad #xad #xad #xad))))
     (begin
       (bytevector-s16-set!
         $v1
         7
         (native->signed #x3a #x1c)
         (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#xad #x00 #x00 #xf3 #x45 #x23 #xc7 #x3a #x1c #xad #xad))))
     (begin
       (bytevector-s16-set! $v1 9 (big-endian->signed #xe3 #xd7) 'big)
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#xad #x00 #x00 #xf3 #x45 #x23 #xc7 #x3a #x1c #xe3 #xd7))))

     (let ([v (bytevector 0 #xc7 #xc7)])
       (do ([i 0 (fx+ i 1)])
           ((fx= i (expt 2 8)) #t)
           (do ([j 0 (fx+ j 1)])
               ((fx= j (expt 2 8)))
               (bytevector-s16-set!
                 v
                 1
                 (native->signed i j)
                 (native-endianness))
               (unless (equal? v (bytevector 0 i j))
                       (errorf #f "failed for ~s and ~s (native)" i j))
               (bytevector-u8-set! v 1 #xc7)
               (bytevector-u8-set! v 2 #xc7)
               (bytevector-s16-set! v 1 (big-endian->signed i j) 'big)
               (unless (equal? v (bytevector 0 i j))
                       (errorf #f "failed for ~s and ~s (big)" i j))
               (bytevector-u8-set! v 1 #xc7)
               (bytevector-u8-set! v 2 #xc7)
               (bytevector-s16-set!
                 v
                 1
                 (little-endian->signed i j)
                 'little)
               (unless (equal? v (bytevector 0 i j))
                       (errorf #f "failed for ~s and ~s (little)" i j))))))

(mat bytevector-u16-set!
     (begin
       (define $v1 (make-bytevector 11 #xad))
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad))))

     ; wrong argument count
     (error? (bytevector-u16-set!))
     (error? (bytevector-u16-set! $v1))
     (error? (bytevector-u16-set! $v1 0 0))
     (error? (begin (bytevector-u16-set! $v1 0 0 0 (native-endianness)) #f))

     ; not a bytevector
     (error? (bytevector-u16-set! (make-vector 10) 0 0 'big))
     (error? (begin (bytevector-u16-set! (make-vector 10) 0 0 'big) #f))

     ; invalid index
     (error? (bytevector-u16-set! $v1 -1 0 (native-endianness)))
     (error? (bytevector-u16-set! $v1 10 0 'big))
     (error? (bytevector-u16-set! $v1 11 0 'big))
     (error? (begin (bytevector-u16-set! $v1 'q 0 'little) #f))

     ; invalid value
     (error? (bytevector-u16-set! $v1 0 #x10000 (native-endianness)))
     (error? (bytevector-u16-set! $v1 1 #x10000 (native-endianness)))
     (error? (bytevector-u16-set! $v1 2 #x-1 'little))
     (error? (bytevector-u16-set! $v1 3 #x-1 'little))
     (error? (bytevector-u16-set! $v1 4 "hello" 'big))
     (error? (begin (bytevector-u16-set! $v1 5 "hello" 'big) #f))

     ; invalid endianness
     (error? (bytevector-u16-set! $v1 0 0 'bigger))
     (error? (bytevector-u16-set! $v1 0 0 "little"))
     (error? (begin (bytevector-u16-set! $v1 0 0 #t) #f))

     ; make sure no damage done
     (and (bytevector? $v1)
          (equal? $v1
            #vu8(#xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad)))

     ; aligned accesses, endianness native
     (begin
       (bytevector-u16-set! $v1 0 #xffff (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#xff #xff #xad #xad #xad #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-u16-set!
         $v1
         0
         (native->unsigned #x80 #x00)
         (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#x80 #x00 #xad #xad #xad #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-u16-set!
         $v1
         0
         (native->unsigned #x00 #x80)
         (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#x00 #x80 #xad #xad #xad #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-u16-set!
         $v1
         0
         (native->unsigned #x7f #xff)
         (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#x7f #xff #xad #xad #xad #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-u16-set!
         $v1
         0
         (native->unsigned #xff #x7f)
         (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#xff #x7f #xad #xad #xad #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-u16-set!
         $v1
         0
         (native->unsigned #xff #xff)
         (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#xff #xff #xad #xad #xad #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-u16-set! $v1 0 #x0000 (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(0 0 #xad #xad #xad #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-u16-set!
         $v1
         2
         (native->unsigned #xf3 #x45)
         (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(0 0 #xf3 #x45 #xad #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-u16-set!
         $v1
         4
         (native->unsigned #x23 #xc7)
         (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(0 0 #xf3 #x45 #x23 #xc7 #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-u16-set!
         $v1
         6
         (native->unsigned #x3a #x1c)
         (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(0 0 #xf3 #x45 #x23 #xc7 #x3a #x1c #xad #xad #xad))))
     (begin
       (bytevector-u16-set!
         $v1
         8
         (native->unsigned #xe3 #xd7)
         (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(0 0 #xf3 #x45 #x23 #xc7 #x3a #x1c #xe3 #xd7 #xad))))

     (let ([v (bytevector #xc7 #xc7)])
       (do ([i 0 (fx+ i 1)])
           ((fx= i (expt 2 8)) #t)
           (do ([j 0 (fx+ j 1)])
               ((fx= j (expt 2 8)))
               (bytevector-u16-set!
                 v
                 0
                 (native->unsigned i j)
                 (native-endianness))
               (unless (equal? v (bytevector i j))
                       (errorf #f "failed for ~s and ~s" i j)))))

     ; aligned accesses, endianness little
     (begin
       (define $v1 (make-bytevector 11 #xad))
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad))))

     (begin
       (bytevector-u16-set! $v1 0 #xffff 'little)
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#xff #xff #xad #xad #xad #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-u16-set!
         $v1
         0
         (little-endian->unsigned #x80 #x00)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#x80 #x00 #xad #xad #xad #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-u16-set!
         $v1
         0
         (little-endian->unsigned #x00 #x80)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#x00 #x80 #xad #xad #xad #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-u16-set!
         $v1
         0
         (little-endian->unsigned #x7f #xff)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#x7f #xff #xad #xad #xad #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-u16-set!
         $v1
         0
         (little-endian->unsigned #xff #x7f)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#xff #x7f #xad #xad #xad #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-u16-set!
         $v1
         0
         (little-endian->unsigned #xff #xff)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#xff #xff #xad #xad #xad #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-u16-set! $v1 0 #x0000 'little)
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(0 0 #xad #xad #xad #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-u16-set!
         $v1
         2
         (little-endian->unsigned #xf3 #x45)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(0 0 #xf3 #x45 #xad #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-u16-set!
         $v1
         4
         (little-endian->unsigned #x23 #xc7)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(0 0 #xf3 #x45 #x23 #xc7 #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-u16-set!
         $v1
         6
         (little-endian->unsigned #x3a #x1c)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(0 0 #xf3 #x45 #x23 #xc7 #x3a #x1c #xad #xad #xad))))
     (begin
       (bytevector-u16-set!
         $v1
         8
         (little-endian->unsigned #xe3 #xd7)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(0 0 #xf3 #x45 #x23 #xc7 #x3a #x1c #xe3 #xd7 #xad))))

     (let ([v (bytevector #xc7 #xc7)])
       (do ([i 0 (fx+ i 1)])
           ((fx= i (expt 2 8)) #t)
           (do ([j 0 (fx+ j 1)])
               ((fx= j (expt 2 8)))
               (bytevector-u16-set!
                 v
                 0
                 (little-endian->unsigned i j)
                 'little)
               (unless (equal? v (bytevector i j))
                       (errorf #f "failed for ~s and ~s" i j)))))

     ; aligned accesses, endianness big
     (begin
       (define $v1 (make-bytevector 11 #xad))
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad))))

     (begin
       (bytevector-u16-set! $v1 0 #xffff 'big)
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#xff #xff #xad #xad #xad #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-u16-set! $v1 0 (big-endian->unsigned #x80 #x00) 'big)
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#x80 #x00 #xad #xad #xad #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-u16-set! $v1 0 (big-endian->unsigned #x00 #x80) 'big)
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#x00 #x80 #xad #xad #xad #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-u16-set! $v1 0 (big-endian->unsigned #x7f #xff) 'big)
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#x7f #xff #xad #xad #xad #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-u16-set! $v1 0 (big-endian->unsigned #xff #x7f) 'big)
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#xff #x7f #xad #xad #xad #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-u16-set! $v1 0 (big-endian->unsigned #xff #xff) 'big)
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#xff #xff #xad #xad #xad #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-u16-set! $v1 0 #x0000 'big)
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(0 0 #xad #xad #xad #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-u16-set! $v1 2 (big-endian->unsigned #xf3 #x45) 'big)
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(0 0 #xf3 #x45 #xad #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-u16-set! $v1 4 (big-endian->unsigned #x23 #xc7) 'big)
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(0 0 #xf3 #x45 #x23 #xc7 #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-u16-set! $v1 6 (big-endian->unsigned #x3a #x1c) 'big)
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(0 0 #xf3 #x45 #x23 #xc7 #x3a #x1c #xad #xad #xad))))
     (begin
       (bytevector-u16-set! $v1 8 (big-endian->unsigned #xe3 #xd7) 'big)
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(0 0 #xf3 #x45 #x23 #xc7 #x3a #x1c #xe3 #xd7 #xad))))

     (let ([v (bytevector #xc7 #xc7)])
       (do ([i 0 (fx+ i 1)])
           ((fx= i (expt 2 8)) #t)
           (do ([j 0 (fx+ j 1)])
               ((fx= j (expt 2 8)))
               (bytevector-u16-set! v 0 (big-endian->unsigned i j) 'big)
               (unless (equal? v (bytevector i j))
                       (errorf #f "failed for ~s and ~s" i j)))))

     ; unaligned accesses, endianness mixed
     (begin
       (define $v1 (make-bytevector 11 #xad))
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad))))

     (begin
       (bytevector-u16-set! $v1 1 #xffff 'big)
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#xad #xff #xff #xad #xad #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-u16-set!
         $v1
         1
         (native->unsigned #x80 #x00)
         (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#xad #x80 #x00 #xad #xad #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-u16-set!
         $v1
         1
         (little-endian->unsigned #x00 #x80)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#xad #x00 #x80 #xad #xad #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-u16-set!
         $v1
         1
         (little-endian->unsigned #x7f #xff)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#xad #x7f #xff #xad #xad #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-u16-set!
         $v1
         1
         (native->unsigned #xff #x7f)
         (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#xad #xff #x7f #xad #xad #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-u16-set! $v1 1 (big-endian->unsigned #xff #xff) 'big)
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#xad #xff #xff #xad #xad #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-u16-set! $v1 1 #x0000 (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#xad #x00 #x00 #xad #xad #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-u16-set! $v1 3 (big-endian->unsigned #xf3 #x45) 'big)
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#xad #x00 #x00 #xf3 #x45 #xad #xad #xad #xad #xad #xad))))
     (begin
       (bytevector-u16-set!
         $v1
         5
         (little-endian->unsigned #x23 #xc7)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#xad #x00 #x00 #xf3 #x45 #x23 #xc7 #xad #xad #xad #xad))))
     (begin
       (bytevector-u16-set!
         $v1
         7
         (native->unsigned #x3a #x1c)
         (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#xad #x00 #x00 #xf3 #x45 #x23 #xc7 #x3a #x1c #xad #xad))))
     (begin
       (bytevector-u16-set! $v1 9 (big-endian->unsigned #xe3 #xd7) 'big)
       (and (bytevector? $v1)
            (equal? $v1
              #vu8(#xad #x00 #x00 #xf3 #x45 #x23 #xc7 #x3a #x1c #xe3 #xd7))))

     (let ([v (bytevector 0 #xc7 #xc7)])
       (do ([i 0 (fx+ i 1)])
           ((fx= i (expt 2 8)) #t)
           (do ([j 0 (fx+ j 1)])
               ((fx= j (expt 2 8)))
               (bytevector-u16-set!
                 v
                 1
                 (native->unsigned i j)
                 (native-endianness))
               (unless (equal? v (bytevector 0 i j))
                       (errorf #f "failed for ~s and ~s (native)" i j))
               (bytevector-u8-set! v 1 #xc7)
               (bytevector-u8-set! v 2 #xc7)
               (bytevector-u16-set! v 1 (big-endian->unsigned i j) 'big)
               (unless (equal? v (bytevector 0 i j))
                       (errorf #f "failed for ~s and ~s (big)" i j))
               (bytevector-u8-set! v 1 #xc7)
               (bytevector-u8-set! v 2 #xc7)
               (bytevector-u16-set!
                 v
                 1
                 (little-endian->unsigned i j)
                 'little)
               (unless (equal? v (bytevector 0 i j))
                       (errorf #f "failed for ~s and ~s (little)" i j))))))

(mat bytevector-s24-ref
     ; wrong argument count
     (error? (bytevector-s24-ref))
     (error? (bytevector-s24-ref #vu8(3 252 5 0)))
     (error? (bytevector-s24-ref #vu8(3 252 5 0) 0))
     (error? (begin
               (bytevector-s24-ref #vu8(3 252 5 0) 0 (native-endianness) 0)
               #f))

     ; not a bytevector
     (error? (bytevector-s24-ref '#(3 252 5 0 0 0 0) 0 'big))
     (error? (begin (bytevector-s24-ref '#(3 252 5 0 0 0 0) 0 'big) #f))

     ; invalid index
     (error? (bytevector-s24-ref #vu8(3 252 5 0 0 0 0) -1 'big))
     (error? (bytevector-s24-ref #vu8(3 252 5 0 0 0 0) 6 'little))
     (error? (bytevector-s24-ref
               #vu8(3 252 5 0 0 0 0)
               7
               (native-endianness)))
     (error? (begin
               (bytevector-s24-ref #vu8(3 252 5 0 0 0 0) 4.0 'little)
               #f))

     ; invalid endianness
     (error? (bytevector-s24-ref #vu8(3 252 5 0 0 0 0) 0 'bigger))
     (error? (bytevector-s24-ref #vu8(3 252 5 0 0 0 0) 0 "little"))
     (error? (begin (bytevector-s24-ref #vu8(3 252 5 0 0 0 0) 0 #t) #f))

     ; 32-bit aligned accesses, endianness native
     (eqv? (bytevector-s24-ref
             #vu8(3 252 5 32 65 87 20)
             0
             (native-endianness))
           (native->signed 3 252 5))
     (equal? (let ([v '#vu8(30 100 200 250 249 199 99 29 248 189 190 207 24
                            25 26 27 28 29 30)])
               (list (bytevector-s24-ref v 0 (native-endianness))
                     (bytevector-s24-ref v 4 (native-endianness))
                     (bytevector-s24-ref v 8 (native-endianness))
                     (bytevector-s24-ref v 12 (native-endianness))))
             (list (native->signed 30 100 200)
                   (native->signed 249 199 99)
                   (native->signed 248 189 190)
                   (native->signed 24 25 26)))

     (do ([i 1000 (fx- i 1)])
         ((fx= i 0) #t)
         (let ([ls (map (lambda (x) (random (expt 2 8))) (make-list 3))])
           (unless (eqv? (bytevector-s24-ref
                           (apply bytevector ls)
                           0
                           (native-endianness))
                         (apply native->signed ls))
                   (errorf #f "failed for ~s" ls))))

     ; 32-bit aligned accesses, endianness big
     (eqv? (bytevector-s24-ref #vu8(3 252 5 32 65 87 20) 0 'big)
           (big-endian->signed 3 252 5))
     (equal? (let ([v '#vu8(30 100 200 250 249 199 99 29 248 189 190 207 24
                            25 26 27 28 29 30)])
               (list (bytevector-s24-ref v 0 'big)
                     (bytevector-s24-ref v 4 'big)
                     (bytevector-s24-ref v 8 'big)
                     (bytevector-s24-ref v 12 'big)))
             (list (big-endian->signed 30 100 200)
                   (big-endian->signed 249 199 99)
                   (big-endian->signed 248 189 190)
                   (big-endian->signed 24 25 26)))

     (do ([i 1000 (fx- i 1)])
         ((fx= i 0) #t)
         (let ([ls (map (lambda (x) (random (expt 2 8))) (make-list 3))])
           (unless (eqv? (bytevector-s24-ref (apply bytevector ls) 0 'big)
                         (apply big-endian->signed ls))
                   (errorf #f "failed for ~s" ls))))

     ; 32-bit aligned accesses, endianness little
     (eqv? (bytevector-s24-ref #vu8(3 252 5 32 65 87 20) 0 'little)
           (little-endian->signed 3 252 5))
     (equal? (let ([v '#vu8(30 100 200 250 249 199 99 29 248 189 190 207 24
                            25 26 27 28 29 30)])
               (list (bytevector-s24-ref v 0 'little)
                     (bytevector-s24-ref v 4 'little)
                     (bytevector-s24-ref v 8 'little)
                     (bytevector-s24-ref v 12 'little)))
             (list (little-endian->signed 30 100 200)
                   (little-endian->signed 249 199 99)
                   (little-endian->signed 248 189 190)
                   (little-endian->signed 24 25 26)))

     (do ([i 1000 (fx- i 1)])
         ((fx= i 0) #t)
         (let ([ls (map (lambda (x) (random (expt 2 8))) (make-list 3))])
           (unless (eqv? (bytevector-s24-ref (apply bytevector ls) 0 'little)
                         (apply little-endian->signed ls))
                   (errorf #f "failed for ~s" ls))))

     ; not 32-bit aligned, endianness mixed
     (eqv? (bytevector-s24-ref
             #vu8(3 252 5 32 65 87 20)
             3
             (native-endianness))
           (native->signed 32 65 87))
     (equal? (let ([v '#vu8(30 100 200 250 249 199 99 29 248 189 190 207 24
                            25 26 27 28 29 30)])
               (list (bytevector-s24-ref v 1 'little)
                     (bytevector-s24-ref v 6 'big)
                     (bytevector-s24-ref v 11 (native-endianness))
                     (bytevector-s24-ref v 15 'little)))
             (list (little-endian->signed 100 200 250)
                   (big-endian->signed 99 29 248)
                   (native->signed 207 24 25)
                   (little-endian->signed 27 28 29)))

     (do ([i 1000 (fx- i 1)])
         ((fx= i 0) #t)
         (let ([ls (map (lambda (x) (random (expt 2 8))) (make-list 4))])
           (unless (eqv? (bytevector-s24-ref
                           (apply bytevector ls)
                           1
                           (native-endianness))
                         (apply native->signed (cdr ls)))
                   (errorf #f "failed for ~s (native)" ls))
           (unless (eqv? (bytevector-s24-ref (apply bytevector ls) 1 'little)
                         (apply little-endian->signed (cdr ls)))
                   (errorf #f "failed for ~s (little)" ls))
           (unless (eqv? (bytevector-s24-ref (apply bytevector ls) 1 'big)
                         (apply big-endian->signed (cdr ls)))
                   (errorf #f "failed for ~s (big)" ls))))

     (do ([i 1000 (fx- i 1)])
         ((fx= i 0) #t)
         (let ([ls (map (lambda (x) (random (expt 2 8))) (make-list 4))])
           (unless (eqv? (eval `(bytevector-s24-ref
                                  ,(apply bytevector ls)
                                  1
                                  (native-endianness)))
                         (apply native->signed (cdr ls)))
                   (errorf #f "failed for ~s (native)" ls))
           (unless (eqv? (eval `(bytevector-s24-ref
                                  ,(apply bytevector ls)
                                  1
                                  'little))
                         (apply little-endian->signed (cdr ls)))
                   (errorf #f "failed for ~s (little)" ls))
           (unless (eqv? (eval `(bytevector-s24-ref
                                  ,(apply bytevector ls)
                                  1
                                  'big))
                         (apply big-endian->signed (cdr ls)))
                   (errorf #f "failed for ~s (big)" ls)))))

(mat bytevector-u24-ref
     ; wrong argument count
     (error? (bytevector-u24-ref))
     (error? (bytevector-u24-ref #vu8(3 252 5 0)))
     (error? (bytevector-u24-ref #vu8(3 252 5 0) 0))
     (error? (begin
               (bytevector-u24-ref #vu8(3 252 5 0) 0 (native-endianness) 0)
               #f))

     ; not a bytevector
     (error? (bytevector-u24-ref '#(3 252 5 0 0 0 0) 0 'big))
     (error? (begin (bytevector-u24-ref '#(3 252 5 0 0 0 0) 0 'big) #f))

     ; invalid index
     (error? (bytevector-u24-ref #vu8(3 252 5 0 0 0 0) -1 'big))
     (error? (bytevector-u24-ref #vu8(3 252 5 0 0 0 0) 6 'little))
     (error? (bytevector-u24-ref
               #vu8(3 252 5 0 0 0 0)
               7
               (native-endianness)))
     (error? (begin
               (bytevector-u24-ref #vu8(3 252 5 0 0 0 0) 4.0 'little)
               #f))

     ; invalid endianness
     (error? (bytevector-u24-ref #vu8(0 1 2 3 4 5 6 7) 0 'bigger))
     (error? (bytevector-u24-ref #vu8(0 1 2 3 4 5 6 7) 0 "little"))
     (error? (begin (bytevector-u24-ref #vu8(0 1 2 3 4 5 6 7) 0 #t) #f))

     ; 32-bit aligned accesses, endianness native
     (eqv? (bytevector-u24-ref
             #vu8(3 252 5 32 65 87 20)
             0
             (native-endianness))
           (native->unsigned 3 252 5))
     (equal? (let ([v '#vu8(30 100 200 250 249 199 99 29 248 189 190 207 24
                            25 26 27 28 29 30)])
               (list (bytevector-u24-ref v 0 (native-endianness))
                     (bytevector-u24-ref v 4 (native-endianness))
                     (bytevector-u24-ref v 8 (native-endianness))
                     (bytevector-u24-ref v 12 (native-endianness))))
             (list (native->unsigned 30 100 200)
                   (native->unsigned 249 199 99)
                   (native->unsigned 248 189 190)
                   (native->unsigned 24 25 26)))

     (do ([i 1000 (fx- i 1)])
         ((fx= i 0) #t)
         (let ([ls (map (lambda (x) (random (expt 2 8))) (make-list 3))])
           (unless (eqv? (bytevector-u24-ref
                           (apply bytevector ls)
                           0
                           (native-endianness))
                         (apply native->unsigned ls))
                   (errorf #f "failed for ~s" ls))))

     ; 32-bit aligned accesses, endianness big
     (eqv? (bytevector-u24-ref #vu8(3 252 5 32 65 87 20) 0 'big)
           (big-endian->unsigned 3 252 5))
     (equal? (let ([v '#vu8(30 100 200 250 249 199 99 29 248 189 190 207 24
                            25 26 27 28 29 30)])
               (list (bytevector-u24-ref v 0 'big)
                     (bytevector-u24-ref v 4 'big)
                     (bytevector-u24-ref v 8 'big)
                     (bytevector-u24-ref v 12 'big)))
             (list (big-endian->unsigned 30 100 200)
                   (big-endian->unsigned 249 199 99)
                   (big-endian->unsigned 248 189 190)
                   (big-endian->unsigned 24 25 26)))

     (do ([i 1000 (fx- i 1)])
         ((fx= i 0) #t)
         (let ([ls (map (lambda (x) (random (expt 2 8))) (make-list 3))])
           (unless (eqv? (bytevector-u24-ref (apply bytevector ls) 0 'big)
                         (apply big-endian->unsigned ls))
                   (errorf #f "failed for ~s" ls))))

     ; 32-bit aligned accesses, endianness little
     (eqv? (bytevector-u24-ref #vu8(3 252 5 32 65 87 20) 0 'little)
           (little-endian->unsigned 3 252 5))
     (equal? (let ([v '#vu8(30 100 200 250 249 199 99 29 248 189 190 207 24
                            25 26 27 28 29 30)])
               (list (bytevector-u24-ref v 0 'little)
                     (bytevector-u24-ref v 4 'little)
                     (bytevector-u24-ref v 8 'little)
                     (bytevector-u24-ref v 12 'little)))
             (list (little-endian->unsigned 30 100 200)
                   (little-endian->unsigned 249 199 99)
                   (little-endian->unsigned 248 189 190)
                   (little-endian->unsigned 24 25 26)))

     (do ([i 1000 (fx- i 1)])
         ((fx= i 0) #t)
         (let ([ls (map (lambda (x) (random (expt 2 8))) (make-list 3))])
           (unless (eqv? (bytevector-u24-ref (apply bytevector ls) 0 'little)
                         (apply little-endian->unsigned ls))
                   (errorf #f "failed for ~s" ls))))

     ; not 32-bit aligned accesses, endianness mixed
     (eqv? (bytevector-u24-ref
             #vu8(3 252 5 32 65 87 20)
             3
             (native-endianness))
           (native->unsigned 32 65 87))
     (equal? (let ([v '#vu8(30 100 200 250 249 199 99 29 248 189 190 207 24
                            25 26 27 28 29)])
               (list (bytevector-u24-ref v 1 'little)
                     (bytevector-u24-ref v 6 'big)
                     (bytevector-u24-ref v 11 (native-endianness))
                     (bytevector-u24-ref v 15 'little)))
             (list (little-endian->unsigned 100 200 250)
                   (big-endian->unsigned 99 29 248)
                   (native->unsigned 207 24 25)
                   (little-endian->unsigned 27 28 29)))

     (do ([i 1000 (fx- i 1)])
         ((fx= i 0) #t)
         (let ([ls (map (lambda (x) (random (expt 2 8))) (make-list 4))])
           (unless (eqv? (bytevector-u24-ref
                           (apply bytevector ls)
                           1
                           (native-endianness))
                         (apply native->unsigned (cdr ls)))
                   (errorf #f "failed for ~s (native)" ls))
           (unless (eqv? (bytevector-u24-ref (apply bytevector ls) 1 'little)
                         (apply little-endian->unsigned (cdr ls)))
                   (errorf #f "failed for ~s (little)" ls))
           (unless (eqv? (bytevector-u24-ref (apply bytevector ls) 1 'big)
                         (apply big-endian->unsigned (cdr ls)))
                   (errorf #f "failed for ~s (big)" ls))))

     (do ([i 1000 (fx- i 1)])
         ((fx= i 0) #t)
         (let ([ls (map (lambda (x) (random (expt 2 8))) (make-list 4))])
           (unless (eqv? (eval `(bytevector-u24-ref
                                  ,(apply bytevector ls)
                                  1
                                  (native-endianness)))
                         (apply native->unsigned (cdr ls)))
                   (errorf #f "failed for ~s (native)" ls))
           (unless (eqv? (eval `(bytevector-u24-ref
                                  ,(apply bytevector ls)
                                  1
                                  'little))
                         (apply little-endian->unsigned (cdr ls)))
                   (errorf #f "failed for ~s (little)" ls))
           (unless (eqv? (eval `(bytevector-u24-ref
                                  ,(apply bytevector ls)
                                  1
                                  'big))
                         (apply big-endian->unsigned (cdr ls)))
                   (errorf #f "failed for ~s (big)" ls)))))

(mat bytevector-s24-set!
     (begin
       (define $v1 (make-bytevector 23 #xad))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))

     ; wrong argument count
     (error? (bytevector-s24-set!))
     (error? (bytevector-s24-set! $v1))
     (error? (bytevector-s24-set! $v1 0))
     (error? (bytevector-s24-set! $v1 0 0))
     (error? (begin (bytevector-s24-set! $v1 0 0 'big 0) #f))

     ; not a bytevector
     (error? (bytevector-s24-set! (make-vector 10) 0 0 (native-endianness)))
     (error? (begin
               (bytevector-s24-set!
                 (make-vector 10)
                 0
                 0
                 (native-endianness))
               #f))

     ; invalid index
     (error? (bytevector-s24-set! $v1 -1 0 'big))
     (error? (bytevector-s24-set! $v1 21 0 (native-endianness)))
     (error? (bytevector-s24-set! $v1 22 0 'little))
     (error? (bytevector-s24-set! $v1 23 0 (native-endianness)))
     (error? (begin (bytevector-s24-set! $v1 'q 0 'big) #f))

     ; invalid value
     (error? (bytevector-s24-set! $v1 0 (expt 2 23) 'big))
     (error? (bytevector-s24-set!
               $v1
               4
               (- -1 (expt 2 23))
               (native-endianness)))
     (error? (begin (bytevector-s24-set! $v1 8 "hello" 'little) #f))

     ; invalid endianness
     (error? (bytevector-s24-set! $v1 0 0 'huge))
     (error? (bytevector-s24-set! $v1 4 0 "tiny"))
     (error? (begin (bytevector-s24-set! $v1 8 0 $v1) #f))

     ; make sure no damage done
     (and (bytevector? $v1)
          (equal? $v1
            '#vu8(#xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                  #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                  #xad)))

     ; 32-bit aligned accesses, endianness native
     (begin
       (bytevector-s24-set! $v1 0 -1 (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xff #xff #xff #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s24-set!
         $v1
         0
         (native->signed #x80 #x00 #x00)
         (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x80 #x00 #x00 #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s24-set!
         $v1
         0
         (native->signed #x00 #x00 #x80)
         (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x80 #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s24-set!
         $v1
         0
         (native->signed #x7f #xff #xff)
         (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x7f #xff #xff #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s24-set!
         $v1
         0
         (native->signed #xff #xff #x7f)
         (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xff #xff #x7f #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s24-set!
         $v1
         0
         (native->signed #xff #xff #xff)
         (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xff #xff #xff #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s24-set! $v1 0 #x000000 (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s24-set!
         $v1
         4
         (native->signed #xf3 #x45 #x19)
         (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #xad #xf3 #x45 #x19 #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s24-set!
         $v1
         8
         (native->signed #x23 #xc7 #xe8)
         (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #xad #xf3 #x45 #x19 #xad #x23 #xc7 #xe8
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s24-set!
         $v1
         12
         (native->signed #x3a #x1c #x59)
         (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #xad #xf3 #x45 #x19 #xad #x23 #xc7 #xe8
                    #xad #x3a #x1c #x59 #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s24-set!
         $v1
         16
         (native->signed #xe3 #xd7 #xa9)
         (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #xad #xf3 #x45 #x19 #xad #x23 #xc7 #xe8
                    #xad #x3a #x1c #x59 #xad #xe3 #xd7 #xa9 #xad #xad #xad
                    #xad))))

     (let ([v (bytevector #xc7 #xc7 #xc7)])
       (do ([i 1000 (fx- i 1)])
           ((fx= i 0) #t)
           (let ([ls (map (lambda (x) (random (expt 2 8))) (make-list 3))])
             (bytevector-s24-set!
               v
               0
               (apply native->signed ls)
               (native-endianness))
             (unless (equal? v (apply bytevector ls))
                     (errorf #f "failed for ~s" ls)))))

     ; 32-bit aligned accesses, endianness big
     (begin
       (define $v1 (make-bytevector 23 #xad))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))

     (begin
       (bytevector-s24-set! $v1 0 -1 'big)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xff #xff #xff #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s24-set! $v1 0 (big-endian->signed #x80 #x00 #x00) 'big)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x80 #x00 #x00 #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s24-set! $v1 0 (big-endian->signed #x00 #x00 #x80) 'big)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x80 #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s24-set! $v1 0 (big-endian->signed #x7f #xff #xff) 'big)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x7f #xff #xff #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s24-set! $v1 0 (big-endian->signed #xff #xff #x7f) 'big)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xff #xff #x7f #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s24-set! $v1 0 (big-endian->signed #xff #xff #xff) 'big)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xff #xff #xff #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s24-set! $v1 0 #x000000 'big)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s24-set! $v1 4 (big-endian->signed #xf3 #x45 #x19) 'big)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #xad #xf3 #x45 #x19 #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s24-set! $v1 8 (big-endian->signed #x23 #xc7 #xe8) 'big)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #xad #xf3 #x45 #x19 #xad #x23 #xc7 #xe8
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s24-set!
         $v1
         12
         (big-endian->signed #x3a #x1c #x59)
         'big)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #xad #xf3 #x45 #x19 #xad #x23 #xc7 #xe8
                    #xad #x3a #x1c #x59 #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s24-set!
         $v1
         16
         (big-endian->signed #xe3 #xd7 #xa9)
         'big)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #xad #xf3 #x45 #x19 #xad #x23 #xc7 #xe8
                    #xad #x3a #x1c #x59 #xad #xe3 #xd7 #xa9 #xad #xad #xad
                    #xad))))

     (let ([v (bytevector #xc7 #xc7 #xc7)])
       (do ([i 1000 (fx- i 1)])
           ((fx= i 0) #t)
           (let ([ls (map (lambda (x) (random (expt 2 8))) (make-list 3))])
             (bytevector-s24-set! v 0 (apply big-endian->signed ls) 'big)
             (unless (equal? v (apply bytevector ls))
                     (errorf #f "failed for ~s" ls)))))

     ; 32-bit aligned accesses, endianness little
     (begin
       (define $v1 (make-bytevector 23 #xad))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))

     (begin
       (bytevector-s24-set! $v1 0 -1 'little)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xff #xff #xff #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s24-set!
         $v1
         0
         (little-endian->signed #x80 #x00 #x00)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x80 #x00 #x00 #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s24-set!
         $v1
         0
         (little-endian->signed #x00 #x00 #x80)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x80 #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s24-set!
         $v1
         0
         (little-endian->signed #x7f #xff #xff)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x7f #xff #xff #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s24-set!
         $v1
         0
         (little-endian->signed #xff #xff #x7f)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xff #xff #x7f #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s24-set!
         $v1
         0
         (little-endian->signed #xff #xff #xff)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xff #xff #xff #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s24-set! $v1 0 #x000000 'little)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s24-set!
         $v1
         4
         (little-endian->signed #xf3 #x45 #x19)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #xad #xf3 #x45 #x19 #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s24-set!
         $v1
         8
         (little-endian->signed #x23 #xc7 #xe8)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #xad #xf3 #x45 #x19 #xad #x23 #xc7 #xe8
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s24-set!
         $v1
         12
         (little-endian->signed #x3a #x1c #x59)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #xad #xf3 #x45 #x19 #xad #x23 #xc7 #xe8
                    #xad #x3a #x1c #x59 #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s24-set!
         $v1
         16
         (little-endian->signed #xe3 #xd7 #xa9)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #xad #xf3 #x45 #x19 #xad #x23 #xc7 #xe8
                    #xad #x3a #x1c #x59 #xad #xe3 #xd7 #xa9 #xad #xad #xad
                    #xad))))

     (let ([v (bytevector #xc7 #xc7 #xc7)])
       (do ([i 1000 (fx- i 1)])
           ((fx= i 0) #t)
           (let ([ls (map (lambda (x) (random (expt 2 8))) (make-list 3))])
             (bytevector-s24-set!
               v
               0
               (apply little-endian->signed ls)
               'little)
             (unless (equal? v (apply bytevector ls))
                     (errorf #f "failed for ~s" ls)))))

     ; not 32-bit aligned accesses, endianness mixed
     (begin
       (define $v1 (make-bytevector 23 #xad))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))

     (begin
       (bytevector-s24-set! $v1 1 -1 'big)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #xff #xff #xff #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s24-set!
         $v1
         1
         (little-endian->signed #x80 #x00 #x00)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #x80 #x00 #x00 #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s24-set!
         $v1
         1
         (native->signed #x00 #x00 #x80)
         (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #x00 #x00 #x80 #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s24-set!
         $v1
         1
         (native->signed #x7f #xff #xff)
         (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #x7f #xff #xff #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s24-set! $v1 1 (big-endian->signed #xff #xff #x7f) 'big)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #xff #xff #x7f #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s24-set!
         $v1
         1
         (little-endian->signed #xff #xff #xff)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #xff #xff #xff #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s24-set! $v1 1 #x000000 'little)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #x00 #x00 #x00 #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s24-set!
         $v1
         5
         (native->signed #xf3 #x45 #x19)
         (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #x00 #x00 #x00 #xad #xf3 #x45 #x19 #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s24-set!
         $v1
         10
         (little-endian->signed #x23 #xc7 #xe8)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #x00 #x00 #x00 #xad #xf3 #x45 #x19 #xad #xad #x23
                    #xc7 #xe8 #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s24-set!
         $v1
         15
         (big-endian->signed #x3a #x1c #x59)
         'big)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #x00 #x00 #x00 #xad #xf3 #x45 #x19 #xad #xad #x23
                    #xc7 #xe8 #xad #xad #x3a #x1c #x59 #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s24-set!
         $v1
         20
         (little-endian->signed #xe3 #xd7 #xa9)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #x00 #x00 #x00 #xad #xf3 #x45 #x19 #xad #xad #x23
                    #xc7 #xe8 #xad #xad #x3a #x1c #x59 #xad #xad #xe3 #xd7
                    #xa9))))

     (let ([v (bytevector #xc7 #xc7 #xc7 #xc7)])
       (do ([i 1000 (fx- i 1)])
           ((fx= i 0) #t)
           (let ([ls (map (lambda (x) (random (expt 2 8))) (make-list 3))])
             (bytevector-s24-set! v 1 (apply big-endian->signed ls) 'big)
             (unless (equal? v (apply bytevector #xc7 ls))
                     (errorf #f "failed for ~s" ls))
             (bytevector-s24-set!
               v
               1
               (apply little-endian->signed (reverse ls))
               'little)
             (unless (equal? v (apply bytevector #xc7 (reverse ls)))
                     (errorf #f "failed for ~s" ls))
             (bytevector-s24-set!
               v
               1
               (apply native->signed ls)
               (native-endianness))
             (unless (equal? v (apply bytevector #xc7 ls))
                     (errorf #f "failed for ~s" ls)))))

     (let ([v (bytevector #xc7 #xc7 #xc7 #xc7)])
       (do ([i 1000 (fx- i 1)])
           ((fx= i 0) #t)
           (let ([ls (map (lambda (x) (random (expt 2 8))) (make-list 3))])
             (eval `(bytevector-s24-set!
                      ,v
                      1
                      ,(apply big-endian->signed ls)
                      'big))
             (unless (equal? v (apply bytevector #xc7 ls))
                     (errorf #f "failed for ~s" ls))
             (eval `(bytevector-s24-set!
                      ,v
                      1
                      ,(apply little-endian->signed (reverse ls))
                      'little))
             (unless (equal? v (apply bytevector #xc7 (reverse ls)))
                     (errorf #f "failed for ~s" ls))
             (eval `(bytevector-s24-set!
                      ,v
                      1
                      ,(apply native->signed ls)
                      (native-endianness)))
             (unless (equal? v (apply bytevector #xc7 ls))
                     (errorf #f "failed for ~s" ls))))))

(mat bytevector-u24-set!
     (begin
       (define $v1 (make-bytevector 23 #xad))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))

     ; wrong argument count
     (error? (bytevector-u24-set!))
     (error? (bytevector-u24-set! $v1))
     (error? (bytevector-u24-set! $v1 0))
     (error? (bytevector-u24-set! $v1 0 0))
     (error? (if (bytevector-u24-set! $v1 0 0 'big 0) #f #t))

     ; not a bytevector
     (error? (bytevector-u24-set! (make-vector 10) 0 0 (native-endianness)))
     (error? (if (bytevector-u24-set!
                   (make-vector 10)
                   0
                   0
                   (native-endianness))
                 #f
                 #t))

     ; invalid index
     (error? (bytevector-u24-set! $v1 -1 0 'big))
     (error? (bytevector-u24-set! $v1 21 0 (native-endianness)))
     (error? (bytevector-u24-set! $v1 22 0 'little))
     (error? (bytevector-u24-set! $v1 23 0 (native-endianness)))
     (error? (if (bytevector-u24-set! $v1 'q 0 'big) #f #t))

     ; invalid value
     (error? (bytevector-u24-set! $v1 0 (expt 2 24) 'big))
     (error? (bytevector-u24-set! $v1 4 #x-1 (native-endianness)))
     (error? (if (bytevector-u24-set! $v1 8 "hello" 'little) #f #t))

     ; invalid endianness
     (error? (bytevector-u24-set! $v1 0 0 'huge))
     (error? (bytevector-u24-set! $v1 4 0 "tiny"))
     (error? (if (bytevector-u24-set! $v1 8 0 $v1) #f #t))

     ; make sure no damage done
     (and (bytevector? $v1)
          (equal? $v1
            '#vu8(#xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                  #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                  #xad)))

     ; 32-bit aligned accesses, endianness native
     (begin
       (bytevector-u24-set! $v1 0 #xffffff (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xff #xff #xff #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u24-set!
         $v1
         0
         (native->unsigned #x80 #x00 #x00)
         (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x80 #x00 #x00 #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u24-set!
         $v1
         0
         (native->unsigned #x00 #x00 #x80)
         (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x80 #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u24-set!
         $v1
         0
         (native->unsigned #x7f #xff #xff)
         (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x7f #xff #xff #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u24-set!
         $v1
         0
         (native->unsigned #xff #xff #x7f)
         (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xff #xff #x7f #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u24-set!
         $v1
         0
         (native->unsigned #xff #xff #xff)
         (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xff #xff #xff #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u24-set! $v1 0 #x000000 (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u24-set!
         $v1
         4
         (native->unsigned #xf3 #x45 #x19)
         (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #xad #xf3 #x45 #x19 #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u24-set!
         $v1
         8
         (native->unsigned #x23 #xc7 #xe8)
         (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #xad #xf3 #x45 #x19 #xad #x23 #xc7 #xe8
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u24-set!
         $v1
         12
         (native->unsigned #x3a #x1c #x59)
         (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #xad #xf3 #x45 #x19 #xad #x23 #xc7 #xe8
                    #xad #x3a #x1c #x59 #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u24-set!
         $v1
         16
         (native->unsigned #xe3 #xd7 #xa9)
         (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #xad #xf3 #x45 #x19 #xad #x23 #xc7 #xe8
                    #xad #x3a #x1c #x59 #xad #xe3 #xd7 #xa9 #xad #xad #xad
                    #xad))))

     (let ([v (bytevector #xc7 #xc7 #xc7)])
       (do ([i 1000 (fx- i 1)])
           ((fx= i 0) #t)
           (let ([ls (map (lambda (x) (random (expt 2 8))) (make-list 3))])
             (bytevector-u24-set!
               v
               0
               (apply native->unsigned ls)
               (native-endianness))
             (unless (equal? v (apply bytevector ls))
                     (errorf #f "failed for ~s" ls)))))

     ; 32-bit aligned accesses, endianness big
     (begin
       (define $v1 (make-bytevector 23 #xad))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))

     (begin
       (bytevector-u24-set! $v1 0 #xffffff 'big)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xff #xff #xff #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u24-set!
         $v1
         0
         (big-endian->unsigned #x80 #x00 #x00)
         'big)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x80 #x00 #x00 #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u24-set!
         $v1
         0
         (big-endian->unsigned #x00 #x00 #x80)
         'big)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x80 #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u24-set!
         $v1
         0
         (big-endian->unsigned #x7f #xff #xff)
         'big)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x7f #xff #xff #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u24-set!
         $v1
         0
         (big-endian->unsigned #xff #xff #x7f)
         'big)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xff #xff #x7f #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u24-set!
         $v1
         0
         (big-endian->unsigned #xff #xff #xff)
         'big)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xff #xff #xff #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u24-set! $v1 0 #x000000 'big)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u24-set!
         $v1
         4
         (big-endian->unsigned #xf3 #x45 #x19)
         'big)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #xad #xf3 #x45 #x19 #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u24-set!
         $v1
         8
         (big-endian->unsigned #x23 #xc7 #xe8)
         'big)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #xad #xf3 #x45 #x19 #xad #x23 #xc7 #xe8
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u24-set!
         $v1
         12
         (big-endian->unsigned #x3a #x1c #x59)
         'big)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #xad #xf3 #x45 #x19 #xad #x23 #xc7 #xe8
                    #xad #x3a #x1c #x59 #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u24-set!
         $v1
         16
         (big-endian->unsigned #xe3 #xd7 #xa9)
         'big)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #xad #xf3 #x45 #x19 #xad #x23 #xc7 #xe8
                    #xad #x3a #x1c #x59 #xad #xe3 #xd7 #xa9 #xad #xad #xad
                    #xad))))

     (let ([v (bytevector #xc7 #xc7 #xc7)])
       (do ([i 1000 (fx- i 1)])
           ((fx= i 0) #t)
           (let ([ls (map (lambda (x) (random (expt 2 8))) (make-list 3))])
             (bytevector-u24-set! v 0 (apply big-endian->unsigned ls) 'big)
             (unless (equal? v (apply bytevector ls))
                     (errorf #f "failed for ~s" ls)))))

     ; 32-bit aligned accesses, endianness little
     (begin
       (define $v1 (make-bytevector 23 #xad))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))

     (begin
       (bytevector-u24-set! $v1 0 #xffffff 'little)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xff #xff #xff #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u24-set!
         $v1
         0
         (little-endian->unsigned #x80 #x00 #x00)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x80 #x00 #x00 #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u24-set!
         $v1
         0
         (little-endian->unsigned #x00 #x00 #x80)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x80 #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u24-set!
         $v1
         0
         (little-endian->unsigned #x7f #xff #xff)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x7f #xff #xff #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u24-set!
         $v1
         0
         (little-endian->unsigned #xff #xff #x7f)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xff #xff #x7f #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u24-set!
         $v1
         0
         (little-endian->unsigned #xff #xff #xff)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xff #xff #xff #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u24-set! $v1 0 #x000000 'little)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u24-set!
         $v1
         4
         (little-endian->unsigned #xf3 #x45 #x19)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #xad #xf3 #x45 #x19 #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u24-set!
         $v1
         8
         (little-endian->unsigned #x23 #xc7 #xe8)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #xad #xf3 #x45 #x19 #xad #x23 #xc7 #xe8
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u24-set!
         $v1
         12
         (little-endian->unsigned #x3a #x1c #x59)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #xad #xf3 #x45 #x19 #xad #x23 #xc7 #xe8
                    #xad #x3a #x1c #x59 #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u24-set!
         $v1
         16
         (little-endian->unsigned #xe3 #xd7 #xa9)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #xad #xf3 #x45 #x19 #xad #x23 #xc7 #xe8
                    #xad #x3a #x1c #x59 #xad #xe3 #xd7 #xa9 #xad #xad #xad
                    #xad))))

     (let ([v (bytevector #xc7 #xc7 #xc7)])
       (do ([i 1000 (fx- i 1)])
           ((fx= i 0) #t)
           (let ([ls (map (lambda (x) (random (expt 2 8))) (make-list 3))])
             (bytevector-u24-set!
               v
               0
               (apply little-endian->unsigned ls)
               'little)
             (unless (equal? v (apply bytevector ls))
                     (errorf #f "failed for ~s" ls)))))

     ; not 32-bit aligned accesses, endianness mixed
     (begin
       (define $v1 (make-bytevector 23 #xad))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))

     (begin
       (bytevector-u24-set! $v1 1 #xffffff 'big)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #xff #xff #xff #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u24-set!
         $v1
         1
         (little-endian->unsigned #x80 #x00 #x00)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #x80 #x00 #x00 #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u24-set!
         $v1
         1
         (native->unsigned #x00 #x00 #x80)
         (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #x00 #x00 #x80 #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u24-set!
         $v1
         1
         (native->unsigned #x7f #xff #xff)
         (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #x7f #xff #xff #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u24-set!
         $v1
         1
         (big-endian->unsigned #xff #xff #x7f)
         'big)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #xff #xff #x7f #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u24-set!
         $v1
         1
         (little-endian->unsigned #xff #xff #xff)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #xff #xff #xff #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u24-set! $v1 1 #x000000 'little)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #x00 #x00 #x00 #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u24-set!
         $v1
         5
         (native->unsigned #xf3 #x45 #x19)
         (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #x00 #x00 #x00 #xad #xf3 #x45 #x19 #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u24-set!
         $v1
         10
         (little-endian->unsigned #x23 #xc7 #xe8)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #x00 #x00 #x00 #xad #xf3 #x45 #x19 #xad #xad #x23
                    #xc7 #xe8 #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u24-set!
         $v1
         15
         (big-endian->unsigned #x3a #x1c #x59)
         'big)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #x00 #x00 #x00 #xad #xf3 #x45 #x19 #xad #xad #x23
                    #xc7 #xe8 #xad #xad #x3a #x1c #x59 #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u24-set!
         $v1
         20
         (little-endian->unsigned #xe3 #xd7 #xa9)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #x00 #x00 #x00 #xad #xf3 #x45 #x19 #xad #xad #x23
                    #xc7 #xe8 #xad #xad #x3a #x1c #x59 #xad #xad #xe3 #xd7
                    #xa9))))

     (let ([v (bytevector #xc7 #xc7 #xc7 #xc7)])
       (do ([i 1000 (fx- i 1)])
           ((fx= i 0) #t)
           (let ([ls (map (lambda (x) (random (expt 2 8))) (make-list 3))])
             (bytevector-u24-set! v 1 (apply big-endian->unsigned ls) 'big)
             (unless (equal? v (apply bytevector #xc7 ls))
                     (errorf #f "failed for ~s" ls))
             (bytevector-u24-set!
               v
               1
               (apply little-endian->unsigned (reverse ls))
               'little)
             (unless (equal? v (apply bytevector #xc7 (reverse ls)))
                     (errorf #f "failed for ~s" ls))
             (bytevector-u24-set!
               v
               1
               (apply native->unsigned ls)
               (native-endianness))
             (unless (equal? v (apply bytevector #xc7 ls))
                     (errorf #f "failed for ~s" ls)))))

     (let ([v (bytevector #xc7 #xc7 #xc7 #xc7)])
       (do ([i 1000 (fx- i 1)])
           ((fx= i 0) #t)
           (let ([ls (map (lambda (x) (random (expt 2 8))) (make-list 3))])
             (eval `(bytevector-u24-set!
                      ,v
                      1
                      ,(apply big-endian->unsigned ls)
                      'big))
             (unless (equal? v (apply bytevector #xc7 ls))
                     (errorf #f "failed for ~s" ls))
             (eval `(bytevector-u24-set!
                      ,v
                      1
                      ,(apply little-endian->unsigned (reverse ls))
                      'little))
             (unless (equal? v (apply bytevector #xc7 (reverse ls)))
                     (errorf #f "failed for ~s" ls))
             (eval `(bytevector-u24-set!
                      ,v
                      1
                      ,(apply native->unsigned ls)
                      (native-endianness)))
             (unless (equal? v (apply bytevector #xc7 ls))
                     (errorf #f "failed for ~s" ls))))))

(mat bytevector-s32-native-ref
     ; wrong argument count
     (error? (bytevector-s32-native-ref))
     (error? (bytevector-s32-native-ref #vu8(3 252 5 0)))
     (error? (begin (bytevector-s32-native-ref #vu8(3 252 5 0) 0 0) #f))

     ; not a bytevector
     (error? (bytevector-s32-native-ref '#(3 252 5 0 0 0 0) 0))
     (error? (begin (bytevector-s32-native-ref '#(3 252 5 0 0 0 0) 0) #f))

     ; invalid index
     (error? (bytevector-s32-native-ref #vu8(3 252 5 0 0 0 0) -1))
     (error? (bytevector-s32-native-ref #vu8(3 252 5 0 0 0 0) 1))
     (error? (bytevector-s32-native-ref #vu8(3 252 5 0 0 0 0) 2))
     (error? (bytevector-s32-native-ref #vu8(3 252 5 0 0 0 0) 3))
     (error? (bytevector-s32-native-ref #vu8(3 252 5 0 0 0 0) 4))
     (error? (bytevector-s32-native-ref #vu8(3 252 5 0 0 0 0) 5))
     (error? (bytevector-s32-native-ref #vu8(3 252 5 0 0 0 0) 6))
     (error? (bytevector-s32-native-ref #vu8(3 252 5 0 0 0 0) 7))
     (error? (begin
               (bytevector-s32-native-ref #vu8(3 252 5 0 0 0 0) 4.0)
               #f))

     (eqv? (bytevector-s32-native-ref #vu8(3 252 5 32 65 87 20) 0)
           (native->signed 3 252 5 32))
     (equal? (let ([v '#vu8(30 100 200 250 249 199 99 29 248 189 190 207 24
                            25 26 27 28 29 30)])
               (list (bytevector-s32-native-ref v 0)
                     (bytevector-s32-native-ref v 4)
                     (bytevector-s32-native-ref v 8)
                     (bytevector-s32-native-ref v 12)))
             (list (native->signed 30 100 200 250)
                   (native->signed 249 199 99 29)
                   (native->signed 248 189 190 207)
                   (native->signed 24 25 26 27)))

     (test-cp0-expansion eqv?
       '(bytevector-s32-native-ref #vu8(3 252 5 32 65 87 20) 0)
       (native->signed 3 252 5 32))
     (equal? (cdr (parameterize
                    ([optimize-level 2]
                     [enable-cp0 #t]
                     [#%$suppress-primitive-inlining #f])
                    (expand/optimize
                      '(let ([v '#vu8(30 100 200 250 249 199 99 29 248 189
                                      190 207 24 25 26 27 28 29 30)])
                         (list (bytevector-s32-native-ref v 0)
                               (bytevector-s32-native-ref v 4)
                               (bytevector-s32-native-ref v 8)
                               (bytevector-s32-native-ref v 12))))))
             (list (native->signed 30 100 200 250)
                   (native->signed 249 199 99 29)
                   (native->signed 248 189 190 207)
                   (native->signed 24 25 26 27)))

     (do ([i 10000 (fx- i 1)])
         ((fx= i 0) #t)
         (let ([ls (map (lambda (x) (random (expt 2 8))) (make-list 4))])
           (unless (eqv? (bytevector-s32-native-ref
                           (apply bytevector ls)
                           0)
                         (apply native->signed ls))
                   (errorf #f "failed for ~s" ls)))))

(mat bytevector-u32-native-ref
     ; wrong argument count
     (error? (bytevector-u32-native-ref))
     (error? (bytevector-u32-native-ref #vu8(3 252 5 0)))
     (error? (begin (bytevector-u32-native-ref #vu8(3 252 5 0) 0 0) #f))

     ; not a bytevector
     (error? (bytevector-u32-native-ref '#(3 252 5 0 0 0 0) 0))
     (error? (begin (bytevector-u32-native-ref '#(3 252 5 0 0 0 0) 0) #f))

     ; invalid index
     (error? (bytevector-u32-native-ref #vu8(3 252 5 0 0 0 0) -1))
     (error? (bytevector-u32-native-ref #vu8(3 252 5 0 0 0 0) 1))
     (error? (bytevector-u32-native-ref #vu8(3 252 5 0 0 0 0) 2))
     (error? (bytevector-u32-native-ref #vu8(3 252 5 0 0 0 0) 3))
     (error? (bytevector-u32-native-ref #vu8(3 252 5 0 0 0 0) 4))
     (error? (bytevector-u32-native-ref #vu8(3 252 5 0 0 0 0) 5))
     (error? (bytevector-u32-native-ref #vu8(3 252 5 0 0 0 0) 6))
     (error? (bytevector-u32-native-ref #vu8(3 252 5 0 0 0 0) 7))
     (error? (begin
               (bytevector-u32-native-ref #vu8(3 252 5 0 0 0 0) 4.0)
               #f))

     (eqv? (bytevector-u32-native-ref #vu8(3 252 5 32 65 87 20) 0)
           (native->unsigned 3 252 5 32))
     (equal? (let ([v '#vu8(30 100 200 250 249 199 99 29 248 189 190 207 24
                            25 26 27 28 29 30)])
               (list (bytevector-u32-native-ref v 0)
                     (bytevector-u32-native-ref v 4)
                     (bytevector-u32-native-ref v 8)
                     (bytevector-u32-native-ref v 12)))
             (list (native->unsigned 30 100 200 250)
                   (native->unsigned 249 199 99 29)
                   (native->unsigned 248 189 190 207)
                   (native->unsigned 24 25 26 27)))

     (test-cp0-expansion eqv?
       '(bytevector-u32-native-ref #vu8(3 252 5 32 65 87 20) 0)
       (native->unsigned 3 252 5 32))
     (equal? (cdr (parameterize
                    ([optimize-level 2]
                     [enable-cp0 #t]
                     [#%$suppress-primitive-inlining #f])
                    (expand/optimize
                      '(let ([v '#vu8(30 100 200 250 249 199 99 29 248 189
                                      190 207 24 25 26 27 28 29 30)])
                         (list (bytevector-u32-native-ref v 0)
                               (bytevector-u32-native-ref v 4)
                               (bytevector-u32-native-ref v 8)
                               (bytevector-u32-native-ref v 12))))))
             (list (native->unsigned 30 100 200 250)
                   (native->unsigned 249 199 99 29)
                   (native->unsigned 248 189 190 207)
                   (native->unsigned 24 25 26 27)))

     (do ([i 10000 (fx- i 1)])
         ((fx= i 0) #t)
         (let ([ls (map (lambda (x) (random (expt 2 8))) (make-list 4))])
           (unless (eqv? (bytevector-u32-native-ref
                           (apply bytevector ls)
                           0)
                         (apply native->unsigned ls))
                   (errorf #f "failed for ~s" ls)))))

(mat bytevector-s32-native-set!
     (begin
       (define $v1 (make-bytevector 23 #xad))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))

     ; wrong argument count
     (error? (bytevector-s32-native-set!))
     (error? (bytevector-s32-native-set! $v1))
     (error? (bytevector-s32-native-set! $v1 0))
     (error? (begin (bytevector-s32-native-set! $v1 0 0 15) #f))

     ; not a bytevector
     (error? (bytevector-s32-native-set! (make-vector 10) 0 0))
     (error? (begin (bytevector-s32-native-set! (make-vector 10) 0 0) #f))

     ; invalid index
     (error? (bytevector-s32-native-set! $v1 -1 0))
     (error? (bytevector-s32-native-set! $v1 1 0))
     (error? (bytevector-s32-native-set! $v1 2 0))
     (error? (bytevector-s32-native-set! $v1 3 0))
     (error? (bytevector-s32-native-set! $v1 5 0))
     (error? (bytevector-s32-native-set! $v1 6 0))
     (error? (bytevector-s32-native-set! $v1 7 0))
     (error? (bytevector-s32-native-set! $v1 9 0))
     (error? (bytevector-s32-native-set! $v1 10 0))
     (error? (bytevector-s32-native-set! $v1 11 0))
     (error? (bytevector-s32-native-set! $v1 13 0))
     (error? (bytevector-s32-native-set! $v1 14 0))
     (error? (bytevector-s32-native-set! $v1 15 0))
     (error? (bytevector-s32-native-set! $v1 17 0))
     (error? (bytevector-s32-native-set! $v1 18 0))
     (error? (bytevector-s32-native-set! $v1 19 0))
     (error? (bytevector-s32-native-set! $v1 20 0))
     (error? (bytevector-s32-native-set! $v1 21 0))
     (error? (bytevector-s32-native-set! $v1 22 0))
     (error? (bytevector-s32-native-set! $v1 23 0))
     (error? (begin (bytevector-s32-native-set! $v1 'q 0) #f))

     ; invalid value
     (error? (bytevector-s32-native-set! $v1 0 #x80000000))
     (error? (bytevector-s32-native-set! $v1 4 #x-80000001))
     (error? (begin (bytevector-s32-native-set! $v1 8 "hello") #f))

     ; make sure no damage done
     (and (bytevector? $v1)
          (equal? $v1
            '#vu8(#xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                  #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                  #xad)))

     (begin
       (bytevector-s32-native-set! $v1 0 -1)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xff #xff #xff #xff #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s32-native-set! $v1 0
         (native->signed #x80 #x00 #x00 #x00))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x80 #x00 #x00 #x00 #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s32-native-set! $v1 0
         (native->signed #x00 #x00 #x00 #x80))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #x80 #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s32-native-set! $v1 0
         (native->signed #x7f #xff #xff #xff))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x7f #xff #xff #xff #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s32-native-set! $v1 0
         (native->signed #xff #xff #xff #x7f))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xff #xff #xff #x7f #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s32-native-set! $v1 0
         (native->signed #xff #xff #xff #xff))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xff #xff #xff #xff #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s32-native-set! $v1 0 #x00000000)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #x00 #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s32-native-set! $v1 4
         (native->signed #xf3 #x45 #x23 #x19))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #x00 #xf3 #x45 #x23 #x19 #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s32-native-set! $v1 8
         (native->signed #x23 #xc7 #x72 #xe8))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #x00 #xf3 #x45 #x23 #x19 #x23 #xc7 #x72
                    #xe8 #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s32-native-set! $v1 12
         (native->signed #x3a #x1c #x22 #x59))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #x00 #xf3 #x45 #x23 #x19 #x23 #xc7 #x72
                    #xe8 #x3a #x1c #x22 #x59 #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s32-native-set! $v1 16
         (native->signed #xe3 #xd7 #xc2 #xa9))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #x00 #xf3 #x45 #x23 #x19 #x23 #xc7 #x72
                    #xe8 #x3a #x1c #x22 #x59 #xe3 #xd7 #xc2 #xa9 #xad #xad
                    #xad))))

     (let ([v (bytevector #xc7 #xc7 #xc7 #xc7)])
       (do ([i 10000 (fx- i 1)])
           ((fx= i 0) #t)
           (let ([ls (map (lambda (x) (random (expt 2 8))) (make-list 4))])
             (bytevector-s32-native-set! v 0 (apply native->signed ls))
             (unless (equal? v (apply bytevector ls))
                     (errorf #f "failed for ~s" ls))))))

(mat bytevector-u32-native-set!
     (begin
       (define $v1 (make-bytevector 23 #xad))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))

     ; wrong argument count
     (error? (bytevector-u32-native-set!))
     (error? (bytevector-u32-native-set! $v1))
     (error? (bytevector-u32-native-set! $v1 0))
     (error? (begin (bytevector-u32-native-set! $v1 0 0 15) #f))

     ; not a bytevector
     (error? (bytevector-u32-native-set! (make-vector 10) 0 0))
     (error? (begin (bytevector-u32-native-set! (make-vector 10) 0 0) #f))

     ; invalid index
     (error? (bytevector-u32-native-set! $v1 -1 0))
     (error? (bytevector-u32-native-set! $v1 1 0))
     (error? (bytevector-u32-native-set! $v1 2 0))
     (error? (bytevector-u32-native-set! $v1 3 0))
     (error? (bytevector-u32-native-set! $v1 5 0))
     (error? (bytevector-u32-native-set! $v1 6 0))
     (error? (bytevector-u32-native-set! $v1 7 0))
     (error? (bytevector-u32-native-set! $v1 9 0))
     (error? (bytevector-u32-native-set! $v1 10 0))
     (error? (bytevector-u32-native-set! $v1 11 0))
     (error? (bytevector-u32-native-set! $v1 13 0))
     (error? (bytevector-u32-native-set! $v1 14 0))
     (error? (bytevector-u32-native-set! $v1 15 0))
     (error? (bytevector-u32-native-set! $v1 17 0))
     (error? (bytevector-u32-native-set! $v1 18 0))
     (error? (bytevector-u32-native-set! $v1 19 0))
     (error? (bytevector-u32-native-set! $v1 20 0))
     (error? (bytevector-u32-native-set! $v1 21 0))
     (error? (bytevector-u32-native-set! $v1 22 0))
     (error? (bytevector-u32-native-set! $v1 23 0))
     (error? (begin (bytevector-u32-native-set! $v1 'q 0) #f))

     ; invalid value
     (error? (bytevector-u32-native-set! $v1 0 #x100000000))
     (error? (bytevector-u32-native-set! $v1 4 #x-1))
     (error? (begin (bytevector-u32-native-set! $v1 8 "hello") #f))

     ; make sure no damage done
     (and (bytevector? $v1)
          (equal? $v1
            '#vu8(#xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                  #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                  #xad)))

     (begin
       (bytevector-u32-native-set! $v1 0 #xffffffff)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xff #xff #xff #xff #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u32-native-set! $v1 0
         (native->unsigned #x80 #x00 #x00 #x00))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x80 #x00 #x00 #x00 #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u32-native-set! $v1 0
         (native->unsigned #x00 #x00 #x00 #x80))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #x80 #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u32-native-set! $v1 0
         (native->unsigned #x7f #xff #xff #xff))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x7f #xff #xff #xff #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u32-native-set! $v1 0
         (native->unsigned #xff #xff #xff #x7f))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xff #xff #xff #x7f #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u32-native-set! $v1 0
         (native->unsigned #xff #xff #xff #xff))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xff #xff #xff #xff #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u32-native-set! $v1 0 #x00000000)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #x00 #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u32-native-set! $v1 4
         (native->unsigned #xf3 #x45 #x23 #x19))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #x00 #xf3 #x45 #x23 #x19 #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u32-native-set! $v1 8
         (native->unsigned #x23 #xc7 #x72 #xe8))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #x00 #xf3 #x45 #x23 #x19 #x23 #xc7 #x72
                    #xe8 #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u32-native-set! $v1 12
         (native->unsigned #x3a #x1c #x22 #x59))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #x00 #xf3 #x45 #x23 #x19 #x23 #xc7 #x72
                    #xe8 #x3a #x1c #x22 #x59 #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u32-native-set! $v1 16
         (native->unsigned #xe3 #xd7 #xc2 #xa9))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #x00 #xf3 #x45 #x23 #x19 #x23 #xc7 #x72
                    #xe8 #x3a #x1c #x22 #x59 #xe3 #xd7 #xc2 #xa9 #xad #xad
                    #xad))))

     (let ([v (bytevector #xc7 #xc7 #xc7 #xc7)])
       (do ([i 10000 (fx- i 1)])
           ((fx= i 0) #t)
           (let ([ls (map (lambda (x) (random (expt 2 8))) (make-list 4))])
             (bytevector-u32-native-set! v 0 (apply native->unsigned ls))
             (unless (equal? v (apply bytevector ls))
                     (errorf #f "failed for ~s" ls))))))

(mat bytevector-s32-ref
     ; wrong argument count
     (error? (bytevector-s32-ref))
     (error? (bytevector-s32-ref #vu8(3 252 5 0)))
     (error? (bytevector-s32-ref #vu8(3 252 5 0) 0))
     (error? (begin
               (bytevector-s32-ref #vu8(3 252 5 0) 0 (native-endianness) 0)
               #f))

     ; not a bytevector
     (error? (bytevector-s32-ref '#(3 252 5 0 0 0 0) 0 'big))
     (error? (begin (bytevector-s32-ref '#(3 252 5 0 0 0 0) 0 'big) #f))

     ; invalid index
     (error? (bytevector-s32-ref #vu8(3 252 5 0 0 0 0) -1 'big))
     (error? (bytevector-s32-ref #vu8(3 252 5 0 0 0 0) 6 'little))
     (error? (bytevector-s32-ref
               #vu8(3 252 5 0 0 0 0)
               7
               (native-endianness)))
     (error? (begin
               (bytevector-s32-ref #vu8(3 252 5 0 0 0 0) 4.0 'little)
               #f))

     ; invalid endianness
     (error? (bytevector-s32-ref $v1 0 'bigger))
     (error? (bytevector-s32-ref $v1 0 "little"))
     (error? (begin (bytevector-s32-ref $v1 0 #t) #f))

     ; aligned accesses, endianness native
     (eqv? (bytevector-s32-ref
             #vu8(3 252 5 32 65 87 20)
             0
             (native-endianness))
           (native->signed 3 252 5 32))
     (equal? (let ([v '#vu8(30 100 200 250 249 199 99 29 248 189 190 207 24
                            25 26 27 28 29 30)])
               (list (bytevector-s32-ref v 0 (native-endianness))
                     (bytevector-s32-ref v 4 (native-endianness))
                     (bytevector-s32-ref v 8 (native-endianness))
                     (bytevector-s32-ref v 12 (native-endianness))))
             (list (native->signed 30 100 200 250)
                   (native->signed 249 199 99 29)
                   (native->signed 248 189 190 207)
                   (native->signed 24 25 26 27)))

     (do ([i 10000 (fx- i 1)])
         ((fx= i 0) #t)
         (let ([ls (map (lambda (x) (random (expt 2 8))) (make-list 4))])
           (unless (eqv? (bytevector-s32-ref
                           (apply bytevector ls)
                           0
                           (native-endianness))
                         (apply native->signed ls))
                   (errorf #f "failed for ~s" ls))))

     ; aligned accesses, endianness big
     (eqv? (bytevector-s32-ref #vu8(3 252 5 32 65 87 20) 0 'big)
           (big-endian->signed 3 252 5 32))
     (equal? (let ([v '#vu8(30 100 200 250 249 199 99 29 248 189 190 207 24
                            25 26 27 28 29 30)])
               (list (bytevector-s32-ref v 0 'big)
                     (bytevector-s32-ref v 4 'big)
                     (bytevector-s32-ref v 8 'big)
                     (bytevector-s32-ref v 12 'big)))
             (list (big-endian->signed 30 100 200 250)
                   (big-endian->signed 249 199 99 29)
                   (big-endian->signed 248 189 190 207)
                   (big-endian->signed 24 25 26 27)))

     (do ([i 10000 (fx- i 1)])
         ((fx= i 0) #t)
         (let ([ls (map (lambda (x) (random (expt 2 8))) (make-list 4))])
           (unless (eqv? (bytevector-s32-ref (apply bytevector ls) 0 'big)
                         (apply big-endian->signed ls))
                   (errorf #f "failed for ~s" ls))))

     ; aligned accesses, endianness little
     (eqv? (bytevector-s32-ref #vu8(3 252 5 32 65 87 20) 0 'little)
           (little-endian->signed 3 252 5 32))
     (equal? (let ([v '#vu8(30 100 200 250 249 199 99 29 248 189 190 207 24
                            25 26 27 28 29 30)])
               (list (bytevector-s32-ref v 0 'little)
                     (bytevector-s32-ref v 4 'little)
                     (bytevector-s32-ref v 8 'little)
                     (bytevector-s32-ref v 12 'little)))
             (list (little-endian->signed 30 100 200 250)
                   (little-endian->signed 249 199 99 29)
                   (little-endian->signed 248 189 190 207)
                   (little-endian->signed 24 25 26 27)))

     (do ([i 10000 (fx- i 1)])
         ((fx= i 0) #t)
         (let ([ls (map (lambda (x) (random (expt 2 8))) (make-list 4))])
           (unless (eqv? (bytevector-s32-ref (apply bytevector ls) 0 'little)
                         (apply little-endian->signed ls))
                   (errorf #f "failed for ~s" ls))))

     ; unaligned accesses, endianness mixed
     (eqv? (bytevector-s32-ref
             #vu8(3 252 5 32 65 87 20)
             3
             (native-endianness))
           (native->signed 32 65 87 20))
     (equal? (let ([v '#vu8(30 100 200 250 249 199 99 29 248 189 190 207 24
                            25 26 27 28 29 30)])
               (list (bytevector-s32-ref v 1 'little)
                     (bytevector-s32-ref v 6 'big)
                     (bytevector-s32-ref v 11 (native-endianness))
                     (bytevector-s32-ref v 15 'little)))
             (list (little-endian->signed 100 200 250 249)
                   (big-endian->signed 99 29 248 189)
                   (native->signed 207 24 25 26)
                   (little-endian->signed 27 28 29 30)))

     (do ([i 10000 (fx- i 1)])
         ((fx= i 0) #t)
         (let ([ls (map (lambda (x) (random (expt 2 8))) (make-list 5))])
           (unless (eqv? (bytevector-s32-ref
                           (apply bytevector ls)
                           1
                           (native-endianness))
                         (apply native->signed (cdr ls)))
                   (errorf #f "failed for ~s (native)" ls))
           (unless (eqv? (bytevector-s32-ref (apply bytevector ls) 1 'little)
                         (apply little-endian->signed (cdr ls)))
                   (errorf #f "failed for ~s (little)" ls))
           (unless (eqv? (bytevector-s32-ref (apply bytevector ls) 1 'big)
                         (apply big-endian->signed (cdr ls)))
                   (errorf #f "failed for ~s (big)" ls)))))

(mat bytevector-u32-ref
     ; wrong argument count
     (error? (bytevector-u32-ref))
     (error? (bytevector-u32-ref #vu8(3 252 5 0)))
     (error? (bytevector-u32-ref #vu8(3 252 5 0) 0))
     (error? (begin
               (bytevector-u32-ref #vu8(3 252 5 0) 0 (native-endianness) 0)
               #f))

     ; not a bytevector
     (error? (bytevector-u32-ref '#(3 252 5 0 0 0 0) 0 'big))
     (error? (begin (bytevector-u32-ref '#(3 252 5 0 0 0 0) 0 'big) #f))

     ; invalid index
     (error? (bytevector-u32-ref #vu8(3 252 5 0 0 0 0) -1 'big))
     (error? (bytevector-u32-ref #vu8(3 252 5 0 0 0 0) 6 'little))
     (error? (bytevector-u32-ref
               #vu8(3 252 5 0 0 0 0)
               7
               (native-endianness)))
     (error? (begin
               (bytevector-u32-ref #vu8(3 252 5 0 0 0 0) 4.0 'little)
               #f))

     ; invalid endianness
     (error? (bytevector-u32-ref $v1 0 'bigger))
     (error? (bytevector-u32-ref $v1 0 "little"))
     (error? (begin (bytevector-u32-ref $v1 0 #t) #f))

     ; aligned accesses, endianness native
     (eqv? (bytevector-u32-ref
             #vu8(3 252 5 32 65 87 20)
             0
             (native-endianness))
           (native->unsigned 3 252 5 32))
     (equal? (let ([v '#vu8(30 100 200 250 249 199 99 29 248 189 190 207 24
                            25 26 27 28 29 30)])
               (list (bytevector-u32-ref v 0 (native-endianness))
                     (bytevector-u32-ref v 4 (native-endianness))
                     (bytevector-u32-ref v 8 (native-endianness))
                     (bytevector-u32-ref v 12 (native-endianness))))
             (list (native->unsigned 30 100 200 250)
                   (native->unsigned 249 199 99 29)
                   (native->unsigned 248 189 190 207)
                   (native->unsigned 24 25 26 27)))

     (do ([i 10000 (fx- i 1)])
         ((fx= i 0) #t)
         (let ([ls (map (lambda (x) (random (expt 2 8))) (make-list 4))])
           (unless (eqv? (bytevector-u32-ref
                           (apply bytevector ls)
                           0
                           (native-endianness))
                         (apply native->unsigned ls))
                   (errorf #f "failed for ~s" ls))))

     ; aligned accesses, endianness big
     (eqv? (bytevector-u32-ref #vu8(3 252 5 32 65 87 20) 0 'big)
           (big-endian->unsigned 3 252 5 32))
     (equal? (let ([v '#vu8(30 100 200 250 249 199 99 29 248 189 190 207 24
                            25 26 27 28 29 30)])
               (list (bytevector-u32-ref v 0 'big)
                     (bytevector-u32-ref v 4 'big)
                     (bytevector-u32-ref v 8 'big)
                     (bytevector-u32-ref v 12 'big)))
             (list (big-endian->unsigned 30 100 200 250)
                   (big-endian->unsigned 249 199 99 29)
                   (big-endian->unsigned 248 189 190 207)
                   (big-endian->unsigned 24 25 26 27)))

     (do ([i 10000 (fx- i 1)])
         ((fx= i 0) #t)
         (let ([ls (map (lambda (x) (random (expt 2 8))) (make-list 4))])
           (unless (eqv? (bytevector-u32-ref (apply bytevector ls) 0 'big)
                         (apply big-endian->unsigned ls))
                   (errorf #f "failed for ~s" ls))))

     ; aligned accesses, endianness little
     (eqv? (bytevector-u32-ref #vu8(3 252 5 32 65 87 20) 0 'little)
           (little-endian->unsigned 3 252 5 32))
     (equal? (let ([v '#vu8(30 100 200 250 249 199 99 29 248 189 190 207 24
                            25 26 27 28 29 30)])
               (list (bytevector-u32-ref v 0 'little)
                     (bytevector-u32-ref v 4 'little)
                     (bytevector-u32-ref v 8 'little)
                     (bytevector-u32-ref v 12 'little)))
             (list (little-endian->unsigned 30 100 200 250)
                   (little-endian->unsigned 249 199 99 29)
                   (little-endian->unsigned 248 189 190 207)
                   (little-endian->unsigned 24 25 26 27)))

     (do ([i 10000 (fx- i 1)])
         ((fx= i 0) #t)
         (let ([ls (map (lambda (x) (random (expt 2 8))) (make-list 4))])
           (unless (eqv? (bytevector-u32-ref (apply bytevector ls) 0 'little)
                         (apply little-endian->unsigned ls))
                   (errorf #f "failed for ~s" ls))))

     ; unaligned accesses, endianness mixed
     (eqv? (bytevector-u32-ref
             #vu8(3 252 5 32 65 87 20)
             3
             (native-endianness))
           (native->unsigned 32 65 87 20))
     (equal? (let ([v '#vu8(30 100 200 250 249 199 99 29 248 189 190 207 24
                            25 26 27 28 29 30)])
               (list (bytevector-u32-ref v 1 'little)
                     (bytevector-u32-ref v 6 'big)
                     (bytevector-u32-ref v 11 (native-endianness))
                     (bytevector-u32-ref v 15 'little)))
             (list (little-endian->unsigned 100 200 250 249)
                   (big-endian->unsigned 99 29 248 189)
                   (native->unsigned 207 24 25 26)
                   (little-endian->unsigned 27 28 29 30)))

     (do ([i 10000 (fx- i 1)])
         ((fx= i 0) #t)
         (let ([ls (map (lambda (x) (random (expt 2 8))) (make-list 5))])
           (unless (eqv? (bytevector-u32-ref
                           (apply bytevector ls)
                           1
                           (native-endianness))
                         (apply native->unsigned (cdr ls)))
                   (errorf #f "failed for ~s (native)" ls))
           (unless (eqv? (bytevector-u32-ref (apply bytevector ls) 1 'little)
                         (apply little-endian->unsigned (cdr ls)))
                   (errorf #f "failed for ~s (little)" ls))
           (unless (eqv? (bytevector-u32-ref (apply bytevector ls) 1 'big)
                         (apply big-endian->unsigned (cdr ls)))
                   (errorf #f "failed for ~s (big)" ls)))))

(mat bytevector-s32-set!
     (begin
       (define $v1 (make-bytevector 23 #xad))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))

     ; wrong argument count
     (error? (bytevector-s32-set!))
     (error? (bytevector-s32-set! $v1))
     (error? (bytevector-s32-set! $v1 0))
     (error? (bytevector-s32-set! $v1 0 0))
     (error? (begin (bytevector-s32-set! $v1 0 0 'big 0) #f))

     ; not a bytevector
     (error? (bytevector-s32-set! (make-vector 10) 0 0 (native-endianness)))
     (error? (begin
               (bytevector-s32-set!
                 (make-vector 10)
                 0
                 0
                 (native-endianness))
               #f))

     ; invalid index
     (error? (bytevector-s32-set! $v1 -1 0 'big))
     (error? (bytevector-s32-set! $v1 20 0 'little))
     (error? (bytevector-s32-set! $v1 21 0 (native-endianness)))
     (error? (bytevector-s32-set! $v1 22 0 'little))
     (error? (bytevector-s32-set! $v1 23 0 (native-endianness)))
     (error? (begin (bytevector-s32-set! $v1 'q 0 'big) #f))

     ; invalid value
     (error? (bytevector-s32-set! $v1 0 #x80000000 'big))
     (error? (bytevector-s32-set! $v1 4 #x-80000001 (native-endianness)))
     (error? (begin (bytevector-s32-set! $v1 8 "hello" 'little) #f))

     ; invalid endianness
     (error? (bytevector-s32-set! $v1 0 #x7ffffff 'huge))
     (error? (bytevector-s32-set! $v1 4 #x-80000000 "tiny"))
     (error? (begin (bytevector-s32-set! $v1 8 0 $v1) #f))

     ; make sure no damage done
     (and (bytevector? $v1)
          (equal? $v1
            '#vu8(#xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                  #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                  #xad)))

     ; aligned accesses, endianness native
     (begin
       (bytevector-s32-set! $v1 0 -1 (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xff #xff #xff #xff #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s32-set!
         $v1
         0
         (native->signed #x80 #x00 #x00 #x00)
         (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x80 #x00 #x00 #x00 #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s32-set!
         $v1
         0
         (native->signed #x00 #x00 #x00 #x80)
         (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #x80 #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s32-set!
         $v1
         0
         (native->signed #x7f #xff #xff #xff)
         (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x7f #xff #xff #xff #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s32-set!
         $v1
         0
         (native->signed #xff #xff #xff #x7f)
         (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xff #xff #xff #x7f #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s32-set!
         $v1
         0
         (native->signed #xff #xff #xff #xff)
         (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xff #xff #xff #xff #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s32-set! $v1 0 #x00000000 (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #x00 #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s32-set!
         $v1
         4
         (native->signed #xf3 #x45 #x23 #x19)
         (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #x00 #xf3 #x45 #x23 #x19 #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s32-set!
         $v1
         8
         (native->signed #x23 #xc7 #x72 #xe8)
         (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #x00 #xf3 #x45 #x23 #x19 #x23 #xc7 #x72
                    #xe8 #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s32-set!
         $v1
         12
         (native->signed #x3a #x1c #x22 #x59)
         (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #x00 #xf3 #x45 #x23 #x19 #x23 #xc7 #x72
                    #xe8 #x3a #x1c #x22 #x59 #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s32-set!
         $v1
         16
         (native->signed #xe3 #xd7 #xc2 #xa9)
         (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #x00 #xf3 #x45 #x23 #x19 #x23 #xc7 #x72
                    #xe8 #x3a #x1c #x22 #x59 #xe3 #xd7 #xc2 #xa9 #xad #xad
                    #xad))))

     (let ([v (bytevector #xc7 #xc7 #xc7 #xc7)])
       (do ([i 10000 (fx- i 1)])
           ((fx= i 0) #t)
           (let ([ls (map (lambda (x) (random (expt 2 8))) (make-list 4))])
             (bytevector-s32-set!
               v
               0
               (apply native->signed ls)
               (native-endianness))
             (unless (equal? v (apply bytevector ls))
                     (errorf #f "failed for ~s" ls)))))

     ; aligned accesses, endianness big
     (begin
       (define $v1 (make-bytevector 23 #xad))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))

     (begin
       (bytevector-s32-set! $v1 0 -1 'big)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xff #xff #xff #xff #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s32-set!
         $v1
         0
         (big-endian->signed #x80 #x00 #x00 #x00)
         'big)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x80 #x00 #x00 #x00 #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s32-set!
         $v1
         0
         (big-endian->signed #x00 #x00 #x00 #x80)
         'big)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #x80 #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s32-set!
         $v1
         0
         (big-endian->signed #x7f #xff #xff #xff)
         'big)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x7f #xff #xff #xff #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s32-set!
         $v1
         0
         (big-endian->signed #xff #xff #xff #x7f)
         'big)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xff #xff #xff #x7f #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s32-set!
         $v1
         0
         (big-endian->signed #xff #xff #xff #xff)
         'big)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xff #xff #xff #xff #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s32-set! $v1 0 #x00000000 'big)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #x00 #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s32-set!
         $v1
         4
         (big-endian->signed #xf3 #x45 #x23 #x19)
         'big)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #x00 #xf3 #x45 #x23 #x19 #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s32-set!
         $v1
         8
         (big-endian->signed #x23 #xc7 #x72 #xe8)
         'big)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #x00 #xf3 #x45 #x23 #x19 #x23 #xc7 #x72
                    #xe8 #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s32-set!
         $v1
         12
         (big-endian->signed #x3a #x1c #x22 #x59)
         'big)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #x00 #xf3 #x45 #x23 #x19 #x23 #xc7 #x72
                    #xe8 #x3a #x1c #x22 #x59 #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s32-set!
         $v1
         16
         (big-endian->signed #xe3 #xd7 #xc2 #xa9)
         'big)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #x00 #xf3 #x45 #x23 #x19 #x23 #xc7 #x72
                    #xe8 #x3a #x1c #x22 #x59 #xe3 #xd7 #xc2 #xa9 #xad #xad
                    #xad))))

     (let ([v (bytevector #xc7 #xc7 #xc7 #xc7)])
       (do ([i 10000 (fx- i 1)])
           ((fx= i 0) #t)
           (let ([ls (map (lambda (x) (random (expt 2 8))) (make-list 4))])
             (bytevector-s32-set! v 0 (apply big-endian->signed ls) 'big)
             (unless (equal? v (apply bytevector ls))
                     (errorf #f "failed for ~s" ls)))))

     ; aligned accesses, endianness little
     (begin
       (define $v1 (make-bytevector 23 #xad))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))

     (begin
       (bytevector-s32-set! $v1 0 -1 'little)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xff #xff #xff #xff #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s32-set!
         $v1
         0
         (little-endian->signed #x80 #x00 #x00 #x00)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x80 #x00 #x00 #x00 #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s32-set!
         $v1
         0
         (little-endian->signed #x00 #x00 #x00 #x80)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #x80 #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s32-set!
         $v1
         0
         (little-endian->signed #x7f #xff #xff #xff)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x7f #xff #xff #xff #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s32-set!
         $v1
         0
         (little-endian->signed #xff #xff #xff #x7f)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xff #xff #xff #x7f #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s32-set!
         $v1
         0
         (little-endian->signed #xff #xff #xff #xff)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xff #xff #xff #xff #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s32-set! $v1 0 #x00000000 'little)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #x00 #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s32-set!
         $v1
         4
         (little-endian->signed #xf3 #x45 #x23 #x19)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #x00 #xf3 #x45 #x23 #x19 #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s32-set!
         $v1
         8
         (little-endian->signed #x23 #xc7 #x72 #xe8)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #x00 #xf3 #x45 #x23 #x19 #x23 #xc7 #x72
                    #xe8 #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s32-set!
         $v1
         12
         (little-endian->signed #x3a #x1c #x22 #x59)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #x00 #xf3 #x45 #x23 #x19 #x23 #xc7 #x72
                    #xe8 #x3a #x1c #x22 #x59 #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s32-set!
         $v1
         16
         (little-endian->signed #xe3 #xd7 #xc2 #xa9)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #x00 #xf3 #x45 #x23 #x19 #x23 #xc7 #x72
                    #xe8 #x3a #x1c #x22 #x59 #xe3 #xd7 #xc2 #xa9 #xad #xad
                    #xad))))

     (let ([v (bytevector #xc7 #xc7 #xc7 #xc7)])
       (do ([i 10000 (fx- i 1)])
           ((fx= i 0) #t)
           (let ([ls (map (lambda (x) (random (expt 2 8))) (make-list 4))])
             (bytevector-s32-set!
               v
               0
               (apply little-endian->signed ls)
               'little)
             (unless (equal? v (apply bytevector ls))
                     (errorf #f "failed for ~s" ls)))))

     ; unaligned accesses, endianness mixed
     (begin
       (define $v1 (make-bytevector 23 #xad))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))

     (begin
       (bytevector-s32-set! $v1 1 -1 'big)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #xff #xff #xff #xff #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s32-set!
         $v1
         1
         (little-endian->signed #x80 #x00 #x00 #x00)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #x80 #x00 #x00 #x00 #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s32-set!
         $v1
         1
         (native->signed #x00 #x00 #x00 #x80)
         (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #x00 #x00 #x00 #x80 #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s32-set!
         $v1
         1
         (native->signed #x7f #xff #xff #xff)
         (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #x7f #xff #xff #xff #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s32-set!
         $v1
         1
         (big-endian->signed #xff #xff #xff #x7f)
         'big)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #xff #xff #xff #x7f #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s32-set!
         $v1
         1
         (little-endian->signed #xff #xff #xff #xff)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #xff #xff #xff #xff #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s32-set! $v1 1 #x00000000 'little)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #x00 #x00 #x00 #x00 #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s32-set!
         $v1
         5
         (native->signed #xf3 #x45 #x23 #x19)
         (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #x00 #x00 #x00 #x00 #xf3 #x45 #x23 #x19 #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s32-set!
         $v1
         10
         (little-endian->signed #x23 #xc7 #x72 #xe8)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #x00 #x00 #x00 #x00 #xf3 #x45 #x23 #x19 #xad #x23
                    #xc7 #x72 #xe8 #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s32-set!
         $v1
         15
         (big-endian->signed #x3a #x1c #x22 #x59)
         'big)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #x00 #x00 #x00 #x00 #xf3 #x45 #x23 #x19 #xad #x23
                    #xc7 #x72 #xe8 #xad #x3a #x1c #x22 #x59 #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-s32-set!
         $v1
         19
         (little-endian->signed #xe3 #xd7 #xc2 #xa9)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #x00 #x00 #x00 #x00 #xf3 #x45 #x23 #x19 #xad #x23
                    #xc7 #x72 #xe8 #xad #x3a #x1c #x22 #x59 #xe3 #xd7 #xc2
                    #xa9))))

     (let ([v (bytevector #xc7 #xc7 #xc7 #xc7 #xc7)])
       (do ([i 10000 (fx- i 1)])
           ((fx= i 0) #t)
           (let ([ls (map (lambda (x) (random (expt 2 8))) (make-list 4))])
             (bytevector-s32-set! v 1 (apply big-endian->signed ls) 'big)
             (unless (equal? v (apply bytevector #xc7 ls))
                     (errorf #f "failed for ~s" ls))
             (bytevector-s32-set!
               v
               1
               (apply little-endian->signed (reverse ls))
               'little)
             (unless (equal? v (apply bytevector #xc7 (reverse ls)))
                     (errorf #f "failed for ~s" ls))
             (bytevector-s32-set!
               v
               1
               (apply native->signed ls)
               (native-endianness))
             (unless (equal? v (apply bytevector #xc7 ls))
                     (errorf #f "failed for ~s" ls))))))

(mat bytevector-u32-set!
     (begin
       (define $v1 (make-bytevector 23 #xad))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))

     ; wrong argument count
     (error? (bytevector-u32-set!))
     (error? (bytevector-u32-set! $v1))
     (error? (bytevector-u32-set! $v1 0))
     (error? (bytevector-u32-set! $v1 0 0))
     (error? (if (bytevector-u32-set! $v1 0 0 'big 0) #f #t))

     ; not a bytevector
     (error? (bytevector-u32-set! (make-vector 10) 0 0 (native-endianness)))
     (error? (if (bytevector-u32-set!
                   (make-vector 10)
                   0
                   0
                   (native-endianness))
                 #f
                 #t))

     ; invalid index
     (error? (bytevector-u32-set! $v1 -1 0 'big))
     (error? (bytevector-u32-set! $v1 20 0 'little))
     (error? (bytevector-u32-set! $v1 21 0 (native-endianness)))
     (error? (bytevector-u32-set! $v1 22 0 'little))
     (error? (bytevector-u32-set! $v1 23 0 (native-endianness)))
     (error? (if (bytevector-u32-set! $v1 'q 0 'big) #f #t))

     ; invalid value
     (error? (bytevector-u32-set! $v1 0 #x100000000 'big))
     (error? (bytevector-u32-set! $v1 4 #x-1 (native-endianness)))
     (error? (if (bytevector-u32-set! $v1 8 "hello" 'little) #f #t))

     ; invalid endianness
     (error? (bytevector-u32-set! $v1 0 #xfffffff 'huge))
     (error? (bytevector-u32-set! $v1 4 0 "tiny"))
     (error? (if (bytevector-u32-set! $v1 8 0 $v1) #f #t))

     ; make sure no damage done
     (and (bytevector? $v1)
          (equal? $v1
            '#vu8(#xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                  #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                  #xad)))

     ; aligned accesses, endianness native
     (begin
       (bytevector-u32-set! $v1 0 #xffffffff (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xff #xff #xff #xff #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u32-set!
         $v1
         0
         (native->unsigned #x80 #x00 #x00 #x00)
         (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x80 #x00 #x00 #x00 #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u32-set!
         $v1
         0
         (native->unsigned #x00 #x00 #x00 #x80)
         (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #x80 #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u32-set!
         $v1
         0
         (native->unsigned #x7f #xff #xff #xff)
         (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x7f #xff #xff #xff #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u32-set!
         $v1
         0
         (native->unsigned #xff #xff #xff #x7f)
         (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xff #xff #xff #x7f #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u32-set!
         $v1
         0
         (native->unsigned #xff #xff #xff #xff)
         (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xff #xff #xff #xff #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u32-set! $v1 0 #x00000000 (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #x00 #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u32-set!
         $v1
         4
         (native->unsigned #xf3 #x45 #x23 #x19)
         (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #x00 #xf3 #x45 #x23 #x19 #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u32-set!
         $v1
         8
         (native->unsigned #x23 #xc7 #x72 #xe8)
         (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #x00 #xf3 #x45 #x23 #x19 #x23 #xc7 #x72
                    #xe8 #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u32-set!
         $v1
         12
         (native->unsigned #x3a #x1c #x22 #x59)
         (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #x00 #xf3 #x45 #x23 #x19 #x23 #xc7 #x72
                    #xe8 #x3a #x1c #x22 #x59 #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u32-set!
         $v1
         16
         (native->unsigned #xe3 #xd7 #xc2 #xa9)
         (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #x00 #xf3 #x45 #x23 #x19 #x23 #xc7 #x72
                    #xe8 #x3a #x1c #x22 #x59 #xe3 #xd7 #xc2 #xa9 #xad #xad
                    #xad))))

     (let ([v (bytevector #xc7 #xc7 #xc7 #xc7)])
       (do ([i 10000 (fx- i 1)])
           ((fx= i 0) #t)
           (let ([ls (map (lambda (x) (random (expt 2 8))) (make-list 4))])
             (bytevector-u32-set!
               v
               0
               (apply native->unsigned ls)
               (native-endianness))
             (unless (equal? v (apply bytevector ls))
                     (errorf #f "failed for ~s" ls)))))

     ; aligned accesses, endianness big
     (begin
       (define $v1 (make-bytevector 23 #xad))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))

     (begin
       (bytevector-u32-set! $v1 0 #xffffffff 'big)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xff #xff #xff #xff #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u32-set!
         $v1
         0
         (big-endian->unsigned #x80 #x00 #x00 #x00)
         'big)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x80 #x00 #x00 #x00 #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u32-set!
         $v1
         0
         (big-endian->unsigned #x00 #x00 #x00 #x80)
         'big)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #x80 #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u32-set!
         $v1
         0
         (big-endian->unsigned #x7f #xff #xff #xff)
         'big)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x7f #xff #xff #xff #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u32-set!
         $v1
         0
         (big-endian->unsigned #xff #xff #xff #x7f)
         'big)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xff #xff #xff #x7f #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u32-set!
         $v1
         0
         (big-endian->unsigned #xff #xff #xff #xff)
         'big)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xff #xff #xff #xff #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u32-set! $v1 0 #x00000000 'big)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #x00 #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u32-set!
         $v1
         4
         (big-endian->unsigned #xf3 #x45 #x23 #x19)
         'big)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #x00 #xf3 #x45 #x23 #x19 #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u32-set!
         $v1
         8
         (big-endian->unsigned #x23 #xc7 #x72 #xe8)
         'big)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #x00 #xf3 #x45 #x23 #x19 #x23 #xc7 #x72
                    #xe8 #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u32-set!
         $v1
         12
         (big-endian->unsigned #x3a #x1c #x22 #x59)
         'big)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #x00 #xf3 #x45 #x23 #x19 #x23 #xc7 #x72
                    #xe8 #x3a #x1c #x22 #x59 #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u32-set!
         $v1
         16
         (big-endian->unsigned #xe3 #xd7 #xc2 #xa9)
         'big)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #x00 #xf3 #x45 #x23 #x19 #x23 #xc7 #x72
                    #xe8 #x3a #x1c #x22 #x59 #xe3 #xd7 #xc2 #xa9 #xad #xad
                    #xad))))

     (let ([v (bytevector #xc7 #xc7 #xc7 #xc7)])
       (do ([i 10000 (fx- i 1)])
           ((fx= i 0) #t)
           (let ([ls (map (lambda (x) (random (expt 2 8))) (make-list 4))])
             (bytevector-u32-set! v 0 (apply big-endian->unsigned ls) 'big)
             (unless (equal? v (apply bytevector ls))
                     (errorf #f "failed for ~s" ls)))))

     ; aligned accesses, endianness little
     (begin
       (define $v1 (make-bytevector 23 #xad))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))

     (begin
       (bytevector-u32-set! $v1 0 #xffffffff 'little)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xff #xff #xff #xff #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u32-set!
         $v1
         0
         (little-endian->unsigned #x80 #x00 #x00 #x00)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x80 #x00 #x00 #x00 #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u32-set!
         $v1
         0
         (little-endian->unsigned #x00 #x00 #x00 #x80)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #x80 #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u32-set!
         $v1
         0
         (little-endian->unsigned #x7f #xff #xff #xff)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x7f #xff #xff #xff #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u32-set!
         $v1
         0
         (little-endian->unsigned #xff #xff #xff #x7f)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xff #xff #xff #x7f #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u32-set!
         $v1
         0
         (little-endian->unsigned #xff #xff #xff #xff)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xff #xff #xff #xff #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u32-set! $v1 0 #x00000000 'little)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #x00 #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u32-set!
         $v1
         4
         (little-endian->unsigned #xf3 #x45 #x23 #x19)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #x00 #xf3 #x45 #x23 #x19 #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u32-set!
         $v1
         8
         (little-endian->unsigned #x23 #xc7 #x72 #xe8)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #x00 #xf3 #x45 #x23 #x19 #x23 #xc7 #x72
                    #xe8 #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u32-set!
         $v1
         12
         (little-endian->unsigned #x3a #x1c #x22 #x59)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #x00 #xf3 #x45 #x23 #x19 #x23 #xc7 #x72
                    #xe8 #x3a #x1c #x22 #x59 #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u32-set!
         $v1
         16
         (little-endian->unsigned #xe3 #xd7 #xc2 #xa9)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #x00 #xf3 #x45 #x23 #x19 #x23 #xc7 #x72
                    #xe8 #x3a #x1c #x22 #x59 #xe3 #xd7 #xc2 #xa9 #xad #xad
                    #xad))))

     (let ([v (bytevector #xc7 #xc7 #xc7 #xc7)])
       (do ([i 10000 (fx- i 1)])
           ((fx= i 0) #t)
           (let ([ls (map (lambda (x) (random (expt 2 8))) (make-list 4))])
             (bytevector-u32-set!
               v
               0
               (apply little-endian->unsigned ls)
               'little)
             (unless (equal? v (apply bytevector ls))
                     (errorf #f "failed for ~s" ls)))))

     ; unaligned accesses, endianness mixed
     (begin
       (define $v1 (make-bytevector 23 #xad))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))

     (begin
       (bytevector-u32-set! $v1 1 #xffffffff 'big)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #xff #xff #xff #xff #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u32-set!
         $v1
         1
         (little-endian->unsigned #x80 #x00 #x00 #x00)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #x80 #x00 #x00 #x00 #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u32-set!
         $v1
         1
         (native->unsigned #x00 #x00 #x00 #x80)
         (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #x00 #x00 #x00 #x80 #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u32-set!
         $v1
         1
         (native->unsigned #x7f #xff #xff #xff)
         (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #x7f #xff #xff #xff #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u32-set!
         $v1
         1
         (big-endian->unsigned #xff #xff #xff #x7f)
         'big)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #xff #xff #xff #x7f #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u32-set!
         $v1
         1
         (little-endian->unsigned #xff #xff #xff #xff)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #xff #xff #xff #xff #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u32-set! $v1 1 #x00000000 'little)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #x00 #x00 #x00 #x00 #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u32-set!
         $v1
         5
         (native->unsigned #xf3 #x45 #x23 #x19)
         (native-endianness))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #x00 #x00 #x00 #x00 #xf3 #x45 #x23 #x19 #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u32-set!
         $v1
         10
         (little-endian->unsigned #x23 #xc7 #x72 #xe8)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #x00 #x00 #x00 #x00 #xf3 #x45 #x23 #x19 #xad #x23
                    #xc7 #x72 #xe8 #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u32-set!
         $v1
         15
         (big-endian->unsigned #x3a #x1c #x22 #x59)
         'big)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #x00 #x00 #x00 #x00 #xf3 #x45 #x23 #x19 #xad #x23
                    #xc7 #x72 #xe8 #xad #x3a #x1c #x22 #x59 #xad #xad #xad
                    #xad))))
     (begin
       (bytevector-u32-set!
         $v1
         19
         (little-endian->unsigned #xe3 #xd7 #xc2 #xa9)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #x00 #x00 #x00 #x00 #xf3 #x45 #x23 #x19 #xad #x23
                    #xc7 #x72 #xe8 #xad #x3a #x1c #x22 #x59 #xe3 #xd7 #xc2
                    #xa9))))

     (let ([v (bytevector #xc7 #xc7 #xc7 #xc7 #xc7)])
       (do ([i 10000 (fx- i 1)])
           ((fx= i 0) #t)
           (let ([ls (map (lambda (x) (random (expt 2 8))) (make-list 4))])
             (bytevector-u32-set! v 1 (apply big-endian->unsigned ls) 'big)
             (unless (equal? v (apply bytevector #xc7 ls))
                     (errorf #f "failed for ~s" ls))
             (bytevector-u32-set!
               v
               1
               (apply little-endian->unsigned (reverse ls))
               'little)
             (unless (equal? v (apply bytevector #xc7 (reverse ls)))
                     (errorf #f "failed for ~s" ls))
             (bytevector-u32-set!
               v
               1
               (apply native->unsigned ls)
               (native-endianness))
             (unless (equal? v (apply bytevector #xc7 ls))
                     (errorf #f "failed for ~s" ls))))))

(mat bytevector-s40-ref
     ; wrong argument count
     (error? (bytevector-s40-ref))
     (error? (bytevector-s40-ref #vu8(3 252 5 0 0)))
     (error? (bytevector-s40-ref #vu8(3 252 5 0 0) 0))
     (error? (begin
               (bytevector-s40-ref
                 #vu8(3 252 5 0 0)
                 0
                 (native-endianness)
                 0)
               #f))

     ; not a bytevector
     (error? (bytevector-s40-ref '#(3 252 5 0 0 0 0) 0 'big))
     (error? (begin (bytevector-s40-ref '#(3 252 5 0 0 0 0) 0 'big) #f))

     ; invalid index
     (error? (bytevector-s40-ref #vu8(3 252 5 0 0 0 0) -1 'big))
     (error? (bytevector-s40-ref #vu8(3 252 5 0 0 0 0) 3 'little))
     (error? (bytevector-s40-ref
               #vu8(3 252 5 0 0 0 0)
               7
               (native-endianness)))
     (error? (begin
               (bytevector-s40-ref #vu8(3 252 5 0 0 0 0) 4.0 'little)
               #f))

     ; invalid endianness
     (error? (bytevector-s40-ref #vu8(0 1 2 3 4 5 6 7) 0 'bigger))
     (error? (bytevector-s40-ref #vu8(0 1 2 3 4 5 6 7) 0 "little"))
     (error? (begin (bytevector-s40-ref #vu8(0 1 2 3 4 5 6 7) 0 #t) #f))

     (do ([i 1000 (fx- i 1)])
         ((fx= i 0) #t)
         (let ([ls (map (lambda (x) (random (expt 2 8))) (make-list 6))])
           (unless (eqv? (bytevector-s40-ref
                           (apply bytevector ls)
                           1
                           (native-endianness))
                         (apply native->signed (cdr ls)))
                   (errorf #f "failed for ~s (native)" ls))
           (unless (eqv? (bytevector-s40-ref (apply bytevector ls) 1 'little)
                         (apply little-endian->signed (cdr ls)))
                   (errorf #f "failed for ~s (little)" ls))
           (unless (eqv? (bytevector-s40-ref (apply bytevector ls) 1 'big)
                         (apply big-endian->signed (cdr ls)))
                   (errorf #f "failed for ~s (big)" ls))))

     (do ([i 1000 (fx- i 1)])
         ((fx= i 0) #t)
         (let ([ls (map (lambda (x) (random (expt 2 8))) (make-list 6))])
           (unless (eqv? (eval `(bytevector-s40-ref
                                  ,(apply bytevector ls)
                                  1
                                  (native-endianness)))
                         (apply native->signed (cdr ls)))
                   (errorf #f "failed for ~s (native)" ls))
           (unless (eqv? (eval `(bytevector-s40-ref
                                  ,(apply bytevector ls)
                                  1
                                  'little))
                         (apply little-endian->signed (cdr ls)))
                   (errorf #f "failed for ~s (little)" ls))
           (unless (eqv? (eval `(bytevector-s40-ref
                                  ,(apply bytevector ls)
                                  1
                                  'big))
                         (apply big-endian->signed (cdr ls)))
                   (errorf #f "failed for ~s (big)" ls)))))

(mat bytevector-u40-ref
     ; wrong argument count
     (error? (bytevector-u40-ref))
     (error? (bytevector-u40-ref #vu8(3 252 5 0 0)))
     (error? (bytevector-u40-ref #vu8(3 252 5 0 0) 0))
     (error? (begin
               (bytevector-u40-ref
                 #vu8(3 252 5 0 0)
                 0
                 (native-endianness)
                 0)
               #f))

     ; not a bytevector
     (error? (bytevector-u40-ref '#(3 252 5 0 0 0 0) 0 'big))
     (error? (begin (bytevector-u40-ref '#(3 252 5 0 0 0 0) 0 'big) #f))

     ; invalid index
     (error? (bytevector-u40-ref #vu8(3 252 5 0 0 0 0) -1 'big))
     (error? (bytevector-u40-ref #vu8(3 252 5 0 0 0 0) 3 'little))
     (error? (bytevector-u40-ref
               #vu8(3 252 5 0 0 0 0)
               7
               (native-endianness)))
     (error? (begin
               (bytevector-u40-ref #vu8(3 252 5 0 0 0 0) 4.0 'little)
               #f))

     ; invalid endianness
     (error? (bytevector-u40-ref #vu8(0 1 2 3 4 5 6 7) 0 'bigger))
     (error? (bytevector-u40-ref #vu8(0 1 2 3 4 5 6 7) 0 "little"))
     (error? (begin (bytevector-u40-ref #vu8(0 1 2 3 4 5 6 7) 0 #t) #f))

     (do ([i 1000 (fx- i 1)])
         ((fx= i 0) #t)
         (let ([ls (map (lambda (x) (random (expt 2 8))) (make-list 6))])
           (unless (eqv? (bytevector-u40-ref
                           (apply bytevector ls)
                           1
                           (native-endianness))
                         (apply native->unsigned (cdr ls)))
                   (errorf #f "failed for ~s (native)" ls))
           (unless (eqv? (bytevector-u40-ref (apply bytevector ls) 1 'little)
                         (apply little-endian->unsigned (cdr ls)))
                   (errorf #f "failed for ~s (little)" ls))
           (unless (eqv? (bytevector-u40-ref (apply bytevector ls) 1 'big)
                         (apply big-endian->unsigned (cdr ls)))
                   (errorf #f "failed for ~s (big)" ls))))

     (do ([i 1000 (fx- i 1)])
         ((fx= i 0) #t)
         (let ([ls (map (lambda (x) (random (expt 2 8))) (make-list 6))])
           (unless (eqv? (eval `(bytevector-u40-ref
                                  ,(apply bytevector ls)
                                  1
                                  (native-endianness)))
                         (apply native->unsigned (cdr ls)))
                   (errorf #f "failed for ~s (native)" ls))
           (unless (eqv? (eval `(bytevector-u40-ref
                                  ,(apply bytevector ls)
                                  1
                                  'little))
                         (apply little-endian->unsigned (cdr ls)))
                   (errorf #f "failed for ~s (little)" ls))
           (unless (eqv? (eval `(bytevector-u40-ref
                                  ,(apply bytevector ls)
                                  1
                                  'big))
                         (apply big-endian->unsigned (cdr ls)))
                   (errorf #f "failed for ~s (big)" ls)))))

(mat bytevector-s40-set!
     (begin
       (define $v1 (make-bytevector 23 #xad))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))

     ; wrong argument count
     (error? (bytevector-s40-set!))
     (error? (bytevector-s40-set! $v1))
     (error? (bytevector-s40-set! $v1 0))
     (error? (bytevector-s40-set! $v1 0 0))
     (error? (begin (bytevector-s40-set! $v1 0 0 'big 0) #f))

     ; not a bytevector
     (error? (bytevector-s40-set! (make-vector 10) 0 0 (native-endianness)))
     (error? (begin
               (bytevector-s40-set!
                 (make-vector 10)
                 0
                 0
                 (native-endianness))
               #f))

     ; invalid index
     (error? (bytevector-s40-set! $v1 -1 0 'big))
     (error? (bytevector-s40-set! $v1 19 0 (native-endianness)))
     (error? (bytevector-s40-set! $v1 22 0 'little))
     (error? (bytevector-s40-set! $v1 23 0 (native-endianness)))
     (error? (begin (bytevector-s40-set! $v1 'q 0 'big) #f))

     ; invalid value
     (error? (bytevector-s40-set! $v1 0 (expt 2 39) 'big))
     (error? (bytevector-s40-set!
               $v1
               4
               (- -1 (expt 2 39))
               (native-endianness)))
     (error? (begin (bytevector-s40-set! $v1 8 "hello" 'little) #f))

     ; invalid endianness
     (error? (bytevector-s40-set! $v1 0 #x7ffffff 'huge))
     (error? (bytevector-s40-set! $v1 4 #x-80000000 "tiny"))
     (error? (begin (bytevector-s40-set! $v1 8 0 $v1) #f))

     ; make sure no damage done
     (and (bytevector? $v1)
          (equal? $v1
            '#vu8(#xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                  #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                  #xad)))

     (let ([v (bytevector #xc7 #xc7 #xc7 #xc7 #xc7 #xc7)])
       (do ([i 1000 (fx- i 1)])
           ((fx= i 0) #t)
           (let ([ls (map (lambda (x) (random (expt 2 8))) (make-list 5))])
             (bytevector-s40-set! v 1 (apply big-endian->signed ls) 'big)
             (unless (equal? v (apply bytevector #xc7 ls))
                     (errorf #f "failed for ~s" ls))
             (bytevector-s40-set!
               v
               1
               (apply little-endian->signed (reverse ls))
               'little)
             (unless (equal? v (apply bytevector #xc7 (reverse ls)))
                     (errorf #f "failed for ~s" ls))
             (bytevector-s40-set!
               v
               1
               (apply native->signed ls)
               (native-endianness))
             (unless (equal? v (apply bytevector #xc7 ls))
                     (errorf #f "failed for ~s" ls)))))

     (let ([v (bytevector #xc7 #xc7 #xc7 #xc7 #xc7 #xc7)])
       (do ([i 1000 (fx- i 1)])
           ((fx= i 0) #t)
           (let ([ls (map (lambda (x) (random (expt 2 8))) (make-list 5))])
             (eval `(bytevector-s40-set!
                      ,v
                      1
                      ,(apply big-endian->signed ls)
                      'big))
             (unless (equal? v (apply bytevector #xc7 ls))
                     (errorf #f "failed for ~s" ls))
             (eval `(bytevector-s40-set!
                      ,v
                      1
                      ,(apply little-endian->signed (reverse ls))
                      'little))
             (unless (equal? v (apply bytevector #xc7 (reverse ls)))
                     (errorf #f "failed for ~s" ls))
             (eval `(bytevector-s40-set!
                      ,v
                      1
                      ,(apply native->signed ls)
                      (native-endianness)))
             (unless (equal? v (apply bytevector #xc7 ls))
                     (errorf #f "failed for ~s" ls))))))

(mat bytevector-u40-set!
     (begin
       (define $v1 (make-bytevector 23 #xad))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))

     ; wrong argument count
     (error? (bytevector-u40-set!))
     (error? (bytevector-u40-set! $v1))
     (error? (bytevector-u40-set! $v1 0))
     (error? (bytevector-u40-set! $v1 0 0))
     (error? (begin (bytevector-u40-set! $v1 0 0 'big 0) #f))

     ; not a bytevector
     (error? (bytevector-u40-set! (make-vector 10) 0 0 (native-endianness)))
     (error? (begin
               (bytevector-u40-set!
                 (make-vector 10)
                 0
                 0
                 (native-endianness))
               #f))

     ; invalid index
     (error? (bytevector-u40-set! $v1 -1 0 'big))
     (error? (bytevector-u40-set! $v1 19 0 (native-endianness)))
     (error? (bytevector-u40-set! $v1 22 0 'little))
     (error? (bytevector-u40-set! $v1 23 0 (native-endianness)))
     (error? (begin (bytevector-u40-set! $v1 'q 0 'big) #f))

     ; invalid value
     (error? (bytevector-u40-set! $v1 0 (expt 2 40) 'big))
     (error? (bytevector-u40-set! $v1 4 -1 (native-endianness)))
     (error? (begin (bytevector-u40-set! $v1 8 "hello" 'little) #f))

     ; invalid endianness
     (error? (bytevector-u40-set! $v1 0 0 'huge))
     (error? (bytevector-u40-set! $v1 4 0 "tiny"))
     (error? (begin (bytevector-u40-set! $v1 8 0 $v1) #f))

     ; make sure no damage done
     (and (bytevector? $v1)
          (equal? $v1
            '#vu8(#xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                  #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                  #xad)))

     (let ([v (bytevector #xc7 #xc7 #xc7 #xc7 #xc7 #xc7)])
       (do ([i 1000 (fx- i 1)])
           ((fx= i 0) #t)
           (let ([ls (map (lambda (x) (random (expt 2 8))) (make-list 5))])
             (bytevector-u40-set! v 1 (apply big-endian->unsigned ls) 'big)
             (unless (equal? v (apply bytevector #xc7 ls))
                     (errorf #f "failed for ~s" ls))
             (bytevector-u40-set!
               v
               1
               (apply little-endian->unsigned (reverse ls))
               'little)
             (unless (equal? v (apply bytevector #xc7 (reverse ls)))
                     (errorf #f "failed for ~s" ls))
             (bytevector-u40-set!
               v
               1
               (apply native->unsigned ls)
               (native-endianness))
             (unless (equal? v (apply bytevector #xc7 ls))
                     (errorf #f "failed for ~s" ls)))))

     (let ([v (bytevector #xc7 #xc7 #xc7 #xc7 #xc7 #xc7)])
       (do ([i 1000 (fx- i 1)])
           ((fx= i 0) #t)
           (let ([ls (map (lambda (x) (random (expt 2 8))) (make-list 5))])
             (eval `(bytevector-u40-set!
                      ,v
                      1
                      ,(apply big-endian->unsigned ls)
                      'big))
             (unless (equal? v (apply bytevector #xc7 ls))
                     (errorf #f "failed for ~s" ls))
             (eval `(bytevector-u40-set!
                      ,v
                      1
                      ,(apply little-endian->unsigned (reverse ls))
                      'little))
             (unless (equal? v (apply bytevector #xc7 (reverse ls)))
                     (errorf #f "failed for ~s" ls))
             (eval `(bytevector-u40-set!
                      ,v
                      1
                      ,(apply native->unsigned ls)
                      (native-endianness)))
             (unless (equal? v (apply bytevector #xc7 ls))
                     (errorf #f "failed for ~s" ls))))))

(mat bytevector-s48-ref
     ; wrong argument count
     (error? (bytevector-s48-ref))
     (error? (bytevector-s48-ref #vu8(3 252 5 0 0 0)))
     (error? (bytevector-s48-ref #vu8(3 252 5 0 0 0) 0))
     (error? (begin
               (bytevector-s48-ref
                 #vu8(3 252 5 0 0 0)
                 0
                 (native-endianness)
                 0)
               #f))

     ; not a bytevector
     (error? (bytevector-s48-ref '#(3 252 5 0 0 0 0) 0 'big))
     (error? (begin (bytevector-s48-ref '#(3 252 5 0 0 0 0) 0 'big) #f))

     ; invalid index
     (error? (bytevector-s48-ref #vu8(3 252 5 0 0 0 0) -1 'big))
     (error? (bytevector-s48-ref #vu8(3 252 5 0 0 0 0) 2 'little))
     (error? (bytevector-s48-ref
               #vu8(3 252 5 0 0 0 0)
               7
               (native-endianness)))
     (error? (begin
               (bytevector-s48-ref #vu8(3 252 5 0 0 0 0) 4.0 'little)
               #f))

     ; invalid endianness
     (error? (bytevector-s48-ref #vu8(0 1 2 3 4 5 6 7) 0 'bigger))
     (error? (bytevector-s48-ref #vu8(0 1 2 3 4 5 6 7) 0 "little"))
     (error? (begin (bytevector-s48-ref #vu8(0 1 2 3 4 5 6 7) 0 #t) #f))

     (do ([i 1000 (fx- i 1)])
         ((fx= i 0) #t)
         (let ([ls (map (lambda (x) (random (expt 2 8))) (make-list 7))])
           (unless (eqv? (bytevector-s48-ref
                           (apply bytevector ls)
                           1
                           (native-endianness))
                         (apply native->signed (cdr ls)))
                   (errorf #f "failed for ~s (native)" ls))
           (unless (eqv? (bytevector-s48-ref (apply bytevector ls) 1 'little)
                         (apply little-endian->signed (cdr ls)))
                   (errorf #f "failed for ~s (little)" ls))
           (unless (eqv? (bytevector-s48-ref (apply bytevector ls) 1 'big)
                         (apply big-endian->signed (cdr ls)))
                   (errorf #f "failed for ~s (big)" ls))))

     (do ([i 1000 (fx- i 1)])
         ((fx= i 0) #t)
         (let ([ls (map (lambda (x) (random (expt 2 8))) (make-list 7))])
           (unless (eqv? (eval `(bytevector-s48-ref
                                  ,(apply bytevector ls)
                                  1
                                  (native-endianness)))
                         (apply native->signed (cdr ls)))
                   (errorf #f "failed for ~s (native)" ls))
           (unless (eqv? (eval `(bytevector-s48-ref
                                  ,(apply bytevector ls)
                                  1
                                  'little))
                         (apply little-endian->signed (cdr ls)))
                   (errorf #f "failed for ~s (little)" ls))
           (unless (eqv? (eval `(bytevector-s48-ref
                                  ,(apply bytevector ls)
                                  1
                                  'big))
                         (apply big-endian->signed (cdr ls)))
                   (errorf #f "failed for ~s (big)" ls)))))

(mat bytevector-u48-ref
     ; wrong argument count
     (error? (bytevector-u48-ref))
     (error? (bytevector-u48-ref #vu8(3 252 5 0 0 0)))
     (error? (bytevector-u48-ref #vu8(3 252 5 0 0 0) 0))
     (error? (begin
               (bytevector-u48-ref
                 #vu8(3 252 5 0 0 0)
                 0
                 (native-endianness)
                 0)
               #f))

     ; not a bytevector
     (error? (bytevector-u48-ref '#(3 252 5 0 0 0 0) 0 'big))
     (error? (begin (bytevector-u48-ref '#(3 252 5 0 0 0 0) 0 'big) #f))

     ; invalid index
     (error? (bytevector-u48-ref #vu8(3 252 5 0 0 0 0) -1 'big))
     (error? (bytevector-u48-ref #vu8(3 252 5 0 0 0 0) 2 'little))
     (error? (bytevector-u48-ref
               #vu8(3 252 5 0 0 0 0)
               7
               (native-endianness)))
     (error? (begin
               (bytevector-u48-ref #vu8(3 252 5 0 0 0 0) 4.0 'little)
               #f))

     ; invalid endianness
     (error? (bytevector-u48-ref #vu8(0 1 2 3 4 5 6 7) 0 'bigger))
     (error? (bytevector-u48-ref #vu8(0 1 2 3 4 5 6 7) 0 "little"))
     (error? (begin (bytevector-u48-ref #vu8(0 1 2 3 4 5 6 7) 0 #t) #f))

     (do ([i 1000 (fx- i 1)])
         ((fx= i 0) #t)
         (let ([ls (map (lambda (x) (random (expt 2 8))) (make-list 7))])
           (unless (eqv? (bytevector-u48-ref
                           (apply bytevector ls)
                           1
                           (native-endianness))
                         (apply native->unsigned (cdr ls)))
                   (errorf #f "failed for ~s (native)" ls))
           (unless (eqv? (bytevector-u48-ref (apply bytevector ls) 1 'little)
                         (apply little-endian->unsigned (cdr ls)))
                   (errorf #f "failed for ~s (little)" ls))
           (unless (eqv? (bytevector-u48-ref (apply bytevector ls) 1 'big)
                         (apply big-endian->unsigned (cdr ls)))
                   (errorf #f "failed for ~s (big)" ls))))

     (do ([i 1000 (fx- i 1)])
         ((fx= i 0) #t)
         (let ([ls (map (lambda (x) (random (expt 2 8))) (make-list 7))])
           (unless (eqv? (eval `(bytevector-u48-ref
                                  ,(apply bytevector ls)
                                  1
                                  (native-endianness)))
                         (apply native->unsigned (cdr ls)))
                   (errorf #f "failed for ~s (native)" ls))
           (unless (eqv? (eval `(bytevector-u48-ref
                                  ,(apply bytevector ls)
                                  1
                                  'little))
                         (apply little-endian->unsigned (cdr ls)))
                   (errorf #f "failed for ~s (little)" ls))
           (unless (eqv? (eval `(bytevector-u48-ref
                                  ,(apply bytevector ls)
                                  1
                                  'big))
                         (apply big-endian->unsigned (cdr ls)))
                   (errorf #f "failed for ~s (big)" ls)))))

(mat bytevector-s48-set!
     (begin
       (define $v1 (make-bytevector 23 #xad))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))

     ; wrong argument count
     (error? (bytevector-s48-set!))
     (error? (bytevector-s48-set! $v1))
     (error? (bytevector-s48-set! $v1 0))
     (error? (bytevector-s48-set! $v1 0 0))
     (error? (begin (bytevector-s48-set! $v1 0 0 'big 0) #f))

     ; not a bytevector
     (error? (bytevector-s48-set! (make-vector 10) 0 0 (native-endianness)))
     (error? (begin
               (bytevector-s48-set!
                 (make-vector 10)
                 0
                 0
                 (native-endianness))
               #f))

     ; invalid index
     (error? (bytevector-s48-set! $v1 -1 0 'big))
     (error? (bytevector-s48-set! $v1 18 0 (native-endianness)))
     (error? (bytevector-s48-set! $v1 22 0 'little))
     (error? (bytevector-s48-set! $v1 23 0 (native-endianness)))
     (error? (begin (bytevector-s48-set! $v1 'q 0 'big) #f))

     ; invalid value
     (error? (bytevector-s48-set! $v1 0 (expt 2 47) 'big))
     (error? (bytevector-s48-set!
               $v1
               4
               (- -1 (expt 2 47))
               (native-endianness)))
     (error? (begin (bytevector-s48-set! $v1 8 "hello" 'little) #f))

     ; invalid endianness
     (error? (bytevector-s48-set! $v1 0 0 'huge))
     (error? (bytevector-s48-set! $v1 4 0 "tiny"))
     (error? (begin (bytevector-s48-set! $v1 8 0 $v1) #f))

     ; make sure no damage done
     (and (bytevector? $v1)
          (equal? $v1
            '#vu8(#xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                  #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                  #xad)))

     (let ([v (bytevector #xc7 #xc7 #xc7 #xc7 #xc7 #xc7 #xc7)])
       (do ([i 1000 (fx- i 1)])
           ((fx= i 0) #t)
           (let ([ls (map (lambda (x) (random (expt 2 8))) (make-list 6))])
             (bytevector-s48-set! v 1 (apply big-endian->signed ls) 'big)
             (unless (equal? v (apply bytevector #xc7 ls))
                     (errorf #f "failed for ~s" ls))
             (bytevector-s48-set!
               v
               1
               (apply little-endian->signed (reverse ls))
               'little)
             (unless (equal? v (apply bytevector #xc7 (reverse ls)))
                     (errorf #f "failed for ~s" ls))
             (bytevector-s48-set!
               v
               1
               (apply native->signed ls)
               (native-endianness))
             (unless (equal? v (apply bytevector #xc7 ls))
                     (errorf #f "failed for ~s" ls)))))

     (let ([v (bytevector #xc7 #xc7 #xc7 #xc7 #xc7 #xc7 #xc7)])
       (do ([i 1000 (fx- i 1)])
           ((fx= i 0) #t)
           (let ([ls (map (lambda (x) (random (expt 2 8))) (make-list 6))])
             (eval `(bytevector-s48-set!
                      ,v
                      1
                      ,(apply big-endian->signed ls)
                      'big))
             (unless (equal? v (apply bytevector #xc7 ls))
                     (errorf #f "failed for ~s" ls))
             (eval `(bytevector-s48-set!
                      ,v
                      1
                      ,(apply little-endian->signed (reverse ls))
                      'little))
             (unless (equal? v (apply bytevector #xc7 (reverse ls)))
                     (errorf #f "failed for ~s" ls))
             (eval `(bytevector-s48-set!
                      ,v
                      1
                      ,(apply native->signed ls)
                      (native-endianness)))
             (unless (equal? v (apply bytevector #xc7 ls))
                     (errorf #f "failed for ~s" ls))))))

(mat bytevector-u48-set!
     (begin
       (define $v1 (make-bytevector 23 #xad))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))

     ; wrong argument count
     (error? (bytevector-u48-set!))
     (error? (bytevector-u48-set! $v1))
     (error? (bytevector-u48-set! $v1 0))
     (error? (bytevector-u48-set! $v1 0 0))
     (error? (begin (bytevector-u48-set! $v1 0 0 'big 0) #f))

     ; not a bytevector
     (error? (bytevector-u48-set! (make-vector 10) 0 0 (native-endianness)))
     (error? (begin
               (bytevector-u48-set!
                 (make-vector 10)
                 0
                 0
                 (native-endianness))
               #f))

     ; invalid index
     (error? (bytevector-u48-set! $v1 -1 0 'big))
     (error? (bytevector-u48-set! $v1 18 0 (native-endianness)))
     (error? (bytevector-u48-set! $v1 22 0 'little))
     (error? (bytevector-u48-set! $v1 23 0 (native-endianness)))
     (error? (begin (bytevector-u48-set! $v1 'q 0 'big) #f))

     ; invalid value
     (error? (bytevector-u48-set! $v1 0 (expt 2 48) 'big))
     (error? (bytevector-u48-set! $v1 4 -1 (native-endianness)))
     (error? (begin (bytevector-u48-set! $v1 8 "hello" 'little) #f))

     ; invalid endianness
     (error? (bytevector-u48-set! $v1 0 0 'huge))
     (error? (bytevector-u48-set! $v1 4 0 "tiny"))
     (error? (begin (bytevector-u48-set! $v1 8 0 $v1) #f))

     ; make sure no damage done
     (and (bytevector? $v1)
          (equal? $v1
            '#vu8(#xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                  #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                  #xad)))

     (let ([v (bytevector #xc7 #xc7 #xc7 #xc7 #xc7 #xc7 #xc7)])
       (do ([i 1000 (fx- i 1)])
           ((fx= i 0) #t)
           (let ([ls (map (lambda (x) (random (expt 2 8))) (make-list 6))])
             (bytevector-u48-set! v 1 (apply big-endian->unsigned ls) 'big)
             (unless (equal? v (apply bytevector #xc7 ls))
                     (errorf #f "failed for ~s" ls))
             (bytevector-u48-set!
               v
               1
               (apply little-endian->unsigned (reverse ls))
               'little)
             (unless (equal? v (apply bytevector #xc7 (reverse ls)))
                     (errorf #f "failed for ~s" ls))
             (bytevector-u48-set!
               v
               1
               (apply native->unsigned ls)
               (native-endianness))
             (unless (equal? v (apply bytevector #xc7 ls))
                     (errorf #f "failed for ~s" ls)))))

     (let ([v (bytevector #xc7 #xc7 #xc7 #xc7 #xc7 #xc7 #xc7)])
       (do ([i 1000 (fx- i 1)])
           ((fx= i 0) #t)
           (let ([ls (map (lambda (x) (random (expt 2 8))) (make-list 6))])
             (eval `(bytevector-u48-set!
                      ,v
                      1
                      ,(apply big-endian->unsigned ls)
                      'big))
             (unless (equal? v (apply bytevector #xc7 ls))
                     (errorf #f "failed for ~s" ls))
             (eval `(bytevector-u48-set!
                      ,v
                      1
                      ,(apply little-endian->unsigned (reverse ls))
                      'little))
             (unless (equal? v (apply bytevector #xc7 (reverse ls)))
                     (errorf #f "failed for ~s" ls))
             (eval `(bytevector-u48-set!
                      ,v
                      1
                      ,(apply native->unsigned ls)
                      (native-endianness)))
             (unless (equal? v (apply bytevector #xc7 ls))
                     (errorf #f "failed for ~s" ls))))))

(mat bytevector-s56-ref
     ; wrong argument count
     (error? (bytevector-s56-ref))
     (error? (bytevector-s56-ref #vu8(3 252 5 0 0 0 0)))
     (error? (bytevector-s56-ref #vu8(3 252 5 0 0 00) 0))
     (error? (begin
               (bytevector-s56-ref
                 #vu8(3 252 5 0 0 0 0)
                 0
                 (native-endianness)
                 0)
               #f))

     ; not a bytevector
     (error? (bytevector-s56-ref '#(3 252 5 0 0 0 0) 0 'big))
     (error? (begin (bytevector-s56-ref '#(3 252 5 0 0 0 0) 0 'big) #f))

     ; invalid index
     (error? (bytevector-s56-ref #vu8(3 252 5 0 0 0 0) -1 'big))
     (error? (bytevector-s56-ref #vu8(3 252 5 0 0 0 0) 1 'little))
     (error? (bytevector-s56-ref
               #vu8(3 252 5 0 0 0 0)
               7
               (native-endianness)))
     (error? (begin
               (bytevector-s56-ref #vu8(3 252 5 0 0 0 0) 4.0 'little)
               #f))

     ; invalid endianness
     (error? (bytevector-s56-ref #vu8(0 1 2 3 4 5 6 7) 0 'bigger))
     (error? (bytevector-s56-ref #vu8(0 1 2 3 4 5 6 7) 0 "little"))
     (error? (begin (bytevector-s56-ref #vu8(0 1 2 3 4 5 6 7) 0 #t) #f))

     (do ([i 1000 (fx- i 1)])
         ((fx= i 0) #t)
         (let ([ls (map (lambda (x) (random (expt 2 8))) (make-list 8))])
           (unless (eqv? (bytevector-s56-ref
                           (apply bytevector ls)
                           1
                           (native-endianness))
                         (apply native->signed (cdr ls)))
                   (errorf #f "failed for ~s (native)" ls))
           (unless (eqv? (bytevector-s56-ref (apply bytevector ls) 1 'little)
                         (apply little-endian->signed (cdr ls)))
                   (errorf #f "failed for ~s (little)" ls))
           (unless (eqv? (bytevector-s56-ref (apply bytevector ls) 1 'big)
                         (apply big-endian->signed (cdr ls)))
                   (errorf #f "failed for ~s (big)" ls))))

     (do ([i 1000 (fx- i 1)])
         ((fx= i 0) #t)
         (let ([ls (map (lambda (x) (random (expt 2 8))) (make-list 8))])
           (unless (eqv? (eval `(bytevector-s56-ref
                                  ,(apply bytevector ls)
                                  1
                                  (native-endianness)))
                         (apply native->signed (cdr ls)))
                   (errorf #f "failed for ~s (native)" ls))
           (unless (eqv? (eval `(bytevector-s56-ref
                                  ,(apply bytevector ls)
                                  1
                                  'little))
                         (apply little-endian->signed (cdr ls)))
                   (errorf #f "failed for ~s (little)" ls))
           (unless (eqv? (eval `(bytevector-s56-ref
                                  ,(apply bytevector ls)
                                  1
                                  'big))
                         (apply big-endian->signed (cdr ls)))
                   (errorf #f "failed for ~s (big)" ls)))))

(mat bytevector-u56-ref
     ; wrong argument count
     (error? (bytevector-u56-ref))
     (error? (bytevector-u56-ref #vu8(3 252 5 0 0 0 0)))
     (error? (bytevector-u56-ref #vu8(3 252 5 0 0 00) 0))
     (error? (begin
               (bytevector-u56-ref
                 #vu8(3 252 5 0 0 0 0)
                 0
                 (native-endianness)
                 0)
               #f))

     ; not a bytevector
     (error? (bytevector-u56-ref '#(3 252 5 0 0 0 0) 0 'big))
     (error? (begin (bytevector-u56-ref '#(3 252 5 0 0 0 0) 0 'big) #f))

     ; invalid index
     (error? (bytevector-u56-ref #vu8(3 252 5 0 0 0 0) -1 'big))
     (error? (bytevector-u56-ref #vu8(3 252 5 0 0 0 0) 1 'little))
     (error? (bytevector-u56-ref
               #vu8(3 252 5 0 0 0 0)
               7
               (native-endianness)))
     (error? (begin
               (bytevector-u56-ref #vu8(3 252 5 0 0 0 0) 4.0 'little)
               #f))

     ; invalid endianness
     (error? (bytevector-u56-ref #vu8(0 1 2 3 4 5 6 7) 0 'bigger))
     (error? (bytevector-u56-ref #vu8(0 1 2 3 4 5 6 7) 0 "little"))
     (error? (begin (bytevector-u56-ref #vu8(0 1 2 3 4 5 6 7) 0 #t) #f))

     (do ([i 1000 (fx- i 1)])
         ((fx= i 0) #t)
         (let ([ls (map (lambda (x) (random (expt 2 8))) (make-list 8))])
           (unless (eqv? (bytevector-u56-ref
                           (apply bytevector ls)
                           1
                           (native-endianness))
                         (apply native->unsigned (cdr ls)))
                   (errorf #f "failed for ~s (native)" ls))
           (unless (eqv? (bytevector-u56-ref (apply bytevector ls) 1 'little)
                         (apply little-endian->unsigned (cdr ls)))
                   (errorf #f "failed for ~s (little)" ls))
           (unless (eqv? (bytevector-u56-ref (apply bytevector ls) 1 'big)
                         (apply big-endian->unsigned (cdr ls)))
                   (errorf #f "failed for ~s (big)" ls))))

     (do ([i 1000 (fx- i 1)])
         ((fx= i 0) #t)
         (let ([ls (map (lambda (x) (random (expt 2 8))) (make-list 8))])
           (unless (eqv? (eval `(bytevector-u56-ref
                                  ,(apply bytevector ls)
                                  1
                                  (native-endianness)))
                         (apply native->unsigned (cdr ls)))
                   (errorf #f "failed for ~s (native)" ls))
           (unless (eqv? (eval `(bytevector-u56-ref
                                  ,(apply bytevector ls)
                                  1
                                  'little))
                         (apply little-endian->unsigned (cdr ls)))
                   (errorf #f "failed for ~s (little)" ls))
           (unless (eqv? (eval `(bytevector-u56-ref
                                  ,(apply bytevector ls)
                                  1
                                  'big))
                         (apply big-endian->unsigned (cdr ls)))
                   (errorf #f "failed for ~s (big)" ls)))))

(mat bytevector-s56-set!
     (begin
       (define $v1 (make-bytevector 23 #xad))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))

     ; wrong argument count
     (error? (bytevector-s56-set!))
     (error? (bytevector-s56-set! $v1))
     (error? (bytevector-s56-set! $v1 0))
     (error? (bytevector-s56-set! $v1 0 0))
     (error? (begin (bytevector-s56-set! $v1 0 0 'big 0) #f))

     ; not a bytevector
     (error? (bytevector-s56-set! (make-vector 10) 0 0 (native-endianness)))
     (error? (begin
               (bytevector-s56-set!
                 (make-vector 10)
                 0
                 0
                 (native-endianness))
               #f))

     ; invalid index
     (error? (bytevector-s56-set! $v1 -1 0 'big))
     (error? (bytevector-s56-set! $v1 17 0 (native-endianness)))
     (error? (bytevector-s56-set! $v1 22 0 'little))
     (error? (bytevector-s56-set! $v1 23 0 (native-endianness)))
     (error? (begin (bytevector-s56-set! $v1 'q 0 'big) #f))

     ; invalid value
     (error? (bytevector-s56-set! $v1 0 (expt 2 55) 'big))
     (error? (bytevector-s56-set!
               $v1
               4
               (- -1 (expt 2 55))
               (native-endianness)))
     (error? (begin (bytevector-s56-set! $v1 8 "hello" 'little) #f))

     ; invalid endianness
     (error? (bytevector-s56-set! $v1 0 0 'huge))
     (error? (bytevector-s56-set! $v1 4 0 "tiny"))
     (error? (begin (bytevector-s56-set! $v1 8 0 $v1) #f))

     ; make sure no damage done
     (and (bytevector? $v1)
          (equal? $v1
            '#vu8(#xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                  #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                  #xad)))

     (let ([v (bytevector #xc7 #xc7 #xc7 #xc7 #xc7 #xc7 #xc7 #xc7)])
       (do ([i 1000 (fx- i 1)])
           ((fx= i 0) #t)
           (let ([ls (map (lambda (x) (random (expt 2 8))) (make-list 7))])
             (bytevector-s56-set! v 1 (apply big-endian->signed ls) 'big)
             (unless (equal? v (apply bytevector #xc7 ls))
                     (errorf #f "failed for ~s" ls))
             (bytevector-s56-set!
               v
               1
               (apply little-endian->signed (reverse ls))
               'little)
             (unless (equal? v (apply bytevector #xc7 (reverse ls)))
                     (errorf #f "failed for ~s" ls))
             (bytevector-s56-set!
               v
               1
               (apply native->signed ls)
               (native-endianness))
             (unless (equal? v (apply bytevector #xc7 ls))
                     (errorf #f "failed for ~s" ls)))))

     (let ([v (bytevector #xc7 #xc7 #xc7 #xc7 #xc7 #xc7 #xc7 #xc7)])
       (do ([i 1000 (fx- i 1)])
           ((fx= i 0) #t)
           (let ([ls (map (lambda (x) (random (expt 2 8))) (make-list 7))])
             (eval `(bytevector-s56-set!
                      ,v
                      1
                      ,(apply big-endian->signed ls)
                      'big))
             (unless (equal? v (apply bytevector #xc7 ls))
                     (errorf #f "failed for ~s" ls))
             (eval `(bytevector-s56-set!
                      ,v
                      1
                      ,(apply little-endian->signed (reverse ls))
                      'little))
             (unless (equal? v (apply bytevector #xc7 (reverse ls)))
                     (errorf #f "failed for ~s" ls))
             (eval `(bytevector-s56-set!
                      ,v
                      1
                      ,(apply native->signed ls)
                      (native-endianness)))
             (unless (equal? v (apply bytevector #xc7 ls))
                     (errorf #f "failed for ~s" ls))))))

(mat bytevector-u56-set!
     (begin
       (define $v1 (make-bytevector 23 #xad))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad))))

     ; wrong argument count
     (error? (bytevector-u56-set!))
     (error? (bytevector-u56-set! $v1))
     (error? (bytevector-u56-set! $v1 0))
     (error? (bytevector-u56-set! $v1 0 0))
     (error? (begin (bytevector-u56-set! $v1 0 0 'big 0) #f))

     ; not a bytevector
     (error? (bytevector-u56-set! (make-vector 10) 0 0 (native-endianness)))
     (error? (begin
               (bytevector-u56-set!
                 (make-vector 10)
                 0
                 0
                 (native-endianness))
               #f))

     ; invalid index
     (error? (bytevector-u56-set! $v1 -1 0 'big))
     (error? (bytevector-u56-set! $v1 17 0 (native-endianness)))
     (error? (bytevector-u56-set! $v1 22 0 'little))
     (error? (bytevector-u56-set! $v1 23 0 (native-endianness)))
     (error? (begin (bytevector-u56-set! $v1 'q 0 'big) #f))

     ; invalid value
     (error? (bytevector-u56-set! $v1 0 (expt 2 56) 'big))
     (error? (bytevector-u56-set! $v1 4 -1 (native-endianness)))
     (error? (begin (bytevector-u56-set! $v1 8 "hello" 'little) #f))

     ; invalid endianness
     (error? (bytevector-u56-set! $v1 0 0 'huge))
     (error? (bytevector-u56-set! $v1 4 0 "tiny"))
     (error? (begin (bytevector-u56-set! $v1 8 0 $v1) #f))

     ; make sure no damage done
     (and (bytevector? $v1)
          (equal? $v1
            '#vu8(#xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                  #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                  #xad)))

     (let ([v (bytevector #xc7 #xc7 #xc7 #xc7 #xc7 #xc7 #xc7 #xc7)])
       (do ([i 1000 (fx- i 1)])
           ((fx= i 0) #t)
           (let ([ls (map (lambda (x) (random (expt 2 8))) (make-list 7))])
             (bytevector-u56-set! v 1 (apply big-endian->unsigned ls) 'big)
             (unless (equal? v (apply bytevector #xc7 ls))
                     (errorf #f "failed for ~s" ls))
             (bytevector-u56-set!
               v
               1
               (apply little-endian->unsigned (reverse ls))
               'little)
             (unless (equal? v (apply bytevector #xc7 (reverse ls)))
                     (errorf #f "failed for ~s" ls))
             (bytevector-u56-set!
               v
               1
               (apply native->unsigned ls)
               (native-endianness))
             (unless (equal? v (apply bytevector #xc7 ls))
                     (errorf #f "failed for ~s" ls)))))

     (let ([v (bytevector #xc7 #xc7 #xc7 #xc7 #xc7 #xc7 #xc7 #xc7)])
       (do ([i 1000 (fx- i 1)])
           ((fx= i 0) #t)
           (let ([ls (map (lambda (x) (random (expt 2 8))) (make-list 7))])
             (eval `(bytevector-u56-set!
                      ,v
                      1
                      ,(apply big-endian->unsigned ls)
                      'big))
             (unless (equal? v (apply bytevector #xc7 ls))
                     (errorf #f "failed for ~s" ls))
             (eval `(bytevector-u56-set!
                      ,v
                      1
                      ,(apply little-endian->unsigned (reverse ls))
                      'little))
             (unless (equal? v (apply bytevector #xc7 (reverse ls)))
                     (errorf #f "failed for ~s" ls))
             (eval `(bytevector-u56-set!
                      ,v
                      1
                      ,(apply native->unsigned ls)
                      (native-endianness)))
             (unless (equal? v (apply bytevector #xc7 ls))
                     (errorf #f "failed for ~s" ls))))))

(mat bytevector-s64-native-ref
     (begin
       (define $v1
         '#vu8(#x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #xff #xff #xff #xff
               #xff #xff #xff #xff #x7f #xff #xff #xff #xff #xff #xff #xff
               #xff #xff #xff #xff #xff #xff #xff #x7f #x80 #x00 #x00 #x00
               #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x80
               #x80 #x00 #x00 #x00 #xff #xff #xff #xff #xff #xff #xff #xff
               #x00 #x00 #x00 #x80 #x12 #x23 #x34 #x45 #x56 #x67 #x78 #x89
               #x89 #x78 #x67 #x56 #x45 #x34 #x23 #x12 #x78 #x89 #x9a #xab
               #xbc #xcd #xde #xef #xef #xde #xcd #xbc #xab #x9a #x89 #x78
               #xfe #xed #xdc #xcb #xba #xa9 #x98))
       (bytevector? $v1))

     ; wrong argument count
     (error? (bytevector-s64-native-ref))
     (error? (bytevector-s64-native-ref $v1))
     (error? (if (bytevector-s64-native-ref $v1 0 0) #f #t))

     ; not a bytevector
     (error? (bytevector-s64-native-ref '#(3 252 5 0 0 0 0 0 0 0 0) 0))
     (error? (if (bytevector-s64-native-ref '#(3 252 5 0 0 0 0 0 0 0 0) 0)
                 #f
                 #t))

     ; invalid index
     (error? (bytevector-s64-native-ref $v1 -1))
     (error? (bytevector-s64-native-ref $v1 1))
     (error? (bytevector-s64-native-ref $v1 2))
     (error? (bytevector-s64-native-ref $v1 3))
     (error? (bytevector-s64-native-ref $v1 4))
     (error? (bytevector-s64-native-ref $v1 5))
     (error? (bytevector-s64-native-ref $v1 6))
     (error? (bytevector-s64-native-ref $v1 7))
     (error? (bytevector-s64-native-ref $v1 9))
     (error? (bytevector-s64-native-ref $v1 18))
     (error? (bytevector-s64-native-ref $v1 27))
     (error? (bytevector-s64-native-ref $v1 36))
     (error? (bytevector-s64-native-ref $v1 45))
     (error? (bytevector-s64-native-ref $v1 54))
     (error? (bytevector-s64-native-ref $v1 63))
     (error? (bytevector-s64-native-ref $v1 73))
     (error? (bytevector-s64-native-ref $v1 82))
     (error? (bytevector-s64-native-ref $v1 91))
     (error? (bytevector-s64-native-ref $v1 96))
     (error? (bytevector-s64-native-ref $v1 97))
     (error? (bytevector-s64-native-ref $v1 98))
     (error? (bytevector-s64-native-ref $v1 99))
     (error? (bytevector-s64-native-ref $v1 100))
     (error? (bytevector-s64-native-ref $v1 101))
     (error? (bytevector-s64-native-ref $v1 102))
     (error? (bytevector-s64-native-ref $v1 103))
     (error? (if (bytevector-s64-native-ref $v1 4.0) #f #t))

     (eqv? (bytevector-s64-native-ref $v1 0) 0)
     (eqv? (bytevector-s64-native-ref $v1 8) -1)
     (eqv? (bytevector-s64-native-ref $v1 16)
           (native->signed #x7f #xff #xff #xff #xff #xff #xff #xff))
     (eqv? (bytevector-s64-native-ref $v1 24)
           (native->signed #xff #xff #xff #xff #xff #xff #xff #x7f))
     (eqv? (bytevector-s64-native-ref $v1 32)
           (native->signed #x80 #x00 #x00 #x00 #x00 #x00 #x00 #x00))
     (eqv? (bytevector-s64-native-ref $v1 40)
           (native->signed #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x80))
     (eqv? (bytevector-s64-native-ref $v1 48)
           (native->signed #x80 #x00 #x00 #x00 #xff #xff #xff #xff))
     (eqv? (bytevector-s64-native-ref $v1 56)
           (native->signed #xff #xff #xff #xff #x00 #x00 #x00 #x80))
     (eqv? (bytevector-s64-native-ref $v1 64)
           (native->signed #x12 #x23 #x34 #x45 #x56 #x67 #x78 #x89))
     (eqv? (bytevector-s64-native-ref $v1 72)
           (native->signed #x89 #x78 #x67 #x56 #x45 #x34 #x23 #x12))
     (eqv? (bytevector-s64-native-ref $v1 80)
           (native->signed #x78 #x89 #x9a #xab #xbc #xcd #xde #xef))
     (eqv? (bytevector-s64-native-ref $v1 88)
           (native->signed #xef #xde #xcd #xbc #xab #x9a #x89 #x78))

     (test-cp0-expansion eqv? `(bytevector-s64-native-ref ,$v1 0) 0)
     (test-cp0-expansion eqv? `(bytevector-s64-native-ref ,$v1 8) -1)
     (test-cp0-expansion eqv?
       `(bytevector-s64-native-ref ,$v1 16)
       (native->signed #x7f #xff #xff #xff #xff #xff #xff #xff))
     (test-cp0-expansion eqv?
       `(bytevector-s64-native-ref ,$v1 24)
       (native->signed #xff #xff #xff #xff #xff #xff #xff #x7f))
     (test-cp0-expansion eqv?
       `(bytevector-s64-native-ref ,$v1 32)
       (native->signed #x80 #x00 #x00 #x00 #x00 #x00 #x00 #x00))
     (test-cp0-expansion eqv?
       `(bytevector-s64-native-ref ,$v1 40)
       (native->signed #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x80))
     (test-cp0-expansion eqv?
       `(bytevector-s64-native-ref ,$v1 48)
       (native->signed #x80 #x00 #x00 #x00 #xff #xff #xff #xff))
     (test-cp0-expansion eqv?
       `(bytevector-s64-native-ref ,$v1 56)
       (native->signed #xff #xff #xff #xff #x00 #x00 #x00 #x80))
     (test-cp0-expansion eqv?
       `(bytevector-s64-native-ref ,$v1 64)
       (native->signed #x12 #x23 #x34 #x45 #x56 #x67 #x78 #x89))
     (test-cp0-expansion eqv?
       `(bytevector-s64-native-ref ,$v1 72)
       (native->signed #x89 #x78 #x67 #x56 #x45 #x34 #x23 #x12))
     (test-cp0-expansion eqv?
       `(bytevector-s64-native-ref ,$v1 80)
       (native->signed #x78 #x89 #x9a #xab #xbc #xcd #xde #xef))
     (test-cp0-expansion eqv?
       `(bytevector-s64-native-ref ,$v1 88)
       (native->signed #xef #xde #xcd #xbc #xab #x9a #x89 #x78))

     (do ([i 10000 (fx- i 1)])
         ((fx= i 0) #t)
         (let ([ls (map (lambda (x) (random (expt 2 8))) (make-list 8))])
           (unless (eqv? (bytevector-s64-native-ref
                           (apply bytevector ls)
                           0)
                         (apply native->signed ls))
                   (errorf #f "failed for ~s" ls)))))

(mat bytevector-u64-native-ref
     (begin
       (define $v1
         '#vu8(#x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #xff #xff #xff #xff
               #xff #xff #xff #xff #x7f #xff #xff #xff #xff #xff #xff #xff
               #xff #xff #xff #xff #xff #xff #xff #x7f #x80 #x00 #x00 #x00
               #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x80
               #x80 #x00 #x00 #x00 #xff #xff #xff #xff #xff #xff #xff #xff
               #x00 #x00 #x00 #x80 #x12 #x23 #x34 #x45 #x56 #x67 #x78 #x89
               #x89 #x78 #x67 #x56 #x45 #x34 #x23 #x12 #x78 #x89 #x9a #xab
               #xbc #xcd #xde #xef #xef #xde #xcd #xbc #xab #x9a #x89 #x78
               #xfe #xed #xdc #xcb #xba #xa9 #x98))
       (bytevector? $v1))

     ; wrong argument count
     (error? (bytevector-u64-native-ref))
     (error? (bytevector-u64-native-ref $v1))
     (error? (if (bytevector-u64-native-ref $v1 0 0) #f #t))

     ; not a bytevector
     (error? (bytevector-u64-native-ref '#(3 252 5 0 0 0 0 0 0 0 0) 0))
     (error? (if (bytevector-u64-native-ref '#(3 252 5 0 0 0 0 0 0 0 0) 0)
                 #f
                 #t))

     ; invalid index
     (error? (bytevector-u64-native-ref $v1 -1))
     (error? (bytevector-u64-native-ref $v1 1))
     (error? (bytevector-u64-native-ref $v1 2))
     (error? (bytevector-u64-native-ref $v1 3))
     (error? (bytevector-u64-native-ref $v1 4))
     (error? (bytevector-u64-native-ref $v1 5))
     (error? (bytevector-u64-native-ref $v1 6))
     (error? (bytevector-u64-native-ref $v1 7))
     (error? (bytevector-u64-native-ref $v1 9))
     (error? (bytevector-u64-native-ref $v1 18))
     (error? (bytevector-u64-native-ref $v1 27))
     (error? (bytevector-u64-native-ref $v1 36))
     (error? (bytevector-u64-native-ref $v1 45))
     (error? (bytevector-u64-native-ref $v1 54))
     (error? (bytevector-u64-native-ref $v1 63))
     (error? (bytevector-u64-native-ref $v1 73))
     (error? (bytevector-u64-native-ref $v1 82))
     (error? (bytevector-u64-native-ref $v1 91))
     (error? (bytevector-u64-native-ref $v1 96))
     (error? (bytevector-u64-native-ref $v1 97))
     (error? (bytevector-u64-native-ref $v1 98))
     (error? (bytevector-u64-native-ref $v1 99))
     (error? (bytevector-u64-native-ref $v1 100))
     (error? (bytevector-u64-native-ref $v1 101))
     (error? (bytevector-u64-native-ref $v1 102))
     (error? (bytevector-u64-native-ref $v1 103))
     (error? (if (bytevector-u64-native-ref $v1 4.0) #f #t))

     (eqv? (bytevector-u64-native-ref $v1 0) 0)
     (eqv? (bytevector-u64-native-ref $v1 8) (- (expt 2 64) 1))
     (eqv? (bytevector-u64-native-ref $v1 16)
           (native->unsigned #x7f #xff #xff #xff #xff #xff #xff #xff))
     (eqv? (bytevector-u64-native-ref $v1 24)
           (native->unsigned #xff #xff #xff #xff #xff #xff #xff #x7f))
     (eqv? (bytevector-u64-native-ref $v1 32)
           (native->unsigned #x80 #x00 #x00 #x00 #x00 #x00 #x00 #x00))
     (eqv? (bytevector-u64-native-ref $v1 40)
           (native->unsigned #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x80))
     (eqv? (bytevector-u64-native-ref $v1 48)
           (native->unsigned #x80 #x00 #x00 #x00 #xff #xff #xff #xff))
     (eqv? (bytevector-u64-native-ref $v1 56)
           (native->unsigned #xff #xff #xff #xff #x00 #x00 #x00 #x80))
     (eqv? (bytevector-u64-native-ref $v1 64)
           (native->unsigned #x12 #x23 #x34 #x45 #x56 #x67 #x78 #x89))
     (eqv? (bytevector-u64-native-ref $v1 72)
           (native->unsigned #x89 #x78 #x67 #x56 #x45 #x34 #x23 #x12))
     (eqv? (bytevector-u64-native-ref $v1 80)
           (native->unsigned #x78 #x89 #x9a #xab #xbc #xcd #xde #xef))
     (eqv? (bytevector-u64-native-ref $v1 88)
           (native->unsigned #xef #xde #xcd #xbc #xab #x9a #x89 #x78))

     (test-cp0-expansion eqv? `(bytevector-u64-native-ref ,$v1 0) 0)
     (test-cp0-expansion eqv?
       `(bytevector-u64-native-ref ,$v1 8)
       (- (expt 2 64) 1))
     (test-cp0-expansion eqv?
       `(bytevector-u64-native-ref ,$v1 16)
       (native->unsigned #x7f #xff #xff #xff #xff #xff #xff #xff))
     (test-cp0-expansion eqv?
       `(bytevector-u64-native-ref ,$v1 24)
       (native->unsigned #xff #xff #xff #xff #xff #xff #xff #x7f))
     (test-cp0-expansion eqv?
       `(bytevector-u64-native-ref ,$v1 32)
       (native->unsigned #x80 #x00 #x00 #x00 #x00 #x00 #x00 #x00))
     (test-cp0-expansion eqv?
       `(bytevector-u64-native-ref ,$v1 40)
       (native->unsigned #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x80))
     (test-cp0-expansion eqv?
       `(bytevector-u64-native-ref ,$v1 48)
       (native->unsigned #x80 #x00 #x00 #x00 #xff #xff #xff #xff))
     (test-cp0-expansion eqv?
       `(bytevector-u64-native-ref ,$v1 56)
       (native->unsigned #xff #xff #xff #xff #x00 #x00 #x00 #x80))
     (test-cp0-expansion eqv?
       `(bytevector-u64-native-ref ,$v1 64)
       (native->unsigned #x12 #x23 #x34 #x45 #x56 #x67 #x78 #x89))
     (test-cp0-expansion eqv?
       `(bytevector-u64-native-ref ,$v1 72)
       (native->unsigned #x89 #x78 #x67 #x56 #x45 #x34 #x23 #x12))
     (test-cp0-expansion eqv?
       `(bytevector-u64-native-ref ,$v1 80)
       (native->unsigned #x78 #x89 #x9a #xab #xbc #xcd #xde #xef))
     (test-cp0-expansion eqv?
       `(bytevector-u64-native-ref ,$v1 88)
       (native->unsigned #xef #xde #xcd #xbc #xab #x9a #x89 #x78))

     (do ([i 10000 (fx- i 1)])
         ((fx= i 0) #t)
         (let ([ls (map (lambda (x) (random (expt 2 8))) (make-list 8))])
           (unless (eqv? (bytevector-u64-native-ref
                           (apply bytevector ls)
                           0)
                         (apply native->unsigned ls))
                   (errorf #f "failed for ~s" ls)))))

(mat bytevector-s64-native-set!
     (begin
       (define $v1 (make-bytevector 39 #xad))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad))))

     ; wrong argument count
     (error? (bytevector-s64-native-set!))
     (error? (bytevector-s64-native-set! $v1))
     (error? (bytevector-s64-native-set! $v1 0))
     (error? (if (bytevector-s64-native-set! $v1 0 0 15) #f #t))

     ; not a bytevector
     (error? (bytevector-s64-native-set! (make-vector 10) 0 0))
     (error? (if (bytevector-s64-native-set! (make-vector 10) 0 0) #f #t))

     ; invalid index
     (error? (bytevector-s64-native-set! $v1 -1 0))
     (error? (bytevector-s64-native-set! $v1 1 0))
     (error? (bytevector-s64-native-set! $v1 2 0))
     (error? (bytevector-s64-native-set! $v1 3 0))
     (error? (bytevector-s64-native-set! $v1 4 0))
     (error? (bytevector-s64-native-set! $v1 5 0))
     (error? (bytevector-s64-native-set! $v1 6 0))
     (error? (bytevector-s64-native-set! $v1 7 0))
     (error? (bytevector-s64-native-set! $v1 9 0))
     (error? (bytevector-s64-native-set! $v1 10 0))
     (error? (bytevector-s64-native-set! $v1 11 0))
     (error? (bytevector-s64-native-set! $v1 12 0))
     (error? (bytevector-s64-native-set! $v1 13 0))
     (error? (bytevector-s64-native-set! $v1 14 0))
     (error? (bytevector-s64-native-set! $v1 15 0))
     (error? (bytevector-s64-native-set! $v1 17 0))
     (error? (bytevector-s64-native-set! $v1 20 0))
     (error? (bytevector-s64-native-set! $v1 23 0))
     (error? (bytevector-s64-native-set! $v1 28 0))
     (error? (bytevector-s64-native-set! $v1 32 0))
     (error? (bytevector-s64-native-set! $v1 33 0))
     (error? (bytevector-s64-native-set! $v1 34 0))
     (error? (bytevector-s64-native-set! $v1 35 0))
     (error? (bytevector-s64-native-set! $v1 36 0))
     (error? (bytevector-s64-native-set! $v1 37 0))
     (error? (bytevector-s64-native-set! $v1 38 0))
     (error? (bytevector-s64-native-set! $v1 39 0))
     (error? (if (bytevector-s64-native-set! $v1 'q 0) #f #t))

     ; invalid value
     (error? (bytevector-s64-native-set! $v1 0 #x8000000000000000))
     (error? (bytevector-s64-native-set! $v1 8 #x-8000000000000001))
     (error? (if (bytevector-s64-native-set! $v1 16 "hello") #f #t))

     ; make sure no damage done
     (and (bytevector? $v1)
          (equal? $v1
            '#vu8(#xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                  #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                  #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                  #xad #xad #xad #xad #xad #xad)))

     (begin
       (bytevector-s64-native-set! $v1 0 0)
       (bytevector-s64-native-set! $v1 8 -1)
       (bytevector-s64-native-set! $v1 16
         (native->signed #x7f #xff #xff #xff #xff #xff #xff #xff))
       (bytevector-s64-native-set! $v1 24
         (native->signed #xff #xff #xff #xff #xff #xff #xff #x7f))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #xff #xff #xff
                    #xff #xff #xff #xff #xff #x7f #xff #xff #xff #xff #xff
                    #xff #xff #xff #xff #xff #xff #xff #xff #xff #x7f #xad
                    #xad #xad #xad #xad #xad #xad))))

     (begin
       (bytevector-s64-native-set! $v1 0
         (native->signed #x80 #x00 #x00 #x00 #x00 #x00 #x00 #x00))
       (bytevector-s64-native-set! $v1 8
         (native->signed #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x80))
       (bytevector-s64-native-set! $v1 16
         (native->signed #x80 #x00 #x00 #x00 #xff #xff #xff #xff))
       (bytevector-s64-native-set! $v1 24
         (native->signed #xff #xff #xff #xff #x00 #x00 #x00 #x80))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x80 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00
                    #x00 #x00 #x00 #x00 #x80 #x80 #x00 #x00 #x00 #xff #xff
                    #xff #xff #xff #xff #xff #xff #x00 #x00 #x00 #x80 #xad
                    #xad #xad #xad #xad #xad #xad))))

     (begin
       (bytevector-s64-native-set! $v1 0
         (native->signed #x12 #x23 #x34 #x45 #x56 #x67 #x78 #x89))
       (bytevector-s64-native-set! $v1 8
         (native->signed #x89 #x78 #x67 #x56 #x45 #x34 #x23 #x12))
       (bytevector-s64-native-set! $v1 16
         (native->signed #x78 #x89 #x9a #xab #xbc #xcd #xde #xef))
       (bytevector-s64-native-set! $v1 24
         (native->signed #xef #xde #xcd #xbc #xab #x9a #x89 #x78))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x12 #x23 #x34 #x45 #x56 #x67 #x78 #x89 #x89 #x78 #x67
                    #x56 #x45 #x34 #x23 #x12 #x78 #x89 #x9a #xab #xbc #xcd
                    #xde #xef #xef #xde #xcd #xbc #xab #x9a #x89 #x78 #xad
                    #xad #xad #xad #xad #xad #xad))))

     (let ([v (bytevector #xc7 #xc7 #xc7 #xc7 #xc7 #xc7 #xc7 #xc7)])
       (do ([i 10000 (fx- i 1)])
           ((fx= i 0) #t)
           (let ([ls (map (lambda (x) (random (expt 2 8))) (make-list 8))])
             (bytevector-s64-native-set! v 0 (apply native->signed ls))
             (unless (equal? v (apply bytevector ls))
                     (errorf #f "failed for ~s" ls))))))

(mat bytevector-u64-native-set!
     (begin
       (define $v1 (make-bytevector 39 #xad))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad))))

     ; wrong argument count
     (error? (bytevector-u64-native-set!))
     (error? (bytevector-u64-native-set! $v1))
     (error? (bytevector-u64-native-set! $v1 0))
     (error? (if (bytevector-u64-native-set! $v1 0 0 15) #f #t))

     ; not a bytevector
     (error? (bytevector-u64-native-set! (make-vector 10) 0 0))
     (error? (if (bytevector-u64-native-set! (make-vector 10) 0 0) #f #t))

     ; invalid index
     (error? (bytevector-u64-native-set! $v1 -1 0))
     (error? (bytevector-u64-native-set! $v1 1 0))
     (error? (bytevector-u64-native-set! $v1 2 0))
     (error? (bytevector-u64-native-set! $v1 3 0))
     (error? (bytevector-u64-native-set! $v1 4 0))
     (error? (bytevector-u64-native-set! $v1 5 0))
     (error? (bytevector-u64-native-set! $v1 6 0))
     (error? (bytevector-u64-native-set! $v1 7 0))
     (error? (bytevector-u64-native-set! $v1 9 0))
     (error? (bytevector-u64-native-set! $v1 10 0))
     (error? (bytevector-u64-native-set! $v1 11 0))
     (error? (bytevector-u64-native-set! $v1 12 0))
     (error? (bytevector-u64-native-set! $v1 13 0))
     (error? (bytevector-u64-native-set! $v1 14 0))
     (error? (bytevector-u64-native-set! $v1 15 0))
     (error? (bytevector-u64-native-set! $v1 17 0))
     (error? (bytevector-u64-native-set! $v1 20 0))
     (error? (bytevector-u64-native-set! $v1 23 0))
     (error? (bytevector-u64-native-set! $v1 28 0))
     (error? (bytevector-u64-native-set! $v1 32 0))
     (error? (bytevector-u64-native-set! $v1 33 0))
     (error? (bytevector-u64-native-set! $v1 34 0))
     (error? (bytevector-u64-native-set! $v1 35 0))
     (error? (bytevector-u64-native-set! $v1 36 0))
     (error? (bytevector-u64-native-set! $v1 37 0))
     (error? (bytevector-u64-native-set! $v1 38 0))
     (error? (bytevector-u64-native-set! $v1 39 0))
     (error? (if (bytevector-u64-native-set! $v1 'q 0) #f #t))

     ; invalid value
     (error? (bytevector-u64-native-set! $v1 0 #x10000000000000000))
     (error? (bytevector-u64-native-set! $v1 8 #x-1))
     (error? (if (bytevector-u64-native-set! $v1 16 "hello") #f #t))

     ; make sure no damage done
     (and (bytevector? $v1)
          (equal? $v1
            '#vu8(#xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                  #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                  #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                  #xad #xad #xad #xad #xad #xad)))

     (begin
       (bytevector-u64-native-set! $v1 0 0)
       (bytevector-u64-native-set! $v1 8 #xffffffffffffffff)
       (bytevector-u64-native-set! $v1 16
         (native->unsigned #x7f #xff #xff #xff #xff #xff #xff #xff))
       (bytevector-u64-native-set! $v1 24
         (native->unsigned #xff #xff #xff #xff #xff #xff #xff #x7f))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #xff #xff #xff
                    #xff #xff #xff #xff #xff #x7f #xff #xff #xff #xff #xff
                    #xff #xff #xff #xff #xff #xff #xff #xff #xff #x7f #xad
                    #xad #xad #xad #xad #xad #xad))))

     (begin
       (bytevector-u64-native-set! $v1 0
         (native->unsigned #x80 #x00 #x00 #x00 #x00 #x00 #x00 #x00))
       (bytevector-u64-native-set! $v1 8
         (native->unsigned #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x80))
       (bytevector-u64-native-set! $v1 16
         (native->unsigned #x80 #x00 #x00 #x00 #xff #xff #xff #xff))
       (bytevector-u64-native-set! $v1 24
         (native->unsigned #xff #xff #xff #xff #x00 #x00 #x00 #x80))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x80 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00
                    #x00 #x00 #x00 #x00 #x80 #x80 #x00 #x00 #x00 #xff #xff
                    #xff #xff #xff #xff #xff #xff #x00 #x00 #x00 #x80 #xad
                    #xad #xad #xad #xad #xad #xad))))

     (begin
       (bytevector-u64-native-set! $v1 0
         (native->unsigned #x12 #x23 #x34 #x45 #x56 #x67 #x78 #x89))
       (bytevector-u64-native-set! $v1 8
         (native->unsigned #x89 #x78 #x67 #x56 #x45 #x34 #x23 #x12))
       (bytevector-u64-native-set! $v1 16
         (native->unsigned #x78 #x89 #x9a #xab #xbc #xcd #xde #xef))
       (bytevector-u64-native-set! $v1 24
         (native->unsigned #xef #xde #xcd #xbc #xab #x9a #x89 #x78))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x12 #x23 #x34 #x45 #x56 #x67 #x78 #x89 #x89 #x78 #x67
                    #x56 #x45 #x34 #x23 #x12 #x78 #x89 #x9a #xab #xbc #xcd
                    #xde #xef #xef #xde #xcd #xbc #xab #x9a #x89 #x78 #xad
                    #xad #xad #xad #xad #xad #xad))))

     (let ([v (bytevector #xc7 #xc7 #xc7 #xc7 #xc7 #xc7 #xc7 #xc7)])
       (do ([i 10000 (fx- i 1)])
           ((fx= i 0) #t)
           (let ([ls (map (lambda (x) (random (expt 2 8))) (make-list 8))])
             (bytevector-u64-native-set! v 0 (apply native->unsigned ls))
             (unless (equal? v (apply bytevector ls))
                     (errorf #f "failed for ~s" ls))))))

(mat bytevector-s64-ref
     (begin
       (define $v1
         '#vu8(#x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #xff #xff #xff #xff
               #xff #xff #xff #xff #x7f #xff #xff #xff #xff #xff #xff #xff
               #xff #xff #xff #xff #xff #xff #xff #x7f #x80 #x00 #x00 #x00
               #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x80
               #x80 #x00 #x00 #x00 #xff #xff #xff #xff #xff #xff #xff #xff
               #x00 #x00 #x00 #x80 #x12 #x23 #x34 #x45 #x56 #x67 #x78 #x89
               #x89 #x78 #x67 #x56 #x45 #x34 #x23 #x12 #x78 #x89 #x9a #xab
               #xbc #xcd #xde #xef #xef #xde #xcd #xbc #xab #x9a #x89 #x78
               #xfe #xed #xdc #xcb #xba #xa9 #x98))
       (bytevector? $v1))

     ; wrong argument count
     (error? (bytevector-s64-ref))
     (error? (bytevector-s64-ref $v1))
     (error? (bytevector-s64-ref $v1 0))
     (error? (if (bytevector-s64-ref $v1 0 'big 0) #f #t))

     ; not a bytevector
     (error? (bytevector-s64-ref '#(3 252 5 0 0 0 0 0 0 0 0) 0 'little))
     (error? (if (bytevector-s64-ref '#(3 252 5 0 0 0 0 0 0 0 0) 0 'little)
                 #f
                 #t))

     ; invalid index
     (error? (bytevector-s64-ref $v1 -1 'big))
     (error? (bytevector-s64-ref $v1 96 'little))
     (error? (bytevector-s64-ref $v1 97 'big))
     (error? (bytevector-s64-ref $v1 98 'little))
     (error? (bytevector-s64-ref $v1 99 'big))
     (error? (bytevector-s64-ref $v1 100 'little))
     (error? (bytevector-s64-ref $v1 101 'big))
     (error? (bytevector-s64-ref $v1 102 'little))
     (error? (bytevector-s64-ref $v1 103 'big))
     (error? (if (bytevector-s64-ref $v1 4.0 (native-endianness)) #f #t))

     ; invalid endianness
     (error? (bytevector-s64-ref $v1 0 ''bonkers))
     (error? (bytevector-s64-ref $v1 0 'get-real))
     (error? (if (bytevector-s64-ref $v1 0 1e23) #f #t))

     ; (not bothering with native endianness, since it's either big or little)

     ; aligned accesses, endianness little
     (eqv? (bytevector-s64-ref $v1 0 'little) 0)
     (eqv? (bytevector-s64-ref $v1 8 'little) -1)
     (eqv? (bytevector-s64-ref $v1 16 'little)
           (little-endian->signed #x7f #xff #xff #xff #xff #xff #xff #xff))
     (eqv? (bytevector-s64-ref $v1 24 'little)
           (little-endian->signed #xff #xff #xff #xff #xff #xff #xff #x7f))
     (eqv? (bytevector-s64-ref $v1 32 'little)
           (little-endian->signed #x80 #x00 #x00 #x00 #x00 #x00 #x00 #x00))
     (eqv? (bytevector-s64-ref $v1 40 'little)
           (little-endian->signed #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x80))
     (eqv? (bytevector-s64-ref $v1 48 'little)
           (little-endian->signed #x80 #x00 #x00 #x00 #xff #xff #xff #xff))
     (eqv? (bytevector-s64-ref $v1 56 'little)
           (little-endian->signed #xff #xff #xff #xff #x00 #x00 #x00 #x80))
     (eqv? (bytevector-s64-ref $v1 64 'little)
           (little-endian->signed #x12 #x23 #x34 #x45 #x56 #x67 #x78 #x89))
     (eqv? (bytevector-s64-ref $v1 72 'little)
           (little-endian->signed #x89 #x78 #x67 #x56 #x45 #x34 #x23 #x12))
     (eqv? (bytevector-s64-ref $v1 80 'little)
           (little-endian->signed #x78 #x89 #x9a #xab #xbc #xcd #xde #xef))
     (eqv? (bytevector-s64-ref $v1 88 'little)
           (little-endian->signed #xef #xde #xcd #xbc #xab #x9a #x89 #x78))

     (do ([i 10000 (fx- i 1)])
         ((fx= i 0) #t)
         (let ([ls (map (lambda (x) (random (expt 2 8))) (make-list 8))])
           (unless (eqv? (bytevector-s64-ref (apply bytevector ls) 0 'little)
                         (apply little-endian->signed ls))
                   (errorf #f "failed for ~s" ls))))

     ; aligned accesses, endianness big
     (begin
       (define $v1
         '#vu8(#x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #xff #xff #xff #xff
               #xff #xff #xff #xff #x7f #xff #xff #xff #xff #xff #xff #xff
               #xff #xff #xff #xff #xff #xff #xff #x7f #x80 #x00 #x00 #x00
               #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x80
               #x80 #x00 #x00 #x00 #xff #xff #xff #xff #xff #xff #xff #xff
               #x00 #x00 #x00 #x80 #x12 #x23 #x34 #x45 #x56 #x67 #x78 #x89
               #x89 #x78 #x67 #x56 #x45 #x34 #x23 #x12 #x78 #x89 #x9a #xab
               #xbc #xcd #xde #xef #xef #xde #xcd #xbc #xab #x9a #x89 #x78
               #xfe #xed #xdc #xcb #xba #xa9 #x98))
       (bytevector? $v1))

     (eqv? (bytevector-s64-ref $v1 0 'big) 0)
     (eqv? (bytevector-s64-ref $v1 8 'big) -1)
     (eqv? (bytevector-s64-ref $v1 16 'big)
           (big-endian->signed #x7f #xff #xff #xff #xff #xff #xff #xff))
     (eqv? (bytevector-s64-ref $v1 24 'big)
           (big-endian->signed #xff #xff #xff #xff #xff #xff #xff #x7f))
     (eqv? (bytevector-s64-ref $v1 32 'big)
           (big-endian->signed #x80 #x00 #x00 #x00 #x00 #x00 #x00 #x00))
     (eqv? (bytevector-s64-ref $v1 40 'big)
           (big-endian->signed #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x80))
     (eqv? (bytevector-s64-ref $v1 48 'big)
           (big-endian->signed #x80 #x00 #x00 #x00 #xff #xff #xff #xff))
     (eqv? (bytevector-s64-ref $v1 56 'big)
           (big-endian->signed #xff #xff #xff #xff #x00 #x00 #x00 #x80))
     (eqv? (bytevector-s64-ref $v1 64 'big)
           (big-endian->signed #x12 #x23 #x34 #x45 #x56 #x67 #x78 #x89))
     (eqv? (bytevector-s64-ref $v1 72 'big)
           (big-endian->signed #x89 #x78 #x67 #x56 #x45 #x34 #x23 #x12))
     (eqv? (bytevector-s64-ref $v1 80 'big)
           (big-endian->signed #x78 #x89 #x9a #xab #xbc #xcd #xde #xef))
     (eqv? (bytevector-s64-ref $v1 88 'big)
           (big-endian->signed #xef #xde #xcd #xbc #xab #x9a #x89 #x78))

     (do ([i 10000 (fx- i 1)])
         ((fx= i 0) #t)
         (let ([ls (map (lambda (x) (random (expt 2 8))) (make-list 8))])
           (unless (eqv? (bytevector-s64-ref (apply bytevector ls) 0 'big)
                         (apply big-endian->signed ls))
                   (errorf #f "failed for ~s" ls))))

     ; unaligned accesses, endianness mixed
     (begin
       (define $v1
         '#vu8(#xc7 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 ; 1
               #xc7 #xff #xff #xff #xff #xff #xff #xff #xff ; 10
               #xc7 #x7f #xff #xff #xff #xff #xff #xff #xff ; 19
               #xc7 #xff #xff #xff #xff #xff #xff #xff #x7f ; 28
               #xc7 #x80 #x00 #x00 #x00 #x00 #x00 #x00 #x00 ; 37
               #xc7 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x80 ; 46
               #xc7 #x80 #x00 #x00 #x00 #xff #xff #xff #xff ; 55
               #xc7 #xc7 #xff #xff #xff #xff #x00 #x00 #x00 #x80 ; 65
               #xc7 #x12 #x23 #x34 #x45 #x56 #x67 #x78 #x89 ; 74
               #xc7 #x89 #x78 #x67 #x56 #x45 #x34 #x23 #x12 ; 83
               #xc7 #x78 #x89 #x9a #xab #xbc #xcd #xde #xef ; 92
               #xc7 #xef #xde #xcd #xbc #xab #x9a #x89 #x78))
       ; 101
       (bytevector? $v1))

     (eqv? (bytevector-s64-ref $v1 1 'big) 0)
     (eqv? (bytevector-s64-ref $v1 10 'little) -1)
     (eqv? (bytevector-s64-ref $v1 19 (native-endianness))
           (native->signed #x7f #xff #xff #xff #xff #xff #xff #xff))
     (eqv? (bytevector-s64-ref $v1 28 'big)
           (big-endian->signed #xff #xff #xff #xff #xff #xff #xff #x7f))
     (eqv? (bytevector-s64-ref $v1 37 'little)
           (little-endian->signed #x80 #x00 #x00 #x00 #x00 #x00 #x00 #x00))
     (eqv? (bytevector-s64-ref $v1 46 'big)
           (big-endian->signed #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x80))
     (eqv? (bytevector-s64-ref $v1 55 'little)
           (little-endian->signed #x80 #x00 #x00 #x00 #xff #xff #xff #xff))
     (eqv? (bytevector-s64-ref $v1 65 'big)
           (big-endian->signed #xff #xff #xff #xff #x00 #x00 #x00 #x80))
     (eqv? (bytevector-s64-ref $v1 74 'little)
           (little-endian->signed #x12 #x23 #x34 #x45 #x56 #x67 #x78 #x89))
     (eqv? (bytevector-s64-ref $v1 83 (native-endianness))
           (native->signed #x89 #x78 #x67 #x56 #x45 #x34 #x23 #x12))
     (eqv? (bytevector-s64-ref $v1 92 'big)
           (big-endian->signed #x78 #x89 #x9a #xab #xbc #xcd #xde #xef))
     (eqv? (bytevector-s64-ref $v1 101 'little)
           (little-endian->signed #xef #xde #xcd #xbc #xab #x9a #x89 #x78))

     (do ([i 10000 (fx- i 1)])
         ((fx= i 0) #t)
         (let ([ls (map (lambda (x) (random (expt 2 8))) (make-list 8))])
           (unless (eqv? (bytevector-s64-ref
                           (apply bytevector #x3e ls)
                           1
                           (native-endianness))
                         (apply native->signed ls))
                   (errorf #f "failed for ~s" ls))
           (unless (eqv? (bytevector-s64-ref (apply bytevector #x3e ls) 1 'big)
                         (apply big-endian->signed ls))
                   (errorf #f "failed for ~s" ls))
           (unless (eqv? (bytevector-s64-ref
                           (apply bytevector #x3e ls)
                           1
                           'little)
                         (apply little-endian->signed ls))
                   (errorf #f "failed for ~s" ls)))))

(mat bytevector-u64-ref
     (begin
       (define $v1
         '#vu8(#x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #xff #xff #xff #xff
               #xff #xff #xff #xff #x7f #xff #xff #xff #xff #xff #xff #xff
               #xff #xff #xff #xff #xff #xff #xff #x7f #x80 #x00 #x00 #x00
               #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x80
               #x80 #x00 #x00 #x00 #xff #xff #xff #xff #xff #xff #xff #xff
               #x00 #x00 #x00 #x80 #x12 #x23 #x34 #x45 #x56 #x67 #x78 #x89
               #x89 #x78 #x67 #x56 #x45 #x34 #x23 #x12 #x78 #x89 #x9a #xab
               #xbc #xcd #xde #xef #xef #xde #xcd #xbc #xab #x9a #x89 #x78
               #xfe #xed #xdc #xcb #xba #xa9 #x98))
       (bytevector? $v1))

     ; wrong argument count
     (error? (bytevector-u64-ref))
     (error? (bytevector-u64-ref $v1))
     (error? (bytevector-u64-ref $v1 0))
     (error? (if (bytevector-u64-ref $v1 0 'big 0) #f #t))

     ; not a bytevector
     (error? (bytevector-u64-ref '#(3 252 5 0 0 0 0 0 0 0 0) 0 'little))
     (error? (if (bytevector-u64-ref '#(3 252 5 0 0 0 0 0 0 0 0) 0 'little)
                 #f
                 #t))

     ; invalid index
     (error? (bytevector-u64-ref $v1 -1 'big))
     (error? (bytevector-u64-ref $v1 96 'little))
     (error? (bytevector-u64-ref $v1 97 'big))
     (error? (bytevector-u64-ref $v1 98 'little))
     (error? (bytevector-u64-ref $v1 99 'big))
     (error? (bytevector-u64-ref $v1 100 'little))
     (error? (bytevector-u64-ref $v1 101 'big))
     (error? (bytevector-u64-ref $v1 102 'little))
     (error? (bytevector-u64-ref $v1 103 'big))
     (error? (if (bytevector-u64-ref $v1 4.0 (native-endianness)) #f #t))

     ; invalid endianness
     (error? (bytevector-u64-ref $v1 0 ''bonkers))
     (error? (bytevector-u64-ref $v1 0 'get-real))
     (error? (if (bytevector-u64-ref $v1 0 1e23) #f #t))

     ; (not bothering with native endianness, since it's either big or little)

     ; aligned accesses, endianness little
     (eqv? (bytevector-u64-ref $v1 0 'little) 0)
     (eqv? (bytevector-u64-ref $v1 8 'little) #xffffffffffffffff)
     (eqv? (bytevector-u64-ref $v1 16 'little)
           (little-endian->unsigned
             #x7f
             #xff
             #xff
             #xff
             #xff
             #xff
             #xff
             #xff))
     (eqv? (bytevector-u64-ref $v1 24 'little)
           (little-endian->unsigned
             #xff
             #xff
             #xff
             #xff
             #xff
             #xff
             #xff
             #x7f))
     (eqv? (bytevector-u64-ref $v1 32 'little)
           (little-endian->unsigned
             #x80
             #x00
             #x00
             #x00
             #x00
             #x00
             #x00
             #x00))
     (eqv? (bytevector-u64-ref $v1 40 'little)
           (little-endian->unsigned
             #x00
             #x00
             #x00
             #x00
             #x00
             #x00
             #x00
             #x80))
     (eqv? (bytevector-u64-ref $v1 48 'little)
           (little-endian->unsigned
             #x80
             #x00
             #x00
             #x00
             #xff
             #xff
             #xff
             #xff))
     (eqv? (bytevector-u64-ref $v1 56 'little)
           (little-endian->unsigned
             #xff
             #xff
             #xff
             #xff
             #x00
             #x00
             #x00
             #x80))
     (eqv? (bytevector-u64-ref $v1 64 'little)
           (little-endian->unsigned
             #x12
             #x23
             #x34
             #x45
             #x56
             #x67
             #x78
             #x89))
     (eqv? (bytevector-u64-ref $v1 72 'little)
           (little-endian->unsigned
             #x89
             #x78
             #x67
             #x56
             #x45
             #x34
             #x23
             #x12))
     (eqv? (bytevector-u64-ref $v1 80 'little)
           (little-endian->unsigned
             #x78
             #x89
             #x9a
             #xab
             #xbc
             #xcd
             #xde
             #xef))
     (eqv? (bytevector-u64-ref $v1 88 'little)
           (little-endian->unsigned
             #xef
             #xde
             #xcd
             #xbc
             #xab
             #x9a
             #x89
             #x78))

     ; aligned accesses, endianness big
     (begin
       (define $v1
         '#vu8(#x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #xff #xff #xff #xff
               #xff #xff #xff #xff #x7f #xff #xff #xff #xff #xff #xff #xff
               #xff #xff #xff #xff #xff #xff #xff #x7f #x80 #x00 #x00 #x00
               #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x80
               #x80 #x00 #x00 #x00 #xff #xff #xff #xff #xff #xff #xff #xff
               #x00 #x00 #x00 #x80 #x12 #x23 #x34 #x45 #x56 #x67 #x78 #x89
               #x89 #x78 #x67 #x56 #x45 #x34 #x23 #x12 #x78 #x89 #x9a #xab
               #xbc #xcd #xde #xef #xef #xde #xcd #xbc #xab #x9a #x89 #x78
               #xfe #xed #xdc #xcb #xba #xa9 #x98))
       (bytevector? $v1))

     (eqv? (bytevector-u64-ref $v1 0 'big) 0)
     (eqv? (bytevector-u64-ref $v1 8 'big) #xffffffffffffffff)
     (eqv? (bytevector-u64-ref $v1 16 'big)
           (big-endian->unsigned #x7f #xff #xff #xff #xff #xff #xff #xff))
     (eqv? (bytevector-u64-ref $v1 24 'big)
           (big-endian->unsigned #xff #xff #xff #xff #xff #xff #xff #x7f))
     (eqv? (bytevector-u64-ref $v1 32 'big)
           (big-endian->unsigned #x80 #x00 #x00 #x00 #x00 #x00 #x00 #x00))
     (eqv? (bytevector-u64-ref $v1 40 'big)
           (big-endian->unsigned #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x80))
     (eqv? (bytevector-u64-ref $v1 48 'big)
           (big-endian->unsigned #x80 #x00 #x00 #x00 #xff #xff #xff #xff))
     (eqv? (bytevector-u64-ref $v1 56 'big)
           (big-endian->unsigned #xff #xff #xff #xff #x00 #x00 #x00 #x80))
     (eqv? (bytevector-u64-ref $v1 64 'big)
           (big-endian->unsigned #x12 #x23 #x34 #x45 #x56 #x67 #x78 #x89))
     (eqv? (bytevector-u64-ref $v1 72 'big)
           (big-endian->unsigned #x89 #x78 #x67 #x56 #x45 #x34 #x23 #x12))
     (eqv? (bytevector-u64-ref $v1 80 'big)
           (big-endian->unsigned #x78 #x89 #x9a #xab #xbc #xcd #xde #xef))
     (eqv? (bytevector-u64-ref $v1 88 'big)
           (big-endian->unsigned #xef #xde #xcd #xbc #xab #x9a #x89 #x78))

     (do ([i 10000 (fx- i 1)])
         ((fx= i 0) #t)
         (let ([ls (map (lambda (x) (random (expt 2 8))) (make-list 8))])
           (unless (eqv? (bytevector-u64-ref (apply bytevector ls) 0 'big)
                         (apply big-endian->unsigned ls))
                   (errorf #f "failed for ~s" ls))))

     ; unaligned accesses, endianness mixed
     (begin
       (define $v1
         '#vu8(#xc7 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 ; 1
               #xc7 #xff #xff #xff #xff #xff #xff #xff #xff ; 10
               #xc7 #x7f #xff #xff #xff #xff #xff #xff #xff ; 19
               #xc7 #xff #xff #xff #xff #xff #xff #xff #x7f ; 28
               #xc7 #x80 #x00 #x00 #x00 #x00 #x00 #x00 #x00 ; 37
               #xc7 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x80 ; 46
               #xc7 #x80 #x00 #x00 #x00 #xff #xff #xff #xff ; 55
               #xc7 #xc7 #xff #xff #xff #xff #x00 #x00 #x00 #x80 ; 65
               #xc7 #x12 #x23 #x34 #x45 #x56 #x67 #x78 #x89 ; 74
               #xc7 #x89 #x78 #x67 #x56 #x45 #x34 #x23 #x12 ; 83
               #xc7 #x78 #x89 #x9a #xab #xbc #xcd #xde #xef ; 92
               #xc7 #xef #xde #xcd #xbc #xab #x9a #x89 #x78))
       ; 101
       (bytevector? $v1))

     (eqv? (bytevector-u64-ref $v1 1 'big) 0)
     (eqv? (bytevector-u64-ref $v1 10 'little) #xffffffffffffffff)
     (eqv? (bytevector-u64-ref $v1 19 (native-endianness))
           (native->unsigned #x7f #xff #xff #xff #xff #xff #xff #xff))
     (eqv? (bytevector-u64-ref $v1 28 'big)
           (big-endian->unsigned #xff #xff #xff #xff #xff #xff #xff #x7f))
     (eqv? (bytevector-u64-ref $v1 37 'little)
           (little-endian->unsigned
             #x80
             #x00
             #x00
             #x00
             #x00
             #x00
             #x00
             #x00))
     (eqv? (bytevector-u64-ref $v1 46 'big)
           (big-endian->unsigned #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x80))
     (eqv? (bytevector-u64-ref $v1 55 'little)
           (little-endian->unsigned
             #x80
             #x00
             #x00
             #x00
             #xff
             #xff
             #xff
             #xff))
     (eqv? (bytevector-u64-ref $v1 65 'big)
           (big-endian->unsigned #xff #xff #xff #xff #x00 #x00 #x00 #x80))
     (eqv? (bytevector-u64-ref $v1 74 'little)
           (little-endian->unsigned
             #x12
             #x23
             #x34
             #x45
             #x56
             #x67
             #x78
             #x89))
     (eqv? (bytevector-u64-ref $v1 83 (native-endianness))
           (native->unsigned #x89 #x78 #x67 #x56 #x45 #x34 #x23 #x12))
     (eqv? (bytevector-u64-ref $v1 92 'big)
           (big-endian->unsigned #x78 #x89 #x9a #xab #xbc #xcd #xde #xef))
     (eqv? (bytevector-u64-ref $v1 101 'little)
           (little-endian->unsigned
             #xef
             #xde
             #xcd
             #xbc
             #xab
             #x9a
             #x89
             #x78))

     (do ([i 10000 (fx- i 1)])
         ((fx= i 0) #t)
         (let ([ls (map (lambda (x) (random (expt 2 8))) (make-list 8))])
           (unless (eqv? (bytevector-u64-ref
                           (apply bytevector #x3e ls)
                           1
                           (native-endianness))
                         (apply native->unsigned ls))
                   (errorf #f "failed for ~s" ls))
           (unless (eqv? (bytevector-u64-ref (apply bytevector #x3e ls) 1 'big)
                         (apply big-endian->unsigned ls))
                   (errorf #f "failed for ~s" ls))
           (unless (eqv? (bytevector-u64-ref
                           (apply bytevector #x3e ls)
                           1
                           'little)
                         (apply little-endian->unsigned ls))
                   (errorf #f "failed for ~s" ls)))))

(mat bytevector-s64-set!
     (begin
       (define $v1 (make-bytevector 39 #xad))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad))))

     ; wrong argument count
     (error? (bytevector-s64-set!))
     (error? (bytevector-s64-set! $v1))
     (error? (bytevector-s64-set! $v1 0))
     (error? (bytevector-s64-set! $v1 0 0))
     (error? (if (bytevector-s64-set! $v1 0 0 'big 15) #f #t))

     ; not a bytevector
     (error? (bytevector-s64-set! (make-vector 10) 0 0 'big))
     (error? (if (bytevector-s64-set! (make-vector 10) 0 0 'big) #f #t))

     ; invalid index
     (error? (bytevector-s64-set! $v1 -1 0 'big))
     (error? (bytevector-s64-set! $v1 32 0 'little))
     (error? (bytevector-s64-set! $v1 33 0 'big))
     (error? (bytevector-s64-set! $v1 34 0 'little))
     (error? (bytevector-s64-set! $v1 35 0 (native-endianness)))
     (error? (bytevector-s64-set! $v1 36 0 'big))
     (error? (bytevector-s64-set! $v1 37 0 'little))
     (error? (bytevector-s64-set! $v1 38 0 'big))
     (error? (bytevector-s64-set! $v1 39 0 'little))
     (error? (if (bytevector-s64-set! $v1 'q 0 (native-endianness)) #f #t))

     ; invalid value
     (error? (bytevector-s64-set! $v1 0 #x8000000000000000 'little))
     (error? (bytevector-s64-set! $v1 8 #x-8000000000000001 'big))
     (error? (if (bytevector-s64-set! $v1 16 "hello" (native-endianness))
                 #f
                 #t))

     ; invalid endianness
     (error? (bytevector-s64-set! $v1 0 0 'gorgeous))
     (error? (bytevector-s64-set! $v1 0 0 '#(ravenous)))
     (error? (if (bytevector-s64-set! $v1 0 0 #t) #f #t))

     ; make sure no damage done
     (and (bytevector? $v1)
          (equal? $v1
            '#vu8(#xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                  #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                  #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                  #xad #xad #xad #xad #xad #xad)))

     ; (not bothering with native endianness, since it's either big or little)

     ; aligned accesses, endianness little
     (begin
       (bytevector-s64-set! $v1 0 0 'little)
       (bytevector-s64-set! $v1 8 -1 'little)
       (bytevector-s64-set!
         $v1
         16
         (little-endian->signed #x7f #xff #xff #xff #xff #xff #xff #xff)
         'little)
       (bytevector-s64-set!
         $v1
         24
         (little-endian->signed #xff #xff #xff #xff #xff #xff #xff #x7f)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #xff #xff #xff
                    #xff #xff #xff #xff #xff #x7f #xff #xff #xff #xff #xff
                    #xff #xff #xff #xff #xff #xff #xff #xff #xff #x7f #xad
                    #xad #xad #xad #xad #xad #xad))))

     (begin
       (bytevector-s64-set!
         $v1
         0
         (little-endian->signed #x80 #x00 #x00 #x00 #x00 #x00 #x00 #x00)
         'little)
       (bytevector-s64-set!
         $v1
         8
         (little-endian->signed #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x80)
         'little)
       (bytevector-s64-set!
         $v1
         16
         (little-endian->signed #x80 #x00 #x00 #x00 #xff #xff #xff #xff)
         'little)
       (bytevector-s64-set!
         $v1
         24
         (little-endian->signed #xff #xff #xff #xff #x00 #x00 #x00 #x80)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x80 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00
                    #x00 #x00 #x00 #x00 #x80 #x80 #x00 #x00 #x00 #xff #xff
                    #xff #xff #xff #xff #xff #xff #x00 #x00 #x00 #x80 #xad
                    #xad #xad #xad #xad #xad #xad))))

     (begin
       (bytevector-s64-set!
         $v1
         0
         (little-endian->signed #x12 #x23 #x34 #x45 #x56 #x67 #x78 #x89)
         'little)
       (bytevector-s64-set!
         $v1
         8
         (little-endian->signed #x89 #x78 #x67 #x56 #x45 #x34 #x23 #x12)
         'little)
       (bytevector-s64-set!
         $v1
         16
         (little-endian->signed #x78 #x89 #x9a #xab #xbc #xcd #xde #xef)
         'little)
       (bytevector-s64-set!
         $v1
         24
         (little-endian->signed #xef #xde #xcd #xbc #xab #x9a #x89 #x78)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x12 #x23 #x34 #x45 #x56 #x67 #x78 #x89 #x89 #x78 #x67
                    #x56 #x45 #x34 #x23 #x12 #x78 #x89 #x9a #xab #xbc #xcd
                    #xde #xef #xef #xde #xcd #xbc #xab #x9a #x89 #x78 #xad
                    #xad #xad #xad #xad #xad #xad))))

     ; aligned accesses, endianness big
     (begin
       (bytevector-s64-set! $v1 0 0 'big)
       (bytevector-s64-set! $v1 8 -1 'big)
       (bytevector-s64-set!
         $v1
         16
         (big-endian->signed #x7f #xff #xff #xff #xff #xff #xff #xff)
         'big)
       (bytevector-s64-set!
         $v1
         24
         (big-endian->signed #xff #xff #xff #xff #xff #xff #xff #x7f)
         'big)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #xff #xff #xff
                    #xff #xff #xff #xff #xff #x7f #xff #xff #xff #xff #xff
                    #xff #xff #xff #xff #xff #xff #xff #xff #xff #x7f #xad
                    #xad #xad #xad #xad #xad #xad))))

     (begin
       (bytevector-s64-set!
         $v1
         0
         (little-endian->signed #x80 #x00 #x00 #x00 #x00 #x00 #x00 #x00)
         'little)
       (bytevector-s64-set!
         $v1
         8
         (little-endian->signed #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x80)
         'little)
       (bytevector-s64-set!
         $v1
         16
         (little-endian->signed #x80 #x00 #x00 #x00 #xff #xff #xff #xff)
         'little)
       (bytevector-s64-set!
         $v1
         24
         (little-endian->signed #xff #xff #xff #xff #x00 #x00 #x00 #x80)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x80 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00
                    #x00 #x00 #x00 #x00 #x80 #x80 #x00 #x00 #x00 #xff #xff
                    #xff #xff #xff #xff #xff #xff #x00 #x00 #x00 #x80 #xad
                    #xad #xad #xad #xad #xad #xad))))

     (begin
       (bytevector-s64-set!
         $v1
         0
         (little-endian->signed #x12 #x23 #x34 #x45 #x56 #x67 #x78 #x89)
         'little)
       (bytevector-s64-set!
         $v1
         8
         (little-endian->signed #x89 #x78 #x67 #x56 #x45 #x34 #x23 #x12)
         'little)
       (bytevector-s64-set!
         $v1
         16
         (little-endian->signed #x78 #x89 #x9a #xab #xbc #xcd #xde #xef)
         'little)
       (bytevector-s64-set!
         $v1
         24
         (little-endian->signed #xef #xde #xcd #xbc #xab #x9a #x89 #x78)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x12 #x23 #x34 #x45 #x56 #x67 #x78 #x89 #x89 #x78 #x67
                    #x56 #x45 #x34 #x23 #x12 #x78 #x89 #x9a #xab #xbc #xcd
                    #xde #xef #xef #xde #xcd #xbc #xab #x9a #x89 #x78 #xad
                    #xad #xad #xad #xad #xad #xad))))

     ; aligned accesses, endianness mixed
     (let ([v (bytevector #xc7 #xc7 #xc7 #xc7 #xc7 #xc7 #xc7 #xc7)])
       (do ([i 10000 (fx- i 1)])
           ((fx= i 0) #t)
           (let ([ls (map (lambda (x) (random (expt 2 8))) (make-list 8))])
             (bytevector-s64-set!
               v
               0
               (apply native->signed ls)
               (native-endianness))
             (unless (equal? v (apply bytevector ls))
                     (errorf #f "failed for ~s" ls))
             (bytevector-s64-set!
               v
               0
               (apply big-endian->signed (reverse ls))
               'big)
             (unless (equal? v (apply bytevector (reverse ls)))
                     (errorf #f "failed for ~s" ls))
             (bytevector-s64-set!
               v
               0
               (apply little-endian->signed ls)
               'little)
             (unless (equal? v (apply bytevector ls))
                     (errorf #f "failed for ~s" ls)))))

     ; unaligned accesses, endianness mixed
     (begin
       (define $v1 (make-bytevector 36 #xad))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #xad #xad #xad #xad #xad #xad #xad #xad ; 1
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad ; 10
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad ; 19
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad))))
     ; 28

     (begin
       (bytevector-s64-set! $v1 1 0 'big)
       (bytevector-s64-set! $v1 10 -1 'little)
       (bytevector-s64-set!
         $v1
         19
         (big-endian->signed #x7f #xff #xff #xff #xff #xff #xff #xff)
         'big)
       (bytevector-s64-set!
         $v1
         28
         (little-endian->signed #xff #xff #xff #xff #xff #xff #xff #x7f)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #xad #xff
                    #xff #xff #xff #xff #xff #xff #xff #xad #x7f #xff #xff
                    #xff #xff #xff #xff #xff #xad #xff #xff #xff #xff #xff
                    #xff #xff #x7f))))

     (begin
       (define $v1 (make-bytevector 37 #xad))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #xad #xad #xad #xad #xad #xad #xad #xad #xad ; 2
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad ; 11
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad ; 20
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad))))
     ; 29

     (begin
       (bytevector-s64-set!
         $v1
         2
         (little-endian->signed #x80 #x00 #x00 #x00 #x00 #x00 #x00 #x00)
         'little)
       (bytevector-s64-set!
         $v1
         11
         (big-endian->signed #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x80)
         'big)
       (bytevector-s64-set!
         $v1
         20
         (big-endian->signed #x80 #x00 #x00 #x00 #xff #xff #xff #xff)
         'big)
       (bytevector-s64-set!
         $v1
         29
         (little-endian->signed #xff #xff #xff #xff #x00 #x00 #x00 #x80)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #xad #x80 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #xad
                    #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x80 #xad #x80 #x00
                    #x00 #x00 #xff #xff #xff #xff #xad #xff #xff #xff #xff
                    #x00 #x00 #x00 #x80))))

     (begin
       (define $v1 (make-bytevector 38 #xad))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    ; 3
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad ; 12
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad ; 21
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad))))
     ; 30

     (begin
       (bytevector-s64-set!
         $v1
         3
         (big-endian->signed #x12 #x23 #x34 #x45 #x56 #x67 #x78 #x89)
         'big)
       (bytevector-s64-set!
         $v1
         12
         (little-endian->signed #x89 #x78 #x67 #x56 #x45 #x34 #x23 #x12)
         'little)
       (bytevector-s64-set!
         $v1
         21
         (little-endian->signed #x78 #x89 #x9a #xab #xbc #xcd #xde #xef)
         'little)
       (bytevector-s64-set!
         $v1
         30
         (big-endian->signed #xef #xde #xcd #xbc #xab #x9a #x89 #x78)
         'big)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #xad #xad #x12 #x23 #x34 #x45 #x56 #x67 #x78 #x89
                    #xad #x89 #x78 #x67 #x56 #x45 #x34 #x23 #x12 #xad #x78
                    #x89 #x9a #xab #xbc #xcd #xde #xef #xad #xef #xde #xcd
                    #xbc #xab #x9a #x89 #x78))))

     (let ([v (make-bytevector 15)])
       (do ([i 10000 (fx- i 1)])
           ((fx= i 0) #t)
           (let ([idx (fx+ (modulo i 7) 1)])
             (let ([ls (map (lambda (x) (random (expt 2 8))) (make-list 8))])
               (bytevector-fill! v #xc7)
               (bytevector-s64-set!
                 v
                 idx
                 (apply native->signed ls)
                 (native-endianness))
               (unless (equal? v
                         (apply bytevector
                           (append (make-list idx #xc7)
                                   ls
                                   (make-list (fx- 7 idx) #xc7))))
                       (errorf #f "failed for ~s (native)" ls))
               (bytevector-s64-set!
                 v
                 idx
                 (apply big-endian->signed (reverse ls))
                 'big)
               (unless (equal? v
                         (apply bytevector
                           (append (make-list idx #xc7)
                                   (reverse ls)
                                   (make-list (fx- 7 idx) #xc7))))
                       (errorf #f "failed for ~s (big)" ls))
               (bytevector-s64-set!
                 v
                 idx
                 (apply little-endian->signed ls)
                 'little)
               (unless (equal? v
                         (apply bytevector
                           (append (make-list idx #xc7)
                                   ls
                                   (make-list (fx- 7 idx) #xc7))))
                       (errorf #f "failed for ~s (little)" ls)))))))

(mat bytevector-u64-set!
     (begin
       (define $v1 (make-bytevector 39 #xad))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    #xad #xad #xad #xad #xad #xad))))

     ; wrong argument count
     (error? (bytevector-u64-set!))
     (error? (bytevector-u64-set! $v1))
     (error? (bytevector-u64-set! $v1 0))
     (error? (bytevector-u64-set! $v1 0 0))
     (error? (if (bytevector-u64-set! $v1 0 0 'big 15) #f #t))

     ; not a bytevector
     (error? (bytevector-u64-set! (make-vector 10) 0 0 'big))
     (error? (if (bytevector-u64-set! (make-vector 10) 0 0 'big) #f #t))

     ; invalid index
     (error? (bytevector-u64-set! $v1 -1 0 'big))
     (error? (bytevector-u64-set! $v1 32 0 'little))
     (error? (bytevector-u64-set! $v1 33 0 'big))
     (error? (bytevector-u64-set! $v1 34 0 'little))
     (error? (bytevector-u64-set! $v1 35 0 (native-endianness)))
     (error? (bytevector-u64-set! $v1 36 0 'big))
     (error? (bytevector-u64-set! $v1 37 0 'little))
     (error? (bytevector-u64-set! $v1 38 0 'big))
     (error? (bytevector-u64-set! $v1 39 0 'little))
     (error? (if (bytevector-u64-set! $v1 'q 0 (native-endianness)) #f #t))

     ; invalid value
     (error? (bytevector-u64-set! $v1 0 #x10000000000000000 'little))
     (error? (bytevector-u64-set! $v1 8 #x-1 'big))
     (error? (if (bytevector-u64-set! $v1 16 "hello" (native-endianness))
                 #f
                 #t))

     ; invalid endianness
     (error? (bytevector-u64-set! $v1 0 0 'gorgeous))
     (error? (bytevector-u64-set! $v1 0 0 '#(ravenous)))
     (error? (if (bytevector-u64-set! $v1 0 0 #t) #f #t))

     ; make sure no damage done
     (and (bytevector? $v1)
          (equal? $v1
            '#vu8(#xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                  #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                  #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                  #xad #xad #xad #xad #xad #xad)))

     ; (not bothering with native endianness, since it's either big or little)

     ; aligned accesses, endianness little
     (begin
       (bytevector-u64-set! $v1 0 0 'little)
       (bytevector-u64-set! $v1 8 #xffffffffffffffff 'little)
       (bytevector-u64-set!
         $v1
         16
         (little-endian->unsigned #x7f #xff #xff #xff #xff #xff #xff #xff)
         'little)
       (bytevector-u64-set!
         $v1
         24
         (little-endian->unsigned #xff #xff #xff #xff #xff #xff #xff #x7f)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #xff #xff #xff
                    #xff #xff #xff #xff #xff #x7f #xff #xff #xff #xff #xff
                    #xff #xff #xff #xff #xff #xff #xff #xff #xff #x7f #xad
                    #xad #xad #xad #xad #xad #xad))))

     (begin
       (bytevector-u64-set!
         $v1
         0
         (little-endian->unsigned #x80 #x00 #x00 #x00 #x00 #x00 #x00 #x00)
         'little)
       (bytevector-u64-set!
         $v1
         8
         (little-endian->unsigned #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x80)
         'little)
       (bytevector-u64-set!
         $v1
         16
         (little-endian->unsigned #x80 #x00 #x00 #x00 #xff #xff #xff #xff)
         'little)
       (bytevector-u64-set!
         $v1
         24
         (little-endian->unsigned #xff #xff #xff #xff #x00 #x00 #x00 #x80)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x80 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00
                    #x00 #x00 #x00 #x00 #x80 #x80 #x00 #x00 #x00 #xff #xff
                    #xff #xff #xff #xff #xff #xff #x00 #x00 #x00 #x80 #xad
                    #xad #xad #xad #xad #xad #xad))))

     (begin
       (bytevector-u64-set!
         $v1
         0
         (little-endian->unsigned #x12 #x23 #x34 #x45 #x56 #x67 #x78 #x89)
         'little)
       (bytevector-u64-set!
         $v1
         8
         (little-endian->unsigned #x89 #x78 #x67 #x56 #x45 #x34 #x23 #x12)
         'little)
       (bytevector-u64-set!
         $v1
         16
         (little-endian->unsigned #x78 #x89 #x9a #xab #xbc #xcd #xde #xef)
         'little)
       (bytevector-u64-set!
         $v1
         24
         (little-endian->unsigned #xef #xde #xcd #xbc #xab #x9a #x89 #x78)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x12 #x23 #x34 #x45 #x56 #x67 #x78 #x89 #x89 #x78 #x67
                    #x56 #x45 #x34 #x23 #x12 #x78 #x89 #x9a #xab #xbc #xcd
                    #xde #xef #xef #xde #xcd #xbc #xab #x9a #x89 #x78 #xad
                    #xad #xad #xad #xad #xad #xad))))

     ; aligned accesses, endianness big
     (begin
       (bytevector-u64-set! $v1 0 0 'big)
       (bytevector-u64-set! $v1 8 #xffffffffffffffff 'big)
       (bytevector-u64-set!
         $v1
         16
         (big-endian->unsigned #x7f #xff #xff #xff #xff #xff #xff #xff)
         'big)
       (bytevector-u64-set!
         $v1
         24
         (big-endian->unsigned #xff #xff #xff #xff #xff #xff #xff #x7f)
         'big)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #xff #xff #xff
                    #xff #xff #xff #xff #xff #x7f #xff #xff #xff #xff #xff
                    #xff #xff #xff #xff #xff #xff #xff #xff #xff #x7f #xad
                    #xad #xad #xad #xad #xad #xad))))

     (begin
       (bytevector-u64-set!
         $v1
         0
         (little-endian->unsigned #x80 #x00 #x00 #x00 #x00 #x00 #x00 #x00)
         'little)
       (bytevector-u64-set!
         $v1
         8
         (little-endian->unsigned #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x80)
         'little)
       (bytevector-u64-set!
         $v1
         16
         (little-endian->unsigned #x80 #x00 #x00 #x00 #xff #xff #xff #xff)
         'little)
       (bytevector-u64-set!
         $v1
         24
         (little-endian->unsigned #xff #xff #xff #xff #x00 #x00 #x00 #x80)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x80 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00
                    #x00 #x00 #x00 #x00 #x80 #x80 #x00 #x00 #x00 #xff #xff
                    #xff #xff #xff #xff #xff #xff #x00 #x00 #x00 #x80 #xad
                    #xad #xad #xad #xad #xad #xad))))

     (begin
       (bytevector-u64-set!
         $v1
         0
         (little-endian->unsigned #x12 #x23 #x34 #x45 #x56 #x67 #x78 #x89)
         'little)
       (bytevector-u64-set!
         $v1
         8
         (little-endian->unsigned #x89 #x78 #x67 #x56 #x45 #x34 #x23 #x12)
         'little)
       (bytevector-u64-set!
         $v1
         16
         (little-endian->unsigned #x78 #x89 #x9a #xab #xbc #xcd #xde #xef)
         'little)
       (bytevector-u64-set!
         $v1
         24
         (little-endian->unsigned #xef #xde #xcd #xbc #xab #x9a #x89 #x78)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#x12 #x23 #x34 #x45 #x56 #x67 #x78 #x89 #x89 #x78 #x67
                    #x56 #x45 #x34 #x23 #x12 #x78 #x89 #x9a #xab #xbc #xcd
                    #xde #xef #xef #xde #xcd #xbc #xab #x9a #x89 #x78 #xad
                    #xad #xad #xad #xad #xad #xad))))

     ; aligned accesses, endianness mixed
     (let ([v (bytevector #xc7 #xc7 #xc7 #xc7 #xc7 #xc7 #xc7 #xc7)])
       (do ([i 10000 (fx- i 1)])
           ((fx= i 0) #t)
           (let ([ls (map (lambda (x) (random (expt 2 8))) (make-list 8))])
             (bytevector-u64-set!
               v
               0
               (apply native->unsigned ls)
               (native-endianness))
             (unless (equal? v (apply bytevector ls))
                     (errorf #f "failed for ~s" ls))
             (bytevector-u64-set!
               v
               0
               (apply big-endian->unsigned (reverse ls))
               'big)
             (unless (equal? v (apply bytevector (reverse ls)))
                     (errorf #f "failed for ~s" ls))
             (bytevector-u64-set!
               v
               0
               (apply little-endian->unsigned ls)
               'little)
             (unless (equal? v (apply bytevector ls))
                     (errorf #f "failed for ~s" ls)))))

     ; unaligned accesses, endianness mixed
     (begin
       (define $v1 (make-bytevector 36 #xad))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #xad #xad #xad #xad #xad #xad #xad #xad ; 1
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad ; 10
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad ; 19
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad))))
     ; 28

     (begin
       (bytevector-u64-set! $v1 1 0 'big)
       (bytevector-u64-set! $v1 10 #xffffffffffffffff 'little)
       (bytevector-u64-set!
         $v1
         19
         (big-endian->unsigned #x7f #xff #xff #xff #xff #xff #xff #xff)
         'big)
       (bytevector-u64-set!
         $v1
         28
         (little-endian->unsigned #xff #xff #xff #xff #xff #xff #xff #x7f)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #xad #xff
                    #xff #xff #xff #xff #xff #xff #xff #xad #x7f #xff #xff
                    #xff #xff #xff #xff #xff #xad #xff #xff #xff #xff #xff
                    #xff #xff #x7f))))

     (begin
       (define $v1 (make-bytevector 37 #xad))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #xad #xad #xad #xad #xad #xad #xad #xad #xad ; 2
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad ; 11
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad ; 20
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad))))
     ; 29

     (begin
       (bytevector-u64-set!
         $v1
         2
         (little-endian->unsigned #x80 #x00 #x00 #x00 #x00 #x00 #x00 #x00)
         'little)
       (bytevector-u64-set!
         $v1
         11
         (big-endian->unsigned #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x80)
         'big)
       (bytevector-u64-set!
         $v1
         20
         (big-endian->unsigned #x80 #x00 #x00 #x00 #xff #xff #xff #xff)
         'big)
       (bytevector-u64-set!
         $v1
         29
         (little-endian->unsigned #xff #xff #xff #xff #x00 #x00 #x00 #x80)
         'little)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #xad #x80 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #xad
                    #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x80 #xad #x80 #x00
                    #x00 #x00 #xff #xff #xff #xff #xad #xff #xff #xff #xff
                    #x00 #x00 #x00 #x80))))

     (begin
       (define $v1 (make-bytevector 38 #xad))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #xad #xad #xad #xad #xad #xad #xad #xad #xad #xad
                    ; 3
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad ; 12
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad ; 21
                    #xad #xad #xad #xad #xad #xad #xad #xad #xad))))
     ; 30

     (begin
       (bytevector-u64-set!
         $v1
         3
         (big-endian->unsigned #x12 #x23 #x34 #x45 #x56 #x67 #x78 #x89)
         'big)
       (bytevector-u64-set!
         $v1
         12
         (little-endian->unsigned #x89 #x78 #x67 #x56 #x45 #x34 #x23 #x12)
         'little)
       (bytevector-u64-set!
         $v1
         21
         (little-endian->unsigned #x78 #x89 #x9a #xab #xbc #xcd #xde #xef)
         'little)
       (bytevector-u64-set!
         $v1
         30
         (big-endian->unsigned #xef #xde #xcd #xbc #xab #x9a #x89 #x78)
         'big)
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xad #xad #xad #x12 #x23 #x34 #x45 #x56 #x67 #x78 #x89
                    #xad #x89 #x78 #x67 #x56 #x45 #x34 #x23 #x12 #xad #x78
                    #x89 #x9a #xab #xbc #xcd #xde #xef #xad #xef #xde #xcd
                    #xbc #xab #x9a #x89 #x78))))

     (let ([v (make-bytevector 15)])
       (do ([i 10000 (fx- i 1)])
           ((fx= i 0) #t)
           (let ([idx (fx+ (modulo i 7) 1)])
             (let ([ls (map (lambda (x) (random (expt 2 8))) (make-list 8))])
               (bytevector-fill! v #xc7)
               (bytevector-u64-set!
                 v
                 idx
                 (apply native->unsigned ls)
                 (native-endianness))
               (unless (equal? v
                         (apply bytevector
                           (append (make-list idx #xc7)
                                   ls
                                   (make-list (fx- 7 idx) #xc7))))
                       (errorf #f "failed for ~s (native)" ls))
               (bytevector-u64-set!
                 v
                 idx
                 (apply big-endian->unsigned (reverse ls))
                 'big)
               (unless (equal? v
                         (apply bytevector
                           (append (make-list idx #xc7)
                                   (reverse ls)
                                   (make-list (fx- 7 idx) #xc7))))
                       (errorf #f "failed for ~s (big)" ls))
               (bytevector-u64-set!
                 v
                 idx
                 (apply little-endian->unsigned ls)
                 'little)
               (unless (equal? v
                         (apply bytevector
                           (append (make-list idx #xc7)
                                   ls
                                   (make-list (fx- 7 idx) #xc7))))
                       (errorf #f "failed for ~s (little)" ls)))))))

(mat bytevector-ieee-single-native-ref
     (begin
       (define $v1
         (case (native-endianness)
           [(little)
            '#vu8(#x00 #x00 #x00 #x00 ; 0.0
                  #x00 #x00 #x00 #x00 
                  ; 0.0   ; extra for consistent mat errors between big- and little-endian machines
                  #x00 #x00 #x80 #x3f ; 1.0
                  #x00 #x00 #x80 #xbf ; -1.0
                  #x00 #x00 #xc0 #x3f ; 1.5
                  #x00 #x00 #xc0 #xbf ; -1.5
                  #xad #xe6 #xd5 #x65 ; #b1.10101011110011010101101e1001100
                  #x00 #x00 #x80 #x7f ; +inf.0
                  #x00 #x00 #x80 #xff ; -inf.0
                  #x01 #x02 #x03)]
           [(big)
            '#vu8(#x00 #x00 #x00 #x00 ; 0.0
                  #x00 #x00 #x00 #x00 
                  ; 0.0   ; extra for consistent mat errors between big- and little-endian machines
                  #x3f #x80 #x00 #x00 ; 1.0
                  #xbf #x80 #x00 #x00 ; -1.0
                  #x3f #xc0 #x00 #x00 ; 1.5
                  #xbf #xc0 #x00 #x00 ; -1.5
                  #x65 #xd5 #xe6 #xad ; #b1.10101011110011010101101e1001100
                  #x7f #x80 #x00 #x00 ; +inf.0
                  #xff #x80 #x00 #x00 ; -inf.0
                  #x01 #x02 #x03)]
           [else
            (errorf #f "mat doesn't handled endianness ~s"
                    (native-endianness))]))
       (bytevector? $v1))

     ; wrong argument count
     (error? (bytevector-ieee-single-native-ref))
     (error? (bytevector-ieee-single-native-ref $v1))
     (error? (if (bytevector-ieee-single-native-ref $v1 0 0) #f #t))

     ; not a bytevector
     (error? (bytevector-ieee-single-native-ref '#(3 252 5 0 0 0 0) 0))
     (error? (if (bytevector-ieee-single-native-ref '#(3 252 5 0 0 0 0) 0)
                 #f
                 #t))

     ; invalid index
     (error? (bytevector-ieee-single-native-ref $v1 -1))
     (error? (bytevector-ieee-single-native-ref $v1 1))
     (error? (bytevector-ieee-single-native-ref $v1 2))
     (error? (bytevector-ieee-single-native-ref $v1 3))
     (error? (bytevector-ieee-single-native-ref $v1 5))
     (error? (bytevector-ieee-single-native-ref $v1 6))
     (error? (bytevector-ieee-single-native-ref $v1 7))
     (error? (bytevector-ieee-single-native-ref $v1 9))
     (error? (bytevector-ieee-single-native-ref $v1 10))
     (error? (bytevector-ieee-single-native-ref $v1 11))
     (error? (bytevector-ieee-single-native-ref $v1 13))
     (error? (bytevector-ieee-single-native-ref $v1 14))
     (error? (bytevector-ieee-single-native-ref $v1 15))
     (error? (bytevector-ieee-single-native-ref $v1 17))
     (error? (bytevector-ieee-single-native-ref $v1 18))
     (error? (bytevector-ieee-single-native-ref $v1 19))
     (error? (bytevector-ieee-single-native-ref $v1 21))
     (error? (bytevector-ieee-single-native-ref $v1 22))
     (error? (bytevector-ieee-single-native-ref $v1 23))
     (error? (bytevector-ieee-single-native-ref $v1 25))
     (error? (bytevector-ieee-single-native-ref $v1 26))
     (error? (bytevector-ieee-single-native-ref $v1 27))
     (error? (bytevector-ieee-single-native-ref $v1 29))
     (error? (bytevector-ieee-single-native-ref $v1 30))
     (error? (bytevector-ieee-single-native-ref $v1 31))
     (error? (bytevector-ieee-single-native-ref $v1 33))
     (error? (bytevector-ieee-single-native-ref $v1 34))
     (error? (bytevector-ieee-single-native-ref $v1 35))
     (error? (bytevector-ieee-single-native-ref $v1 36))
     (error? (bytevector-ieee-single-native-ref $v1 37))
     (error? (bytevector-ieee-single-native-ref $v1 38))
     (error? (bytevector-ieee-single-native-ref $v1 39))
     (error? (if (bytevector-ieee-single-native-ref $v1 4.0) #f #t))

     (eqv? (bytevector-ieee-single-native-ref $v1 0) 0.0)
     (eqv? (bytevector-ieee-single-native-ref $v1 4) 0.0)
     (eqv? (bytevector-ieee-single-native-ref $v1 8) 1.0)
     (eqv? (bytevector-ieee-single-native-ref $v1 12) -1.0)
     (eqv? (bytevector-ieee-single-native-ref $v1 16) 1.5)
     (eqv? (bytevector-ieee-single-native-ref $v1 20) -1.5)
     (eqv? (bytevector-ieee-single-native-ref $v1 24)
           #b1.10101011110011010101101e1001100)
     (eqv? (bytevector-ieee-single-native-ref $v1 28) +inf.0)
     (eqv? (bytevector-ieee-single-native-ref $v1 32) -inf.0))

(mat bytevector-ieee-double-native-ref
     (begin
       (define $v1
         (case (native-endianness)
           [(little)
            '#vu8(#x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 ; 0.0
                  #x00 #x00 #x00 #x00 #x00 #x00 #xf0 #x3f ; 1.0
                  #x00 #x00 #x00 #x00 #x00 #x00 #xf0 #xbf ; -1.0
                  #x00 #x00 #x00 #x00 #x00 #x00 #xf8 #x3f ; 1.5
                  #x00 #x00 #x00 #x00 #x00 #x00 #xf8 #xbf ; -1.5
                  #xef #xcd #xab #x89 #x67 #x45 #xa3 #x9c 
                  ; #b-1.0011010001010110011110001001101010111100110111101111e-1000110101
                  #x00 #x00 #x00 #x00 #x00 #x00 #xf0 #x7f ; +inf.0
                  #x00 #x00 #x00 #x00 #x00 #x00 #xf0 #xff ; -inf.0
                  #x01 #x02 #x03 #x04 #x05 #x06 #x07)]
           [(big)
            '#vu8(#x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 ; 0.0
                  #x3f #xf0 #x00 #x00 #x00 #x00 #x00 #x00 ; 1.0
                  #xbf #xf0 #x00 #x00 #x00 #x00 #x00 #x00 ; -1.0
                  #x3f #xf8 #x00 #x00 #x00 #x00 #x00 #x00 ; 1.5
                  #xbf #xf8 #x00 #x00 #x00 #x00 #x00 #x00 ; -1.5
                  #x9c #xa3 #x45 #x67 #x89 #xab #xcd #xef 
                  ; #b-1.0011010001010110011110001001101010111100110111101111e-1000110101
                  #x7f #xf0 #x00 #x00 #x00 #x00 #x00 #x00 ; +inf.0
                  #xff #xf0 #x00 #x00 #x00 #x00 #x00 #x00 ; -inf.0
                  #x01 #x02 #x03 #x04 #x05 #x06 #x07)]
           [else
            (errorf #f "mat doesn't handled endianness ~s"
                    (native-endianness))]))
       (bytevector? $v1))

     ; wrong argument count
     (error? (bytevector-ieee-double-native-ref))
     (error? (bytevector-ieee-double-native-ref $v1))
     (error? (if (bytevector-ieee-double-native-ref $v1 0 0) #f #t))

     ; not a bytevector
     (error? (bytevector-ieee-double-native-ref '#(3 252 5 0 0 0 0) 0))
     (error? (if (bytevector-ieee-double-native-ref '#(3 252 5 0 0 0 0) 0)
                 #f
                 #t))

     ; invalid index
     (error? (bytevector-ieee-double-native-ref $v1 -1))
     (error? (bytevector-ieee-double-native-ref $v1 1))
     (error? (bytevector-ieee-double-native-ref $v1 2))
     (error? (bytevector-ieee-double-native-ref $v1 3))
     (error? (bytevector-ieee-double-native-ref $v1 4))
     (error? (bytevector-ieee-double-native-ref $v1 5))
     (error? (bytevector-ieee-double-native-ref $v1 6))
     (error? (bytevector-ieee-double-native-ref $v1 7))
     (error? (bytevector-ieee-double-native-ref $v1 9))
     (error? (bytevector-ieee-double-native-ref $v1 10))
     (error? (bytevector-ieee-double-native-ref $v1 11))
     (error? (bytevector-ieee-double-native-ref $v1 12))
     (error? (bytevector-ieee-double-native-ref $v1 13))
     (error? (bytevector-ieee-double-native-ref $v1 14))
     (error? (bytevector-ieee-double-native-ref $v1 15))
     (error? (bytevector-ieee-double-native-ref $v1 17))
     (error? (bytevector-ieee-double-native-ref $v1 18))
     (error? (bytevector-ieee-double-native-ref $v1 19))
     (error? (bytevector-ieee-double-native-ref $v1 20))
     (error? (bytevector-ieee-double-native-ref $v1 21))
     (error? (bytevector-ieee-double-native-ref $v1 22))
     (error? (bytevector-ieee-double-native-ref $v1 23))
     (error? (bytevector-ieee-double-native-ref $v1 25))
     (error? (bytevector-ieee-double-native-ref $v1 26))
     (error? (bytevector-ieee-double-native-ref $v1 27))
     (error? (bytevector-ieee-double-native-ref $v1 28))
     (error? (bytevector-ieee-double-native-ref $v1 29))
     (error? (bytevector-ieee-double-native-ref $v1 30))
     (error? (bytevector-ieee-double-native-ref $v1 31))
     (error? (bytevector-ieee-double-native-ref $v1 33))
     (error? (bytevector-ieee-double-native-ref $v1 42))
     (error? (bytevector-ieee-double-native-ref $v1 51))
     (error? (bytevector-ieee-double-native-ref $v1 60))
     (error? (bytevector-ieee-double-native-ref $v1 69))
     (error? (bytevector-ieee-double-native-ref $v1 70))
     (error? (bytevector-ieee-double-native-ref $v1 71))
     (error? (if (bytevector-ieee-double-native-ref $v1 4.0) #f #t))

     (eqv? (bytevector-ieee-double-native-ref $v1 0) 0.0)
     (eqv? (bytevector-ieee-double-native-ref $v1 8) 1.0)
     (eqv? (bytevector-ieee-double-native-ref $v1 16) -1.0)
     (eqv? (bytevector-ieee-double-native-ref $v1 24) 1.5)
     (eqv? (bytevector-ieee-double-native-ref $v1 32) -1.5)
     (eqv? (bytevector-ieee-double-native-ref $v1 40)
           #b-1.0011010001010110011110001001101010111100110111101111e-1000110101)
     (eqv? (bytevector-ieee-double-native-ref $v1 48) +inf.0)
     (eqv? (bytevector-ieee-double-native-ref $v1 56) -inf.0))

(mat bytevector-ieee-single-native-set!
     (begin
       (define $v1 (make-bytevector 35 #xeb))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb
                    #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb
                    #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb
                    #xeb #xeb))))

     ; wrong argument count
     (error? (bytevector-ieee-single-native-set!))
     (error? (bytevector-ieee-single-native-set! $v1))
     (error? (bytevector-ieee-single-native-set! $v1 0))
     (error? (if (bytevector-ieee-single-native-set! $v1 0 0.0 0.0) #f #t))

     ; not a bytevector
     (error? (bytevector-ieee-single-native-set! '#(3 252 5 0 0 0 0) 0 0.0))
     (error? (if (bytevector-ieee-single-native-set! '#(3 252 5 0 0 0 0) 0 0.0)
                 #f
                 #t))

     ; invalid index
     (error? (bytevector-ieee-single-native-set! $v1 -1 0.0))
     (error? (bytevector-ieee-single-native-set! $v1 1 0.0))
     (error? (bytevector-ieee-single-native-set! $v1 2 0.0))
     (error? (bytevector-ieee-single-native-set! $v1 3 0.0))
     (error? (bytevector-ieee-single-native-set! $v1 5 0.0))
     (error? (bytevector-ieee-single-native-set! $v1 6 0.0))
     (error? (bytevector-ieee-single-native-set! $v1 7 0.0))
     (error? (bytevector-ieee-single-native-set! $v1 9 0.0))
     (error? (bytevector-ieee-single-native-set! $v1 10 0.0))
     (error? (bytevector-ieee-single-native-set! $v1 11 0.0))
     (error? (bytevector-ieee-single-native-set! $v1 13 0.0))
     (error? (bytevector-ieee-single-native-set! $v1 14 0.0))
     (error? (bytevector-ieee-single-native-set! $v1 15 0.0))
     (error? (bytevector-ieee-single-native-set! $v1 17 0.0))
     (error? (bytevector-ieee-single-native-set! $v1 18 0.0))
     (error? (bytevector-ieee-single-native-set! $v1 19 0.0))
     (error? (bytevector-ieee-single-native-set! $v1 21 0.0))
     (error? (bytevector-ieee-single-native-set! $v1 22 0.0))
     (error? (bytevector-ieee-single-native-set! $v1 23 0.0))
     (error? (bytevector-ieee-single-native-set! $v1 25 0.0))
     (error? (bytevector-ieee-single-native-set! $v1 26 0.0))
     (error? (bytevector-ieee-single-native-set! $v1 27 0.0))
     (error? (bytevector-ieee-single-native-set! $v1 29 0.0))
     (error? (bytevector-ieee-single-native-set! $v1 30 0.0))
     (error? (bytevector-ieee-single-native-set! $v1 31 0.0))
     (error? (if (bytevector-ieee-single-native-set! $v1 4.0 0.0) #f #t))

     ; invalid value
     (error? (bytevector-ieee-single-native-set! $v1 0 1+2i))
     (error? (bytevector-ieee-single-native-set! $v1 0 1.0+3.0i))
     (error? (bytevector-ieee-single-native-set! $v1 0 1.0+0.0i))
     (error? (bytevector-ieee-single-native-set! $v1 0 1.0-0.0i))
     (error? (if (bytevector-ieee-single-native-set! $v1 0 "oops") #f #t))

     ; make sure no damage done
     (and (bytevector? $v1)
          (equal? $v1
            '#vu8(#xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb
                  #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb
                  #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb
                  #xeb #xeb)))

     (begin
       (bytevector-ieee-single-native-set! $v1 0 0.0)
       (bytevector-ieee-single-native-set! $v1 4 1)
       (bytevector-ieee-single-native-set! $v1 8 -1)
       (bytevector-ieee-single-native-set! $v1 12 3/2)
       (bytevector-ieee-single-native-set! $v1 16 -3/2)
       (bytevector-ieee-single-native-set!
         $v1
         20
         #b1.10101011110011010101101e1001100)
       (bytevector-ieee-single-native-set! $v1 24 +inf.0)
       (bytevector-ieee-single-native-set! $v1 28 -inf.0)
       (and (bytevector? $v1)
            (equal? $v1
              (case (native-endianness)
                [(little)
                 '#vu8(#x00 #x00 #x00 #x00 ; 0.0
                       #x00 #x00 #x80 #x3f ; 1.0
                       #x00 #x00 #x80 #xbf ; -1.0
                       #x00 #x00 #xc0 #x3f ; 1.5
                       #x00 #x00 #xc0 #xbf ; -1.5
                       #xad #xe6 #xd5 #x65 ; #b1.10101011110011010101101e1001100
                       #x00 #x00 #x80 #x7f ; +inf.0
                       #x00 #x00 #x80 #xff ; -inf.0
                       #xeb #xeb #xeb)]
                [(big)
                 '#vu8(#x00 #x00 #x00 #x00 ; 0.0
                       #x3f #x80 #x00 #x00 ; 1.0
                       #xbf #x80 #x00 #x00 ; -1.0
                       #x3f #xc0 #x00 #x00 ; 1.5
                       #xbf #xc0 #x00 #x00 ; -1.5
                       #x65 #xd5 #xe6 #xad ; #b1.10101011110011010101101e1001100
                       #x7f #x80 #x00 #x00 ; +inf.0
                       #xff #x80 #x00 #x00 ; -inf.0
                       #xeb #xeb #xeb)]
                [else
                 (errorf #f "mat doesn't handled endianness ~s"
                         (native-endianness))])))))

(mat bytevector-ieee-double-native-set!
     (begin
       (define $v1 (make-bytevector 71 #xeb))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb
                    #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb
                    #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb
                    #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb
                    #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb
                    #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb
                    #xeb #xeb #xeb #xeb #xeb))))

     ; wrong argument count
     (error? (bytevector-ieee-double-native-set!))
     (error? (bytevector-ieee-double-native-set! $v1))
     (error? (bytevector-ieee-double-native-set! $v1 0))
     (error? (if (bytevector-ieee-double-native-set! $v1 0 0.0 0.0) #f #t))

     ; not a bytevector
     (error? (bytevector-ieee-double-native-set! '#(3 252 5 0 0 0 0) 0 0.0))
     (error? (if (bytevector-ieee-double-native-set! '#(3 252 5 0 0 0 0) 0 0.0)
                 #f
                 #t))

     ; invalid index
     (error? (bytevector-ieee-double-native-set! $v1 -1 0.0))
     (error? (bytevector-ieee-double-native-set! $v1 1 0.0))
     (error? (bytevector-ieee-double-native-set! $v1 2 0.0))
     (error? (bytevector-ieee-double-native-set! $v1 3 0.0))
     (error? (bytevector-ieee-double-native-set! $v1 4 0.0))
     (error? (bytevector-ieee-double-native-set! $v1 5 0.0))
     (error? (bytevector-ieee-double-native-set! $v1 6 0.0))
     (error? (bytevector-ieee-double-native-set! $v1 7 0.0))
     (error? (bytevector-ieee-double-native-set! $v1 9 0.0))
     (error? (bytevector-ieee-double-native-set! $v1 10 0.0))
     (error? (bytevector-ieee-double-native-set! $v1 11 0.0))
     (error? (bytevector-ieee-double-native-set! $v1 12 0.0))
     (error? (bytevector-ieee-double-native-set! $v1 13 0.0))
     (error? (bytevector-ieee-double-native-set! $v1 14 0.0))
     (error? (bytevector-ieee-double-native-set! $v1 15 0.0))
     (error? (bytevector-ieee-double-native-set! $v1 17 0.0))
     (error? (bytevector-ieee-double-native-set! $v1 18 0.0))
     (error? (bytevector-ieee-double-native-set! $v1 19 0.0))
     (error? (bytevector-ieee-double-native-set! $v1 20 0.0))
     (error? (bytevector-ieee-double-native-set! $v1 21 0.0))
     (error? (bytevector-ieee-double-native-set! $v1 22 0.0))
     (error? (bytevector-ieee-double-native-set! $v1 23 0.0))
     (error? (bytevector-ieee-double-native-set! $v1 25 0.0))
     (error? (bytevector-ieee-double-native-set! $v1 26 0.0))
     (error? (bytevector-ieee-double-native-set! $v1 27 0.0))
     (error? (bytevector-ieee-double-native-set! $v1 28 0.0))
     (error? (bytevector-ieee-double-native-set! $v1 29 0.0))
     (error? (bytevector-ieee-double-native-set! $v1 30 0.0))
     (error? (bytevector-ieee-double-native-set! $v1 31 0.0))
     (error? (bytevector-ieee-double-native-set! $v1 33 0.0))
     (error? (bytevector-ieee-double-native-set! $v1 42 0.0))
     (error? (bytevector-ieee-double-native-set! $v1 51 0.0))
     (error? (bytevector-ieee-double-native-set! $v1 60 0.0))
     (error? (bytevector-ieee-double-native-set! $v1 69 0.0))
     (error? (bytevector-ieee-double-native-set! $v1 70 0.0))
     (error? (bytevector-ieee-double-native-set! $v1 71 0.0))
     (error? (if (bytevector-ieee-double-native-set! $v1 4.0 0.0) #f #t))

     ; invalid value
     (error? (bytevector-ieee-double-native-set! $v1 0 1+2i))
     (error? (bytevector-ieee-double-native-set! $v1 0 1.0-7.3i))
     (error? (bytevector-ieee-double-native-set! $v1 0 -i))
     (error? (bytevector-ieee-double-native-set! $v1 0 1.0+0.0i))
     (error? (bytevector-ieee-double-native-set! $v1 0 1.0-0.0i))
     (error? (if (bytevector-ieee-double-native-set! $v1 0 "oops") #f #t))

     ; make sure no damage done
     (and (bytevector? $v1)
          (equal? $v1
            '#vu8(#xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb
                  #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb
                  #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb
                  #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb
                  #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb
                  #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb
                  #xeb #xeb #xeb #xeb #xeb)))

     (begin
       (bytevector-ieee-double-native-set! $v1 0 0.0)
       (bytevector-ieee-double-native-set! $v1 8 1)
       (bytevector-ieee-double-native-set! $v1 16 -1)
       (bytevector-ieee-double-native-set! $v1 24 3/2)
       (bytevector-ieee-double-native-set! $v1 32 -3/2)
       (bytevector-ieee-double-native-set!
         $v1
         40
         #b-1.0011010001010110011110001001101010111100110111101111e-1000110101)
       (bytevector-ieee-double-native-set! $v1 48 +inf.0)
       (bytevector-ieee-double-native-set! $v1 56 -inf.0)
       (and (bytevector? $v1)
            (equal? $v1
              (case (native-endianness)
                [(little)
                 '#vu8(#x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 ; 0.0
                       #x00 #x00 #x00 #x00 #x00 #x00 #xf0 #x3f ; 1.0
                       #x00 #x00 #x00 #x00 #x00 #x00 #xf0 #xbf ; -1.0
                       #x00 #x00 #x00 #x00 #x00 #x00 #xf8 #x3f ; 1.5
                       #x00 #x00 #x00 #x00 #x00 #x00 #xf8 #xbf ; -1.5
                       #xef #xcd #xab #x89 #x67 #x45 #xa3 #x9c 
                       ; #b-1.0011010001010110011110001001101010111100110111101111e-1000110101
                       #x00 #x00 #x00 #x00 #x00 #x00 #xf0 #x7f ; +inf.0
                       #x00 #x00 #x00 #x00 #x00 #x00 #xf0 #xff ; -inf.0
                       #xeb #xeb #xeb #xeb #xeb #xeb #xeb)]
                [(big)
                 '#vu8(#x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 ; 0.0
                       #x3f #xf0 #x00 #x00 #x00 #x00 #x00 #x00 ; 1.0
                       #xbf #xf0 #x00 #x00 #x00 #x00 #x00 #x00 ; -1.0
                       #x3f #xf8 #x00 #x00 #x00 #x00 #x00 #x00 ; 1.5
                       #xbf #xf8 #x00 #x00 #x00 #x00 #x00 #x00 ; -1.5
                       #x9c #xa3 #x45 #x67 #x89 #xab #xcd #xef 
                       ; #b-1.0011010001010110011110001001101010111100110111101111e-1000110101
                       #x7f #xf0 #x00 #x00 #x00 #x00 #x00 #x00 ; +inf.0
                       #xff #xf0 #x00 #x00 #x00 #x00 #x00 #x00 ; -inf.0
                       #xeb #xeb #xeb #xeb #xeb #xeb #xeb)]
                [else
                 (errorf #f "mat doesn't handled endianness ~s"
                         (native-endianness))])))))

(mat bytevector-ieee-single-ref
     (begin
       (define $vlittle
         '#vu8(#x00 #x00 #x00 #x00 ; 0.0   ; 0
               #xc7 #x00 #x00 #x00 #x00 ; 0.0   ; 5
               #xc7 #x00 #x00 #x80 #x3f ; 1.0   ; 10
               #xc7 #x00 #x00 #x80 #xbf ; -1.0  ; 15
               #xc7 #x00 #x00 #xc0 #x3f ; 1.5   ; 20
               #xc7 #x00 #x00 #xc0 #xbf ; -1.5  ; 25
               #xc7 #xad #xe6 #xd5 #x65 ; #b1.10101011110011010101101e1001100 ; 30
               #xc7 #x00 #x00 #x80 #x7f ; +inf.0 ; 35
               #xc7 #x00 #x00 #x80 #xff ; -inf.0 ; 40
               #xc7))
       (define $vbig
         '#vu8(#x00 #x00 #x00 #x00 ; 0.0   ; 0
               #xc7 #x00 #x00 #x00 #x00 ; 0.0   ; 5
               #xc7 #x3f #x80 #x00 #x00 ; 1.0   ; 10
               #xc7 #xbf #x80 #x00 #x00 ; -1.0  ; 15
               #xc7 #x3f #xc0 #x00 #x00 ; 1.5   ; 20
               #xc7 #xbf #xc0 #x00 #x00 ; -1.5  ; 25
               #xc7 #x65 #xd5 #xe6 #xad ; #b1.10101011110011010101101e1001100 ; 30
               #xc7 #x7f #x80 #x00 #x00 ; +inf.0 ; 35
               #xc7 #xff #x80 #x00 #x00 ; -inf.0 ; 40
               #xc7))
       (define $vnative
         (case (native-endianness)
           [(little) $vlittle]
           [(big) $vbig]
           [else
            (errorf #f "mat doesn't handled endianness ~s"
                    (native-endianness))]))
       (andmap bytevector? (list $vlittle $vbig $vnative)))

     ; wrong argument count
     (error? (bytevector-ieee-single-ref))
     (error? (bytevector-ieee-single-ref $vnative))
     (error? (bytevector-ieee-single-ref $vnative 0))
     (error? (if (bytevector-ieee-single-ref $vnative 0 'big 0) #f #t))

     ; not a bytevector
     (error? (bytevector-ieee-single-ref '#(3 252 5 0 0 0 0) 0 'big))
     (error? (if (bytevector-ieee-single-ref '#(3 252 5 0 0 0 0) 0 'big)
                 #f
                 #t))

     ; invalid index
     (error? (bytevector-ieee-single-ref $vnative -1 'big))
     (error? (bytevector-ieee-single-ref $vnative 42 'little))
     (error? (bytevector-ieee-single-ref $vnative 43 'big))
     (error? (bytevector-ieee-single-ref $vnative 44 (native-endianness)))
     (error? (bytevector-ieee-single-ref $vnative 45 'little))
     (error? (if (bytevector-ieee-single-ref $vnative 4.0 'big) #f #t))

     ; invalid endianness
     (error? (bytevector-ieee-single-ref $vnative 0 "nuts"))
     (error? (bytevector-ieee-single-ref $vnative 0 'crazy))
     (error? (if (bytevector-ieee-single-ref $vnative 0 35) #f #t))

     (eqv? (bytevector-ieee-single-ref $vnative 0 (native-endianness)) 0.0)
     (eqv? (bytevector-ieee-single-ref $vnative 5 (native-endianness)) 0.0)
     (eqv? (bytevector-ieee-single-ref $vnative 10 (native-endianness))
           1.0)
     (eqv? (bytevector-ieee-single-ref $vnative 15 (native-endianness))
           -1.0)
     (eqv? (bytevector-ieee-single-ref $vnative 20 (native-endianness))
           1.5)
     (eqv? (bytevector-ieee-single-ref $vnative 25 (native-endianness))
           -1.5)
     (eqv? (bytevector-ieee-single-ref $vnative 30 (native-endianness))
           #b1.10101011110011010101101e1001100)
     (eqv? (bytevector-ieee-single-ref $vnative 35 (native-endianness))
           +inf.0)
     (eqv? (bytevector-ieee-single-ref $vnative 40 (native-endianness))
           -inf.0)

     (eqv? (bytevector-ieee-single-ref $vlittle 0 'little) 0.0)
     (eqv? (bytevector-ieee-single-ref $vlittle 5 'little) 0.0)
     (eqv? (bytevector-ieee-single-ref $vlittle 10 'little) 1.0)
     (eqv? (bytevector-ieee-single-ref $vlittle 15 'little) -1.0)
     (eqv? (bytevector-ieee-single-ref $vlittle 20 'little) 1.5)
     (eqv? (bytevector-ieee-single-ref $vlittle 25 'little) -1.5)
     (eqv? (bytevector-ieee-single-ref $vlittle 30 'little)
           #b1.10101011110011010101101e1001100)
     (eqv? (bytevector-ieee-single-ref $vlittle 35 'little) +inf.0)
     (eqv? (bytevector-ieee-single-ref $vlittle 40 'little) -inf.0)

     (eqv? (bytevector-ieee-single-ref $vbig 0 'big) 0.0)
     (eqv? (bytevector-ieee-single-ref $vbig 5 'big) 0.0)
     (eqv? (bytevector-ieee-single-ref $vbig 10 'big) 1.0)
     (eqv? (bytevector-ieee-single-ref $vbig 15 'big) -1.0)
     (eqv? (bytevector-ieee-single-ref $vbig 20 'big) 1.5)
     (eqv? (bytevector-ieee-single-ref $vbig 25 'big) -1.5)
     (eqv? (bytevector-ieee-single-ref $vbig 30 'big)
           #b1.10101011110011010101101e1001100)
     (eqv? (bytevector-ieee-single-ref $vbig 35 'big) +inf.0)
     (eqv? (bytevector-ieee-single-ref $vbig 40 'big) -inf.0))

(mat bytevector-ieee-double-ref
     (begin
       (define $vlittle
         '#vu8(#x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 ; 0.0    ; 0
               #xed #x00 #x00 #x00 #x00 #x00 #x00 #xf0 #x3f ; 1.0    ; 9
               #xed #x00 #x00 #x00 #x00 #x00 #x00 #xf0 #xbf ; -1.0   ; 18
               #xed #x00 #x00 #x00 #x00 #x00 #x00 #xf8 #x3f ; 1.5    ; 27
               #xed #x00 #x00 #x00 #x00 #x00 #x00 #xf8 #xbf ; -1.5   ; 36
               #xed #xef #xcd #xab #x89 #x67 #x45 #xa3 #x9c 
               ; #b-1.0011010001010110011110001001101010111100110111101111e-1000110101 ; 45
               #xed #x00 #x00 #x00 #x00 #x00 #x00 #xf0 #x7f ; +inf.0 ; 54
               #xed #x00 #x00 #x00 #x00 #x00 #x00 #xf0 #xff))
       ; -inf.0 ; 63
       (define $vbig
         '#vu8(#x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 ; 0.0    ; 0
               #xed #x3f #xf0 #x00 #x00 #x00 #x00 #x00 #x00 ; 1.0    ; 9
               #xed #xbf #xf0 #x00 #x00 #x00 #x00 #x00 #x00 ; -1.0   ; 18
               #xed #x3f #xf8 #x00 #x00 #x00 #x00 #x00 #x00 ; 1.5    ; 27
               #xed #xbf #xf8 #x00 #x00 #x00 #x00 #x00 #x00 ; -1.5   ; 36
               #xed #x9c #xa3 #x45 #x67 #x89 #xab #xcd #xef 
               ; #b-1.0011010001010110011110001001101010111100110111101111e-1000110101 ; 45
               #xed #x7f #xf0 #x00 #x00 #x00 #x00 #x00 #x00 ; +inf.0 ; 54
               #xed #xff #xf0 #x00 #x00 #x00 #x00 #x00 #x00))
       ; -inf.0 ; 63
       (define $vnative
         (case (native-endianness)
           [(little) $vlittle]
           [(big) $vbig]
           [else
            (errorf #f "mat doesn't handled endianness ~s"
                    (native-endianness))]))
       (andmap bytevector? (list $vlittle $vbig $vnative)))

     ; wrong argument count
     (error? (bytevector-ieee-double-ref))
     (error? (bytevector-ieee-double-ref $vnative))
     (error? (bytevector-ieee-double-ref $vnative 0))
     (error? (if (bytevector-ieee-double-ref $vnative 0 'big 0) #f #t))

     ; not a bytevector
     (error? (bytevector-ieee-double-ref '#(3 252 5 0 0 0 0) 0 'big))
     (error? (if (bytevector-ieee-double-ref '#(3 252 5 0 0 0 0) 0 'big)
                 #f
                 #t))

     ; invalid index
     (error? (bytevector-ieee-double-ref $vnative -1 'big))
     (error? (bytevector-ieee-double-ref $vnative 64 'big))
     (error? (bytevector-ieee-double-ref $vnative 65 (native-endianness)))
     (error? (bytevector-ieee-double-ref $vnative 66 'little))
     (error? (bytevector-ieee-double-ref $vnative 67 'big))
     (error? (bytevector-ieee-double-ref $vnative 68 (native-endianness)))
     (error? (bytevector-ieee-double-ref $vnative 69 'little))
     (error? (bytevector-ieee-double-ref $vnative 70 'big))
     (error? (bytevector-ieee-double-ref $vnative 71 'little))
     (error? (if (bytevector-ieee-double-ref $vnative 4.0 'big) #f #t))

     ; invalid endianness
     (error? (bytevector-ieee-double-ref $vnative 0 "nuts"))
     (error? (bytevector-ieee-double-ref $vnative 0 'crazy))
     (error? (if (bytevector-ieee-double-ref $vnative 0 35) #f #t))

     (eqv? (bytevector-ieee-double-ref $vnative 0 (native-endianness)) 0.0)
     (eqv? (bytevector-ieee-double-ref $vnative 9 (native-endianness)) 1.0)
     (eqv? (bytevector-ieee-double-ref $vnative 18 (native-endianness))
           -1.0)
     (eqv? (bytevector-ieee-double-ref $vnative 27 (native-endianness))
           1.5)
     (eqv? (bytevector-ieee-double-ref $vnative 36 (native-endianness))
           -1.5)
     (eqv? (bytevector-ieee-double-ref $vnative 45 (native-endianness))
           #b-1.0011010001010110011110001001101010111100110111101111e-1000110101)
     (eqv? (bytevector-ieee-double-ref $vnative 54 (native-endianness))
           +inf.0)
     (eqv? (bytevector-ieee-double-ref $vnative 63 (native-endianness))
           -inf.0)

     (eqv? (bytevector-ieee-double-ref $vlittle 0 'little) 0.0)
     (eqv? (bytevector-ieee-double-ref $vlittle 9 'little) 1.0)
     (eqv? (bytevector-ieee-double-ref $vlittle 18 'little) -1.0)
     (eqv? (bytevector-ieee-double-ref $vlittle 27 'little) 1.5)
     (eqv? (bytevector-ieee-double-ref $vlittle 36 'little) -1.5)
     (eqv? (bytevector-ieee-double-ref $vlittle 45 'little)
           #b-1.0011010001010110011110001001101010111100110111101111e-1000110101)
     (eqv? (bytevector-ieee-double-ref $vlittle 54 'little) +inf.0)
     (eqv? (bytevector-ieee-double-ref $vlittle 63 'little) -inf.0)

     (eqv? (bytevector-ieee-double-ref $vbig 0 'big) 0.0)
     (eqv? (bytevector-ieee-double-ref $vbig 9 'big) 1.0)
     (eqv? (bytevector-ieee-double-ref $vbig 18 'big) -1.0)
     (eqv? (bytevector-ieee-double-ref $vbig 27 'big) 1.5)
     (eqv? (bytevector-ieee-double-ref $vbig 36 'big) -1.5)
     (eqv? (bytevector-ieee-double-ref $vbig 45 'big)
           #b-1.0011010001010110011110001001101010111100110111101111e-1000110101)
     (eqv? (bytevector-ieee-double-ref $vbig 54 'big) +inf.0)
     (eqv? (bytevector-ieee-double-ref $vbig 63 'big) -inf.0))

(mat bytevector-ieee-single-set!
     (begin
       (define $v1 (make-bytevector 39 #xeb))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xeb #xeb #xeb #xeb ; 0
                    #xeb #xeb #xeb #xeb #xeb ; 5
                    #xeb #xeb #xeb #xeb #xeb ; 10
                    #xeb #xeb #xeb #xeb #xeb ; 15
                    #xeb #xeb #xeb #xeb #xeb ; 20
                    #xeb #xeb #xeb #xeb #xeb ; 25
                    #xeb #xeb #xeb #xeb #xeb ; 30
                    #xeb #xeb #xeb #xeb #xeb))))
     ; 35

     ; wrong argument count
     (error? (bytevector-ieee-single-set!))
     (error? (bytevector-ieee-single-set! $v1))
     (error? (bytevector-ieee-single-set! $v1 0))
     (error? (bytevector-ieee-single-set! $v1 0 0.0))
     (error? (if (bytevector-ieee-single-set! $v1 0 0.0 'big 'bigger)
                 #f
                 #t))

     ; not a bytevector
     (error? (bytevector-ieee-single-set! '#(3 252 5 0 0 0 0) 0 0.0 'little))
     (error? (if (bytevector-ieee-single-set! '#(3 252 5 0 0 0 0) 0 0.0 'little)
                 #f
                 #t))

     ; invalid index
     (error? (bytevector-ieee-single-set! $v1 -1 0.0 'little))
     (error? (bytevector-ieee-single-set! $v1 36 0.0 'little))
     (error? (bytevector-ieee-single-set! $v1 37 0.0 'big))
     (error? (bytevector-ieee-single-set! $v1 38 0.0 'big))
     (error? (bytevector-ieee-single-set! $v1 39 0.0 'little))
     (error? (if (bytevector-ieee-single-set!
                   $v1
                   4.0
                   0.0
                   (native-endianness))
                 #f
                 #t))

     ; invalid value
     (error? (bytevector-ieee-single-set! $v1 0 1+2i 'big))
     (error? (bytevector-ieee-single-set! $v1 0 1.0+3.0i 'little))
     (error? (bytevector-ieee-single-set! $v1 0 1.0+0.0i 'big))
     (error? (bytevector-ieee-single-set!
               $v1
               0
               1.0-0.0i
               (native-endianness)))
     (error? (if (bytevector-ieee-single-set! $v1 0 "oops" 'little) #f #t))

     ; invalid endianness
     (error? (bytevector-ieee-single-set! $v1 0 0.0 "ouch"))
     (error? (bytevector-ieee-single-set! $v1 0 0.0 'what?))
     (error? (if (bytevector-ieee-single-set! $v1 0 0.0 #\newline) #f #t))

     ; make sure no damage done
     (and (bytevector? $v1)
          (equal? $v1
            '#vu8(#xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb
                  #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb
                  #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb
                  #xeb #xeb #xeb #xeb #xeb #xeb)))

     (begin
       (define $vlittle
         '#vu8(#x00 #x00 #x00 #x00 ; 0.0
               #xeb #x00 #x00 #x80 #x3f ; 1.0
               #xeb #x00 #x00 #x80 #xbf ; -1.0
               #xeb #x00 #x00 #xc0 #x3f ; 1.5
               #xeb #x00 #x00 #xc0 #xbf ; -1.5
               #xeb #xad #xe6 #xd5 #x65 ; #b1.10101011110011010101101e1001100
               #xeb #x00 #x00 #x80 #x7f ; +inf.0
               #xeb #x00 #x00 #x80 #xff))
       ; -inf.0

       (define $vbig
         '#vu8(#x00 #x00 #x00 #x00 ; 0.0
               #xeb #x3f #x80 #x00 #x00 ; 1.0
               #xeb #xbf #x80 #x00 #x00 ; -1.0
               #xeb #x3f #xc0 #x00 #x00 ; 1.5
               #xeb #xbf #xc0 #x00 #x00 ; -1.5
               #xeb #x65 #xd5 #xe6 #xad ; #b1.10101011110011010101101e1001100
               #xeb #x7f #x80 #x00 #x00 ; +inf.0
               #xeb #xff #x80 #x00 #x00))
       ; -inf.0

       (define $vnative
         (case (native-endianness)
           [(little) $vlittle]
           [(big) $vbig]
           [else
            (errorf #f "mat doesn't handled endianness ~s"
                    (native-endianness))]))
       (andmap bytevector? (list $vlittle $vbig $vnative)))

     (begin
       (bytevector-ieee-single-set! $v1 0 0.0 (native-endianness))
       (bytevector-ieee-single-set! $v1 5 1 (native-endianness))
       (bytevector-ieee-single-set! $v1 10 -1 (native-endianness))
       (bytevector-ieee-single-set! $v1 15 3/2 (native-endianness))
       (bytevector-ieee-single-set! $v1 20 -3/2 (native-endianness))
       (bytevector-ieee-single-set!
         $v1
         25
         #b1.10101011110011010101101e1001100
         (native-endianness))
       (bytevector-ieee-single-set! $v1 30 +inf.0 (native-endianness))
       (bytevector-ieee-single-set! $v1 35 -inf.0 (native-endianness))
       (and (bytevector? $v1) (equal? $v1 $vnative)))

     (begin
       (bytevector-ieee-single-set! $v1 0 0.0 'little)
       (bytevector-ieee-single-set! $v1 5 1 'little)
       (bytevector-ieee-single-set! $v1 10 -1 'little)
       (bytevector-ieee-single-set! $v1 15 3/2 'little)
       (bytevector-ieee-single-set! $v1 20 -3/2 'little)
       (bytevector-ieee-single-set!
         $v1
         25
         #b1.10101011110011010101101e1001100
         'little)
       (bytevector-ieee-single-set! $v1 30 +inf.0 'little)
       (bytevector-ieee-single-set! $v1 35 -inf.0 'little)
       (and (bytevector? $v1) (equal? $v1 $vlittle)))

     (begin
       (bytevector-ieee-single-set! $v1 0 0.0 'big)
       (bytevector-ieee-single-set! $v1 5 1 'big)
       (bytevector-ieee-single-set! $v1 10 -1 'big)
       (bytevector-ieee-single-set! $v1 15 3/2 'big)
       (bytevector-ieee-single-set! $v1 20 -3/2 'big)
       (bytevector-ieee-single-set!
         $v1
         25
         #b1.10101011110011010101101e1001100
         'big)
       (bytevector-ieee-single-set! $v1 30 +inf.0 'big)
       (bytevector-ieee-single-set! $v1 35 -inf.0 'big)
       (and (bytevector? $v1) (equal? $v1 $vbig))))

(mat bytevector-ieee-double-set!
     (begin
       (define $v1 (make-bytevector 71 #xeb))
       (and (bytevector? $v1)
            (equal? $v1
              '#vu8(#xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb ; 0
                    #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb ; 9
                    #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb ; 18
                    #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb ; 27
                    #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb ; 36
                    #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb ; 45
                    #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb ; 54
                    #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb))))
     ; 63

     ; wrong argument count
     (error? (bytevector-ieee-double-set!))
     (error? (bytevector-ieee-double-set! $v1))
     (error? (bytevector-ieee-double-set! $v1 0))
     (error? (bytevector-ieee-double-set! $v1 0 0.0))
     (error? (if (bytevector-ieee-double-set! $v1 0 0.0 'big 'bigger)
                 #f
                 #t))

     ; not a bytevector
     (error? (bytevector-ieee-double-set! '#(3 252 5 0 0 0 0) 0 0.0 'little))
     (error? (if (bytevector-ieee-double-set! '#(3 252 5 0 0 0 0) 0 0.0 'little)
                 #f
                 #t))

     ; invalid index
     (error? (bytevector-ieee-double-set! $v1 -1 0.0 'little))
     (error? (bytevector-ieee-double-set! $v1 64 0.0 'little))
     (error? (bytevector-ieee-double-set! $v1 65 0.0 'little))
     (error? (bytevector-ieee-double-set! $v1 66 0.0 'little))
     (error? (bytevector-ieee-double-set! $v1 67 0.0 'little))
     (error? (bytevector-ieee-double-set! $v1 68 0.0 'little))
     (error? (bytevector-ieee-double-set! $v1 69 0.0 'big))
     (error? (bytevector-ieee-double-set! $v1 70 0.0 'big))
     (error? (bytevector-ieee-double-set! $v1 71 0.0 'little))
     (error? (if (bytevector-ieee-double-set!
                   $v1
                   4.0
                   0.0
                   (native-endianness))
                 #f
                 #t))

     ; invalid value
     (error? (bytevector-ieee-double-set! $v1 0 1+2i 'big))
     (error? (bytevector-ieee-double-set! $v1 0 1.0+3.0i 'little))
     (error? (bytevector-ieee-double-set! $v1 0 1.0+0.0i 'big))
     (error? (bytevector-ieee-double-set!
               $v1
               0
               1.0-0.0i
               (native-endianness)))
     (error? (if (bytevector-ieee-double-set! $v1 0 "oops" 'little) #f #t))

     ; invalid endianness
     (error? (bytevector-ieee-double-set! $v1 0 0.0 "ouch"))
     (error? (bytevector-ieee-double-set! $v1 0 0.0 'what?))
     (error? (if (bytevector-ieee-double-set! $v1 0 0.0 #\newline) #f #t))

     ; make sure no damage done
     (and (bytevector? $v1)
          (equal? $v1
            '#vu8(#xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb ; 0
                  #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb ; 9
                  #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb ; 18
                  #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb ; 27
                  #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb ; 36
                  #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb ; 45
                  #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb ; 54
                  #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb #xeb)))
     ; 63

     (begin
       (define $vlittle
         '#vu8(#x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 ; 0.0
               #xeb #x00 #x00 #x00 #x00 #x00 #x00 #xf0 #x3f ; 1.0
               #xeb #x00 #x00 #x00 #x00 #x00 #x00 #xf0 #xbf ; -1.0
               #xeb #x00 #x00 #x00 #x00 #x00 #x00 #xf8 #x3f ; 1.5
               #xeb #x00 #x00 #x00 #x00 #x00 #x00 #xf8 #xbf ; -1.5
               #xeb #xef #xcd #xab #x89 #x67 #x45 #xa3 #x9c 
               ; #b-1.0011010001010110011110001001101010111100110111101111e-1000110101
               #xeb #x00 #x00 #x00 #x00 #x00 #x00 #xf0 #x7f ; +inf.0
               #xeb #x00 #x00 #x00 #x00 #x00 #x00 #xf0 #xff))
       ; -inf.0

       (define $vbig
         '#vu8(#x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 ; 0.0
               #xeb #x3f #xf0 #x00 #x00 #x00 #x00 #x00 #x00 ; 1.0
               #xeb #xbf #xf0 #x00 #x00 #x00 #x00 #x00 #x00 ; -1.0
               #xeb #x3f #xf8 #x00 #x00 #x00 #x00 #x00 #x00 ; 1.5
               #xeb #xbf #xf8 #x00 #x00 #x00 #x00 #x00 #x00 ; -1.5
               #xeb #x9c #xa3 #x45 #x67 #x89 #xab #xcd #xef 
               ; #b-1.0011010001010110011110001001101010111100110111101111e-1000110101
               #xeb #x7f #xf0 #x00 #x00 #x00 #x00 #x00 #x00 ; +inf.0
               #xeb #xff #xf0 #x00 #x00 #x00 #x00 #x00 #x00))
       ; -inf.0

       (define $vnative
         (case (native-endianness)
           [(little) $vlittle]
           [(big) $vbig]
           [else
            (errorf #f "mat doesn't handled endianness ~s"
                    (native-endianness))]))
       (andmap bytevector? (list $vlittle $vbig $vnative)))

     (begin
       (bytevector-ieee-double-set! $v1 0 0.0 (native-endianness))
       (bytevector-ieee-double-set! $v1 9 1 (native-endianness))
       (bytevector-ieee-double-set! $v1 18 -1 (native-endianness))
       (bytevector-ieee-double-set! $v1 27 3/2 (native-endianness))
       (bytevector-ieee-double-set! $v1 36 -3/2 (native-endianness))
       (bytevector-ieee-double-set!
         $v1
         45
         #b-1.0011010001010110011110001001101010111100110111101111e-1000110101
         (native-endianness))
       (bytevector-ieee-double-set! $v1 54 +inf.0 (native-endianness))
       (bytevector-ieee-double-set! $v1 63 -inf.0 (native-endianness))
       (and (bytevector? $v1) (equal? $v1 $vnative)))

     (begin
       (bytevector-ieee-double-set! $v1 0 0.0 'big)
       (bytevector-ieee-double-set! $v1 9 1 'big)
       (bytevector-ieee-double-set! $v1 18 -1 'big)
       (bytevector-ieee-double-set! $v1 27 3/2 'big)
       (bytevector-ieee-double-set! $v1 36 -3/2 'big)
       (bytevector-ieee-double-set!
         $v1
         45
         #b-1.0011010001010110011110001001101010111100110111101111e-1000110101
         'big)
       (bytevector-ieee-double-set! $v1 54 +inf.0 'big)
       (bytevector-ieee-double-set! $v1 63 -inf.0 'big)
       (and (bytevector? $v1) (equal? $v1 $vbig)))

     (begin
       (bytevector-ieee-double-set! $v1 0 0.0 'little)
       (bytevector-ieee-double-set! $v1 9 1 'little)
       (bytevector-ieee-double-set! $v1 18 -1 'little)
       (bytevector-ieee-double-set! $v1 27 3/2 'little)
       (bytevector-ieee-double-set! $v1 36 -3/2 'little)
       (bytevector-ieee-double-set!
         $v1
         45
         #b-1.0011010001010110011110001001101010111100110111101111e-1000110101
         'little)
       (bytevector-ieee-double-set! $v1 54 +inf.0 'little)
       (bytevector-ieee-double-set! $v1 63 -inf.0 'little)
       (and (bytevector? $v1) (equal? $v1 $vlittle))))

(mat bytevector-sint-ref
     (begin
       (define $v1
         '#vu8(#x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #xff #xff #xff #xff
               #xff #xff #xff #xff #x7f #xff #xff #xff #xff #xff #xff #xff
               #xff #xff #xff #xff #xff #xff #xff #x7f #x80 #x00 #x00 #x00
               #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x80
               #x80 #x00 #x00 #x00 #xff #xff #xff #xff #xff #xff #xff #xff
               #x00 #x00 #x00 #x80 #x12 #x23 #x34 #x45 #x56 #x67 #x78 #x89
               #x89 #x78 #x67 #x56 #x45 #x34 #x23 #x12 #x78 #x89 #x9a #xab
               #xbc #xcd #xde #xef #xef #xde #xcd #xbc #xab #x9a #x89 #x78
               #xfe #xed #xdc #xcb #xba #xa9 #x98))
       (bytevector? $v1))

     ; wrong argument count
     (error? (bytevector-sint-ref))
     (error? (bytevector-sint-ref $v1))
     (error? (bytevector-sint-ref $v1 0))
     (error? (bytevector-sint-ref $v1 0 'big))
     (error? (if (bytevector-sint-ref $v1 0 'big 5 0) #f #t))

     ; not a bytevector
     (error? (bytevector-sint-ref '#(3 252 5 0 0 0 0 0 0 0 0) 0 'little 1))
     (error? (if (bytevector-sint-ref '#(3 252 5 0 0 0 0 0 0 0 0) 0 'little 1)
                 #f
                 #t))

     ; invalid index
     (error? (bytevector-sint-ref $v1 -1 'big 1))
     (error? (bytevector-sint-ref $v1 -1 'big 2))
     (error? (bytevector-sint-ref $v1 -1 'big 3))
     (error? (bytevector-sint-ref $v1 -1 'big 4))
     (error? (bytevector-sint-ref $v1 -1 'big 8))
     (error? (bytevector-sint-ref $v1 -1 'big 9))
     (error? (if (bytevector-sint-ref $v1 -1 'big 10) #f #t))

     (error? (bytevector-sint-ref $v1 96 'little 8))
     (error? (bytevector-sint-ref $v1 96 'little 9))
     (error? (bytevector-sint-ref $v1 97 'big 7))
     (error? (bytevector-sint-ref $v1 98 'little 6))
     (error? (bytevector-sint-ref $v1 99 'big 5))
     (error? (bytevector-sint-ref $v1 100 'big 4))
     (error? (bytevector-sint-ref $v1 100 'big 5))
     (error? (bytevector-sint-ref $v1 100 'big 8))
     (error? (bytevector-sint-ref $v1 101 'big 3))
     (error? (bytevector-sint-ref $v1 101 'little 4))
     (error? (bytevector-sint-ref $v1 102 'little 2))
     (error? (bytevector-sint-ref $v1 102 'big 3))
     (error? (bytevector-sint-ref $v1 103 'big 1))
     (error? (bytevector-sint-ref $v1 103 'big 2))
     (error? (bytevector-sint-ref $v1 103 'big 3))
     (error? (if (bytevector-sint-ref $v1 4.0 (native-endianness) 3) #f #t))

     ; invalid endianness
     (error? (bytevector-sint-ref $v1 0 'bonkers 1))
     (error? (bytevector-sint-ref $v1 0 'bonkers 2))
     (error? (bytevector-sint-ref $v1 0 'bonkers 3))
     (error? (bytevector-sint-ref $v1 0 'bonkers 4))
     (error? (bytevector-sint-ref $v1 0 'bonkers 8))
     (error? (if (bytevector-sint-ref $v1 0 'bonkers 35) #f #t))

     ; invalid size
     (error? (bytevector-sint-ref $v1 0 'little 0))
     (error? (bytevector-sint-ref $v1 1 'big -1))
     (error? (if (bytevector-sint-ref $v1 4 'little 'byte) #f #t))

     ; constant args
     (andmap (lambda (b*) (andmap (lambda (b) (eq? b #t)) b*))
       (let ()
         (define-syntax a
           (lambda (x)
             (define (sublist ls i j)
               (list-head (list-tail ls i) j))
             (let* ([ls '(1 254
                            3
                            252
                            5
                            250
                            7
                            249
                            8
                            248
                            9
                            247
                            10
                            246
                            40
                            216
                            80
                            176
                            100
                            156)] [n (length ls)])
               #`(let ()
                   (define v '#,(apply bytevector ls))
                   (list #,@(let f ([i 0])
                              (if (fx= i n)
                                  '()
                                  #`((list #,@(let g ([j 1])
                                                (if (fx<= j (fx- n i))
                                                    #`((eqv? (bytevector-sint-ref v #,i 'little #,j)
                                                             #,(apply little-endian->signed (sublist ls i j)))
                                                       (eqv? (bytevector-sint-ref v #,i 'big #,j)
                                                             #,(apply big-endian->signed (sublist ls i j)))
                                                       #,@(g (fx+ j 1)))
                                                    '())))
                                     #,@(f (fx+ i 1))))))))))
         a))

     ; nonconstant args
     (do ([i 100 (fx- i 1)])
         ((fx= i 0) #t)
         (let ([ls (map (lambda (x) (random 256)) (make-list (random 25)))])
           (unless (andmap (lambda (b*)
                             (andmap (lambda (b) (eq? b #t)) b*))
                     (let ()
                       (define (sublist ls i j)
                         (list-head (list-tail ls i) j))
                       (let ([n (length ls)])
                         (define v (apply bytevector ls))
                         (let f ([i 0])
                           (if (fx= i n)
                               '()
                               (cons (let g ([j 1])
                                       (if (fx<= j (fx- n i))
                                           (cons* (eqv? (bytevector-sint-ref v i 'little j)
                                                        (apply little-endian->signed (sublist ls i j)))
                                                  (eqv? (bytevector-sint-ref v i 'big j)
                                                        (apply big-endian->signed (sublist ls i j)))
                                                  (g (fx+ j 1)))
                                           '()))
                                     (f (fx+ i 1))))))))
                   (pretty-print ls)
                   (errorf #f "failed for for ~s" ls)))))

(mat bytevector-uint-ref
     (begin
       (define $v1
         '#vu8(#x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #xff #xff #xff #xff
               #xff #xff #xff #xff #x7f #xff #xff #xff #xff #xff #xff #xff
               #xff #xff #xff #xff #xff #xff #xff #x7f #x80 #x00 #x00 #x00
               #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x80
               #x80 #x00 #x00 #x00 #xff #xff #xff #xff #xff #xff #xff #xff
               #x00 #x00 #x00 #x80 #x12 #x23 #x34 #x45 #x56 #x67 #x78 #x89
               #x89 #x78 #x67 #x56 #x45 #x34 #x23 #x12 #x78 #x89 #x9a #xab
               #xbc #xcd #xde #xef #xef #xde #xcd #xbc #xab #x9a #x89 #x78
               #xfe #xed #xdc #xcb #xba #xa9 #x98))
       (bytevector? $v1))

     ; wrong argument count
     (error? (bytevector-uint-ref))
     (error? (bytevector-uint-ref $v1))
     (error? (bytevector-uint-ref $v1 0))
     (error? (bytevector-uint-ref $v1 0 'big))
     (error? (if (bytevector-uint-ref $v1 0 'big 5 0) #f #t))

     ; not a bytevector
     (error? (bytevector-uint-ref '#(3 252 5 0 0 0 0 0 0 0 0) 0 'little 1))
     (error? (if (bytevector-uint-ref '#(3 252 5 0 0 0 0 0 0 0 0) 0 'little 1)
                 #f
                 #t))

     ; invalid index
     (error? (bytevector-uint-ref $v1 -1 'big 1))
     (error? (bytevector-uint-ref $v1 -1 'big 2))
     (error? (bytevector-uint-ref $v1 -1 'big 3))
     (error? (bytevector-uint-ref $v1 -1 'big 4))
     (error? (bytevector-uint-ref $v1 -1 'big 8))
     (error? (bytevector-uint-ref $v1 -1 'big 9))
     (error? (if (bytevector-uint-ref $v1 -1 'big 10) #f #t))

     (error? (bytevector-uint-ref $v1 96 'little 8))
     (error? (bytevector-uint-ref $v1 96 'little 9))
     (error? (bytevector-uint-ref $v1 97 'big 7))
     (error? (bytevector-uint-ref $v1 98 'little 6))
     (error? (bytevector-uint-ref $v1 99 'big 5))
     (error? (bytevector-uint-ref $v1 100 'big 4))
     (error? (bytevector-uint-ref $v1 100 'big 5))
     (error? (bytevector-uint-ref $v1 100 'big 8))
     (error? (bytevector-uint-ref $v1 101 'big 3))
     (error? (bytevector-uint-ref $v1 101 'little 4))
     (error? (bytevector-uint-ref $v1 102 'little 2))
     (error? (bytevector-uint-ref $v1 102 'big 3))
     (error? (bytevector-uint-ref $v1 103 'big 1))
     (error? (bytevector-uint-ref $v1 103 'big 2))
     (error? (bytevector-uint-ref $v1 103 'big 3))
     (error? (if (bytevector-uint-ref $v1 4.0 (native-endianness) 3) #f #t))

     ; invalid endianness
     (error? (bytevector-uint-ref $v1 0 'bonkers 1))
     (error? (bytevector-uint-ref $v1 0 'bonkers 2))
     (error? (bytevector-uint-ref $v1 0 'bonkers 3))
     (error? (bytevector-uint-ref $v1 0 'bonkers 4))
     (error? (bytevector-uint-ref $v1 0 'bonkers 8))
     (error? (if (bytevector-uint-ref $v1 0 'bonkers 35) #f #t))

     ; invalid size
     (error? (bytevector-uint-ref $v1 0 'little 0))
     (error? (bytevector-uint-ref
               $v1
               0
               'little
               (+ (bytevector-length $v1) 1)))
     (error? (bytevector-uint-ref
               $v1
               7
               'little
               (- (bytevector-length $v1) 6)))
     (error? (bytevector-uint-ref #vu8(1 2 3 4) 0 'big 32))
     (error? (bytevector-uint-ref $v1 1 'big -1))
     (error? (if (bytevector-uint-ref $v1 4 'little 'byte) #f #t))

     ; constant args
     (andmap (lambda (b*) (andmap (lambda (b) (eq? b #t)) b*))
       (let ()
         (define-syntax a
           (lambda (x)
             (define (sublist ls i j)
               (list-head (list-tail ls i) j))
             (let* ([ls '(1 254
                            3
                            252
                            5
                            250
                            7
                            249
                            8
                            248
                            9
                            247
                            10
                            246
                            40
                            216
                            80
                            176
                            100
                            156)] [n (length ls)])
               #`(let ()
                   (define v '#,(apply bytevector ls))
                   (list #,@(let f ([i 0])
                              (if (fx= i n)
                                  '()
                                  #`((list #,@(let g ([j 1])
                                                (if (fx<= j (fx- n i))
                                                    #`((eqv? (bytevector-uint-ref v #,i 'little #,j)
                                                             #,(apply little-endian->unsigned (sublist ls i j)))
                                                       (eqv? (bytevector-uint-ref v #,i 'big #,j)
                                                             #,(apply big-endian->unsigned (sublist ls i j)))
                                                       #,@(g (fx+ j 1)))
                                                    '())))
                                     #,@(f (fx+ i 1))))))))))
         a))

     ; nonconstant args
     (do ([i 100 (fx- i 1)])
         ((fx= i 0) #t)
         (let ([ls (map (lambda (x) (random 256)) (make-list (random 25)))])
           (unless (andmap (lambda (b*)
                             (andmap (lambda (b) (eq? b #t)) b*))
                     (let ()
                       (define (sublist ls i j)
                         (list-head (list-tail ls i) j))
                       (let ([n (length ls)])
                         (define v (apply bytevector ls))
                         (let f ([i 0])
                           (if (fx= i n)
                               '()
                               (cons (let g ([j 1])
                                       (if (fx<= j (fx- n i))
                                           (cons* (eqv? (bytevector-uint-ref v i 'little j)
                                                        (apply little-endian->unsigned (sublist ls i j)))
                                                  (eqv? (bytevector-uint-ref v i 'big j)
                                                        (apply big-endian->unsigned (sublist ls i j)))
                                                  (g (fx+ j 1)))
                                           '()))
                                     (f (fx+ i 1))))))))
                   (pretty-print ls)
                   (errorf #f "failed for for ~s" ls)))))

(mat bytevector-sint-set!
     (begin
       (define $v1
         '#vu8(#x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #xff #xff #xff #xff
               #xff #xff #xff #xff #x7f #xff #xff #xff #xff #xff #xff #xff
               #xff #xff #xff #xff #xff #xff #xff #x7f #x80 #x00 #x00 #x00
               #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x80
               #x80 #x00 #x00 #x00 #xff #xff #xff #xff #xff #xff #xff #xff
               #x00 #x00 #x00 #x80 #x12 #x23 #x34 #x45 #x56 #x67 #x78 #x89
               #x89 #x78 #x67 #x56 #x45 #x34 #x23 #x12 #x78 #x89 #x9a #xab
               #xbc #xcd #xde #xef #xef #xde #xcd #xbc #xab #x9a #x89 #x78
               #xfe #xed #xdc #xcb #xba #xa9 #x98))
       (bytevector? $v1))

     ; wrong argument count
     (error? (bytevector-sint-set!))
     (error? (bytevector-sint-set! $v1))
     (error? (bytevector-sint-set! $v1 0))
     (error? (bytevector-sint-set! $v1 0 7))
     (error? (bytevector-sint-set! $v1 0 7 'big))
     (error? (if (bytevector-sint-set! $v1 0 7 'big 5 0) #f #t))

     ; not a bytevector
     (error? (bytevector-sint-set! '#(3 252 5 0 0 0 0 0 0 0 0) 0 7 'little 1))
     (error? (if (bytevector-sint-set!
                   '#(3 252 5 0 0 0 0 0 0 0 0)
                   0
                   7
                   'little
                   1)
                 #f
                 #t))

     ; invalid index
     (error? (bytevector-sint-set! $v1 -1 7 'big 1))
     (error? (bytevector-sint-set! $v1 -1 7 'big 2))
     (error? (bytevector-sint-set! $v1 -1 7 'big 3))
     (error? (bytevector-sint-set! $v1 -1 7 'big 4))
     (error? (bytevector-sint-set! $v1 -1 7 'big 8))
     (error? (bytevector-sint-set! $v1 -1 7 'big 9))
     (error? (if (bytevector-sint-set! $v1 -1 7 'big 10) #f #t))

     (error? (bytevector-sint-set! $v1 96 7 'little 8))
     (error? (bytevector-sint-set! $v1 96 7 'little 9))
     (error? (bytevector-sint-set! $v1 97 7 'big 7))
     (error? (bytevector-sint-set! $v1 98 7 'little 6))
     (error? (bytevector-sint-set! $v1 99 7 'big 5))
     (error? (bytevector-sint-set! $v1 100 7 'big 4))
     (error? (bytevector-sint-set! $v1 100 7 'big 5))
     (error? (bytevector-sint-set! $v1 100 7 'big 8))
     (error? (bytevector-sint-set! $v1 101 7 'big 3))
     (error? (bytevector-sint-set! $v1 101 7 'little 4))
     (error? (bytevector-sint-set! $v1 102 7 'little 2))
     (error? (bytevector-sint-set! $v1 102 7 'big 3))
     (error? (bytevector-sint-set! $v1 103 7 'big 1))
     (error? (bytevector-sint-set! $v1 103 7 'big 2))
     (error? (bytevector-sint-set! $v1 103 7 'big 3))
     (error? (if (bytevector-sint-set! $v1 4.0 7 (native-endianness) 3)
                 #f
                 #t))

     ; invalid value
     (error? (bytevector-sint-set! $v1 0 #x-81 'big 1))
     (error? (bytevector-sint-set! $v1 0 #x-81 'little 1))
     (error? (bytevector-sint-set! $v1 0 #x80 'big 1))
     (error? (bytevector-sint-set! $v1 0 #x80 'little 1))
     (error? (bytevector-sint-set! $v1 0 #x-8001 'big 2))
     (error? (bytevector-sint-set! $v1 0 #x-8001 'little 2))
     (error? (bytevector-sint-set! $v1 0 #x8000 'big 2))
     (error? (bytevector-sint-set! $v1 0 #x8000 'little 2))
     (error? (bytevector-sint-set! $v1 0 #x-800001 'big 3))
     (error? (bytevector-sint-set! $v1 0 #x-800001 'little 3))
     (error? (bytevector-sint-set! $v1 0 #x800000 'big 3))
     (error? (bytevector-sint-set! $v1 0 #x800000 'little 3))
     (error? (bytevector-sint-set! $v1 0 #x-80000001 'big 4))
     (error? (bytevector-sint-set! $v1 0 #x-80000001 'little 4))
     (error? (bytevector-sint-set! $v1 0 #x80000000 'big 4))
     (error? (bytevector-sint-set! $v1 0 #x80000000 'little 4))
     (error? (bytevector-sint-set! $v1 0 #x-8000000000000001 'big 8))
     (error? (bytevector-sint-set! $v1 0 #x-8000000000000001 'little 8))
     (error? (bytevector-sint-set! $v1 0 #x8000000000000000 'big 8))
     (error? (bytevector-sint-set! $v1 0 #x8000000000000000 'little 8))
     (error? (bytevector-sint-set! $v1 0 #x-80000000000000000001 'big 10))
     (error? (bytevector-sint-set!
               $v1
               0
               #x-80000000000000000001
               'little
               10))
     (error? (bytevector-sint-set! $v1 0 #x80000000000000000000 'big 10))
     (error? (if (bytevector-sint-set!
                   $v1
                   0
                   #x80000000000000000000
                   'little
                   10)
                 #f
                 #t))

     ; invalid endianness
     (error? (bytevector-sint-set! $v1 0 7 'bonkers 1))
     (error? (bytevector-sint-set! $v1 0 7 'bonkers 2))
     (error? (bytevector-sint-set! $v1 0 7 'bonkers 3))
     (error? (bytevector-sint-set! $v1 0 7 'bonkers 4))
     (error? (bytevector-sint-set! $v1 0 7 'bonkers 8))
     (error? (if (bytevector-sint-set! $v1 0 7 'bonkers 35) #f #t))

     ; invalid size
     (error? (bytevector-sint-set! $v1 0 7 'little 0))
     (error? (bytevector-sint-set! $v1 1 7 'big -1))
     (error? (if (bytevector-sint-set! $v1 4 7 'little 'byte) #f #t))

     ; constant args
     (andmap (lambda (b*) (andmap (lambda (b) (eq? b #t)) b*))
       (let ()
         (define-syntax a
           (lambda (x)
             (define (sublist ls i j)
               (list-head (list-tail ls i) j))
             (define (cmp-vec ls i j)
               (apply bytevector
                 `(,@(make-list i #xc7)
                   ,@(sublist ls i j)
                   ,@(make-list (fx- (length ls) (+ i j)) #xc7))))
             (let* ([ls '(1 254 3)
                        #;
                        '(1 254
                            3
                            252
                            5
                            250
                            7
                            249
                            8
                            248
                            9
                            247
                            10
                            246
                            40
                            216
                            80
                            176
                            100
                            156)] [n (length ls)])
               #`(list #,@(let f ([i 0])
                            (if (fx= i n)
                                '()
                                #`((list #,@(let g ([j 1])
                                              (if (fx<= j (fx- n i))
                                                  #`((equal? (let ([v (make-bytevector #,n #xc7)])
                                                               (bytevector-sint-set!
                                                                 v
                                                                 #,i
                                                                 #,(apply little-endian->signed (sublist ls i j))
                                                                 'little
                                                                 #,j)
                                                               v)
                                                             '#,(cmp-vec
                                                                 ls i j))
                                                     (equal? (let ([v (make-bytevector #,n #xc7)])
                                                               (bytevector-sint-set!
                                                                 v
                                                                 #,i
                                                                 #,(apply big-endian->signed (sublist ls i j))
                                                                 'big
                                                                 #,j)
                                                               v)
                                                             '#,(cmp-vec
                                                                 ls i j))
                                                     #,@(g (fx+ j 1)))
                                                  '())))
                                   #,@(f (fx+ i 1)))))))))
         a))

     ; nonconstant args
     (do ([i 100 (fx- i 1)])
         ((fx= i 0) #t)
         (let ([ls (map (lambda (x) (random 256)) (make-list (random 25)))])
           (unless (andmap (lambda (b*)
                             (andmap (lambda (b) (eq? b #t)) b*))
                     (let ()
                       (define (sublist ls i j)
                         (list-head (list-tail ls i) j))
                       (define (cmp-vec ls i j)
                         (apply bytevector
                           `(,@(make-list i #xc7)
                             ,@(sublist ls i j)
                             ,@(make-list (fx- (length ls) (+ i j)) #xc7))))
                       (let ([n (length ls)])
                         (let f ([i 0])
                           (if (fx= i n)
                               '()
                               (cons (let g ([j 1])
                                       (if (fx<= j (fx- n i))
                                           (cons* (equal? (let ([v (make-bytevector n #xc7)])
                                                            (bytevector-sint-set!
                                                              v
                                                              i
                                                              (apply little-endian->signed (sublist ls i j))
                                                              'little
                                                              j)
                                                            v)
                                                          (cmp-vec ls i j))
                                                  (equal? (let ([v (make-bytevector n #xc7)])
                                                            (bytevector-sint-set!
                                                              v
                                                              i
                                                              (apply big-endian->signed (sublist ls i j))
                                                              'big
                                                              j)
                                                            v)
                                                          (cmp-vec ls i j))
                                                  (g (fx+ j 1)))
                                           '()))
                                     (f (fx+ i 1))))))))
                   (pretty-print ls)
                   (errorf #f "failed for for ~s" ls)))))

(mat bytevector-uint-set!
     (begin
       (define $v1
         '#vu8(#x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #xff #xff #xff #xff
               #xff #xff #xff #xff #x7f #xff #xff #xff #xff #xff #xff #xff
               #xff #xff #xff #xff #xff #xff #xff #x7f #x80 #x00 #x00 #x00
               #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x80
               #x80 #x00 #x00 #x00 #xff #xff #xff #xff #xff #xff #xff #xff
               #x00 #x00 #x00 #x80 #x12 #x23 #x34 #x45 #x56 #x67 #x78 #x89
               #x89 #x78 #x67 #x56 #x45 #x34 #x23 #x12 #x78 #x89 #x9a #xab
               #xbc #xcd #xde #xef #xef #xde #xcd #xbc #xab #x9a #x89 #x78
               #xfe #xed #xdc #xcb #xba #xa9 #x98))
       (bytevector? $v1))

     ; wrong argument count
     (error? (bytevector-uint-set!))
     (error? (bytevector-uint-set! $v1))
     (error? (bytevector-uint-set! $v1 0))
     (error? (bytevector-uint-set! $v1 0 7))
     (error? (bytevector-uint-set! $v1 0 7 'big))
     (error? (if (bytevector-uint-set! $v1 0 7 'big 5 0) #f #t))

     ; not a bytevector
     (error? (bytevector-uint-set! '#(3 252 5 0 0 0 0 0 0 0 0) 0 7 'little 1))
     (error? (if (bytevector-uint-set!
                   '#(3 252 5 0 0 0 0 0 0 0 0)
                   0
                   7
                   'little
                   1)
                 #f
                 #t))

     ; invalid index
     (error? (bytevector-uint-set! $v1 -1 7 'big 1))
     (error? (bytevector-uint-set! $v1 -1 7 'big 2))
     (error? (bytevector-uint-set! $v1 -1 7 'big 3))
     (error? (bytevector-uint-set! $v1 -1 7 'big 4))
     (error? (bytevector-uint-set! $v1 -1 7 'big 8))
     (error? (bytevector-uint-set! $v1 -1 7 'big 9))
     (error? (if (bytevector-uint-set! $v1 -1 7 'big 10) #f #t))

     (error? (bytevector-uint-set! $v1 96 7 'little 8))
     (error? (bytevector-uint-set! $v1 96 7 'little 9))
     (error? (bytevector-uint-set! $v1 97 7 'big 7))
     (error? (bytevector-uint-set! $v1 98 7 'little 6))
     (error? (bytevector-uint-set! $v1 99 7 'big 5))
     (error? (bytevector-uint-set! $v1 100 7 'big 4))
     (error? (bytevector-uint-set! $v1 100 7 'big 5))
     (error? (bytevector-uint-set! $v1 100 7 'big 8))
     (error? (bytevector-uint-set! $v1 101 7 'big 3))
     (error? (bytevector-uint-set! $v1 101 7 'little 4))
     (error? (bytevector-uint-set! $v1 102 7 'little 2))
     (error? (bytevector-uint-set! $v1 102 7 'big 3))
     (error? (bytevector-uint-set! $v1 103 7 'big 1))
     (error? (bytevector-uint-set! $v1 103 7 'big 2))
     (error? (bytevector-uint-set! $v1 103 7 'big 3))
     (error? (if (bytevector-uint-set! $v1 4.0 7 (native-endianness) 3)
                 #f
                 #t))

     ; invalid value
     (error? (bytevector-uint-set! $v1 0 #x-1 'big 1))
     (error? (bytevector-uint-set! $v1 0 #x-1 'little 1))
     (error? (bytevector-uint-set! $v1 0 #x100 'big 1))
     (error? (bytevector-uint-set! $v1 0 #x100 'little 1))
     (error? (bytevector-uint-set! $v1 0 #x-1 'big 2))
     (error? (bytevector-uint-set! $v1 0 #x-1 'little 2))
     (error? (bytevector-uint-set! $v1 0 #x10000 'big 2))
     (error? (bytevector-uint-set! $v1 0 #x10000 'little 2))
     (error? (bytevector-uint-set! $v1 0 #x-1 'big 3))
     (error? (bytevector-uint-set! $v1 0 #x-1 'little 3))
     (error? (bytevector-uint-set! $v1 0 #x1000000 'big 3))
     (error? (bytevector-uint-set! $v1 0 #x1000000 'little 3))
     (error? (bytevector-uint-set! $v1 0 #x-1 'big 4))
     (error? (bytevector-uint-set! $v1 0 #x-1 'little 4))
     (error? (bytevector-uint-set! $v1 0 #x100000000 'big 4))
     (error? (bytevector-uint-set! $v1 0 #x100000000 'little 4))
     (error? (bytevector-uint-set! $v1 0 #x-1 'big 8))
     (error? (bytevector-uint-set! $v1 0 #x-1 'little 8))
     (error? (bytevector-uint-set! $v1 0 #x10000000000000000 'big 8))
     (error? (bytevector-uint-set! $v1 0 #x10000000000000000 'little 8))
     (error? (bytevector-uint-set! $v1 0 #x-1 'big 10))
     (error? (bytevector-uint-set! $v1 0 #x-1 'little 10))
     (error? (bytevector-uint-set! $v1 0 #x100000000000000000000 'big 10))
     (error? (if (bytevector-uint-set!
                   $v1
                   0
                   #x100000000000000000000
                   'little
                   10)
                 #f
                 #t))

     ; invalid endianness
     (error? (bytevector-uint-set! $v1 0 7 'bonkers 1))
     (error? (bytevector-uint-set! $v1 0 7 'bonkers 2))
     (error? (bytevector-uint-set! $v1 0 7 'bonkers 3))
     (error? (bytevector-uint-set! $v1 0 7 'bonkers 4))
     (error? (bytevector-uint-set! $v1 0 7 'bonkers 8))
     (error? (if (bytevector-uint-set! $v1 0 7 'bonkers 35) #f #t))

     ; invalid size
     (error? (bytevector-uint-set! $v1 0 7 'little 0))
     (error? (bytevector-uint-set! $v1 1 7 'big -1))
     (error? (if (bytevector-uint-set! $v1 4 7 'little 'byte) #f #t))

     ; constant args
     (andmap (lambda (b*) (andmap (lambda (b) (eq? b #t)) b*))
       (let ()
         (define-syntax a
           (lambda (x)
             (define (sublist ls i j)
               (list-head (list-tail ls i) j))
             (define (cmp-vec ls i j)
               (apply bytevector
                 `(,@(make-list i #xc7)
                   ,@(sublist ls i j)
                   ,@(make-list (fx- (length ls) (+ i j)) #xc7))))
             (let* ([ls '(1 254 3)
                        #;
                        '(1 254
                            3
                            252
                            5
                            250
                            7
                            249
                            8
                            248
                            9
                            247
                            10
                            246
                            40
                            216
                            80
                            176
                            100
                            156)] [n (length ls)])
               #`(list #,@(let f ([i 0])
                            (if (fx= i n)
                                '()
                                #`((list #,@(let g ([j 1])
                                              (if (fx<= j (fx- n i))
                                                  #`((equal? (let ([v (make-bytevector #,n #xc7)])
                                                               (bytevector-uint-set!
                                                                 v
                                                                 #,i
                                                                 #,(apply little-endian->unsigned (sublist ls i j))
                                                                 'little
                                                                 #,j)
                                                               v)
                                                             '#,(cmp-vec
                                                                 ls i j))
                                                     (equal? (let ([v (make-bytevector #,n #xc7)])
                                                               (bytevector-uint-set!
                                                                 v
                                                                 #,i
                                                                 #,(apply big-endian->unsigned (sublist ls i j))
                                                                 'big
                                                                 #,j)
                                                               v)
                                                             '#,(cmp-vec
                                                                 ls i j))
                                                     #,@(g (fx+ j 1)))
                                                  '())))
                                   #,@(f (fx+ i 1)))))))))
         a))

     ; nonconstant args
     (do ([i 100 (fx- i 1)])
         ((fx= i 0) #t)
         (let ([ls (map (lambda (x) (random 256)) (make-list (random 25)))])
           (unless (andmap (lambda (b*)
                             (andmap (lambda (b) (eq? b #t)) b*))
                     (let ()
                       (define (sublist ls i j)
                         (list-head (list-tail ls i) j))
                       (define (cmp-vec ls i j)
                         (apply bytevector
                           `(,@(make-list i #xc7)
                             ,@(sublist ls i j)
                             ,@(make-list (fx- (length ls) (+ i j)) #xc7))))
                       (let ([n (length ls)])
                         (let f ([i 0])
                           (if (fx= i n)
                               '()
                               (cons (let g ([j 1])
                                       (if (fx<= j (fx- n i))
                                           (cons* (equal? (let ([v (make-bytevector n #xc7)])
                                                            (bytevector-uint-set!
                                                              v
                                                              i
                                                              (apply little-endian->unsigned (sublist ls i j))
                                                              'little
                                                              j)
                                                            v)
                                                          (cmp-vec ls i j))
                                                  (equal? (let ([v (make-bytevector n #xc7)])
                                                            (bytevector-uint-set!
                                                              v
                                                              i
                                                              (apply big-endian->unsigned (sublist ls i j))
                                                              'big
                                                              j)
                                                            v)
                                                          (cmp-vec ls i j))
                                                  (g (fx+ j 1)))
                                           '()))
                                     (f (fx+ i 1))))))))
                   (pretty-print ls)
                   (errorf #f "failed for for ~s" ls)))))

(mat bytevector-copy
     ; wrong argument count
     (error? (bytevector-copy))
     (error? (if (bytevector-copy #vu8() '#vu8()) #f #t))

     ; not a bytevector
     (error? (bytevector-copy '(a b c)))
     (error? (if (bytevector-copy '(a b c)) #f #t))

     (equal? (bytevector-copy #vu8()) '#vu8())
     (equal? (bytevector-copy #vu8(3 252 5)) '#vu8(3 252 5))
     (let* ([x1 (bytevector 1 2 3)] [x2 (bytevector-copy x1)])
       (and (equal? x2 x1) (not (eq? x2 x1)))))

(mat bytevector-copy!
     (begin
       (define $v1 (bytevector 1 2 3 4))
       (define $v2
         (bytevector 255 254 253 252 251 250 249 248 247))
       (and (bytevector? $v1)
            (bytevector? $v2)
            (eqv? (bytevector-length $v1) 4)
            (eqv? (bytevector-length $v2) 9)))

     ; wrong number of arguments
     (error? (bytevector-copy!))
     (error? (bytevector-copy! $v2))
     (error? (bytevector-copy! $v2 3))
     (error? (bytevector-copy! $v2 3 $v1))
     (error? (bytevector-copy! $v2 3 $v1 1))
     (error? (if (bytevector-copy! $v2 3 $v1 1 2 3) #f #t))

     ; not bytevector
     (error? (bytevector-copy! 0 0 $v2 0 0))
     (error? (if (bytevector-copy! $v1 0 (vector 1 2 3) 0 0) #f #t))

     ; bad index
     (error? (bytevector-copy! $v1 -1 $v2 0 0))
     (error? (bytevector-copy! $v1 0 $v2 -1 0))
     (error? (bytevector-copy! $v1 'a $v2 0 0))
     (error? (bytevector-copy! $v1 0 $v2 0.0 0))
     (error? (bytevector-copy! $v1 (+ (most-positive-fixnum) 1) $v2 0 0))
     (error? (if (bytevector-copy!
                   $v1
                   0
                   $v2
                   (+ (most-positive-fixnum) 1)
                   0)
                 #f
                 #t))

     ; bad count
     (error? (bytevector-copy! $v1 0 $v2 0 -1))
     (error? (bytevector-copy! $v1 0 $v2 0 (+ (most-positive-fixnum) 1)))
     (error? (if (bytevector-copy! $v1 0 $v2 0 'a) #f #t))

     ; beyond end
     (error? (bytevector-copy! $v1 0 $v2 0 5))
     (error? (bytevector-copy! $v2 0 $v1 0 5))
     (error? (bytevector-copy! $v1 1 $v2 0 4))
     (error? (bytevector-copy! $v2 0 $v1 1 4))
     (error? (bytevector-copy! $v1 2 $v2 0 3))
     (error? (bytevector-copy! $v2 0 $v1 2 3))
     (error? (bytevector-copy! $v1 3 $v2 0 2))
     (error? (bytevector-copy! $v2 0 $v1 3 2))
     (error? (bytevector-copy! $v1 4 $v2 0 1))
     (error? (bytevector-copy! $v2 0 $v1 4 1))
     (error? (bytevector-copy! $v2 0 $v1 0 500))
     (error? (if (bytevector-copy! $v2 500 $v1 0 0) #f #t))

     ; make sure no damage done
     (and (bytevector? $v1)
          (bytevector? $v2)
          (equal? $v1 #vu8(1 2 3 4))
          (equal? $v2 #vu8(255 254 253 252 251 250 249 248 247)))

     (begin
       (bytevector-copy! $v2 3 $v1 1 2)
       (and (equal? $v1 #vu8(1 252 251 4))
            (equal? $v2 #vu8(255 254 253 252 251 250 249 248 247))))
     (begin
       (bytevector-copy! $v2 6 $v1 2 2)
       (and (equal? $v1 #vu8(1 252 249 248))
            (equal? $v2 #vu8(255 254 253 252 251 250 249 248 247))))
     (begin
       (bytevector-copy! $v2 0 $v1 4 0)
       (and (equal? $v1 #vu8(1 252 249 248))
            (equal? $v2 #vu8(255 254 253 252 251 250 249 248 247))))
     (begin
       (bytevector-copy! $v2 3 $v1 4 0)
       (and (equal? $v1 #vu8(1 252 249 248))
            (equal? $v2 #vu8(255 254 253 252 251 250 249 248 247))))
     (begin
       (bytevector-copy! $v2 3 $v2 4 0)
       (and (equal? $v1 #vu8(1 252 249 248))
            (equal? $v2 #vu8(255 254 253 252 251 250 249 248 247))))
     (begin
       (bytevector-copy! $v2 2 $v1 1 3)
       (and (equal? $v1 #vu8(1 253 252 251))
            (equal? $v2 #vu8(255 254 253 252 251 250 249 248 247))))
     (begin
       (bytevector-copy! $v1 0 $v2 3 4)
       (and (equal? $v1 #vu8(1 253 252 251))
            (equal? $v2 #vu8(255 254 253 1 253 252 251 248 247))))
     (begin
       (bytevector-copy! $v2 0 $v2 3 5)
       (and (equal? $v1 #vu8(1 253 252 251))
            (equal? $v2 #vu8(255 254 253 255 254 253 1 253 247))))
     (begin
       (bytevector-copy! $v2 4 $v2 2 5)
       (and (equal? $v1 #vu8(1 253 252 251))
            (equal? $v2 #vu8(255 254 254 253 1 253 247 253 247))))
     (begin
       (bytevector-copy! $v2 1 $v2 1 7)
       (and (equal? $v1 #vu8(1 253 252 251))
            (equal? $v2 #vu8(255 254 254 253 1 253 247 253 247)))))

(mat bytevector-truncate!
     (begin
       (define $v (bytevector 1 2 3 4 5 6 7 8 9))
       (and (bytevector? $v)
            (fx= (bytevector-length $v) 9)
            (bytevector=? $v #vu8(1 2 3 4 5 6 7 8 9))))

     ; wrong number of arguments
     (error? (bytevector-truncate!))
     (error? (bytevector-truncate! $v))
     (error? (bytevector-truncate! $v 3 15))

     ; not bytevector
     (error? (bytevector-truncate! 0 0))
     (error? (if (bytevector-truncate! (string #\a #\b #\c) 2) #f #t))

     ; bad length
     (error? (bytevector-truncate! $v -1))
     (error? (bytevector-truncate! $v 10))
     (error? (bytevector-truncate! $v 1000))
     (error? (bytevector-truncate! $v (+ (most-positive-fixnum) 1)))
     (error? (bytevector-truncate! $v 'a))

     (begin
       (bytevector-truncate! $v 9)
       (and (bytevector? $v)
            (fx= (bytevector-length $v) 9)
            (bytevector=? $v #vu8(1 2 3 4 5 6 7 8 9))))

     (begin
       (bytevector-truncate! $v 8)
       (and (bytevector? $v)
            (fx= (bytevector-length $v) 8)
            (bytevector=? $v #vu8(1 2 3 4 5 6 7 8))))

     (begin
       (bytevector-truncate! $v 6)
       (and (bytevector? $v)
            (fx= (bytevector-length $v) 6)
            (bytevector=? $v #vu8(1 2 3 4 5 6))))

     (begin
       (bytevector-truncate! $v 3)
       (and (bytevector? $v)
            (fx= (bytevector-length $v) 3)
            (bytevector=? $v #vu8(1 2 3))))

     (begin
       (define $v2 (bytevector-truncate! $v 0))
       (and (eqv? $v2 #vu8())
            (bytevector? $v)
            (fx= (bytevector-length $v) 3)
            (bytevector=? $v #vu8(1 2 3)))))

(mat bytevector-fill!
     (begin
       (define $v1 (bytevector 1 2 3 4))
       (define $v2
         (bytevector 255 254 253 252 251 250 249 248 247))
       (and (bytevector? $v1)
            (bytevector? $v2)
            (eqv? (bytevector-length $v1) 4)
            (eqv? (bytevector-length $v2) 9)))

     ; wrong argument count
     (error? (bytevector-fill!))
     (error? (bytevector-fill! $v1))
     (error? (begin (bytevector-fill! $v1 0 0) #f))

     ; not a bytevector
     (error? (bytevector-fill! 'a 3))
     (error? (begin (let ([v (vector 1)]) (bytevector-fill! v 3)) #f))

     ; invalid fill
     (error? (bytevector-fill! $v1 -129))
     (error? (bytevector-fill! $v1 256))
     (error? (begin (bytevector-fill! $v1 'a) #f))

     ; make sure no damage done
     (and (bytevector? $v1)
          (bytevector? $v2)
          (equal? $v1 #vu8(1 2 3 4))
          (equal? $v2 #vu8(255 254 253 252 251 250 249 248 247)))

     (begin
       (bytevector-fill! $v1 -128)
       (and (bytevector? $v1)
            (equal? $v1 #vu8(128 128 128 128))))
     (begin
       (bytevector-fill! $v1 -1)
       (and (bytevector? $v1)
            (equal? $v1 #vu8(255 255 255 255))))
     (begin
       (bytevector-fill! $v1 0)
       (and (bytevector? $v1) (equal? $v1 #vu8(0 0 0 0))))
     (begin
       (bytevector-fill! $v1 127)
       (and (bytevector? $v1)
            (equal? $v1 #vu8(127 127 127 127))))
     (begin
       (bytevector-fill! $v1 128)
       (and (bytevector? $v1)
            (equal? $v1 #vu8(128 128 128 128))))
     (begin
       (bytevector-fill! $v1 255)
       (and (bytevector? $v1)
            (equal? $v1 #vu8(255 255 255 255))))
     (begin
       (bytevector-fill! $v2 -128)
       (and (bytevector? $v2)
            (equal? $v2 #vu8(128 128 128 128 128 128 128 128 128))))
     (begin
       (bytevector-fill! $v2 -1)
       (and (bytevector? $v2)
            (equal? $v2 #vu8(255 255 255 255 255 255 255 255 255))))
     (begin
       (bytevector-fill! $v2 0)
       (and (bytevector? $v2)
            (equal? $v2 #vu8(0 0 0 0 0 0 0 0 0))))
     (begin
       (bytevector-fill! $v2 127)
       (and (bytevector? $v2)
            (equal? $v2 #vu8(127 127 127 127 127 127 127 127 127))))
     (begin
       (bytevector-fill! $v2 128)
       (and (bytevector? $v2)
            (equal? $v2 #vu8(128 128 128 128 128 128 128 128 128))))
     (begin
       (bytevector-fill! $v2 255)
       (and (bytevector? $v2)
            (equal? $v2 #vu8(255 255 255 255 255 255 255 255 255))))

     (let ([v (bytevector-copy '#5vu8(1 2 3 4 5))])
       (and (equal? v '#5vu8(1 2 3 4 5))
            (begin
              (bytevector-fill! v 9)
              (equal? v '#5vu8(9)))))
     (let ([v (bytevector-copy '#5vu8(1 2 3 4 5))])
       (and (equal? v '#5vu8(1 2 3 4 5))
            (begin
              (bytevector-fill! v -17)
              (equal? v '#5vu8(239)))))
     (do ([q 10000 (fx- q 1)])
         ((fx= q 0) #t)
         (let ([v (bytevector 3 4 5)])
           (do ([n -128 (fx+ n 1)])
               ((fx= n 128) #t)
               (bytevector-fill! v n)
               (unless (and (eqv? (bytevector-s8-ref v 0) n)
                            (eqv? (bytevector-s8-ref v 1) n)
                            (eqv? (bytevector-s8-ref v 2) n))
                       (errorf #f "wrong value for ~s" n)))))
     (do ([q 10000 (fx- q 1)])
         ((fx= q 0) #t)
         (let ([v (bytevector 3 4 5)])
           (do ([n 0 (fx+ n 1)])
               ((fx= n 255) #t)
               (bytevector-fill! v n)
               (unless (and (eqv? (bytevector-u8-ref v 0) n)
                            (eqv? (bytevector-u8-ref v 1) n)
                            (eqv? (bytevector-u8-ref v 2) n))
                       (errorf #f "wrong value for ~s" n))))))

(mat s8-list->bytevector
     ; wrong argument count
     (error? (s8-list->bytevector))
     (error? (begin (s8-list->bytevector '(1 -2 3) '(1 -2 3)) #t))

     ; not a list
     (error? (s8-list->bytevector '#(a b c)))
     (error? (begin (s8-list->bytevector '#(a b c)) #t))

     ; improper or cyclic list
     (error? (s8-list->bytevector '(1 2 . 3)))
     (error? (s8-list->bytevector
               (let ([ls (list 1 2 3)])
                 (set-cdr! (cddr ls) (cdr ls))
                 ls)))

     ; invalid value
     (error? (s8-list->bytevector '(1 -129 3)))
     (error? (begin (s8-list->bytevector '(1 128 3)) #t))

     (equal? (s8-list->bytevector '(1 -2 3)) #vu8(1 254 3))
     (equal? (s8-list->bytevector '()) #vu8())
     (do ([n -128 (fx+ n 1)])
         ((fx= n 128) #t)
         (let ([v (s8-list->bytevector (list 3 n 4))])
           (unless (and (eqv? (bytevector-s8-ref v 0) 3)
                        (eqv? (bytevector-s8-ref v 1) n)
                        (eqv? (bytevector-s8-ref v 2) 4))
                   (errorf #f "wrong value for ~s" n)))))

(mat u8-list->bytevector
     ; wrong argument count
     (error? (u8-list->bytevector))
     (error? (begin (u8-list->bytevector '(1 2 3) '(1 2 3)) #t))

     ; not a bytevector
     (error? (u8-list->bytevector '#(a b c)))
     (error? (begin (u8-list->bytevector '#(a b c)) #t))

     ; invalid value
     (error? (u8-list->bytevector '(1 -129 3)))
     (error? (begin (u8-list->bytevector '(1 -1 3)) #t))

     ; improper or cyclic list
     (error? (u8-list->bytevector '(1 2 . 3)))
     (error? (u8-list->bytevector
               (let ([ls (list 1 2 3)])
                 (set-cdr! (cddr ls) (cdr ls))
                 ls)))

     (equal? (u8-list->bytevector '(1 2 3)) #vu8(1 2 3))
     (equal? (u8-list->bytevector '()) #vu8())
     (do ([n 0 (fx+ n 1)])
         ((fx= n 255) #t)
         (let ([v (u8-list->bytevector (list 3 n 4))])
           (unless (and (eqv? (bytevector-u8-ref v 0) 3)
                        (eqv? (bytevector-u8-ref v 1) n)
                        (eqv? (bytevector-u8-ref v 2) 4))
                   (errorf #f "wrong value for ~s" n)))))

(mat bytevector->s8-list
     ; wrong argument count
     (error? (bytevector->s8-list))
     (error? (begin (bytevector->s8-list #vu8(1 2 3) '#vu8(1 2 3)) #t))

     ; not a bytevector
     (error? (begin (bytevector->s8-list "hello") #t))
     (error? (bytevector->s8-list '(a b c)))

     (equal? (bytevector->s8-list #vu8(1 255 3)) '(1 -1 3))
     (equal? (bytevector->s8-list #vu8(1 255 253 4)) '(1 -1 -3 4))
     (equal? (bytevector->s8-list #vu8()) '()))

(mat bytevector->u8-list
     ; wrong argument count
     (error? (bytevector->u8-list))
     (error? (begin (bytevector->u8-list #vu8(1 2 3) '#vu8(1 2 3)) #t))

     ; not a bytevector
     (error? (bytevector->u8-list "hello"))
     (error? (begin (bytevector->u8-list '(a b c)) #t))

     (equal? (bytevector->u8-list #vu8(1 2 3)) '(1 2 3))
     (equal? (bytevector->u8-list #vu8(1 255 253 4)) '(1 255 253 4))
     (equal? (bytevector->u8-list #vu8()) '()))

(mat sint-list->bytevector
     ; wrong argument count
     (error? (sint-list->bytevector))
     (error? (sint-list->bytevector '(1 3 7) 'little))
     (error? (begin (sint-list->bytevector '(1 -3 7) 'big 1 0) #t))

     ; not a list
     (error? (sint-list->bytevector '#(a b c) 'little 1))
     (error? (begin (sint-list->bytevector '#(a b c) 'little 1) #t))

     ; improper or cyclic list
     (error? (sint-list->bytevector '(1 2 . 3) 'little 1))
     (error? (sint-list->bytevector
               (let ([ls (list 1 2 3)])
                 (set-cdr! (cddr ls) (cdr ls))
                 ls)
               'little
               1))

     ; invalid value
     (error? (sint-list->bytevector '(0 #x-81 0) 'big 1))
     (error? (sint-list->bytevector '(0 #x-81 0) 'little 1))
     (error? (sint-list->bytevector '(0 #x80 0) (native-endianness) 1))
     (error? (sint-list->bytevector '(0 #x80 0) 'little 1))
     (error? (sint-list->bytevector '(0 #x-8001 0) (native-endianness) 2))
     (error? (sint-list->bytevector '(0 #x-8001 0) 'little 2))
     (error? (sint-list->bytevector '(0 #x8000 0) 'big 2))
     (error? (sint-list->bytevector '(0 #x8000 0) 'little 2))
     (error? (sint-list->bytevector '(0 #x-800001 0) 'big 3))
     (error? (sint-list->bytevector '(0 #x-800001 0) 'little 3))
     (error? (sint-list->bytevector '(0 #x800000 0) 'big 3))
     (error? (sint-list->bytevector '(0 #x800000 0) (native-endianness) 3))
     (error? (sint-list->bytevector '(0 #x-80000001 0) 'big 4))
     (error? (sint-list->bytevector '(0 #x-80000001 0) 'little 4))
     (error? (sint-list->bytevector '(0 #x80000000 0)
               (native-endianness)
               4))
     (error? (sint-list->bytevector '(0 #x80000000 0) 'little 4))
     (error? (sint-list->bytevector '(0 #x-8000000000000001 0) 'big 8))
     (error? (sint-list->bytevector '(0 #x-8000000000000001 0)
               (native-endianness)
               8))
     (error? (sint-list->bytevector '(0 #x8000000000000000 0) 'big 8))
     (error? (sint-list->bytevector '(0 #x8000000000000000 0) 'little 8))
     (error? (sint-list->bytevector '(0 #x-80000000000000000001 0)
               (native-endianness)
               10))
     (error? (sint-list->bytevector '(0 #x-80000000000000000001 0) 'little 10))
     (error? (sint-list->bytevector '(0 #x80000000000000000000 0) 'big 10))
     (error? (begin
               (sint-list->bytevector '(0 #x80000000000000000000 0) 'little 10)
               #t))

     ; invalid endianness
     (error? (sint-list->bytevector
               '(1 3 7 4 3 -3 5 -6 127 -128 -50 50)
               'spam
               1))
     (error? (sint-list->bytevector
               '(1 3 7 4 3 -3 5 -6 127 -128 -50 50)
               'spam
               2))
     (error? (sint-list->bytevector
               '(1 3 7 4 3 -3 5 -6 127 -128 -50 50)
               'spam
               3))
     (error? (sint-list->bytevector
               '(1 3 7 4 3 -3 5 -6 127 -128 -50 50)
               'spam
               4))
     (error? (sint-list->bytevector
               '(1 3 7 4 3 -3 5 -6 127 -128 -50 50)
               'spam
               6))
     (error? (begin
               (sint-list->bytevector
                 '(1 3 7 4 3 -3 5 -6 127 -128 -50 50)
                 'spam
                 12)
               #t))

     ; invalid size
     (error? (sint-list->bytevector
               '(1 3 7 4 3 -3 5 -6 127 -128 -50 50)
               'big
               -1))
     (error? (sint-list->bytevector '(1 3 7 4 3 -3 5 -6 127 -128 -50 50) 'big 0))
     (error? (sint-list->bytevector
               '(1 3 7 4 3 -3 5 -6 127 -128 -50 50)
               'big
               1.0))
     (error? (begin
               (sint-list->bytevector
                 '(1 3 7 4 3 -3 5 -6 127 -128 -50 50)
                 'big
                 "oops")
               #t))

     (equal? (sint-list->bytevector '(#x-1 #x01 #x02 #x-5 #x-80 #x7f) 'little 1)
             #vu8(#xff #x01 #x02 #xfb #x80 #x7f))

     (equal? (sint-list->bytevector '(#x7f #x-80 -5 #x2 #x1 -1) 'big 1)
             #vu8(#x7f #x80 #xfb #x2 #x1 #xff))

     (equal? (sint-list->bytevector '(#x-ff #x2FB #x-7f81) 'big 2)
             #vu8(#xff #x01 #x02 #xfb #x80 #x7f))

     (equal? (sint-list->bytevector
               (list (little-endian->signed #xff 1 3 #xa0)
                     (little-endian->signed #x71 #x82 #x95 #x61)
                     (little-endian->signed #x91 #xa2 #xb5 #xc1)
                     (little-endian->signed 5 2 3 4))
               'little
               4)
             #vu8(#xff #x01 #x03 #xa0 #x71 #x82 #x95 #x61 #x91 #xa2 #xb5
                  #xc1 5 2 3 4))

     (equal? (sint-list->bytevector
               (list (little-endian->signed #xff 1 3 #xa0 #x55)
                     (little-endian->signed #x71 #x82 #x95 #x61 #x85)
                     (little-endian->signed #x91 #xa2 #xb5 #xc1 #x99)
                     (little-endian->signed 5 2 3 4 6))
               'little
               5)
             #vu8(#xff #x01 #x03 #xa0 #x55 #x71 #x82 #x95 #x61 #x85 #x91
                  #xa2 #xb5 #xc1 #x99 5 2 3 4 6))

     (equal? (sint-list->bytevector
               (list (little-endian->signed
                       #xff
                       1
                       3
                       #xa0
                       #x71
                       #x82
                       #x95
                       #x98)
                     (little-endian->signed #x91 #xa2 #xb5 #xc1 5 2 3 4))
               'little
               8)
             #vu8(#xff #x01 #x03 #xa0 #x71 #x82 #x95 #x98 #x91 #xa2 #xb5
                  #xc1 5 2 3 4))

     (do ([q 500 (fx- q 1)])
         ((fx= q 0) #t)
         (do ([i 1 (fx+ i 1)])
             ((fx= i 25))
             (let ([ls* (map (lambda (x)
                               (map (lambda (x) (random 256))
                                    (make-list i)))
                             (make-list (random 10)))])
               (unless (equal? (sint-list->bytevector
                                 (map (lambda (ls)
                                        (apply little-endian->signed ls))
                                      ls*)
                                 'little
                                 i)
                               (apply bytevector (apply append ls*)))
                       (pretty-print ls*)
                       (errorf #f "failed for ~s (little)" ls*))
               (unless (equal? (sint-list->bytevector
                                 (map (lambda (ls)
                                        (apply big-endian->signed ls))
                                      ls*)
                                 'big
                                 i)
                               (apply bytevector (apply append ls*)))
                       (pretty-print ls*)
                       (errorf #f "failed for ~s (big)" ls*))))))

(mat uint-list->bytevector
     ; wrong argument count
     (error? (uint-list->bytevector))
     (error? (uint-list->bytevector '(1 3 7) 'little))
     (error? (begin (uint-list->bytevector '(1 -3 7) 'big 1 0) #t))

     ; not a list
     (error? (uint-list->bytevector '#(a b c) 'little 1))
     (error? (begin (uint-list->bytevector '#(a b c) 'little 1) #t))

     ; improper or cyclic list
     (error? (uint-list->bytevector '(1 2 . 3) 'little 1))
     (error? (uint-list->bytevector
               (let ([ls (list 1 2 3)])
                 (set-cdr! (cddr ls) (cdr ls))
                 ls)
               'little
               1))

     ; invalid value
     (error? (uint-list->bytevector '(0 #x-1 0) 'big 1))
     (error? (uint-list->bytevector '(0 #x-1 0) 'little 1))
     (error? (uint-list->bytevector '(0 #x100 0) (native-endianness) 1))
     (error? (uint-list->bytevector '(0 #x100 0) 'little 1))
     (error? (uint-list->bytevector '(0 x-1 0) (native-endianness) 2))
     (error? (uint-list->bytevector '(0 x-1 0) 'little 2))
     (error? (uint-list->bytevector '(0 #x10000 0) 'big 2))
     (error? (uint-list->bytevector '(0 #x10000 0) 'little 2))
     (error? (uint-list->bytevector '(0 x-1 0) 'big 3))
     (error? (uint-list->bytevector '(0 x-1 0) 'little 3))
     (error? (uint-list->bytevector '(0 #x1000000 0) 'big 3))
     (error? (uint-list->bytevector '(0 #x1000000 0) (native-endianness) 3))
     (error? (uint-list->bytevector '(0 x-1 0) 'big 4))
     (error? (uint-list->bytevector '(0 x-1 0) 'little 4))
     (error? (uint-list->bytevector '(0 #x100000000 0)
               (native-endianness)
               4))
     (error? (uint-list->bytevector '(0 #x100000000 0) 'little 4))
     (error? (uint-list->bytevector '(0 x-1 0) 'big 8))
     (error? (uint-list->bytevector '(0 x-1 0) (native-endianness) 8))
     (error? (uint-list->bytevector '(0 #x10000000000000000 0) 'big 8))
     (error? (uint-list->bytevector '(0 #x10000000000000000 0) 'little 8))
     (error? (uint-list->bytevector '(0 x-1 0) (native-endianness) 10))
     (error? (uint-list->bytevector '(0 x-1 0) 'little 10))
     (error? (uint-list->bytevector '(0 #x100000000000000000000 0) 'big 10))
     (error? (begin
               (uint-list->bytevector '(0 #x100000000000000000000 0) 'little 10)
               #t))

     ; invalid endianness
     (error? (uint-list->bytevector
               '(1 3 7 4 3 -3 5 -6 127 -128 -50 50)
               'spam
               1))
     (error? (uint-list->bytevector
               '(1 3 7 4 3 -3 5 -6 127 -128 -50 50)
               'spam
               2))
     (error? (uint-list->bytevector
               '(1 3 7 4 3 -3 5 -6 127 -128 -50 50)
               'spam
               3))
     (error? (uint-list->bytevector
               '(1 3 7 4 3 -3 5 -6 127 -128 -50 50)
               'spam
               4))
     (error? (uint-list->bytevector
               '(1 3 7 4 3 -3 5 -6 127 -128 -50 50)
               'spam
               6))
     (error? (begin
               (uint-list->bytevector
                 '(1 3 7 4 3 -3 5 -6 127 -128 -50 50)
                 'spam
                 12)
               #t))

     ; invalid size
     (error? (uint-list->bytevector
               '(1 3 7 4 3 -3 5 -6 127 -128 -50 50)
               'big
               -1))
     (error? (uint-list->bytevector '(1 3 7 4 3 -3 5 -6 127 -128 -50 50) 'big 0))
     (error? (uint-list->bytevector
               '(1 3 7 4 3 -3 5 -6 127 -128 -50 50)
               'big
               1.0))
     (error? (begin
               (uint-list->bytevector
                 '(1 3 7 4 3 -3 5 -6 127 -128 -50 50)
                 'big
                 "oops")
               #t))

     (equal? (uint-list->bytevector '(#xff #x01 #x02 #xfb #x80 #x7f) 'little 1)
             #vu8(#xff #x01 #x02 #xfb #x80 #x7f))

     (equal? (uint-list->bytevector '(#x7f #x80 #xfb #x2 #x1 #xff) 'big 1)
             #vu8(#x7f #x80 #xfb #x2 #x1 #xff))

     (equal? (uint-list->bytevector '(#xff01 #x2FB #x807f) 'big 2)
             #vu8(#xff #x01 #x02 #xfb #x80 #x7f))

     (equal? (uint-list->bytevector
               (list (little-endian->unsigned #xff 1 3 #xa0)
                     (little-endian->unsigned #x71 #x82 #x95 #x61)
                     (little-endian->unsigned #x91 #xa2 #xb5 #xc1)
                     (little-endian->unsigned 5 2 3 4))
               'little
               4)
             #vu8(#xff #x01 #x03 #xa0 #x71 #x82 #x95 #x61 #x91 #xa2 #xb5
                  #xc1 5 2 3 4))

     (equal? (uint-list->bytevector
               (list (little-endian->unsigned #xff 1 3 #xa0 #x55)
                     (little-endian->unsigned #x71 #x82 #x95 #x61 #x85)
                     (little-endian->unsigned #x91 #xa2 #xb5 #xc1 #x99)
                     (little-endian->unsigned 5 2 3 4 6))
               'little
               5)
             #vu8(#xff #x01 #x03 #xa0 #x55 #x71 #x82 #x95 #x61 #x85 #x91
                  #xa2 #xb5 #xc1 #x99 5 2 3 4 6))

     (equal? (uint-list->bytevector
               (list (little-endian->unsigned
                       #xff
                       1
                       3
                       #xa0
                       #x71
                       #x82
                       #x95
                       #x98)
                     (little-endian->unsigned #x91 #xa2 #xb5 #xc1 5 2 3 4))
               'little
               8)
             #vu8(#xff #x01 #x03 #xa0 #x71 #x82 #x95 #x98 #x91 #xa2 #xb5
                  #xc1 5 2 3 4))

     (do ([q 500 (fx- q 1)])
         ((fx= q 0) #t)
         (do ([i 1 (fx+ i 1)])
             ((fx= i 25))
             (let ([ls* (map (lambda (x)
                               (map (lambda (x) (random 256))
                                    (make-list i)))
                             (make-list (random 10)))])
               (unless (equal? (uint-list->bytevector
                                 (map (lambda (ls)
                                        (apply little-endian->unsigned ls))
                                      ls*)
                                 'little
                                 i)
                               (apply bytevector (apply append ls*)))
                       (pretty-print ls*)
                       (errorf #f "failed for ~s (little)" ls*))
               (unless (equal? (uint-list->bytevector
                                 (map (lambda (ls)
                                        (apply big-endian->unsigned ls))
                                      ls*)
                                 'big
                                 i)
                               (apply bytevector (apply append ls*)))
                       (pretty-print ls*)
                       (errorf #f "failed for ~s (big)" ls*))))))

(mat bytevector->sint-list
     ; wrong argument count
     (error? (bytevector->sint-list))
     (error? (bytevector->sint-list #vu8(1 3 7) 'little))
     (error? (begin (bytevector->sint-list #vu8(1 253 7) 'big 1 0) #t))

     ; not a bytevector
     (error? (bytevector->sint-list '#(a b c) 'little 1))
     (error? (begin (bytevector->sint-list '#(a b c) 'little 1) #t))

     ; invalid endianness
     (error? (bytevector->sint-list
               #vu8(1 3 7 4 3 253 5 250 127 128 206 50)
               'spam
               1))
     (error? (bytevector->sint-list
               #vu8(1 3 7 4 3 253 5 250 127 128 206 50)
               'spam
               2))
     (error? (bytevector->sint-list
               #vu8(1 3 7 4 3 253 5 250 127 128 206 50)
               'spam
               3))
     (error? (bytevector->sint-list
               #vu8(1 3 7 4 3 253 5 250 127 128 206 50)
               'spam
               4))
     (error? (bytevector->sint-list
               #vu8(1 3 7 4 3 253 5 250 127 128 206 50)
               'spam
               6))
     (error? (begin
               (bytevector->sint-list
                 #vu8(1 3 7 4 3 253 5 250 127 128 206 50)
                 'spam
                 12)
               #t))

     ; invalid size
     (error? (bytevector->sint-list
               #vu8(1 3 7 4 3 253 5 250 127 128 206 50)
               'big
               -1))
     (error? (bytevector->sint-list
               #vu8(1 3 7 4 3 253 5 250 127 128 206 50)
               'big
               0))
     (error? (bytevector->sint-list
               #vu8(1 3 7 4 3 253 5 250 127 128 206 50)
               'big
               1.0))
     (error? (begin
               (bytevector->sint-list
                 #vu8(1 3 7 4 3 253 5 250 127 128 206 50)
                 'big
                 "oops")
               #t))

     ; length not multiple of size
     (error? (bytevector->sint-list
               #vu8(1 3 7 4 3 253 5 250 127 128 206 50)
               'big
               5))
     (error? (bytevector->sint-list
               #vu8(1 3 7 4 3 253 5 250 127 128 206 50)
               'little
               7))
     (error? (bytevector->sint-list
               #vu8(1 3 7 4 3 253 5 250 127 128 206 50)
               'big
               8))
     (error? (bytevector->sint-list
               #vu8(1 3 7 4 3 253 5 250 127 128 206 50)
               (native-endianness)
               9))
     (error? (bytevector->sint-list
               #vu8(1 3 7 4 3 253 5 250 127 128 206 50)
               'big
               10))
     (error? (bytevector->sint-list
               #vu8(1 3 7 4 3 253 5 250 127 128 206 50)
               'little
               11))
     (error? (begin
               (bytevector->sint-list
                 #vu8(1 3 7 4 3 253 5 250 127 128 206 50)
                 (native-endianness)
                 50)
               #t))

     (equal? (bytevector->sint-list
               #vu8(#xff #x01 #x02 #xfb #x80 #x7f)
               'little
               1)
             '(#x-1 #x01 #x02 #x-5 #x-80 #x7f))

     (equal? (bytevector->sint-list #vu8(#x7f #x80 #xfb #x2 #x1 #xff) 'big 1)
             '(#x7f #x-80 -5 #x2 #x1 -1))

     (equal? (bytevector->sint-list #vu8(#xff #x01 #x02 #xfb #x80 #x7f) 'big 2)
             '(#x-ff #x2FB #x-7f81))

     (equal? (bytevector->sint-list
               #vu8(#xff #x01 #x03 #xa0 #x71 #x82 #x95 #x61 #x91 #xa2 #xb5
                    #xc1 5 2 3 4)
               'little
               4)
             (list (little-endian->signed #xff 1 3 #xa0)
                   (little-endian->signed #x71 #x82 #x95 #x61)
                   (little-endian->signed #x91 #xa2 #xb5 #xc1)
                   (little-endian->signed 5 2 3 4)))

     (equal? (bytevector->sint-list
               #vu8(#xff #x01 #x03 #xa0 #x55 #x71 #x82 #x95 #x61 #x85 #x91
                    #xa2 #xb5 #xc1 #x99 5 2 3 4 6)
               'little
               5)
             (list (little-endian->signed #xff 1 3 #xa0 #x55)
                   (little-endian->signed #x71 #x82 #x95 #x61 #x85)
                   (little-endian->signed #x91 #xa2 #xb5 #xc1 #x99)
                   (little-endian->signed 5 2 3 4 6)))

     (equal? (bytevector->sint-list
               #vu8(#xff #x01 #x03 #xa0 #x71 #x82 #x95 #x98 #x91 #xa2 #xb5
                    #xc1 5 2 3 4)
               'little
               8)
             (list (little-endian->signed
                     #xff
                     1
                     3
                     #xa0
                     #x71
                     #x82
                     #x95
                     #x98)
                   (little-endian->signed #x91 #xa2 #xb5 #xc1 5 2 3 4)))

     (do ([q 500 (fx- q 1)])
         ((fx= q 0) #t)
         (do ([i 1 (fx+ i 1)])
             ((fx= i 25))
             (let ([ls* (map (lambda (x)
                               (map (lambda (x) (random 256))
                                    (make-list i)))
                             (make-list (random 10)))])
               (unless (equal? (bytevector->sint-list
                                 (apply bytevector (apply append ls*))
                                 'little
                                 i)
                               (map (lambda (ls)
                                      (apply little-endian->signed ls))
                                    ls*))
                       (pretty-print ls*)
                       (errorf #f "failed for ~s (little)" ls*))
               (unless (equal? (bytevector->sint-list
                                 (apply bytevector (apply append ls*))
                                 'big
                                 i)
                               (map (lambda (ls)
                                      (apply big-endian->signed ls))
                                    ls*))
                       (pretty-print ls*)
                       (errorf #f "failed for ~s (big)" ls*))))))

(mat bytevector->uint-list
     ; wrong argument count
     (error? (bytevector->uint-list))
     (error? (bytevector->uint-list #vu8(1 3 7) 'little))
     (error? (begin (bytevector->uint-list #vu8(1 253 7) 'big 1 0) #t))

     ; not a bytevector
     (error? (bytevector->uint-list '#(a b c) 'little 1))
     (error? (begin (bytevector->uint-list '#(a b c) 'little 1) #t))

     ; invalid endianness
     (error? (bytevector->uint-list
               #vu8(1 3 7 4 3 253 5 250 127 128 206 50)
               'spam
               1))
     (error? (bytevector->uint-list
               #vu8(1 3 7 4 3 253 5 250 127 128 206 50)
               'spam
               2))
     (error? (bytevector->uint-list
               #vu8(1 3 7 4 3 253 5 250 127 128 206 50)
               'spam
               3))
     (error? (bytevector->uint-list
               #vu8(1 3 7 4 3 253 5 250 127 128 206 50)
               'spam
               4))
     (error? (bytevector->uint-list
               #vu8(1 3 7 4 3 253 5 250 127 128 206 50)
               'spam
               6))
     (error? (begin
               (bytevector->uint-list
                 #vu8(1 3 7 4 3 253 5 250 127 128 206 50)
                 'spam
                 12)
               #t))

     ; invalid size
     (error? (bytevector->uint-list
               #vu8(1 3 7 4 3 253 5 250 127 128 206 50)
               'big
               -1))
     (error? (bytevector->uint-list
               #vu8(1 3 7 4 3 253 5 250 127 128 206 50)
               'big
               0))
     (error? (bytevector->uint-list
               #vu8(1 3 7 4 3 253 5 250 127 128 206 50)
               'big
               1.0))
     (error? (begin
               (bytevector->uint-list
                 #vu8(1 3 7 4 3 253 5 250 127 128 206 50)
                 'big
                 "oops")
               #t))

     ; length not multiple of size
     (error? (bytevector->uint-list
               #vu8(1 3 7 4 3 253 5 250 127 128 206 50)
               'big
               5))
     (error? (bytevector->uint-list
               #vu8(1 3 7 4 3 253 5 250 127 128 206 50)
               'little
               7))
     (error? (bytevector->uint-list
               #vu8(1 3 7 4 3 253 5 250 127 128 206 50)
               'big
               8))
     (error? (bytevector->uint-list
               #vu8(1 3 7 4 3 253 5 250 127 128 206 50)
               (native-endianness)
               9))
     (error? (bytevector->uint-list
               #vu8(1 3 7 4 3 253 5 250 127 128 206 50)
               'big
               10))
     (error? (bytevector->uint-list
               #vu8(1 3 7 4 3 253 5 250 127 128 206 50)
               'little
               11))
     (error? (begin
               (bytevector->uint-list
                 #vu8(1 3 7 4 3 253 5 250 127 128 206 50)
                 (native-endianness)
                 50)
               #t))

     (equal? (bytevector->uint-list
               #vu8(#xff #x01 #x02 #xfb #x80 #x7f)
               'little
               1)
             '(#xff #x01 #x02 #xfb #x80 #x7f))

     (equal? (bytevector->uint-list #vu8(#x7f #x80 #xfb #x2 #x1 #xff) 'big 1)
             '(#x7f #x80 #xfb #x2 #x1 #xff))

     (equal? (bytevector->uint-list #vu8(#xff #x01 #x02 #xfb #x80 #x7f) 'big 2)
             '(#xff01 #x2FB #x807f))

     (equal? (bytevector->uint-list
               #vu8(#xff #x01 #x03 #xa0 #x71 #x82 #x95 #x61 #x91 #xa2 #xb5
                    #xc1 5 2 3 4)
               'little
               4)
             (list (little-endian->unsigned #xff 1 3 #xa0)
                   (little-endian->unsigned #x71 #x82 #x95 #x61)
                   (little-endian->unsigned #x91 #xa2 #xb5 #xc1)
                   (little-endian->unsigned 5 2 3 4)))

     (equal? (bytevector->uint-list
               #vu8(#xff #x01 #x03 #xa0 #x55 #x71 #x82 #x95 #x61 #x85 #x91
                    #xa2 #xb5 #xc1 #x99 5 2 3 4 6)
               'little
               5)
             (list (little-endian->unsigned #xff 1 3 #xa0 #x55)
                   (little-endian->unsigned #x71 #x82 #x95 #x61 #x85)
                   (little-endian->unsigned #x91 #xa2 #xb5 #xc1 #x99)
                   (little-endian->unsigned 5 2 3 4 6)))

     (equal? (bytevector->uint-list
               #vu8(#xff #x01 #x03 #xa0 #x71 #x82 #x95 #x98 #x91 #xa2 #xb5
                    #xc1 5 2 3 4)
               'little
               8)
             (list (little-endian->unsigned
                     #xff
                     1
                     3
                     #xa0
                     #x71
                     #x82
                     #x95
                     #x98)
                   (little-endian->unsigned #x91 #xa2 #xb5 #xc1 5 2 3 4)))

     (do ([q 500 (fx- q 1)])
         ((fx= q 0) #t)
         (do ([i 1 (fx+ i 1)])
             ((fx= i 25))
             (let ([ls* (map (lambda (x)
                               (map (lambda (x) (random 256))
                                    (make-list i)))
                             (make-list (random 10)))])
               (unless (equal? (bytevector->uint-list
                                 (apply bytevector (apply append ls*))
                                 'little
                                 i)
                               (map (lambda (ls)
                                      (apply little-endian->unsigned ls))
                                    ls*))
                       (pretty-print ls*)
                       (errorf #f "failed for ~s (little)" ls*))
               (unless (equal? (bytevector->uint-list
                                 (apply bytevector (apply append ls*))
                                 'big
                                 i)
                               (map (lambda (ls)
                                      (apply big-endian->unsigned ls))
                                    ls*))
                       (pretty-print ls*)
                       (errorf #f "failed for ~s (big)" ls*))))))

(mat bytevector=?
     ; wrong argument count
     (error? (bytevector=?))
     (error? (bytevector=? #vu8()))
     (error? (begin (bytevector=? #vu8() '#vu8() '#vu8()) #t))

     ; not a bytevector
     (error? (bytevector=? #vu8() 'a))
     (error? (begin (bytevector=? "a" #vu8()) #t))

     (bytevector=? #vu8() (bytevector))
     (bytevector=? #vu8() (make-bytevector 0))
     (bytevector=? #vu8() (make-bytevector 0 17))
     (bytevector=? #vu8() (make-bytevector 0 -17))
     (not (bytevector=? #vu8() (bytevector 1)))
     (not (bytevector=? #vu8() (make-bytevector 1)))
     (not (bytevector=? #vu8() (make-bytevector 1 17)))
     (not (bytevector=? #vu8() (make-bytevector 1 -17)))
     (bytevector=? #vu8(1 2 3 4) (bytevector 1 2 3 4))
     (not (bytevector=? #vu8(1 2 3 4) (bytevector 1 2 4 3)))
     (not (bytevector=? #vu8(1 2 3 4) (bytevector 1 2 3)))
     (not (bytevector=? #vu8(1 2 3 4) (bytevector 1 2)))
     (not (bytevector=? #vu8(1 2 3 4) (bytevector 1)))
     (not (bytevector=? #vu8(1 2 3 4) (bytevector)))
     (bytevector=? (bytevector 255 254 253) (bytevector -1 -2 -3))
     (do ([n 1 (fx+ n 1)])
         ((fx= n 1000) #t)
         (let* ([v1 (u8-list->bytevector
                      (map (lambda (x) (random 256))
                           (make-list n)))]
                [v2 (bytevector-copy v1)])
           (when (eq? v1 v2)
                 (errorf #f "copy is eq to original"))
           (unless (bytevector=? v1 v2)
                   (pretty-print v1)
                   (errorf #f
                           "first bytevector=? failed for ~s (see output for vector)"
                           n))
           (do ([i 0 (fx+ i 1)])
               ((fx= i n))
               (let ([k (bytevector-u8-ref v2 i)])
                 (bytevector-u8-set! v2 i (fxmodulo (fx+ k 1) 256))
                 (when (bytevector=? v1 v2)
                       (pretty-print v1)
                       (pretty-print v2)
                       (errorf #f
                               "second bytevector=? failed for n=~s and i=~s (see output for vector)"
                               n
                               i))
                 (bytevector-u8-set! v2 i k))
               (unless (bytevector=? v1 v2)
                       (pretty-print v1)
                       (errorf #f
                               "third bytevector=? failed for n=~s and i=~s (see output for vector)"
                               n
                               i))))))

(mat r6rs-bytevector-examples
     (equal? (let ([b (u8-list->bytevector '(1 2 3 4 5 6 7 8))])
               (bytevector-copy! b 0 b 3 4)
               (bytevector->u8-list b))
             '(1 2 3 1 2 3 4 8))


     (equal? (let ([b1 (make-bytevector 16 -127)]
                   [b2 (make-bytevector 16 255)])
               (list (bytevector-s8-ref b1 0)
                     (bytevector-u8-ref b1 0)
                     (bytevector-s8-ref b2 0)
                     (bytevector-u8-ref b2 0)))
             '(-127 129 -1 255))

     (equal? (let ([b (make-bytevector 16 -127)])
               (bytevector-s8-set! b 0 -126)
               (bytevector-u8-set! b 1 246)
               (list (bytevector-s8-ref b 0)
                     (bytevector-u8-ref b 0)
                     (bytevector-s8-ref b 1)
                     (bytevector-u8-ref b 1)))
             '(-126 130 -10 246))

     (begin
       (define $bv (make-bytevector 16 -127))
       (bytevector? $bv))

     (eqv? (begin
             (bytevector-uint-set!
               $bv
               0
               (- (expt 2 128) 3)
               (endianness little)
               16)
             (bytevector-uint-ref $bv 0 (endianness little) 16))
           #xfffffffffffffffffffffffffffffffd)

     (eqv? (bytevector-sint-ref $bv 0 (endianness little) 16) -3)

     (equal? (bytevector->u8-list $bv)
       '(253 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255))

     (eqv? (begin
             (bytevector-uint-set!
               $bv
               0
               (- (expt 2 128) 3)
               (endianness big)
               16)
             (bytevector-uint-ref $bv 0 (endianness big) 16))
           #xfffffffffffffffffffffffffffffffd)

     (eqv? (bytevector-sint-ref $bv 0 (endianness big) 16) -3)

     (equal? (bytevector->u8-list $bv)
       '(255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 253))

     (equal? (let ([b (u8-list->bytevector '(1 2 3 255 1 2 1 2))])
               (bytevector->sint-list b (endianness little) 2))
             '(513 -253 513 513))

     (equal? (let ([b (u8-list->bytevector '(1 2 3 255 1 2 1 2))])
               (bytevector->uint-list b (endianness little) 2))
             '(513 65283 513 513))

     (begin
       (define $bv
         (u8-list->bytevector
           '(255 255
                 255
                 255
                 255
                 255
                 255
                 255
                 255
                 255
                 255
                 255
                 255
                 255
                 255
                 253)))
       (bytevector? $bv))

     (eqv? (bytevector-u16-ref $bv 14 (endianness little)) 65023)
     (eqv? (bytevector-s16-ref $bv 14 (endianness little)) -513)
     (eqv? (bytevector-u16-ref $bv 14 (endianness big)) 65533)
     (eqv? (bytevector-s16-ref $bv 14 (endianness big)) -3)

     (eqv? (begin
             (bytevector-u16-set! $bv 0 12345 (endianness little))
             (bytevector-u16-ref $bv 0 (endianness little)))
           12345)

     (eqv? (begin
             (bytevector-u16-native-set! $bv 0 12345)
             (bytevector-u16-native-ref $bv 0))
           12345)

     (and (memv (bytevector-u16-ref $bv 0 (endianness little))
                '(12345 14640))
          #t)

     (begin
       (define $bv
         (u8-list->bytevector
           '(255 255
                 255
                 255
                 255
                 255
                 255
                 255
                 255
                 255
                 255
                 255
                 255
                 255
                 255
                 253)))
       (bytevector? $bv))

     (eqv? (bytevector-u32-ref $bv 12 (endianness little)) 4261412863)
     (eqv? (bytevector-s32-ref $bv 12 (endianness little)) -33554433)
     (eqv? (bytevector-u32-ref $bv 12 (endianness big)) 4294967293)
     (eqv? (bytevector-s32-ref $bv 12 (endianness big)) -3)

     (begin
       (define $bv
         (u8-list->bytevector
           '(255 255
                 255
                 255
                 255
                 255
                 255
                 255
                 255
                 255
                 255
                 255
                 255
                 255
                 255
                 253)))
       (bytevector? $bv))

     (eqv? (bytevector-u64-ref $bv 8 (endianness little))
           '18302628885633695743)
     (eqv? (bytevector-s64-ref $bv 8 (endianness little))
           '-144115188075855873)
     (eqv? (bytevector-u64-ref $bv 8 (endianness big))
           '18446744073709551613)
     (eqv? (bytevector-s64-ref $bv 8 (endianness big)) '-3))

(mat refimpl-tests
     ; rkd: the following tests are adapted from the bytevector reference
     ; implementation tests bytevector-tests.sch, which is:
     ; Copyright 2007 William D Clinger.
     ;
     ; Permission to copy this software, in whole or in part, to use this
     ; software for any lawful purpose, and to redistribute this software
     ; is granted subject to the restriction that all copies made of this
     ; software must include this copyright notice in full.
     ;
     ; I also request that you send me a copy of any improvements that you
     ; make to this software so that they may be incorporated within it to
     ; the benefit of the Scheme community.

     ; rkd: commented out some tests (look for "rkd") because they are
     ; implementation-dependent or require non-R6RS functionality or behavior.
     (begin
       ; rkd: writing code to a file first to get useful file positions for errors
       (with-output-to-file "testfile-bytevector.ss"
         (lambda ()
           (pretty-print
             '(define (bytevector-refimpl-tests)
                (define *random-stress-tests* 100)
                (define *random-stress-test-max-size* 50)

                ; rkd: rewrote to support for our test infrastructure
                (define okay? #t)
                (define-syntax test
                  (syntax-rules (=> error)
                    ((test exp => result)
                     (guard (c [#t (display-condition c)
                                   (newline)
                                   (set! okay? #f)])
                            (unless (equal? exp 'result)
                                    (syntax-error #'exp "failed"))))))

                (define (basic-bytevector-tests)
                  (test (endianness big) => big)
                  (test (endianness little) => little)

                  (test (or (eq? (native-endianness) 'big)
                            (eq? (native-endianness) 'little))
                        =>
                        #t)

                  (test (bytevector? (vector)) => #f)
                  (test (bytevector? (make-bytevector 3)) => #t)

                  (test (bytevector-length (make-bytevector 44)) => 44)

                  (test (let ((b1 (make-bytevector 16 -127))
                              (b2 (make-bytevector 16 255)))
                          (list (bytevector-s8-ref b1 0)
                                (bytevector-u8-ref b1 0)
                                (bytevector-s8-ref b2 0)
                                (bytevector-u8-ref b2 0)))
                        =>
                        (-127 129 -1 255))

                  (test (let ((b (make-bytevector 16 -127)))
                          (bytevector-s8-set! b 0 -126)
                          (bytevector-u8-set! b 1 246)
                          (list (bytevector-s8-ref b 0)
                                (bytevector-u8-ref b 0)
                                (bytevector-s8-ref b 1)
                                (bytevector-u8-ref b 1)))
                        =>
                        (-126 130 -10 246))

                  (let ()
                    (define b (make-bytevector 16 -127))
                    (bytevector-uint-set!
                      b
                      0
                      (- (expt 2 128) 3)
                      (endianness little)
                      16)

                    (test (bytevector-uint-ref b 0 (endianness little) 16)
                          =>
                          #xfffffffffffffffffffffffffffffffd)

                    (test (bytevector-sint-ref b 0 (endianness little) 16)
                          =>
                          -3)

                    (test (bytevector->u8-list b)
                          =>
                          (253 255
                               255
                               255
                               255
                               255
                               255
                               255
                               255
                               255
                               255
                               255
                               255
                               255
                               255
                               255))

                    (bytevector-uint-set!
                      b
                      0
                      (- (expt 2 128) 3)
                      (endianness big)
                      16)

                    (test (bytevector-uint-ref b 0 (endianness big) 16)
                          =>
                          #xfffffffffffffffffffffffffffffffd)

                    (test (bytevector-sint-ref b 0 (endianness big) 16) => -3)

                    (test (bytevector->u8-list b)
                          =>
                          (255 255
                               255
                               255
                               255
                               255
                               255
                               255
                               255
                               255
                               255
                               255
                               255
                               255
                               255
                               253)))

                  (let ()
                    (define b
                      (u8-list->bytevector
                        '(255 255
                              255
                              255
                              255
                              255
                              255
                              255
                              255
                              255
                              255
                              255
                              255
                              255
                              255
                              253)))

                    (test (bytevector-u16-ref b 14 (endianness little))
                          =>
                          65023)

                    (test (bytevector-s16-ref b 14 (endianness little)) => -513)

                    (test (bytevector-u16-ref b 14 (endianness big)) => 65533)

                    (test (bytevector-s16-ref b 14 (endianness big)) => -3)

                    (bytevector-u16-set! b 0 12345 (endianness little))

                    (test (bytevector-u16-ref b 0 (endianness little)) => 12345)

                    (bytevector-u16-native-set! b 0 12345)

                    (test (bytevector-u16-native-ref b 0) => 12345))

                  (let ()
                    (define b
                      (u8-list->bytevector
                        '(255 255
                              255
                              255
                              255
                              255
                              255
                              255
                              255
                              255
                              255
                              255
                              255
                              255
                              255
                              253)))

                    (test (bytevector-u32-ref b 12 (endianness little))
                          =>
                          4261412863)

                    (test (bytevector-s32-ref b 12 (endianness little))
                          =>
                          -33554433)

                    (test (bytevector-u32-ref b 12 (endianness big))
                          =>
                          4294967293)

                    (test (bytevector-s32-ref b 12 (endianness big)) => -3))

                  (let ()
                    (define b
                      (u8-list->bytevector
                        '(255 255
                              255
                              255
                              255
                              255
                              255
                              255
                              255
                              255
                              255
                              255
                              255
                              255
                              255
                              253)))

                    (test (bytevector-u64-ref b 8 (endianness little))
                          =>
                          18302628885633695743)

                    (test (bytevector-s64-ref b 8 (endianness little))
                          =>
                          -144115188075855873)

                    (test (bytevector-u64-ref b 8 (endianness big))
                          =>
                          18446744073709551613)

                    (test (bytevector-s64-ref b 8 (endianness big)) => -3))

                  (let ()
                    (define b1
                      (u8-list->bytevector '(255 2 254 3 255)))
                    (define b2
                      (u8-list->bytevector '(255 3 254 2 255)))
                    (define b3
                      (u8-list->bytevector '(255 3 254 2 255)))
                    (define b4
                      (u8-list->bytevector '(255 3 255)))

                    (test (bytevector=? b1 b2) => #f)
                    (test (bytevector=? b2 b3) => #t)
                    (test (bytevector=? b3 b4) => #f)
                    (test (bytevector=? b4 b3) => #f))

                  (let ()
                    (define b
                      (u8-list->bytevector '(63 240 0 0 0 0 0 0)))

                    (test (bytevector-ieee-single-ref b 4 'little) => 0.0)

                    (test (bytevector-ieee-double-ref b 0 'big) => 1.0)

                    (bytevector-ieee-single-native-set! b 4 3.0)

                    (test (bytevector-ieee-single-native-ref b 4) => 3.0)

                    (bytevector-ieee-double-native-set! b 0 5.0)

                    (test (bytevector-ieee-double-native-ref b 0) => 5.0)

                    (bytevector-ieee-double-set! b 0 1.75 'big)

                    (test (bytevector->u8-list b) => (63 252 0 0 0 0 0 0)))

                  (let ((b (make-bytevector 7 12)))
                    (bytevector-fill! b 127)
                    (test (bytevector->u8-list b)
                          =>
                          (127 127 127 127 127 127 127)))

                  (let ((b (u8-list->bytevector '(1 2 3 4 5 6 7 8))))
                    (bytevector-copy! b 0 b 3 4)
                    (test (bytevector->u8-list b) => (1 2 3 1 2 3 4 8))
                    (test (bytevector=? b (bytevector-copy b)) => #t))

                  (let ((b (u8-list->bytevector '(1 2 3 255 1 2 1 2))))
                    (test (bytevector->sint-list b (endianness little) 2) => (513 -253 513 513))
                    (test (bytevector->uint-list b (endianness little) 2) => (513 65283 513 513))))

                (define (ieee-bytevector-tests)

                  (define (roundtrip x getter setter! k endness)
                    (let ((b (make-bytevector 100)))
                      (setter! b k x endness)
                      (getter b k endness)))

                  (define (->single x)
                    (roundtrip
                      x
                      bytevector-ieee-single-ref
                      bytevector-ieee-single-set!
                      0
                      'big))

                  (define (->double x)
                    (roundtrip
                      x
                      bytevector-ieee-double-ref
                      bytevector-ieee-double-set!
                      0
                      'big))

                  ; Single precision, offset 0, big-endian

                  (test (roundtrip
                          +inf.0
                          bytevector-ieee-single-ref
                          bytevector-ieee-single-set!
                          0
                          'big)
                        =>
                        +inf.0)

                  (test (roundtrip
                          -inf.0
                          bytevector-ieee-single-ref
                          bytevector-ieee-single-set!
                          0
                          'big)
                        =>
                        -inf.0)

                  (test (let ((x (roundtrip
                                   +nan.0
                                   bytevector-ieee-single-ref
                                   bytevector-ieee-single-set!
                                   0
                                   'big)))
                          (= x x))
                        =>
                        #f)

                  (test (roundtrip
                          1e10
                          bytevector-ieee-single-ref
                          bytevector-ieee-single-set!
                          0
                          'big)
                        =>
                        1e10)

                  (test (roundtrip
                          -0.2822580337524414
                          bytevector-ieee-single-ref
                          bytevector-ieee-single-set!
                          0
                          'big)
                        =>
                        -0.2822580337524414)

                  ; Single precision, offset 0, little-endian

                  (test (roundtrip
                          +inf.0
                          bytevector-ieee-single-ref
                          bytevector-ieee-single-set!
                          0
                          'little)
                        =>
                        +inf.0)

                  (test (roundtrip
                          -inf.0
                          bytevector-ieee-single-ref
                          bytevector-ieee-single-set!
                          0
                          'little)
                        =>
                        -inf.0)

                  (test (let ((x (roundtrip
                                   +nan.0
                                   bytevector-ieee-single-ref
                                   bytevector-ieee-single-set!
                                   0
                                   'little)))
                          (= x x))
                        =>
                        #f)

                  (test (roundtrip
                          1e10
                          bytevector-ieee-single-ref
                          bytevector-ieee-single-set!
                          0
                          'little)
                        =>
                        1e10)

                  (test (roundtrip
                          -0.2822580337524414
                          bytevector-ieee-single-ref
                          bytevector-ieee-single-set!
                          0
                          'little)
                        =>
                        -0.2822580337524414)

                  ; Single precision, offset 1, big-endian

                  (test (roundtrip
                          +inf.0
                          bytevector-ieee-single-ref
                          bytevector-ieee-single-set!
                          1
                          'big)
                        =>
                        +inf.0)

                  (test (roundtrip
                          -inf.0
                          bytevector-ieee-single-ref
                          bytevector-ieee-single-set!
                          1
                          'big)
                        =>
                        -inf.0)

                  (test (let ((x (roundtrip
                                   +nan.0
                                   bytevector-ieee-single-ref
                                   bytevector-ieee-single-set!
                                   1
                                   'big)))
                          (= x x))
                        =>
                        #f)

                  (test (roundtrip
                          1e10
                          bytevector-ieee-single-ref
                          bytevector-ieee-single-set!
                          1
                          'big)
                        =>
                        1e10)

                  (test (roundtrip
                          -0.2822580337524414
                          bytevector-ieee-single-ref
                          bytevector-ieee-single-set!
                          1
                          'big)
                        =>
                        -0.2822580337524414)

                  ; Single precision, offset 1, little-endian

                  (test (roundtrip
                          +inf.0
                          bytevector-ieee-single-ref
                          bytevector-ieee-single-set!
                          1
                          'little)
                        =>
                        +inf.0)

                  (test (roundtrip
                          -inf.0
                          bytevector-ieee-single-ref
                          bytevector-ieee-single-set!
                          1
                          'little)
                        =>
                        -inf.0)

                  (test (let ((x (roundtrip
                                   +nan.0
                                   bytevector-ieee-single-ref
                                   bytevector-ieee-single-set!
                                   1
                                   'little)))
                          (= x x))
                        =>
                        #f)

                  (test (roundtrip
                          1e10
                          bytevector-ieee-single-ref
                          bytevector-ieee-single-set!
                          1
                          'little)
                        =>
                        1e10)

                  (test (roundtrip
                          -0.2822580337524414
                          bytevector-ieee-single-ref
                          bytevector-ieee-single-set!
                          1
                          'little)
                        =>
                        -0.2822580337524414)

                  ; Single precision, offset 2, big-endian

                  (test (roundtrip
                          +inf.0
                          bytevector-ieee-single-ref
                          bytevector-ieee-single-set!
                          2
                          'big)
                        =>
                        +inf.0)

                  (test (roundtrip
                          -inf.0
                          bytevector-ieee-single-ref
                          bytevector-ieee-single-set!
                          2
                          'big)
                        =>
                        -inf.0)

                  (test (let ((x (roundtrip
                                   +nan.0
                                   bytevector-ieee-single-ref
                                   bytevector-ieee-single-set!
                                   2
                                   'big)))
                          (= x x))
                        =>
                        #f)

                  (test (roundtrip
                          1e10
                          bytevector-ieee-single-ref
                          bytevector-ieee-single-set!
                          2
                          'big)
                        =>
                        1e10)

                  (test (roundtrip
                          -0.2822580337524414
                          bytevector-ieee-single-ref
                          bytevector-ieee-single-set!
                          2
                          'big)
                        =>
                        -0.2822580337524414)

                  ; Single precision, offset 2, little-endian

                  (test (roundtrip
                          +inf.0
                          bytevector-ieee-single-ref
                          bytevector-ieee-single-set!
                          2
                          'little)
                        =>
                        +inf.0)

                  (test (roundtrip
                          -inf.0
                          bytevector-ieee-single-ref
                          bytevector-ieee-single-set!
                          2
                          'little)
                        =>
                        -inf.0)

                  (test (let ((x (roundtrip
                                   +nan.0
                                   bytevector-ieee-single-ref
                                   bytevector-ieee-single-set!
                                   2
                                   'little)))
                          (= x x))
                        =>
                        #f)

                  (test (roundtrip
                          1e10
                          bytevector-ieee-single-ref
                          bytevector-ieee-single-set!
                          2
                          'little)
                        =>
                        1e10)

                  (test (roundtrip
                          -0.2822580337524414
                          bytevector-ieee-single-ref
                          bytevector-ieee-single-set!
                          2
                          'little)
                        =>
                        -0.2822580337524414)

                  ; Single precision, offset 3, big-endian

                  (test (roundtrip
                          +inf.0
                          bytevector-ieee-single-ref
                          bytevector-ieee-single-set!
                          3
                          'big)
                        =>
                        +inf.0)

                  (test (roundtrip
                          -inf.0
                          bytevector-ieee-single-ref
                          bytevector-ieee-single-set!
                          3
                          'big)
                        =>
                        -inf.0)

                  (test (let ((x (roundtrip
                                   +nan.0
                                   bytevector-ieee-single-ref
                                   bytevector-ieee-single-set!
                                   3
                                   'big)))
                          (= x x))
                        =>
                        #f)

                  (test (roundtrip
                          1e10
                          bytevector-ieee-single-ref
                          bytevector-ieee-single-set!
                          3
                          'big)
                        =>
                        1e10)

                  (test (roundtrip
                          -0.2822580337524414
                          bytevector-ieee-single-ref
                          bytevector-ieee-single-set!
                          3
                          'big)
                        =>
                        -0.2822580337524414)

                  ; Single precision, offset 3, little-endian

                  (test (roundtrip
                          +inf.0
                          bytevector-ieee-single-ref
                          bytevector-ieee-single-set!
                          3
                          'little)
                        =>
                        +inf.0)

                  (test (roundtrip
                          -inf.0
                          bytevector-ieee-single-ref
                          bytevector-ieee-single-set!
                          3
                          'little)
                        =>
                        -inf.0)

                  (test (let ((x (roundtrip
                                   +nan.0
                                   bytevector-ieee-single-ref
                                   bytevector-ieee-single-set!
                                   3
                                   'little)))
                          (= x x))
                        =>
                        #f)

                  (test (roundtrip
                          1e10
                          bytevector-ieee-single-ref
                          bytevector-ieee-single-set!
                          3
                          'little)
                        =>
                        1e10)

                  (test (roundtrip
                          -0.2822580337524414
                          bytevector-ieee-single-ref
                          bytevector-ieee-single-set!
                          3
                          'little)
                        =>
                        -0.2822580337524414)

                  ; Double precision, offset 0, big-endian

                  (test (roundtrip
                          +inf.0
                          bytevector-ieee-double-ref
                          bytevector-ieee-double-set!
                          0
                          'big)
                        =>
                        +inf.0)

                  (test (roundtrip
                          -inf.0
                          bytevector-ieee-double-ref
                          bytevector-ieee-double-set!
                          0
                          'big)
                        =>
                        -inf.0)

                  (test (let ((x (roundtrip
                                   +nan.0
                                   bytevector-ieee-double-ref
                                   bytevector-ieee-double-set!
                                   0
                                   'big)))
                          (= x x))
                        =>
                        #f)

                  (test (roundtrip
                          1e10
                          bytevector-ieee-double-ref
                          bytevector-ieee-double-set!
                          0
                          'big)
                        =>
                        1e10)

                  (test (roundtrip
                          -0.2822580337524414
                          bytevector-ieee-double-ref
                          bytevector-ieee-double-set!
                          0
                          'big)
                        =>
                        -0.2822580337524414)

                  ; Double precision, offset 0, little-endian

                  (test (roundtrip
                          +inf.0
                          bytevector-ieee-double-ref
                          bytevector-ieee-double-set!
                          0
                          'little)
                        =>
                        +inf.0)

                  (test (roundtrip
                          -inf.0
                          bytevector-ieee-double-ref
                          bytevector-ieee-double-set!
                          0
                          'little)
                        =>
                        -inf.0)

                  (test (let ((x (roundtrip
                                   +nan.0
                                   bytevector-ieee-double-ref
                                   bytevector-ieee-double-set!
                                   0
                                   'little)))
                          (= x x))
                        =>
                        #f)

                  (test (roundtrip
                          1e10
                          bytevector-ieee-double-ref
                          bytevector-ieee-double-set!
                          0
                          'little)
                        =>
                        1e10)

                  (test (roundtrip
                          -0.2822580337524414
                          bytevector-ieee-double-ref
                          bytevector-ieee-double-set!
                          0
                          'little)
                        =>
                        -0.2822580337524414)

                  ; Double precision, offset 1, big-endian

                  (test (roundtrip
                          +inf.0
                          bytevector-ieee-double-ref
                          bytevector-ieee-double-set!
                          1
                          'big)
                        =>
                        +inf.0)

                  (test (roundtrip
                          -inf.0
                          bytevector-ieee-double-ref
                          bytevector-ieee-double-set!
                          1
                          'big)
                        =>
                        -inf.0)

                  (test (let ((x (roundtrip
                                   +nan.0
                                   bytevector-ieee-double-ref
                                   bytevector-ieee-double-set!
                                   1
                                   'big)))
                          (= x x))
                        =>
                        #f)

                  (test (roundtrip
                          1e10
                          bytevector-ieee-double-ref
                          bytevector-ieee-double-set!
                          1
                          'big)
                        =>
                        1e10)

                  (test (roundtrip
                          -0.2822580337524414
                          bytevector-ieee-double-ref
                          bytevector-ieee-double-set!
                          1
                          'big)
                        =>
                        -0.2822580337524414)

                  ; Double precision, offset 1, little-endian

                  (test (roundtrip
                          +inf.0
                          bytevector-ieee-double-ref
                          bytevector-ieee-double-set!
                          1
                          'little)
                        =>
                        +inf.0)

                  (test (roundtrip
                          -inf.0
                          bytevector-ieee-double-ref
                          bytevector-ieee-double-set!
                          1
                          'little)
                        =>
                        -inf.0)

                  (test (let ((x (roundtrip
                                   +nan.0
                                   bytevector-ieee-double-ref
                                   bytevector-ieee-double-set!
                                   1
                                   'little)))
                          (= x x))
                        =>
                        #f)

                  (test (roundtrip
                          1e10
                          bytevector-ieee-double-ref
                          bytevector-ieee-double-set!
                          1
                          'little)
                        =>
                        1e10)

                  (test (roundtrip
                          -0.2822580337524414
                          bytevector-ieee-double-ref
                          bytevector-ieee-double-set!
                          1
                          'little)
                        =>
                        -0.2822580337524414)

                  ; Double precision, offset 2, big-endian

                  (test (roundtrip
                          +inf.0
                          bytevector-ieee-double-ref
                          bytevector-ieee-double-set!
                          2
                          'big)
                        =>
                        +inf.0)

                  (test (roundtrip
                          -inf.0
                          bytevector-ieee-double-ref
                          bytevector-ieee-double-set!
                          2
                          'big)
                        =>
                        -inf.0)

                  (test (let ((x (roundtrip
                                   +nan.0
                                   bytevector-ieee-double-ref
                                   bytevector-ieee-double-set!
                                   2
                                   'big)))
                          (= x x))
                        =>
                        #f)

                  (test (roundtrip
                          1e10
                          bytevector-ieee-double-ref
                          bytevector-ieee-double-set!
                          2
                          'big)
                        =>
                        1e10)

                  (test (roundtrip
                          -0.2822580337524414
                          bytevector-ieee-double-ref
                          bytevector-ieee-double-set!
                          2
                          'big)
                        =>
                        -0.2822580337524414)

                  ; Double precision, offset 2, little-endian

                  (test (roundtrip
                          +inf.0
                          bytevector-ieee-double-ref
                          bytevector-ieee-double-set!
                          2
                          'little)
                        =>
                        +inf.0)

                  (test (roundtrip
                          -inf.0
                          bytevector-ieee-double-ref
                          bytevector-ieee-double-set!
                          2
                          'little)
                        =>
                        -inf.0)

                  (test (let ((x (roundtrip
                                   +nan.0
                                   bytevector-ieee-double-ref
                                   bytevector-ieee-double-set!
                                   2
                                   'little)))
                          (= x x))
                        =>
                        #f)

                  (test (roundtrip
                          1e10
                          bytevector-ieee-double-ref
                          bytevector-ieee-double-set!
                          2
                          'little)
                        =>
                        1e10)

                  (test (roundtrip
                          -0.2822580337524414
                          bytevector-ieee-double-ref
                          bytevector-ieee-double-set!
                          2
                          'little)
                        =>
                        -0.2822580337524414)

                  ; Double precision, offset 3, big-endian

                  (test (roundtrip
                          +inf.0
                          bytevector-ieee-double-ref
                          bytevector-ieee-double-set!
                          3
                          'big)
                        =>
                        +inf.0)

                  (test (roundtrip
                          -inf.0
                          bytevector-ieee-double-ref
                          bytevector-ieee-double-set!
                          3
                          'big)
                        =>
                        -inf.0)

                  (test (let ((x (roundtrip
                                   +nan.0
                                   bytevector-ieee-double-ref
                                   bytevector-ieee-double-set!
                                   3
                                   'big)))
                          (= x x))
                        =>
                        #f)

                  (test (roundtrip
                          1e10
                          bytevector-ieee-double-ref
                          bytevector-ieee-double-set!
                          3
                          'big)
                        =>
                        1e10)

                  (test (roundtrip
                          -0.2822580337524414
                          bytevector-ieee-double-ref
                          bytevector-ieee-double-set!
                          3
                          'big)
                        =>
                        -0.2822580337524414)

                  ; Double precision, offset 3, little-endian

                  (test (roundtrip
                          +inf.0
                          bytevector-ieee-double-ref
                          bytevector-ieee-double-set!
                          3
                          'little)
                        =>
                        +inf.0)

                  (test (roundtrip
                          -inf.0
                          bytevector-ieee-double-ref
                          bytevector-ieee-double-set!
                          3
                          'little)
                        =>
                        -inf.0)

                  (test (let ((x (roundtrip
                                   +nan.0
                                   bytevector-ieee-double-ref
                                   bytevector-ieee-double-set!
                                   3
                                   'little)))
                          (= x x))
                        =>
                        #f)

                  (test (roundtrip
                          1e10
                          bytevector-ieee-double-ref
                          bytevector-ieee-double-set!
                          3
                          'little)
                        =>
                        1e10)

                  (test (roundtrip
                          -0.2822580337524414
                          bytevector-ieee-double-ref
                          bytevector-ieee-double-set!
                          3
                          'little)
                        =>
                        -0.2822580337524414)

                  ; Denormalized numbers.

                  (do ((x (expt .5 100) (* .5 x)))
                      ((= x 0.0))
                      (let ((y (->single x)))
                        (test (or (= y 0.0) (= x y)) => #t)))

                  (do ((x (expt .5 100) (* .5 x)))
                      ((= x 0.0))
                      (let ((y (->double x)))
                        (test (= x y) => #t))))

                (define (string-bytevector-tests)

                  ; rkd: rewrote to support for our test infrastructure
                  (define-syntax test-roundtrip
                    (syntax-rules ()
                      [(_ bvec tostring tobvec)
                       (let* ((s1 (tostring bvec))
                              (b2 (tobvec s1))
                              (s2 (tostring b2)))
                         (test (string=? s1 s2) => #t))]))

                  (define random
                    (letrec ((random14 (lambda (n)
                                         (set! x
                                           (remainder (+ (* a x) c) (+ m 1)))
                                         (remainder (quotient x 8) n)))
                             (a 701)
                             (x 1)
                             (c 743483)
                             (m 524287)
                             (loop (lambda (q r n)
                                     (if (zero? q)
                                         (remainder r n)
                                         (loop (quotient q 16384)
                                               (+ (* 16384 r) (random14 16384))
                                               n)))))
                      (lambda (n)
                        (if (< n 16384)
                            (random14 n)
                            (loop (quotient n 16384) (random14 16384) n)))))

                  ; Returns a random bytevector of length up to n.

                  (define (random-bytevector n)
                    (let* ((n (random n)) (bv (make-bytevector n)))
                      (do ((i 0 (+ i 1)))
                          ((= i n) bv)
                          (bytevector-u8-set! bv i (random 256)))))

                  ; Returns a random bytevector of even length up to n.

                  (define (random-bytevector2 n)
                    (let* ((n (random n))
                           (n (if (odd? n) (+ n 1) n))
                           (bv (make-bytevector n)))
                      (do ((i 0 (+ i 1)))
                          ((= i n) bv)
                          (bytevector-u8-set! bv i (random 256)))))

                  ; Returns a random bytevector of multiple-of-4 length up to n.

                  (define (random-bytevector4 n)
                    (let* ((n (random n))
                           (n (* 4 (round (/ n 4))))
                           (bv (make-bytevector n)))
                      (do ((i 0 (+ i 1)))
                          ((= i n) bv)
                          (bytevector-u8-set! bv i (random 256)))))

                  (test (bytevector=?
                          (string->utf8
                            "k\x007f;\x0080;\x07ff;\x0800;\xffff;")
                          '#vu8(#x6b #x7f #b11000010 #b10000000 #b11011111
                                #b10111111 #b11100000 #b10100000 #b10000000
                                #b11101111 #b10111111 #b10111111))
                        =>
                        #t)

                  (test (bytevector=? (string->utf8 "\x010000;\x10ffff;")
                          '#vu8(#b11110000 #b10010000 #b10000000 #b10000000
                                #b11110100 #b10001111 #b10111111 #b10111111))
                        =>
                        #t)

                  (test (string=? (utf8->string
                                    '#vu8(#x61 ; a
                                          #xc0 #x62 ; ?b
                                          #xc1 #x63 ; ?c
                                          #xc2 #x64 ; ?d
                                          #x80 #x65 ; ?e
                                          #xc0 #xc0 #x66 ; ??f
                                          #xe0 #x67 ; ?g
                                          
                                          ))
                                  "a\xfffd;b\xfffd;c\xfffd;d\xfffd;e\xfffd;\xfffd;f\xfffd;g")
                        =>
                        #t)

                  #;
                  ; rkd: implementation dependent number of replacement characters
                  (test (string=? (utf8->string
                                    '#vu8(#xe0 #x80 #x80 #x68 ; ???h
                                          #xe0 #xc0 #x80 #x69 ; ???i
                                          #xf0 #x6a ; ?j
                                          
                                          ))
                                  "\xfffd;\xfffd;\xfffd;h\xfffd;\xfffd;\xfffd;i\xfffd;j")
                        =>
                        #t)

                  #;
                  ; rkd: implementation dependent number of replacement characters
                  (test (string=? (utf8->string
                                    '#vu8(#x61 ; a
                                          #xf0 #x80 #x80 #x80 #x62 ; ????b
                                          #xf0 #x90 #x80 #x80 #x63 ; .c
                                          
                                          ))
                                  "a\xfffd;\xfffd;\xfffd;\xfffd;b\x10000;c")
                        =>
                        #t)

                  (test (string=? (utf8->string
                                    '#vu8(#x61 ; a
                                          #xf0 #xbf #xbf #xbf #x64 ; .d
                                          #xf0 #xbf #xbf #x65 ; ?e
                                          #xf0 #xbf #x66 ; ?f
                                          
                                          ))
                                  "a\x3ffff;d\xfffd;e\xfffd;f")
                        =>
                        #t)

                  #;
                  ; rkd: implementation dependent number of replacement characters
                  (test (string=? (utf8->string
                                    '#vu8(#x61 ; a
                                          #xf4 #x8f #xbf #xbf #x62 ; .b
                                          #xf4 #x90 #x80 #x80 #x63 ; ????c
                                          
                                          ))

                                  "a\x10ffff;b\xfffd;\xfffd;\xfffd;\xfffd;c")
                        =>
                        #t)

                  (test (string=? (utf8->string
                                    '#vu8(#x61 ; a
                                          #xf5 #x80 #x80 #x80 #x64 ; ????d
                                          
                                          ))

                                  "a\xfffd;\xfffd;\xfffd;\xfffd;d")
                        =>
                        #t)

                  ; ignores BOM signature

                  (test (string=? (utf8->string
                                    '#vu8(#xef #xbb #xbf #x61 #x62 #x63 #x64))
                                  "abcd")
                        =>
                        #t)

                  (test-roundtrip
                    (random-bytevector 10)
                    utf8->string
                    string->utf8)

                  (do ((i 0 (+ i 1)))
                      ((= i *random-stress-tests*))
                      (test-roundtrip
                        (random-bytevector *random-stress-test-max-size*)
                        utf8->string
                        string->utf8))

                  (test (bytevector=?
                          (string->utf16
                            "k\x007f;\x0080;\x07ff;\x0800;\xffff;")
                          '#vu8(#x00 #x6b #x00 #x7f #x00 #x80 #x07 #xff #x08
                                #x00 #xff #xff))
                        =>
                        #t)

                  (test (bytevector=?
                          (string->utf16
                            "k\x007f;\x0080;\x07ff;\x0800;\xffff;"
                            'little)
                          '#vu8(#x6b #x00 #x7f #x00 #x80 #x00 #xff #x07 #x00
                                #x08 #xff #xff))
                        =>
                        #t)

                  (test (bytevector=?
                          (string->utf16 "\x010000;\xfdcba;\x10ffff;")
                          '#vu8(#xd8 #x00 #xdc #x00 #xdb #xb7 #xdc #xba #xdb
                                #xff #xdf #xff))
                        =>
                        #t)

                  (test (bytevector=?
                          (string->utf16
                            "\x010000;\xfdcba;\x10ffff;"
                            'little)
                          '#vu8(#x00 #xd8 #x00 #xdc #xb7 #xdb #xba #xdc #xff
                                #xdb #xff #xdf))
                        =>
                        #t)

                  (test (bytevector=?
                          (string->utf16 "ab\x010000;\xfdcba;\x10ffff;cd")
                          (string->utf16
                            "ab\x010000;\xfdcba;\x10ffff;cd"
                            'big))
                        =>
                        #t)

                  #;
                  ; rkd: utf16->string requires endianness argument
                  (test (string=? "k\x007f;\x0080;\x07ff;\x0800;\xffff;"
                                  (utf16->string
                                    '#vu8(#x00 #x6b #x00 #x7f #x00 #x80 #x07
                                          #xff #x08 #x00 #xff #xff)))
                        =>
                        #t)

                  (test (string=? "k\x007f;\x0080;\x07ff;\x0800;\xffff;"
                                  (utf16->string
                                    '#vu8(#x00 #x6b #x00 #x7f #x00 #x80 #x07
                                          #xff #x08 #x00 #xff #xff)
                                    'big))
                        =>
                        #t)

                  #;
                  ; rkd: utf16->string requires endianness argument
                  (test (string=? "k\x007f;\x0080;\x07ff;\x0800;\xffff;"
                          (utf16->string
                            '#vu8(#xfe #xff ; big-endian BOM
                                  #x00 #x6b #x00 #x7f #x00 #x80 #x07 #xff
                                  #x08 #x00 #xff #xff)))
                        =>
                        #t)

                  (test (string=? "k\x007f;\x0080;\x07ff;\x0800;\xffff;"
                          (utf16->string
                            '#vu8(#x6b #x00 #x7f #x00 #x80 #x00 #xff #x07
                                  #x00 #x08 #xff #xff)
                            'little))
                        =>
                        #t)

                  #;
                  ; rkd: utf16->string requires endianness argument
                  (test (string=? "k\x007f;\x0080;\x07ff;\x0800;\xffff;"
                          (utf16->string
                            '#vu8(#xff #xfe ; little-endian BOM
                                  #x6b #x00 #x7f #x00 #x80 #x00 #xff #x07
                                  #x00 #x08 #xff #xff)))
                        =>
                        #t)

                  (let ((tostring utf16->string)
                        (tostring-big
                          (lambda (bv)
                            (utf16->string bv 'big)))
                        (tostring-little
                          (lambda (bv)
                            (utf16->string bv 'little)))
                        (tobvec string->utf16)
                        (tobvec-big (lambda (s) (string->utf16 s 'big)))
                        (tobvec-little
                          (lambda (s)
                            (string->utf16 s 'little))))

                    (do ((i 0 (+ i 1)))
                        ((= i *random-stress-tests*))
                        #;
                        ; rkd: utf16->string requires endianness argument
                        (test-roundtrip
                          (random-bytevector2 *random-stress-test-max-size*)
                          tostring
                          tobvec)
                        (test-roundtrip
                          (random-bytevector2 *random-stress-test-max-size*)
                          tostring-big
                          tobvec-big)
                        (test-roundtrip
                          (random-bytevector2 *random-stress-test-max-size*)
                          tostring-little
                          tobvec-little)))

                  (test (bytevector=? (string->utf32 "abc")
                          '#vu8(#x00 #x00 #x00 #x61 #x00 #x00 #x00 #x62 #x00
                                #x00 #x00 #x63))
                        =>
                        #t)

                  (test (bytevector=? (string->utf32 "abc" 'big)
                          '#vu8(#x00 #x00 #x00 #x61 #x00 #x00 #x00 #x62 #x00
                                #x00 #x00 #x63))
                        =>
                        #t)

                  (test (bytevector=? (string->utf32 "abc" 'little)
                          '#vu8(#x61 #x00 #x00 #x00 #x62 #x00 #x00 #x00 #x63
                                #x00 #x00 #x00))
                        =>
                        #t)

                  #;
                  ; rkd: utf32->string requires endianness argument
                  (test (string=? "a\xfffd;b\xfffd;c\xfffd;d\xfffd;e"
                          (utf32->string
                            '#vu8(#x00 #x00 #x00 #x61 #x00 #x00 #xd9 #x00
                                  #x00 #x00 #x00 #x62 #x00 #x00 #xdd #xab
                                  #x00 #x00 #x00 #x63 #x00 #x11 #x00 #x00
                                  #x00 #x00 #x00 #x64 #x01 #x00 #x00 #x65
                                  #x00 #x00 #x00 #x65)))
                        =>
                        #t)

                  (test (string=? "a\xfffd;b\xfffd;c\xfffd;d\xfffd;e"
                          (utf32->string
                            '#vu8(#x00 #x00 #x00 #x61 #x00 #x00 #xd9 #x00
                                  #x00 #x00 #x00 #x62 #x00 #x00 #xdd #xab
                                  #x00 #x00 #x00 #x63 #x00 #x11 #x00 #x00
                                  #x00 #x00 #x00 #x64 #x01 #x00 #x00 #x65
                                  #x00 #x00 #x00 #x65)
                            'big))
                        =>
                        #t)

                  #;
                  ; rkd: utf32->string requires endianness argument
                  (test (string=? "a\xfffd;b\xfffd;c\xfffd;d\xfffd;e"
                          (utf32->string
                            '#vu8(#x00 #x00 #xfe #xff ; big-endian BOM
                                  #x00 #x00 #x00 #x61 #x00 #x00 #xd9 #x00
                                  #x00 #x00 #x00 #x62 #x00 #x00 #xdd #xab
                                  #x00 #x00 #x00 #x63 #x00 #x11 #x00 #x00
                                  #x00 #x00 #x00 #x64 #x01 #x00 #x00 #x65
                                  #x00 #x00 #x00 #x65)))
                        =>
                        #t)

                  (test (string=? "\xfeff;a\xfffd;b\xfffd;c\xfffd;d\xfffd;e"
                          (utf32->string
                            '#vu8(#x00 #x00 #xfe #xff ; big-endian BOM
                                  #x00 #x00 #x00 #x61 #x00 #x00 #xd9 #x00
                                  #x00 #x00 #x00 #x62 #x00 #x00 #xdd #xab
                                  #x00 #x00 #x00 #x63 #x00 #x11 #x00 #x00
                                  #x00 #x00 #x00 #x64 #x01 #x00 #x00 #x65
                                  #x00 #x00 #x00 #x65)
                            'big
                            ; rkd: added endianness-manditory? flag
                            #t))
                        =>
                        #t)

                  (test (string=? "a\xfffd;b\xfffd;c\xfffd;d\xfffd;e"
                          (utf32->string
                            '#vu8(#x61 #x00 #x00 #x00 #x00 #xd9 #x00 #x00
                                  #x62 #x00 #x00 #x00 #xab #xdd #x00 #x00
                                  #x63 #x00 #x00 #x00 #x00 #x00 #x11 #x00
                                  #x64 #x00 #x00 #x00 #x65 #x00 #x00 #x01
                                  #x65 #x00 #x00 #x00)
                            'little))
                        =>
                        #t)

                  #;
                  ; rkd: utf32->string requires endianness argument
                  (test (string=? "a\xfffd;b\xfffd;c\xfffd;d\xfffd;e"
                          (utf32->string
                            '#vu8(#xff #xfe #x00 #x00 ; little-endian BOM
                                  #x61 #x00 #x00 #x00 #x00 #xd9 #x00 #x00
                                  #x62 #x00 #x00 #x00 #xab #xdd #x00 #x00
                                  #x63 #x00 #x00 #x00 #x00 #x00 #x11 #x00
                                  #x64 #x00 #x00 #x00 #x65 #x00 #x00 #x01
                                  #x65 #x00 #x00 #x00)))
                        =>
                        #t)

                  (test (string=? "\xfeff;a\xfffd;b\xfffd;c\xfffd;d\xfffd;e"
                          (utf32->string
                            '#vu8(#xff #xfe #x00 #x00 ; little-endian BOM
                                  #x61 #x00 #x00 #x00 #x00 #xd9 #x00 #x00
                                  #x62 #x00 #x00 #x00 #xab #xdd #x00 #x00
                                  #x63 #x00 #x00 #x00 #x00 #x00 #x11 #x00
                                  #x64 #x00 #x00 #x00 #x65 #x00 #x00 #x01
                                  #x65 #x00 #x00 #x00)
                            'little
                            ; rkd: added endianness-manditory? flag
                            #t))
                        =>
                        #t)

                  (let ((tostring utf32->string)
                        (tostring-big
                          (lambda (bv)
                            (utf32->string bv 'big)))
                        (tostring-little
                          (lambda (bv)
                            (utf32->string bv 'little)))
                        (tobvec string->utf32)
                        (tobvec-big (lambda (s) (string->utf32 s 'big)))
                        (tobvec-little
                          (lambda (s)
                            (string->utf32 s 'little))))

                    (do ((i 0 (+ i 1)))
                        ((= i *random-stress-tests*))
                        #;
                        ; rkd: utf32->string requires endianness argument
                        (test-roundtrip
                          (random-bytevector4 *random-stress-test-max-size*)
                          tostring
                          tobvec)
                        (test-roundtrip
                          (random-bytevector4 *random-stress-test-max-size*)
                          tostring-big
                          tobvec-big)
                        (test-roundtrip
                          (random-bytevector4 *random-stress-test-max-size*)
                          tostring-little
                          tobvec-little)))
                  )

                ; Tests string <-> bytevector conversion on strings
                ; that contain every Unicode scalar value.
                (define (exhaustive-string-bytevector-tests)

                  ; Tests throughout an inclusive range.

                  (define (test-char-range lo hi tostring tobytevector)
                    (let* ((n (+ 1 (- hi lo)))
                           (s (make-string n))
                           (replacement-character (integer->char #xfffd)))
                      (do ((i lo (+ i 1)))
                          ((> i hi))
                          (let ((c (if (or (<= 0 i #xd7ff)
                                           (<= #xe000 i #x10ffff))
                                       (integer->char i)
                                       replacement-character)))
                            (string-set! s (- i lo) c)))
                      (test (string=? (tostring (tobytevector s)) s) => #t)))

                  (define (test-exhaustively name tostring tobytevector)
                    (display "Testing ")
                    (display name)
                    (display " conversions...")
                    (newline)
                    (test-char-range 0 #xffff tostring tobytevector)
                    (test-char-range #x10000 #x1ffff tostring tobytevector)
                    (test-char-range #x20000 #x2ffff tostring tobytevector)
                    (test-char-range #x30000 #x3ffff tostring tobytevector)
                    (test-char-range #x40000 #x4ffff tostring tobytevector)
                    (test-char-range #x50000 #x5ffff tostring tobytevector)
                    (test-char-range #x60000 #x6ffff tostring tobytevector)
                    (test-char-range #x70000 #x7ffff tostring tobytevector)
                    (test-char-range #x80000 #x8ffff tostring tobytevector)
                    (test-char-range #x90000 #x9ffff tostring tobytevector)
                    (test-char-range #xa0000 #xaffff tostring tobytevector)
                    (test-char-range #xb0000 #xbffff tostring tobytevector)
                    (test-char-range #xc0000 #xcffff tostring tobytevector)
                    (test-char-range #xd0000 #xdffff tostring tobytevector)
                    (test-char-range #xe0000 #xeffff tostring tobytevector)
                    (test-char-range #xf0000 #xfffff tostring tobytevector)
                    (test-char-range
                      #x100000
                      #x10ffff
                      tostring
                      tobytevector))

                  ; Feel free to replace this with your favorite timing macro.

                  (define (timeit x) x)

                  (timeit (test-exhaustively
                            "UTF-8"
                            utf8->string
                            string->utf8))

                  #;
                  ; rkd: utf16->string requires endianness argument
                  (timeit (test-exhaustively
                            "UTF-16"
                            utf16->string
                            string->utf16))

                  (timeit (test-exhaustively "UTF-16BE"
                            (lambda (bv) (utf16->string bv 'big))
                            (lambda (s) (string->utf16 s 'big))))

                  (timeit (test-exhaustively "UTF-16LE"
                            (lambda (bv) (utf16->string bv 'little))
                            (lambda (s) (string->utf16 s 'little))))

                  #;
                  ; rkd: utf32->string requires endianness argument
                  (timeit (test-exhaustively
                            "UTF-32"
                            utf32->string
                            string->utf32))

                  (timeit (test-exhaustively "UTF-32BE"
                            (lambda (bv) (utf32->string bv 'big))
                            (lambda (s) (string->utf32 s 'big))))

                  (timeit (test-exhaustively "UTF-32LE"
                            (lambda (bv) (utf32->string bv 'little))
                            (lambda (s) (string->utf32 s 'little)))))

                (basic-bytevector-tests)
                (ieee-bytevector-tests)
                (string-bytevector-tests)
                (exhaustive-string-bytevector-tests)
                okay?)))
         'replace)
       #t)
     (begin (load "testfile-bytevector.ss") #t)
     (bytevector-refimpl-tests))

(mat tspl/csug-examples
     (equal? '#vu8(1 2 3) #vu8(1 2 3))
     (equal? #vu8(1 2 3) #vu8(1 2 3))
     (equal? #vu8(#x3f #x7f #xbf #xff) #vu8(63 127 191 255))
     (equal? (endianness little) 'little)
     (equal? (endianness big) 'big)
     (error? (endianness "spam"))
     (equal? (symbol? (native-endianness)) #t)
     (equal? (bytevector? #vu8()) #t)
     (equal? (bytevector? '#()) #f)
     (equal? (bytevector? "abc") #f)
     (equal? (bytevector) #vu8())
     (equal? (bytevector 1 3 5) #vu8(1 3 5))
     (equal? (bytevector -1 -3 -5) #vu8(255 253 251))
     (equal? (make-bytevector 0) #vu8())
     (equal? (make-bytevector 0 7) #vu8())
     (equal? (make-bytevector 5 7) #vu8(7 7 7 7 7))
     (equal? (make-bytevector 5 -7) #vu8(249 249 249 249 249))
     (equal? (bytevector-length #vu8()) 0)
     (equal? (bytevector-length #vu8(1 2 3)) 3)
     (equal? (bytevector-length (make-bytevector 300)) 300)
     (equal? (bytevector=? #vu8() #vu8()) #t)
     (equal? (bytevector=? (make-bytevector 3 0) #vu8(0 0 0)) #t)
     (equal? (bytevector=? (make-bytevector 5 0) #vu8(0 0 0)) #f)
     (equal? (bytevector=? #vu8(1 127 128 255) #vu8(255 128 127 1)) #f)
     (equal? (let ([v (make-bytevector 6)]) (bytevector-fill! v 255) v)
             #vu8(255 255 255 255 255 255))
     (equal? (let ([v (make-bytevector 6)]) (bytevector-fill! v -128) v)
             #vu8(128 128 128 128 128 128))
     (equal? (bytevector-copy #vu8(1 127 128 255)) #vu8(1 127 128 255))
     (equal? (let ([v #vu8(1 127 128 255)]) (eq? v (bytevector-copy v)))
             #f)
     (begin
       (define $v1 #vu8(31 63 95 127 159 191 223 255))
       (define $v2 (make-bytevector 10 0))
       (bytevector-copy! $v1 2 $v2 1 4)
       (equal? $v2 #vu8(0 95 127 159 191 0 0 0 0 0)))
     (begin
       (bytevector-copy! $v1 5 $v2 7 3)
       (equal? $v2 #vu8(0 95 127 159 191 0 0 191 223 255)))
     (begin
       (bytevector-copy! $v2 3 $v2 0 6)
       (equal? $v2 #vu8(159 191 0 0 191 223 0 191 223 255)))
     (begin
       (bytevector-copy! $v2 0 $v2 1 9)
       (equal? $v2 #vu8(159 159 191 0 0 191 223 0 191 223)))

     (equal? (bytevector-u8-ref #vu8(1 127 128 255) 0) 1)
     (equal? (bytevector-u8-ref #vu8(1 127 128 255) 2) 128)
     (equal? (bytevector-u8-ref #vu8(1 127 128 255) 3) 255)
     (equal? (bytevector-s8-ref #vu8(1 127 128 255) 0) 1)
     (equal? (bytevector-s8-ref #vu8(1 127 128 255) 1) 127)
     (equal? (bytevector-s8-ref #vu8(1 127 128 255) 2) -128)
     (equal? (bytevector-s8-ref #vu8(1 127 128 255) 3) -1)
     (equal? (let ([v (make-bytevector 5 -1)])
               (bytevector-u8-set! v 2 128)
               v)
             #vu8(255 255 128 255 255))
     (equal? (let ([v (make-bytevector 4 0)])
               (bytevector-s8-set! v 1 100)
               (bytevector-s8-set! v 2 -100)
               v)
             #vu8(0 100 156 0))
     (equal? (bytevector->u8-list (make-bytevector 0)) '())
     (equal? (bytevector->u8-list #vu8(1 127 128 255)) '(1 127 128 255))
     (equal? (let ([v #vu8(1 2 3 255)]) (apply * (bytevector->u8-list v)))
             1530)
     (equal? (bytevector->s8-list (make-bytevector 0)) '())
     (equal? (bytevector->s8-list #vu8(1 127 128 255)) '(1 127 -128 -1))
     (equal? (let ([v #vu8(1 2 3 255)]) (apply * (bytevector->s8-list v)))
             -6)
     (equal? (u8-list->bytevector '()) #vu8())
     (equal? (u8-list->bytevector '(1 127 128 255)) #vu8(1 127 128 255))
     (equal? (let ([v #vu8(1 2 3 4 5)])
               (let ([ls (bytevector->u8-list v)])
                 (u8-list->bytevector (map * ls ls))))
             #vu8(1 4 9 16 25))
     (equal? (s8-list->bytevector '()) #vu8())
     (equal? (s8-list->bytevector '(1 127 -128 -1)) #vu8(1 127 128 255))
     (equal? (let ([v #vu8(1 2 3 4 5)])
               (let ([ls (bytevector->s8-list v)])
                 (s8-list->bytevector (map - ls))))
             #vu8(255 254 253 252 251))
     (begin
       (define $v
         #vu8(#x12 #x34 #xfe #x56 #xdc #xba #x78 #x98))
       (bytevector? $v))
     (equal? (case (native-endianness)
               [(big)
                (list (equal? (bytevector-u16-native-ref $v 2) #xfe56)
                      (equal? (bytevector-s16-native-ref $v 2) #x-1aa)
                      (equal? (bytevector-s16-native-ref $v 6) #x7898)
                      (equal? (bytevector-u32-native-ref $v 0) #x1234fe56)
                      (equal? (bytevector-s32-native-ref $v 0) #x1234fe56)
                      (equal? (bytevector-s32-native-ref $v 4) #x-23458768)
                      (equal? (bytevector-u64-native-ref $v 0) #x1234fe56dcba7898)
                      (equal? (bytevector-s64-native-ref $v 0) #x1234fe56dcba7898))]
               [(little)
                (list (equal? (bytevector-u16-native-ref $v 2) #x56fe)
                      (equal? (bytevector-s16-native-ref $v 2) #x56fe)
                      (equal? (bytevector-s16-native-ref $v 6) #x-6788)
                      (equal? (bytevector-u32-native-ref $v 0) #x56fe3412)
                      (equal? (bytevector-s32-native-ref $v 0) #x56fe3412)
                      (equal? (bytevector-s32-native-ref $v 4) #x-67874524)
                      (equal? (bytevector-u64-native-ref $v 0) #x9878badc56fe3412)
                      (equal? (bytevector-s64-native-ref $v 0) #x-67874523a901cbee))]
               [else
                (errorf #f "mat does not handle endianness ~s"
                        (native-endianness))])
             '(#t #t #t #t #t #t #t #t))

     (let ()
       (define v (make-bytevector 8 0))
       (bytevector-u16-native-set! v 0 #xfe56)
       (bytevector-s16-native-set! v 2 #x-1aa)
       (bytevector-s16-native-set! v 4 #x7898)
       (case (native-endianness)
         [(big) (equal? v #vu8(#xfe #x56 #xfe #x56 #x78 #x98 #x00 #x00))]
         [(little)
          (equal? v #vu8(#x56 #xfe #x56 #xfe #x98 #x78 #x00 #x00))]
         [else
          (errorf #f "mat does not handle endianness ~s"
                  (native-endianness))]))
     (let ()
       (define v (make-bytevector 16 0))
       (bytevector-u32-native-set! v 0 #x1234fe56)
       (bytevector-s32-native-set! v 4 #x1234fe56)
       (bytevector-s32-native-set! v 8 #x-23458768)
       (case (native-endianness)
         [(big)
          (equal? v
            #vu8(#x12 #x34 #xfe #x56 #x12 #x34 #xfe #x56 #xdc #xba #x78 #x98
                 #x00 #x00 #x00 #x00))]
         [(little)
          (equal? v
            #vu8(#x56 #xfe #x34 #x12 #x56 #xfe #x34 #x12 #x98 #x78 #xba #xdc
                 #x00 #x00 #x00 #x00))]
         [else
          (errorf #f "mat does not handle endianness ~s"
                  (native-endianness))]))
     (let ()
       (define v (make-bytevector 24 0))
       (bytevector-u64-native-set! v 0 #x1234fe56dcba7898)
       (bytevector-s64-native-set! v 8 #x1234fe56dcba7898)
       (bytevector-s64-native-set! v 16 #x-67874523a901cbee)
       (case (native-endianness)
         [(big)
          (equal? v
            #vu8(#x12 #x34 #xfe #x56 #xdc #xba #x78 #x98 #x12 #x34 #xfe #x56
                 #xdc #xba #x78 #x98 #x98 #x78 #xba #xdc #x56 #xfe #x34 #x12))]
         [(little)
          (equal? v
            #vu8(#x98 #x78 #xba #xdc #x56 #xfe #x34 #x12 #x98 #x78 #xba #xdc
                 #x56 #xfe #x34 #x12 #x12 #x34 #xfe #x56 #xdc #xba #x78 #x98))]
         [else
          (errorf #f "mat does not handle endianness ~s"
                  (native-endianness))]))

     (begin
       (define $v
         #vu8(#x12 #x34 #xfe #x56 #xdc #xba #x78 #x98 #x9a #x76))
       (bytevector? $v))
     (equal? (bytevector-u16-ref $v 0 (endianness big)) #x1234)
     (equal? (bytevector-s16-ref $v 1 (endianness big)) #x34fe)
     (equal? (bytevector-s16-ref $v 5 (endianness big)) #x-4588)
     (equal? (bytevector-u32-ref $v 2 'big) #xfe56dcba)
     (equal? (bytevector-s32-ref $v 3 'big) #x56dcba78)
     (equal? (bytevector-s32-ref $v 4 'big) #x-23458768)
     (equal? (bytevector-u64-ref $v 0 'big) #x1234fe56dcba7898)
     (equal? (bytevector-s64-ref $v 1 'big) #x34fe56dcba78989a)
     (equal? (bytevector-u16-ref $v 0 (endianness little)) #x3412)
     (equal? (bytevector-s16-ref $v 1 (endianness little)) #x-1cc)
     (equal? (bytevector-s16-ref $v 5 (endianness little)) #x78ba)
     (equal? (bytevector-u32-ref $v 2 'little) #xbadc56fe)
     (equal? (bytevector-s32-ref $v 3 'little) #x78badc56)
     (equal? (bytevector-s32-ref $v 4 'little) #x-67874524)
     (equal? (bytevector-u64-ref $v 0 'little) #x9878badc56fe3412)
     (equal? (bytevector-s64-ref $v 1 'little) #x-6567874523a901cc)

     (let ()
       (define v (make-bytevector 8 0))
       (bytevector-u16-set! v 0 #xfe56 (endianness big))
       (bytevector-s16-set! v 3 #x-1aa (endianness little))
       (bytevector-s16-set! v 5 #x7898 (endianness big))
       (equal? v #vu8(#xfe #x56 #x0 #x56 #xfe #x78 #x98 #x0)))
     (let ()
       (define v (make-bytevector 16 0))
       (bytevector-u32-set! v 0 #x1234fe56 'little)
       (bytevector-s32-set! v 6 #x1234fe56 'big)
       (bytevector-s32-set! v 11 #x-23458768 'little)
       (equal? v
         #vu8(#x56 #xfe #x34 #x12 #x0 #x0 #x12 #x34 #xfe #x56 #x0 #x98 #x78
              #xba #xdc #x0)))
     (let ()
       (define v (make-bytevector 28 0))
       (bytevector-u64-set! v 0 #x1234fe56dcba7898 'little)
       (bytevector-s64-set! v 10 #x1234fe56dcba7898 'big)
       (bytevector-s64-set! v 19 #x-67874523a901cbee 'big)
       (equal? v
         #vu8(#x98 #x78 #xba #xdc #x56 #xfe #x34 #x12 #x0 #x0 #x12 #x34 #xfe
              #x56 #xdc #xba #x78 #x98 #x0 #x98 #x78 #xba #xdc #x56 #xfe
              #x34 #x12 #x0)))

     (let ()
       (define v
         #vu8(#x12 #x34 #xfe #x56 #xdc #xba #x78 #x98 #x9a #x76))
       (and (equal? (bytevector-uint-ref v 0 'big 1) #x12)
            (equal? (bytevector-uint-ref v 0 'little 1) #x12)
            (equal? (bytevector-uint-ref v 1 'big 3) #x34fe56)
            (equal? (bytevector-uint-ref v 2 'little 7) #x9a9878badc56fe)
            (equal? (bytevector-sint-ref v 2 'big 1) #x-02)
            (equal? (bytevector-sint-ref v 1 'little 6) #x78badc56fe34)
            (equal? (bytevector-sint-ref v 2 'little 7) #x-6567874523a902)
            (equal? (bytevector-sint-ref (make-bytevector 1000 -1) 0 'big 1000)
                    -1)))

     (let ()
       (define v (make-bytevector 5 0))
       (bytevector-uint-set! v 1 #x123456 (endianness big) 3)
       (equal? v #vu8(0 #x12 #x34 #x56 0)))
     (let ()
       (define v (make-bytevector 7 -1))
       (bytevector-sint-set! v 1 #x-8000000000 (endianness little) 5)
       (equal? v #vu8(#xff 0 0 0 0 #x80 #xff)))

     (equal? (bytevector->uint-list (make-bytevector 0) 'little 3) '())
     (equal? (let ([v #vu8(1 2 3 4 5 6)]) (bytevector->uint-list v 'big 3))
             '(#x010203 #x040506))
     (equal? (let ([v (make-bytevector 80 -1)])
               (bytevector->sint-list v 'big 20))
             '(-1 -1 -1 -1))
     (equal? (uint-list->bytevector '() 'big 25) #vu8())
     (equal? (sint-list->bytevector '(0 -1) 'big 3)
             #vu8(0 0 0 #xff #xff #xff))
     (equal? (let ()
               (define (f size)
                 (let ([ls (list (- (expt 2 (- (* 8 size) 1)))
                                 (- (expt 2 (- (* 8 size) 1)) 1))])
                   (sint-list->bytevector ls 'little size)))
               (f 6))
             #vu8(#x00 #x00 #x00 #x00 #x00 #x80 #xff #xff #xff #xff #xff
                  #x7f))

     (begin
       (define $v (make-bytevector 8 0))
       (bytevector-ieee-single-native-set! $v 0 .125)
       (bytevector-ieee-single-native-set! $v 4 -3/2)
       (equal? (list (bytevector-ieee-single-native-ref $v 0)
                     (bytevector-ieee-single-native-ref $v 4))
               '(0.125 -1.5)))
     (begin
       (bytevector-ieee-double-native-set! $v 0 1e23)
       (equal? (bytevector-ieee-double-native-ref $v 0) 1e23))

     (begin
       (define $v (make-bytevector 10 #xc7))
       (bytevector-ieee-single-set! $v 1 .125 'little)
       (bytevector-ieee-single-set! $v 6 -3/2 'big)
       (equal? (list (bytevector-ieee-single-ref $v 1 'little)
                     (bytevector-ieee-single-ref $v 6 'big))
               '(0.125 -1.5)))
     (equal? $v #vu8(#xc7 #x0 #x0 #x0 #x3e #xc7 #xbf #xc0 #x0 #x0))
     (begin
       (bytevector-ieee-double-set! $v 1 1e23 'big)
       (equal? (bytevector-ieee-double-ref $v 1 'big) 1e23)))

#;
(mat bytevector-logical
     ; A reference implementation in scheme
     (begin
       (define $bytevector-blurp
         (lambda (f)
           (lambda (bv1 bv2)
             (let ([len1 (bytevector-length bv1)]
                   [len2 (bytevector-length bv2)])
               (let ([len (max len1 len2)])
                 (if (fx= len 0)
                     bv1
                     (let ([new (make-bytevector len)])
                       (define endianness 'big)
                       (define (uint-ref bv len)
                         (if (fx= len 0)
                             0
                             (bytevector-uint-ref bv 0 endianness len)))
                       (bytevector-uint-set!
                         new
                         0
                         (f (uint-ref bv1 len1) (uint-ref bv2 len2))
                         endianness
                         len)
                       new)))))))

       (define $bytevector-and
         ($bytevector-blurp bitwise-and))

       (define $bytevector-ior
         ($bytevector-blurp bitwise-ior))

       (define $bytevector-xor
         ($bytevector-blurp bitwise-xor))
       (define $bytevector-not
         (lambda (bv)
           (let ([len (bytevector-length bv)])
             (if (fx= len 0)
                 bv
                 (let ([new (make-bytevector len)])
                   #;
                   (bytevector-uint-set!
                     new
                     0
                     (- (- (expt 256 len) 1)
                        (bytevector-uint-ref bv 0 (native-endianness) len))
                     (native-endianness)
                     len)
                   (bytevector-sint-set!
                     new
                     0
                     (bitwise-not
                       (bytevector-sint-ref bv 0 (native-endianness) len))
                     (native-endianness)
                     len)
                   new)))))

       (define $make-random-bytevector
         (lambda (len)
           (let ([bv (make-bytevector len)])
             (do ([n len (- n 1)])
                 ((zero? n) bv)
                 (bytevector-u8-set! bv (- n 1) (random 256))))))

       #t)

     ; Currently the reference implementation is the only implemenation,
     ; so go ahead and use it for the tests and the random tests below.
     (define bytevector-and $bytevector-and)
     (define bytevector-ior $bytevector-ior)
     (define bytevector-xor $bytevector-xor)
     (define bytevector-not $bytevector-not)

     (error? (bytevector-not '#()))
     (error? (bytevector-not 75))
     (error? (bytevector-not #vu8(5) '#()))
     (error? (bytevector-not 75 #vu8(5)))
     (equal? (bytevector-not #vu8()) #vu8())
     (equal? (bytevector-not #vu8(23)) #vu8(232))
     (equal? (bytevector-not #vu8(23 129)) #vu8(232 126))
     (equal? (bytevector-not #vu8(23 129 99)) #vu8(232 126 156))
     (equal? (bytevector-not #vu8(#x7f #xff #xff #xff)) #vu8(128 0 0 0))
     (equal? (bytevector-not #vu8(#xff #xff #xff #xff)) #vu8(0 0 0 0))
     (equal? (bytevector-not #vu8(#x00 #x00 #x00 #x00))
             #vu8(#xff #xff #xff #xff))
     (equal? (bytevector-not #vu8(0 255 170 85)) #vu8(255 0 85 170))
     (equal? (bytevector-not #vu8(#x00 #x00 #x00 #x02))
             #vu8(#xff #xff #xff #xfd))
     (equal? (bytevector-not
               #vu8(#x0f #xff #xff #xff #xff #xff #xff #xff #xff #xff))
             #vu8(#xf0 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00))

     (error? (bytevector-and '#()))
     (error? (bytevector-and 75))
     (error? (bytevector-and #vu8(5) '#()))
     (error? (bytevector-and 75 #vu8(5)))
     (equal? (bytevector-and #vu8() #vu8()) #vu8())
     (equal? (bytevector-and #vu8(#xff #xff #xff) #vu8(#x54 #x27 #x86))
             #vu8(#x54 #x27 #x86))
     (equal? (bytevector-and #vu8(#x00 #x00 #x00) #vu8(#x54 #x27 #x86))
             #vu8(#x00 #x00 #x00))
     (equal? (bytevector-and #vu8(#x65 #x33 #xf0) #vu8(#x54 #x27 #x86))
             #vu8(#x44 #x23 #x80))
     (equal? (bytevector-and #vu8(#x65 #x33 #xf0 #x75 #x83 #x99 #x41)
               #vu8(#x54 #x27 #x86 #x99 #x87 #x76 #x63))
             #vu8(#x44 #x23 #x80 #x11 #x83 #x10 #x41))
     (equal? (bytevector-and #vu8(#x65 #x33 #xf0 #x75 #x83 #x99)
               #vu8(#x54 #x27 #x86 #x99 #x87 #x76))
             #vu8(#x44 #x23 #x80 #x11 #x83 #x10))
     (equal? (bytevector-and #vu8(#x0 #x0 #x0 #x0) #vu8(#x0 #x0 #x0 #x0))
             #vu8(#x0 #x0 #x0 #x0))
     (equal? (bytevector-and #vu8(#xff #xff #xff #xff)
               #vu8(#x0 #x0 #x0 #x0))
             #vu8(#x0 #x0 #x0 #x0))
     (equal? (bytevector-and #vu8(#x0 #x0 #x0 #x0)
               #vu8(#xff #xff #xff #xff))
             #vu8(#x0 #x0 #x0 #x0))
     (equal? (bytevector-and #vu8(20) #vu8(0)) #vu8(0))
     (equal? (bytevector-and #vu8(20) #vu8(#xff)) #vu8(20))
     (equal? (bytevector-and
               #vu8(#x0f #xff #xff #xff #xff #xff #xff #xff #xff #xff)
               #vu8(#xff #xff #xff #xff #xff #xff #xff #xff #xff #xff))
             #vu8(#x0f #xff #xff #xff #xff #xff #xff #xff #xff #xff))
     (equal? (bytevector-and
               #vu8(#x11 #x11 #x11 #x11 #x11 #x11 #x11 #x11 #x11 #x11)
               #vu8(#xff #xff #xff #xff #xff #xff #xff #xff #xff #xff))
             #vu8(#x11 #x11 #x11 #x11 #x11 #x11 #x11 #x11 #x11 #x11))
     (equal? (bytevector-and
               #vu8(#x11 #x11 #x11 #x11 #x11 #x11 #x11 #x11 #x11 #x11 #x11
                    #x11 #x11)
               #vu8(#x22 #x22 #x22 #x22 #x22 #x22 #x22 #x22 #x22 #x22 #x22
                    #x22 #x22))
             #vu8(#x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00
                  #x00 #x00))
     (equal? (bytevector-and
               #vu8(#x12 #x12 #x12 #x12 #x12 #x12 #x12 #x12 #x12 #x12 #x12
                    #x12 #x12)
               #vu8(#x22 #x22 #x22 #x22 #x22 #x22 #x22 #x22 #x22 #x22 #x22
                    #x22 #x22))
             #vu8(#x02 #x02 #x02 #x02 #x02 #x02 #x02 #x02 #x02 #x02 #x02
                  #x02 #x02))
     (equal? (bytevector-and
               #vu8(#x2 #xb2 #x25 #xd2 #x7f #x49 #xc1 #xfe #xd3 #x01 #xb8
                    #x91 #x03)
               #vu8(#x0 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x1f #x36
                    #x65 #x67))
             #vu8(#x0 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x01 #x30 #x01
                  #x03))
     (equal? (bytevector-and
               #vu8(#x0 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x1f #x36
                    #x65 #x67)
               #vu8(#x2 #xb2 #x25 #xd2 #x7f #x49 #xc1 #xfe #xd3 #x01 #xb8
                    #x91 #x03))
             #vu8(#x0 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x01 #x30 #x01
                  #x03))
     ; different length bytevectors, how should they work?
     (equal? (bytevector-and
               #vu8(#x2 #xb2 #x25 #xd2 #x7f #x49 #xc1 #xfe #xd3 #x01 #xb8
                    #x91 #x03)
               #vu8(#x1f #x36 #x65 #x67))
             #vu8(#x0 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x01 #x30 #x01
                  #x03))
     (equal? (bytevector-and #vu8(#x1f #x36 #x65 #x67)
               #vu8(#x2 #xb2 #x25 #xd2 #x7f #x49 #xc1 #xfe #xd3 #x01 #xb8
                    #x91 #x03))
             #vu8(#x0 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x01 #x30 #x01
                  #x03))

     (error? (bytevector-ior '#()))
     (error? (bytevector-ior 75))
     (error? (bytevector-ior #vu8(5) '#()))
     (error? (bytevector-ior 75 #vu8(5)))
     (equal? (bytevector-ior #vu8() #vu8()) #vu8())
     (equal? (bytevector-ior #vu8(0 0 0) #vu8(0 0 0)) #vu8(0 0 0))
     (equal? (bytevector-ior #vu8(#xff #xff #xff #xff) #vu8(0 0 0 0))
             #vu8(#xff #xff #xff #xff))
     (equal? (bytevector-ior #vu8(0 0 0 0) #vu8(#xff #xff #xff #xff))
             #vu8(#xff #xff #xff #xff))
     (equal? (bytevector-ior #vu8(#xff #xff #xff) #vu8(#x54 #x27 #x86))
             #vu8(#xff #xff #xff))
     (equal? (bytevector-ior #vu8(#x00 #x00 #x00) #vu8(#x54 #x27 #x86))
             #vu8(#x54 #x27 #x86))
     (equal? (bytevector-ior #vu8(#x65 #x33 #xf0) #vu8(#x54 #x27 #x86))
             #vu8(#x75 #x37 #xf6))
     (equal? (bytevector-ior #vu8(#x65 #x33 #xf0 #x75 #x83 #x99 #x41)
               #vu8(#x54 #x27 #x86 #x99 #x87 #x76 #x63))
             #vu8(#x75 #x37 #xf6 #xfd #x87 #xff #x63))
     (equal? (bytevector-ior #vu8(#x65 #x33 #xf0 #x75 #x83 #x99)
               #vu8(#x54 #x27 #x86 #x99 #x87 #x76))
             #vu8(#x75 #x37 #xf6 #xfd #x87 #xff))
     (equal? (bytevector-ior #vu8(20) #vu8(#xff)) #vu8(#xff))
     (equal? (bytevector-ior
               #vu8(#x1 #x11 #x11 #x11 #x11 #x11 #x11 #x11 #x11 #x11 #x11
                    #x11 #x11)
               #vu8(#x2 #x22 #x22 #x22 #x22 #x22 #x22 #x22 #x22 #x22 #x22
                    #x22 #x22))
             #vu8(#x3 #x33 #x33 #x33 #x33 #x33 #x33 #x33 #x33 #x33 #x33 #x33
                  #x33))
     (equal? (bytevector-ior
               #vu8(#x1 #x21 #x21 #x21 #x21 #x21 #x21 #x21 #x21 #x21 #x21
                    #x21 #x21)
               #vu8(#x2 #x22 #x22 #x22 #x22 #x22 #x22 #x22 #x22 #x22 #x22
                    #x22 #x22))
             #vu8(#x3 #x23 #x23 #x23 #x23 #x23 #x23 #x23 #x23 #x23 #x23 #x23
                  #x23))
     (equal? (bytevector-ior
               #vu8(#x2 #xb2 #x25 #xd2 #x7f #x49 #xc1 #xfe #xd3 #x01 #xb8
                    #x91 #x03)
               #vu8(#x0 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x1f #x36
                    #x65 #x67))
             #vu8(#x2 #xb2 #x25 #xd2 #x7f #x49 #xc1 #xfe #xd3 #x1f #xbe #xf5
                  #x67))
     (equal? (bytevector-ior
               #vu8(#x0 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x1f #x36
                    #x65 #x67)
               #vu8(#x2 #xb2 #x25 #xd2 #x7f #x49 #xc1 #xfe #xd3 #x01 #xb8
                    #x91 #x03))
             #vu8(#x2 #xb2 #x25 #xd2 #x7f #x49 #xc1 #xfe #xd3 #x1f #xbe #xf5
                  #x67))
     ; different size bytevectors how should the work?
     (equal? (bytevector-ior
               #vu8(#x2 #xb2 #x25 #xd2 #x7f #x49 #xc1 #xfe #xd3 #x01 #xb8
                    #x91 #x03)
               #vu8(#x1f #x36 #x65 #x67))
             #vu8(#x2 #xb2 #x25 #xd2 #x7f #x49 #xc1 #xfe #xd3 #x1f #xbe #xf5
                  #x67))
     (equal? (bytevector-ior #vu8(#x1f #x36 #x65 #x67)
               #vu8(#x2 #xb2 #x25 #xd2 #x7f #x49 #xc1 #xfe #xd3 #x01 #xb8
                    #x91 #x03))
             #vu8(#x2 #xb2 #x25 #xd2 #x7f #x49 #xc1 #xfe #xd3 #x1f #xbe #xf5
                  #x67))

     (error? (bytevector-xor '#()))
     (error? (bytevector-xor 75))
     (error? (bytevector-xor #vu8(5) '#()))
     (error? (bytevector-xor 75 #vu8(5)))
     (equal? (bytevector-xor #vu8() #vu8()) #vu8())
     (equal? (bytevector-xor #vu8(#xff #xff #xff) #vu8(#x00 #x00 #x00))
             #vu8(#xff #xff #xff))
     (equal? (bytevector-xor #vu8(#x00 #x00 #x00) #vu8(#xff #xff #xff))
             #vu8(#xff #xff #xff))
     (equal? (bytevector-xor #vu8(#xff #xff #xff) #vu8(#xff #xff #xff))
             #vu8(#x00 #x00 #x00))
     (equal? (bytevector-xor #vu8(#x0f #x0f #x0f #x0f)
               #vu8(#xff #xff #xff #xff))
             #vu8(#xf0 #xf0 #xf0 #xf0))
     (equal? (bytevector-xor #vu8(#x00 #x14) #vu8(#xff #xff))
             #vu8(#xff #xeb))
     (equal? (bytevector-xor
               #vu8(#x1 #x11 #x11 #x11 #x11 #x11 #x11 #x11 #x11 #x11 #x11
                    #x11 #x11)
               #vu8(#x2 #x22 #x22 #x22 #x22 #x22 #x22 #x22 #x22 #x22 #x22
                    #x22 #x22))
             #vu8(#x3 #x33 #x33 #x33 #x33 #x33 #x33 #x33 #x33 #x33 #x33 #x33
                  #x33))
     (equal? (bytevector-xor
               #vu8(#x1 #x21 #x21 #x21 #x21 #x21 #x21 #x21 #x21 #x21 #x21
                    #x21 #x21)
               #vu8(#x2 #x22 #x22 #x22 #x22 #x22 #x22 #x22 #x22 #x22 #x22
                    #x22 #x22))
             #vu8(#x3 #x03 #x03 #x03 #x03 #x03 #x03 #x03 #x03 #x03 #x03 #x03
                  #x03))
     (equal? (bytevector-xor
               #vu8(#x2 #xB2 #x25 #xD2 #x7F #x49 #xC1 #xFE #xD3 #x01 #xB8
                    #x91 #x03)
               #vu8(#x0 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x1F #x36
                    #x65 #x67))
             #vu8(#x2 #xB2 #x25 #xD2 #x7F #x49 #xC1 #xFE #xD3 #x1E #x8E #xF4
                  #x64))
     (equal? (bytevector-xor
               #vu8(#x0 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00 #x1F #x36
                    #x65 #x67)
               #vu8(#x2 #xB2 #x25 #xD2 #x7F #x49 #xC1 #xFE #xD3 #x01 #xB8
                    #x91 #x03))
             #vu8(#x2 #xB2 #x25 #xD2 #x7F #x49 #xC1 #xFE #xD3 #x1E #x8E #xF4
                  #x64))
     ; different length bytevectors: how should they work?
     (equal? (bytevector-xor
               #vu8(#x2 #xB2 #x25 #xD2 #x7F #x49 #xC1 #xFE #xD3 #x01 #xB8
                    #x91 #x03)
               #vu8(#x1F #x36 #x65 #x67))
             #vu8(#x2 #xB2 #x25 #xD2 #x7F #x49 #xC1 #xFE #xD3 #x1E #x8E #xF4
                  #x64))
     (equal? (bytevector-xor #vu8(#x1F #x36 #x65 #x67)
               #vu8(#x2 #xB2 #x25 #xD2 #x7F #x49 #xC1 #xFE #xD3 #x01 #xB8
                    #x91 #x03))
             #vu8(#x2 #xB2 #x25 #xD2 #x7F #x49 #xC1 #xFE #xD3 #x1E #x8E #xF4
                  #x64))

     ; random tests
     (do ([n 1000 (fx- n 1)])
         ((fxzero? n) #t)
         (let ([size (random 30)])
           (let ([bv1 ($make-random-bytevector size)]
                 [bv2 ($make-random-bytevector size)])
             (unless (equal? (bytevector-not bv1) ($bytevector-not bv1))
                     (errorf #f "bytevector-not failed on ~s" bv1))
             (unless (equal? (bytevector-and bv1 bv2)
                             ($bytevector-and bv1 bv2))
                     (errorf #f
                             "bytevector-and failed on ~s and ~s"
                             bv1
                             bv2))
             (unless (equal? (bytevector-and bv2 bv1)
                             ($bytevector-and bv2 bv1))
                     (errorf #f
                             "bytevector-and failed on ~s and ~s"
                             bv2
                             bv1))
             (unless (equal? (bytevector-and bv1 bv1)
                             ($bytevector-and bv1 bv1))
                     (errorf #f
                             "bytevector-and failed on ~s and ~s"
                             bv1
                             bv1))
             (unless (equal? (bytevector-ior bv1 bv2)
                             ($bytevector-ior bv1 bv2))
                     (errorf #f
                             "bytevector-ior failed on ~s and ~s"
                             bv1
                             bv2))
             (unless (equal? (bytevector-ior bv2 bv1)
                             ($bytevector-ior bv2 bv1))
                     (errorf #f
                             "bytevector-ior failed on ~s and ~s"
                             bv2
                             bv1))
             (unless (equal? (bytevector-ior bv1 bv1)
                             ($bytevector-ior bv1 bv1))
                     (errorf #f
                             "bytevector-ior failed on ~s and ~s"
                             bv1
                             bv1))
             (unless (equal? (bytevector-xor bv1 bv2)
                             ($bytevector-xor bv1 bv2))
                     (errorf #f
                             "bytevector-xor failed on ~s and ~s"
                             bv1
                             bv2))
             (unless (equal? (bytevector-xor bv2 bv1)
                             ($bytevector-xor bv2 bv1))
                     (errorf #f
                             "bytevector-xor failed on ~s and ~s"
                             bv2
                             bv1))
             (unless (equal? (bytevector-xor bv1 bv1)
                             ($bytevector-xor bv1 bv1))
                     (errorf #f
                             "bytevector-xor failed on ~s and ~s"
                             bv1
                             bv1))))))

(mat bytevector->immutable-bytevector
     (begin
       (define immutable-100-bytevector
         (bytevector->immutable-bytevector (make-bytevector 100 42)))
       #t)
     (immutable-bytevector? immutable-100-bytevector)
     (not (mutable-bytevector? immutable-100-bytevector))
     (equal? (make-bytevector 100 42) immutable-100-bytevector)
     (eq? immutable-100-bytevector
          (bytevector->immutable-bytevector immutable-100-bytevector))
     (not (immutable-bytevector? (make-bytevector 5)))
     (mutable-bytevector? (make-bytevector 5))
     (immutable-bytevector?
       (bytevector->immutable-bytevector (bytevector)))
     (not (mutable-bytevector?
            (bytevector->immutable-bytevector (bytevector))))
     (not (immutable-bytevector? (bytevector)))
     (mutable-bytevector? (bytevector))
     (not (immutable-bytevector?
            (bytevector-copy immutable-100-bytevector)))

     ;; Make sure `...set!` functions check for mutability:
     (error? (bytevector-uint-set!
               immutable-100-bytevector
               0
               1
               (endianness big)
               4))
     (error? (bytevector-sint-set!
               immutable-100-bytevector
               0
               1
               (endianness big)
               4))
     (error? (bytevector-u8-set! immutable-100-bytevector 0 1))
     (error? (bytevector-s8-set! immutable-100-bytevector 0 1))
     (error? (bytevector-u16-set!
               immutable-100-bytevector
               0
               1
               (endianness big)))
     (error? (bytevector-s16-set!
               immutable-100-bytevector
               0
               1
               (endianness big)))
     (error? (bytevector-u16-native-set! immutable-100-bytevector 0 1))
     (error? (bytevector-s16-native-set! immutable-100-bytevector 0 1))
     (error? (bytevector-u24-set!
               immutable-100-bytevector
               0
               1
               (endianness big)))
     (error? (bytevector-s24-set!
               immutable-100-bytevector
               0
               1
               (endianness big)))
     (error? (bytevector-u32-set!
               immutable-100-bytevector
               0
               1
               (endianness big)))
     (error? (bytevector-s32-set!
               immutable-100-bytevector
               0
               1
               (endianness big)))
     (error? (bytevector-u32-native-set! immutable-100-bytevector 0 1))
     (error? (bytevector-s32-native-set! immutable-100-bytevector 0 1))
     (error? (bytevector-u40-set!
               immutable-100-bytevector
               0
               1
               (endianness big)))
     (error? (bytevector-s40-set!
               immutable-100-bytevector
               0
               1
               (endianness big)))
     (error? (bytevector-u48-set!
               immutable-100-bytevector
               0
               1
               (endianness big)))
     (error? (bytevector-s48-set!
               immutable-100-bytevector
               0
               1
               (endianness big)))
     (error? (bytevector-u56-set!
               immutable-100-bytevector
               0
               1
               (endianness big)))
     (error? (bytevector-s56-set!
               immutable-100-bytevector
               0
               1
               (endianness big)))
     (error? (bytevector-u64-set!
               immutable-100-bytevector
               0
               1
               (endianness big)))
     (error? (bytevector-s64-set!
               immutable-100-bytevector
               0
               1
               (endianness big)))
     (error? (bytevector-u64-native-set! immutable-100-bytevector 0 1))
     (error? (bytevector-s64-native-set! immutable-100-bytevector 0 1))
     (error? (bytevector-ieee-single-set!
               immutable-100-bytevector
               0
               1.0
               (endianness big)))
     (error? (bytevector-ieee-double-set!
               immutable-100-bytevector
               0
               1.0
               (endianness big)))
     (error? (bytevector-ieee-single-native-set! immutable-100-bytevector 0 1.0))
     (error? (bytevector-ieee-double-native-set! immutable-100-bytevector 0 1.0))
     (error? (bytevector-fill! immutable-100-bytevector 0))
     (error? (bytevector-copy! '#vu8(4 5 6) 0 immutable-100-bytevector 0 3))
     (error? (bytevector-truncate! immutable-100-bytevector 1))

     ;; Make sure `...ref!` functions *don't* accidentally check for mutability:
     (number? (bytevector-uint-ref
                immutable-100-bytevector
                0
                (endianness big)
                4))
     (number? (bytevector-sint-ref
                immutable-100-bytevector
                0
                (endianness big)
                4))
     (number? (bytevector-u8-ref immutable-100-bytevector 0))
     (number? (bytevector-s8-ref immutable-100-bytevector 0))
     (number? (bytevector-u16-ref immutable-100-bytevector 0
                (endianness big)))
     (number? (bytevector-s16-ref immutable-100-bytevector 0
                (endianness big)))
     (number? (bytevector-u16-native-ref immutable-100-bytevector 0))
     (number? (bytevector-s16-native-ref immutable-100-bytevector 0))
     (number? (bytevector-u24-ref immutable-100-bytevector 0
                (endianness big)))
     (number? (bytevector-s24-ref immutable-100-bytevector 0
                (endianness big)))
     (number? (bytevector-u32-ref immutable-100-bytevector 0
                (endianness big)))
     (number? (bytevector-s32-ref immutable-100-bytevector 0
                (endianness big)))
     (number? (bytevector-u32-native-ref immutable-100-bytevector 0))
     (number? (bytevector-s32-native-ref immutable-100-bytevector 0))
     (number? (bytevector-u40-ref immutable-100-bytevector 0
                (endianness big)))
     (number? (bytevector-s40-ref immutable-100-bytevector 0
                (endianness big)))
     (number? (bytevector-u48-ref immutable-100-bytevector 0
                (endianness big)))
     (number? (bytevector-s48-ref immutable-100-bytevector 0
                (endianness big)))
     (number? (bytevector-u56-ref immutable-100-bytevector 0
                (endianness big)))
     (number? (bytevector-s56-ref immutable-100-bytevector 0
                (endianness big)))
     (number? (bytevector-u64-ref immutable-100-bytevector 0
                (endianness big)))
     (number? (bytevector-s64-ref immutable-100-bytevector 0
                (endianness big)))
     (number? (bytevector-u64-native-ref immutable-100-bytevector 0))
     (number? (bytevector-s64-native-ref immutable-100-bytevector 0))
     (number? (bytevector-ieee-single-ref immutable-100-bytevector 0
                (endianness big)))
     (number? (bytevector-ieee-double-ref immutable-100-bytevector 0
                (endianness big)))
     (number? (bytevector-ieee-single-native-ref
                immutable-100-bytevector
                0))
     (number? (bytevector-ieee-double-native-ref
                immutable-100-bytevector
                0)))


(mat bytevector-compress
     (parameters [compress-format 'gzip 'lz4])
     (error? (bytevector-compress 7))
     (error? (bytevector-compress "hello"))
     (error? (bytevector-uncompress 7))
     (error? (bytevector-uncompress "hello"))
     (begin
       (define (round-trip-bytevector-compress bv)
         (equal? (bytevector-uncompress (bytevector-compress bv)) bv))
       (round-trip-bytevector-compress (string->utf8 "hello")))
     (round-trip-bytevector-compress '#vu8())
     (round-trip-bytevector-compress
       (apply bytevector
         (let loop ([i 0])
           (if (= i 4096)
               '()
               (cons (bitwise-and i 255) (loop (+ i 1)))))))
     (error? ;; Need at least 8 bytes for result size
             (bytevector-uncompress '#vu8()))
     (error? ;; Need at least 8 bytes for result size
             (bytevector-uncompress '#vu8(0 0 0 0 0 0 255)))
     (error? ;; Claming a too-large size in the header should fail with a suitable message:
             (bytevector-uncompress
               '#vu8(255 255 255 255 255 255 255 255 1 2 3))))
;;; thread.ms
;;; Copyright 1984-2017 Cisco Systems, Inc.
;;; 
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;; 
;;; http://www.apache.org/licenses/LICENSE-2.0
;;; 
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

; why can't this come after misc.ms?

(define-syntax when-threaded
  (lambda (x)
    (syntax-case x ()
      [(_ e ...) (if (threaded?) #'(begin (void) e ...) #'(void))])))

(mat engine-thread
     (let ()
       (define fattercode
         '(module (fatterfib fatter slimmer zero)
            (define zero? null?)
            (define 1+ list)
            (define 1- car)
            (define zero '())
            (define (fatter n)
              (if (= n 0) zero (1+ (fatter (- n 1)))))
            (define (slimmer x)
              (if (zero? x) 0 (+ (slimmer (1- x)) 1)))
            (define fatter+
              (lambda (x y)
                (if (zero? y) x (fatter+ (1+ x) (1- y)))))
            (define fatterfib
              (lambda (x)
                (if (or (zero? x) (zero? (1- x)))
                    (1+ zero)
                    (fatter+ (fatterfib (1- x)) (fatterfib (1- (1- x)))))))))
       (define fatter-eval
         (lambda (eval loc)
           (lambda ()
             (let f ([n 10] [a 0])
               (if (= n 0)
                   (set-car! loc a)
                   (f (- n 1)
                      (+ a
                         (eval `(let ()
                                  ,fattercode
                                  (slimmer (fatterfib (fatter 10))))))))))))
       (define (engine-eval-test n)
         (define thread-list '())
         (define fork-thread
           (lambda (x)
             (set! thread-list
               (cons (make-engine x) thread-list))))
         (define locs (map list (make-list n 0)))
         (for-each
           (lambda (x)
             (fork-thread (fatter-eval interpret x)))
           locs)
         (let f ([q thread-list])
           (unless (null? q)
                   ((car q)
                    10
                    (lambda (t . r) (f (cdr q)))
                    (lambda (x)
                      (f (append (cdr q) (list x)))))))
         (map car locs))

       (equal? (engine-eval-test 7) '(890 890 890 890 890 890 890))))

(when-threaded
  (mat thread
       (let ([m (make-mutex)]
             [c (make-condition)]
             [m2 (make-mutex 'mname)]
             [c2 (make-condition 'cname)])
         (and (mutex? m)
              (thread-condition? c)
              (mutex? m2)
              (thread-condition? c2)
              (not (mutex? c))
              (not (thread-condition? m))
              (not (mutex? c2))
              (not (thread-condition? m2))
              (not (mutex-name m))
              (not (condition-name c))
              (eq? 'mname (mutex-name m2))
              (eq? 'cname (condition-name c2))
              (not (mutex? 'mutex))
              (not (thread-condition? 'condition))))
       (begin
         (define $threads
           (foreign-procedure "(cs)threads" () scheme-object))
         (define $fib
           (lambda (x)
             (if (< x 2)
                 1
                 (+ ($fib (- x 1)) ($fib (- x 2))))))
         (define $nthreads 1)
         (define $yield
           (let ([t (make-time 'time-duration 1000000 0)])
             (lambda () (sleep t))))
         (define $thread-check
           (lambda ()
             (let loop ([n 100] [nt (length ($threads))])
               (cond
                 [(<= nt $nthreads) (set! $nthreads nt) (collect)]
                 [else
                  ($yield)
                  (let* ([ls ($threads)] [nnt (length ls)])
                    (cond
                      [(< nnt nt) (loop n nnt)]
                      [(= n 0)
                       (set! $nthreads nnt)
                       (errorf #f "extra threads running ~s" ls)]
                      [else (loop (- n 1) nnt)]))]))
             #t))
         (define $time-in-range?
           (lambda (start stop target)
             (let ([t (time-difference stop start)])
               (<= (abs (- (+ (time-second t) (* (time-nanosecond t) 1e-9))
                           target))
                   0.1))))
         (andmap procedure?
           (list $threads $fib $thread-check $time-in-range?)))
       ($thread-check)
       (not (= (let ([n #f])
                 (fork-thread (lambda () (set! n (get-thread-id))))
                 (let f () (if n n (begin ($yield) (f)))))
               0))
       ($thread-check)
       (= (let ([n #f])
            (fork-thread (lambda () (set! n (get-process-id))))
            (let f () (if n n (begin ($yield) (f)))))
          (get-process-id))
       ($thread-check)
       (equal? (let ()
                 (define fat+
                   (lambda (x y)
                     (if (zero? y) x (fat+ (1+ x) (1- y)))))
                 (define fatfib
                   (lambda (x)
                     (if (< x 2)
                         1
                         (fat+ (fatfib (1- x)) (fatfib (1- (1- x)))))))
                 (define iota
                   (case-lambda
                     [(n) (iota 0 n)]
                     [(i n)
                      (if (= n 0)
                          '()
                          (cons i (iota (+ i 1) (- n 1))))]))
                 (define-syntax parallel-list
                   (syntax-rules ()
                     [(_ x ...)
                      (let ([v (make-vector (length '(x ...)) #f)]
                            [m (make-mutex)]
                            [c (make-condition)]
                            [n (length '(x ...))])
                        (map (lambda (p i) (p i))
                             (list (lambda (i)
                                     (fork-thread
                                       (lambda ()
                                         (vector-set! v i x)
                                         (with-mutex m
                                           (set! n (- n 1))
                                           (when (= n 0)
                                                 (condition-signal c))))))
                                   ...)
                             (iota (length '(x ...))))
                        (and (with-mutex m
                               (condition-wait c m
                                 (make-time 'time-duration 0 60)))
                             (vector->list v)))]))
                 (parallel-list (fatfib 26)
                   (fatfib 27)
                   (fatfib 28)
                   (fatfib 29)
                   (fatfib 30)
                   (fatfib 31)))
               '(196418 317811 514229 832040 1346269 2178309))
       ($thread-check)
       (let ([m (make-mutex)] [c (make-condition)])
         (with-mutex m
           (let* ([start (current-time)]
                  [r (condition-wait c m
                       (make-time 'time-duration 250000000 1))]
                  [stop (current-time)])
             (and (not r) ($time-in-range? start stop 1.25)))))
       (let ([m (make-mutex)] [c (make-condition)])
         (with-mutex m
           (let* ([start (current-time)]
                  [r (condition-wait c m
                       (add-duration start
                         (make-time 'time-duration 250000000 1)))]
                  [stop (current-time)])
             (and (not r) ($time-in-range? start stop 1.25)))))
       (let ([m (make-mutex)] [c (make-condition)])
         (with-mutex m
           (let* ([start (current-time)]
                  [r (condition-wait c m (make-time 'time-duration 0 -1))]
                  [stop (current-time)])
             (and (not r) ($time-in-range? start stop 0.0)))))
       (let ([m (make-mutex)] [c (make-condition)])
         (with-mutex m
           (let* ([start (current-time)]
                  [r (condition-wait c m
                       (add-duration start (make-time 'time-duration 0 -1)))]
                  [stop (current-time)])
             (and (not r) ($time-in-range? start stop 0.0)))))
       (let ([m (make-mutex)] [c (make-condition)])
         (with-mutex m
           (fork-thread
             (lambda ()
               (with-mutex m
                 (sleep (make-time 'time-duration 250000000 0)))))
           (let* ([start (current-time)]
                  [r (condition-wait c m
                       (make-time 'time-duration 100000000 0))]
                  [stop (current-time)])
             (and (not r) ($time-in-range? start stop 0.25)))))
       (let ([count 300] [live 0] [live-m (make-mutex)])
         (parameterize
           ([collect-request-handler
              (lambda () (set! count (- count 1)) (collect))])
           (define chew
             (lambda (x) (when (> count 0) (chew (list 0)))))
           (define (gc-test n)
             (set! live n)
             (do ([i 0 (+ i 1)])
                 ((= i n))
                 (fork-thread
                   (lambda ()
                     (chew 0)
                     (with-mutex live-m (set! live (- live 1)))))))
           (gc-test 4)
           (chew 0))
         ; wait for the others to die
         (let f () (unless (= live 0) ($yield) (f)))
         #t)
       ($thread-check)
       (let ([count 300] [live 0] [live-m (make-mutex)])
         (parameterize
           ([collect-request-handler
              (lambda () (set! count (- count 1)) (collect))])
           (define chew
             (lambda (x) (when (> count 0) (chew (list 0)))))
           (define (gc-test n)
             (set! live n)
             (do ([i 0 (+ i 1)])
                 ((= i n))
                 (fork-thread
                   (lambda ()
                     (chew 0)
                     (with-mutex live-m (set! live (- live 1)))))))
           (let ([m1 (make-mutex)]
                 [m2 (make-mutex)]
                 [c1 (make-condition)]
                 [c2 (make-condition)])
             ; suspend one thread on a condition, waiting for it to get there
             (with-mutex m1
               (fork-thread
                 (lambda ()
                   (with-mutex m1
                     (condition-signal c1)
                     (condition-wait c1 m1)
                     (condition-signal c1))))
               (condition-wait c1 m1))
             ; try to get another suspended on a mutex
             (mutex-acquire m2)
             (fork-thread (lambda () (with-mutex m2 (condition-signal c2))))
             ; start some threads a-allocating 
             (gc-test 3)
             ; join in the fun
             (chew 0)
             ; release the suspended threads
             (with-mutex m1 (condition-signal c1) (condition-wait c1 m1))
             (condition-wait c2 m2)
             (mutex-release m2)))
         ; wait for the others to die
         (let f () (unless (= live 0) ($yield) (f)))
         #t)
       ($thread-check)
       (let ([count 300] [live 0] [live-m (make-mutex)])
         (define fat+
           (lambda (x y)
             (if (zero? y) x (fat+ (1+ x) (1- y)))))
         (define fatfib
           (lambda (x)
             (if (< x 2)
                 1
                 (fat+ (fatfib (1- x)) (fatfib (1- (1- x)))))))
         (parameterize
           ([collect-request-handler
              (lambda () (set! count (- count 1)) (collect))])
           (define chew
             (lambda (x) (when (> count 0) (chew (list 0)))))
           (define (gc-test n)
             (set! live n)
             (do ([i 0 (+ i 1)])
                 ((= i n))
                 (fork-thread
                   (lambda ()
                     (chew 0)
                     (with-mutex live-m (set! live (- live 1)))))))
           (let ([m1 (make-mutex)]
                 [m2 (make-mutex)]
                 [c1 (make-condition)]
                 [c2 (make-condition)])
             ; suspend one thread on a condition, waiting for it to get there
             (with-mutex m1
               (fork-thread
                 (lambda ()
                   (with-mutex m1
                     (condition-signal c1)
                     (condition-wait c1 m1)
                     (condition-signal c1))))
               (condition-wait c1 m1))
             ; try to get another suspended on a mutex
             (mutex-acquire m2)
             (fork-thread (lambda () (with-mutex m2 (condition-signal c2))))
             ; start some threads a-allocating 
             (gc-test 5)
             ; create threads that die quickly while waiting for
             ; our count collections to occur
             (let ([live 0] [live-m (make-mutex)])
               (let f ()
                 (when (> count 0)
                       (fatfib 20)
                       (with-mutex live-m
                         ; cap the number of quickly dying threads, or ti3nb
                         ; runs out of memory somewhere later in the mat run.
                         ; theory is that virtual address space gets chopped
                         ; up and that the main thread can't access virtual
                         ; memory previously assigned to a child thread.
                         (if (< live 20)
                             ; don't panic if we try to create too many...
                             (guard (c [#t (values)])
                               (fork-thread
                                 (lambda ()
                                   (with-mutex live-m (set! live
                                                        (- live 1)))))
                               (set! live (+ live 1)))))
                       (f))))
             ; release the suspended threads
             (with-mutex m1 (condition-signal c1) (condition-wait c1 m1))
             (condition-wait c2 m2)
             (mutex-release m2)))
         ; wait for the others to die
         (let f () (unless (= live 0) ($yield) (f)))
         #t)
       ($thread-check)
       (let ([count 30])
         (parameterize
           ([collect-request-handler
              (lambda () (set! count (- count 1)) (collect))])
           (define chew
             (lambda (x) (when (> count 0) (chew (list 0)))))
           (define (gc-test4 n)
             (define fib
               (lambda (x)
                 (if (< x 2)
                     1
                     (+ (fib (- x 1)) (fib (- x 2))))))
             ; stall collection for a bit
             (disable-interrupts)
             (do ([i 0 (+ i 1)])
                 ((= i n))
                 (fork-thread (lambda () (enable-interrupts) (chew 0))))
             (fib 35)
             (enable-interrupts))
           (gc-test4 4)
           (chew 0)
           #t))
       ($thread-check)
       (eqv? (let ()
               (define m (make-mutex))
               (define fib
                 (lambda (n)
                   (if (with-mutex m (< n 2))
                       1
                       (+ (fib (- n 1)) (fib (- n 2))))))
               (fib 20))
             10946)
       ($thread-check)
       (let ()
         (define m (make-mutex))
         (define mgrab
           (lambda (n)
             (unless (fxzero? n)
                     (mutex-acquire m)
                     (mutex-release m)
                     (mgrab (fx- n 1)))))
         (mgrab 100)
         #t)
       ($thread-check)
       (let ()
         (define m (make-mutex))
         (define recmgrab
           (lambda (n)
             (set! m (make-mutex))
             (let f ([n n])
               (unless (fxzero? n)
                       (mutex-acquire m)
                       (f (fx- n 1))
                       (mutex-release m)))
             (fork-thread
               (lambda ()
                 (mutex-acquire m)
                 #;
                 (pretty-print 'bye)))))
         (recmgrab 100)
         #t)
       ($thread-check)
       (eqv? (let ([cnt 0] [ans 0])
               (define m (make-mutex))
               (mutex-acquire m)
               (fork-thread
                 (rec f
                      (lambda ()
                        (with-mutex m (set! cnt (+ cnt 1)))
                        (if (= ans 0)
                            (begin ($yield) (f))
                            (set! ans (- ans))))))
               (mutex-release m)
               (let f ()
                 (when (= cnt 0) (begin ($yield) (f))))
               (set! ans 17)
               (let f ()
                 (if (< ans 0) ans (begin ($yield) (f)))))
             -17)
       ($thread-check)
       (eqv? (let ()
               (define ans 0)
               (define cnt 0)
               (define m (make-mutex))
               (define c (make-condition))
               (define (f n)
                 (fork-thread
                   (lambda ()
                     (with-mutex m
                       (set! ans (+ ans n))
                       (set! cnt (+ cnt 1))
                       (condition-wait c m)
                       (set! cnt (- cnt 1))))))
               (f 1)
               (f 2)
               (f 4)
               (let f ()
                 (unless (= cnt 3) (begin ($yield) (f))))
               (with-mutex m (condition-broadcast c))
               (let f ()
                 (unless (= cnt 0) (begin ($yield) (f))))
               ans)
             7)
       ($thread-check)
       (let ([nthreads (length ($threads))])
         (define-record bounded-queue
           (i)
           ([vec (make-vector i)]
            [mutex (make-mutex)]
            [ready (make-condition)]
            [room (make-condition)]
            [waiting 0]
            [die? #f]))
         (define queue-empty?
           (lambda (bq)
             (with-mutex (bounded-queue-mutex bq)
               (= (bounded-queue-i bq)
                  (vector-length (bounded-queue-vec bq))))))
         (define enqueue!
           (lambda (item bq)
             (let ([mutex (bounded-queue-mutex bq)])
               (with-mutex mutex
                 (let loop ()
                   (unless (bounded-queue-die? bq)
                           (if (zero? (bounded-queue-i bq))
                               (begin
                                 (condition-wait (bounded-queue-room bq) mutex)
                                 ; we grab the mutex when we wake up, but some other thread may
                                 ; beat us to the punch
                                 (loop))
                               (let ([i (- (bounded-queue-i bq) 1)])
                                 (vector-set! (bounded-queue-vec bq) i item)
                                 (set-bounded-queue-i! bq i)
                                 (unless (zero? (bounded-queue-waiting bq))
                                         (condition-signal (bounded-queue-ready bq)))))))))))
         (define dequeue!
           (lambda (bq)
             (let ([mutex (bounded-queue-mutex bq)])
               (with-mutex mutex
                 (let loop ()
                   (unless (bounded-queue-die? bq)
                           (if (= (bounded-queue-i bq)
                                  (vector-length (bounded-queue-vec bq)))
                               (begin
                                 (set-bounded-queue-waiting! bq
                                   (+ (bounded-queue-waiting bq) 1))
                                 (condition-wait (bounded-queue-ready bq) mutex)
                                 (set-bounded-queue-waiting! bq
                                   (- (bounded-queue-waiting bq) 1))
                                 ; we grab the mutex when we wake up, but some other thread may
                                 ; beat us to the punch
                                 (loop))
                               (let ([i (bounded-queue-i bq)])
                                 (let ([item (vector-ref (bounded-queue-vec bq) i)])
                                   (set-bounded-queue-i! bq (+ i 1))
                                   (condition-signal (bounded-queue-room bq))
                                   item)))))))))
         (define job-queue)
         (define fib
           (lambda (n)
             (if (< n 2) n (+ (fib (- n 2)) (fib (- n 1))))))

         (define make-job
           (let ([count 0])
             (lambda (n)
               (set! count (+ count 1))
               (printf "Adding job #~s = (lambda () (fib ~s))\n" count n)
               (cons count (lambda () (fib n))))))
         (define make-producer
           (lambda (n)
             (rec producer
                  (lambda ()
                    (printf "producer ~s posting a job\n" n)
                    (enqueue! (make-job (+ 20 (random 10))) job-queue)
                    (if (bounded-queue-die? job-queue)
                        (printf "producer ~s dying\n" n)
                        (producer))))))
         (define make-consumer
           (lambda (n)
             (rec consumer
                  (lambda ()
                    (printf "consumer ~s looking for a job~%" n)
                    (let ([job (dequeue! job-queue)])
                      (if (bounded-queue-die? job-queue)
                          (printf "consumer ~s dying\n" n)
                          (begin
                            (printf "consumer ~s executing job #~s~%" n
                                    (car job))
                            (printf "consumer ~s computed:  ~s~%" n ((cdr job)))
                            (consumer))))))))
         (define (bq-test np nc)
           (set! job-queue (make-bounded-queue (max nc np)))
           (do ([np np (- np 1)])
               ((<= np 0))
               (fork-thread (make-producer np)))
           (do ([nc nc (- nc 1)])
               ((<= nc 0))
               (fork-thread (make-consumer nc))))

         (bq-test 3 4)
         (set! ans (fib 35))
         ; flush out the waiting producers and consumers
         (set-bounded-queue-die?! job-queue #t)
         (let ()
           (let f ()
             (unless (= (length ($threads)) nthreads)
                     (with-mutex (bounded-queue-mutex job-queue)
                       (condition-signal (bounded-queue-room job-queue))
                       (condition-signal (bounded-queue-ready job-queue)))
                     ($yield)
                     (f))))
         (eqv? ans 9227465))
       ($thread-check)
       (let ([ans #f])
         (define fattercode
           '(module (fatterfib fatter slimmer zero)
              (define zero? null?)
              (define 1+ list)
              (define 1- car)
              (define zero '())
              (define (fatter n)
                (if (= n 0) zero (1+ (fatter (- n 1)))))
              (define (slimmer x)
                (if (zero? x) 0 (+ (slimmer (1- x)) 1)))
              (define fatter+
                (lambda (x y)
                  (if (zero? y) x (fatter+ (1+ x) (1- y)))))
              (define fatterfib
                (lambda (x)
                  (if (or (zero? x) (zero? (1- x)))
                      (1+ zero)
                      (fatter+ (fatterfib (1- x)) (fatterfib (1- (1- x)))))))))
         (define fatter-eval
           (lambda (eval loc)
             (lambda ()
               (let f ([n 10] [a 0])
                 (if (= n 0)
                     (set-car! loc a)
                     (f (- n 1)
                        (+ a
                           (eval `(let ()
                                    ,fattercode
                                    (slimmer (fatterfib (fatter 10))))))))))))
         (define (thread-eval-test n)
           (define locs (map list (make-list n 0)))
           (for-each
             ; compiler is not reentrant wrt threads, so must use interpret
             (lambda (loc)
               (fork-thread (fatter-eval interpret loc)))
             locs)
           (let f ()
             (when (ormap zero? (map car locs))
                   ($yield)
                   (f)))
           (map car locs))

         (equal? (thread-eval-test 7) '(890 890 890 890 890 890 890)))
       ($thread-check)
       (equal? (let ([x1 #f] [x2 #f] [x3 #f] [x4 #f] [x5 #f])
                 (define p (make-thread-parameter 0))
                 (set! x1 (p))
                 (p 3)
                 (set! x2 (p))
                 (fork-thread (lambda () (set! x3 (p)) (p 5) (set! x4 (p))))
                 (let f () (unless x4 ($yield) (f)))
                 (set! x5 (p))
                 (list x1 x2 x3 x4 x5))
               '(0 3 3 5 3))
       ($thread-check)
       (equal? (let ([x1 #f] [x2 #f] [x3 #f] [x4 #f] [x5 #f])
                 (define p (make-thread-parameter 0))
                 (define m (make-mutex))
                 (define c (make-condition))
                 (set! x1 (p))
                 (p 3)
                 (set! x2 (p))
                 (with-mutex m
                   (fork-thread
                     (lambda ()
                       (set! x3 (p))
                       (p 5)
                       (set! x4 (p))
                       (with-mutex m (condition-signal c))))
                   (condition-wait c m))
                 (set! x5 (p))
                 (list x1 x2 x3 x4 x5))
               '(0 3 3 5 3))
       ($thread-check)
       (let ()
         (define done? #f)
         (define m (make-mutex))
         (define spin
           (lambda ()
             (unless done?
                     (if (mutex-acquire m #f)
                         (set! done? #t)
                         (begin ($yield) (spin))))))
         (fork-thread spin)
         (fork-thread spin)
         (spin)
         done?)
       ($thread-check)
       (eqv? (let ()
               (define-record accumulator
                 ()
                 ([acc 0] [increments 0] [(immutable mutex) (make-mutex)]))
               (define incr!
                 (lambda (a n)
                   (with-mutex (accumulator-mutex a)
                     (set-accumulator-acc! a (+ (accumulator-acc a) n))
                     (set-accumulator-increments! a
                       (+ (accumulator-increments a) 1)))))
               (define fact
                 (lambda (x)
                   (if (= x 0) 1 (* x (fact (- x 1))))))
               (define foo
                 (lambda (x)
                   (string-length (number->string (fact x)))))
               (let ()
                 (define acc (make-accumulator))
                 (define bar
                   (lambda (x)
                     (fork-thread (lambda () (incr! acc (foo x))))))
                 (bar 1100)
                 (bar 1200)
                 (bar 1300)
                 (bar 1400)
                 (bar 1500)
                 (bar 1400)
                 (bar 1300)
                 (bar 1200)
                 (bar 1100)
                 (let f ()
                   (unless (= (accumulator-increments acc) 9)
                           ($yield)
                           (f)))
                 (accumulator-acc acc)))
             30777)
       ($thread-check)
       (let ()
         (define fat+
           (lambda (x y)
             (if (zero? y) x (fat+ (1+ x) (1- y)))))
         (define fatfib
           (lambda (x)
             (if (< x 2)
                 1
                 (fat+ (fatfib (1- x)) (fatfib (1- (1- x)))))))
         (set! ans (fatfib 30))
         (collect)
         (eqv? ans 1346269))
       ($thread-check)
       (eq? (let ()
              (define bt
                (foreign-procedure "(cs)backdoor_thread"
                  (scheme-object)
                  iptr))
              (let f ([n 100])
                (let ([q 0])
                  (unless (= n 0)
                          (let ([p (lambda ()
                                     (let ([count 10])
                                       (define chew
                                         (lambda (x)
                                           (when (> count 0)
                                                 (chew (list 0)))))
                                       (parameterize
                                         ([collect-request-handler
                                            (lambda ()
                                              (set! count
                                                (- count 1))
                                              (collect))])
                                         (chew 0)))
                                     (set! q (+ q 7)))])
                            (lock-object p)
                            (bt p)
                            (let f ()
                              (when (= q 0) ($yield) (f)))
                            (let f ()
                              (unless (= (length ($threads)) 1)
                                      ($yield)
                                      (f)))
                            (unlock-object p))
                          (unless (= q 14)
                                  (errorf #f "~s isn't 14" q))
                          (f (- n 1)))))
              'cool)
            'cool)
       ($thread-check)
       (let ()
         (define m (make-mutex))
         (define c (make-condition))
         (define nthreads 4)
         (define saved-condition #f)
         (with-mutex m
           (let f ([n nthreads])
             (unless (= n 0)
                     (fork-thread
                       (lambda ()
                         (guard (c [else (set! saved-condition c)])
                           (let g ([k 1000])
                             (unless (= k 0)
                                     (let ([op (open-file-output-port
                                                 (format "testfile~s.ss" n)
                                                 (file-options replace))])
                                       (port-file-compressed! op)
                                       (put-u8 op 104)
                                       (close-port op))
                                     (g (- k 1)))))
                         (with-mutex m
                           (set! nthreads (- nthreads 1))
                           (when (= nthreads 0)
                                 (condition-signal c)))))
                     (f (- n 1))))
           (condition-wait c m))
         (when saved-condition (raise saved-condition))
         #t)
       ($thread-check)
       (let ()
         (define m (make-mutex))
         (define c (make-condition))
         (define nthreads 4)
         (define saved-condition #f)
         (with-mutex m
           (let f ([n nthreads])
             (unless (= n 0)
                     (fork-thread
                       (lambda ()
                         (guard (c [else (set! saved-condition c)])
                           (let g ([k 1000])
                             (unless (= k 0)
                                     (let ([ip (open-file-input-port (format "testfile~s.ss" n))])
                                       (port-file-compressed! ip)
                                       (let ([b (get-u8 ip)])
                                         (unless (eqv? b 104)
                                                 (error #f "thread ~s read wrong value ~s" n b)))
                                       (close-port ip))
                                     (g (- k 1)))))
                         (with-mutex m
                           (set! nthreads (- nthreads 1))
                           (when (= nthreads 0)
                                 (condition-signal c)))))
                     (f (- n 1))))
           (condition-wait c m))
         (when saved-condition (raise saved-condition))
         #t)
       ($thread-check)
       (begin
         (module ($tt-count $tt-done!)
           (define n 0)
           (define done-mutex (make-mutex))
           (define $tt-count (lambda () n))
           (define ($tt-done!)
             (with-mutex done-mutex (set! n (+ n 1)))))
         (define $tt-spam (make-thread-parameter 'main))
         (define $tt-run (make-thread-parameter void))
         (define $tt-global-mutex (make-mutex))
         (define $tt-fat
           (make-thread-parameter
             (let f ([n 100] [ls (oblist)])
               (define (pick-rem ls)
                 (let f ([ls ls] [i (random (length ls))])
                   (if (fx= i 0)
                       (values (car ls) (cdr ls))
                       (let-values ([(x d) (f (cdr ls) (fx- i 1))])
                         (values x (cons (car ls) d))))))
               (if (= n 0)
                   '()
                   (let-values ([(x ls) (pick-rem ls)])
                     (cons x (f (- n 1) ls)))))))
         ; original test used copy-environment, which we don't use because
         ; environments are never collected and we don't want the remaining
         ; mats to take forever to run because the heap is full of lots of
         ; unreclaimable junk.  So we simulate some of the chores of copying
         ; an environment
         (define ($tt-chew ls)
           (let ([g* (map (lambda (x)
                            (let ([g (gensym)])
                              (putprop g '*cte* (cons 'alias x))
                              (when (#%$top-level-bound? x)
                                    (#%$set-top-level-value! g (#%$top-level-value x)))
                              g))
                          ls)])
             (map (lambda (g) (cdr (getprop g '*cte*))) g*)))
         (with-output-to-file "testfile.ss"
           (lambda ()
             (pretty-print
               '($tt-run (lambda ()
                           (do ([i 2 (1- i)])
                               ((= i 0))
                               (with-mutex $tt-global-mutex
                                 (printf "thread ~s iteration ~s\n" ($tt-spam) i))
                               (with-mutex $tt-global-mutex
                                 ($tt-fat ($tt-chew ($tt-fat)))))))))
           'replace)
         (parameterize
           ([collect-request-handler
              (lambda ()
                (printf "~s collecting\n" ($tt-spam))
                (collect))]
            [collect-notify #t])
           (time (do ([i 15 (1- i)])
                     ((= i 0))
                     (printf "Pass ~a~%" i)
                     (time (let* ([thread-count 25]
                                  #;
                                  [compile-mutex (make-mutex)]
                                  [thread-finished-mutex (make-mutex)]
                                  [thread-finished-count 0]
                                  [program-finished-condition (make-condition)]
                                  [console-mutex $tt-global-mutex]
                                  [saved-condition #f])
                             (do ([i thread-count (1- i)])
                                 ((= i 0))
                                 (mutex-acquire $tt-global-mutex)
                                 (parameterize
                                   ([$tt-fat ($tt-chew ($tt-fat))])
                                   (mutex-release $tt-global-mutex)
                                   (fork-thread
                                     (lambda ()
                                       (guard (c [else
                                                  (set! saved-condition
                                                    c)])
                                         ($tt-spam i)
                                         (with-mutex console-mutex
                                           (printf "Starting thread ~s...~%" i))
                                         ; mutex should no longer be needed as of v7.3
                                         #;
                                         (with-mutex compile-mutex (load "testfile.ss"))
                                         ; let's see if we can load from source w/o a mutex
                                         (load "testfile.ss")
                                         (($tt-run))
                                         ; now let's see if we can compile and load object code
                                         ; w/o a mutex
                                         (compile-file "testfile.ss"
                                           (format "testfile.~s" i))
                                         (load (format "testfile.~s" i))
                                         (($tt-run))
                                         (with-mutex console-mutex
                                           (printf "Finished ~s.~%" i)))
                                       ($tt-done!)
                                       (with-mutex thread-finished-mutex
                                         (set! thread-finished-count
                                           (1+ thread-finished-count))
                                         (when (= thread-finished-count thread-count)
                                               (condition-signal program-finished-condition)))))))
                             (with-mutex thread-finished-mutex
                               (unless (= thread-finished-count thread-count)
                                       (condition-wait
                                         program-finished-condition
                                         thread-finished-mutex)))
                             ($tt-done!)
                             (when saved-condition
                                   (raise saved-condition)))))))
         (eqv? ($tt-count) 390))
       ($thread-check)
       ; following tests garbage collection of code created and run by multiple
       ; threads.  gc is done by one thread.  will the others find their instruction
       ; and data caches properly synchronized?
       (let ([thread-count 2] [iterations 10000])
         (equal? (parameterize
                   ([collect-trip-bytes (expt 2 15)]
                    [collect-generation-radix 1])
                   (let ([out '()]
                         [out-mutex (make-mutex)]
                         [out-condition (make-condition)]
                         [error? #f])
                     (do ([i 0 (+ i 1)])
                         ((= i thread-count))
                         (fork-thread
                           (lambda ()
                             (guard (c [#t (with-mutex out-mutex (set! error?
                                                                   c))])
                               (let ([n (eval `(let ()
                                                 (define zero?
                                                   null?)
                                                 (define 1+
                                                   list)
                                                 (define 1-
                                                   car)
                                                 (define zero
                                                   '())
                                                 (define (fatter n)
                                                   (if (= n 0)
                                                       zero
                                                       (1+ (fatter (- n 1)))))
                                                 (define (slimmer x)
                                                   (if (zero? x)
                                                       0
                                                       (+ (slimmer (1- x)) 1)))
                                                 (define fatter+
                                                   (lambda (x y)
                                                     (if (zero? y)
                                                         x
                                                         (fatter+ (1+ x) (1- y)))))
                                                 (define fatterfib
                                                   (lambda (x)
                                                     (if (or (zero? x)
                                                             (zero? (1- x)))
                                                         (1+ zero)
                                                         (fatter+ (fatterfib (1- x))
                                                                  (fatterfib (1- (1- x)))))))
                                                 (let loop ([n ,iterations] [a 0])
                                                   (if (= n 0)
                                                       a
                                                       (loop (- n 1)
                                                             (+ a (slimmer (fatterfib (fatter 10)))))))))])
                                 (with-mutex out-mutex
                                   (set! out (cons n out))
                                   (condition-signal out-condition)))))))
                     (let f ()
                       (printf "waiting for ~s more thread(s)\n"
                               (- thread-count (length out)))
                       (with-mutex out-mutex
                         (unless (or error?
                                     (= (length out) thread-count)
                                     (= (length ($threads)) $nthreads))
                                 (condition-wait out-condition out-mutex)))
                       (cond
                         [error? (raise error?)]
                         [(or (= (length out) thread-count)
                              (= (length ($threads)) $nthreads))
                          (printf "done\n")
                          out]
                         [else (f)]))))
                 (make-list thread-count (* 89 iterations))))
       ($thread-check)
       ; following tries to verify proper synchronization when top-level exports
       ; build up system property list.  need a module with at least 21 exports to
       ; force syntax.ss to consult property list for imports
       (let ([thread-count 20]
             [iterations 100]
             [syms '(a1 a2
                        a3
                        a4
                        a5
                        a6
                        a7
                        a8
                        a9
                        a10
                        a11
                        a12
                        a13
                        a14
                        a15
                        a16
                        a17
                        a18
                        a19
                        a20
                        a21
                        a22
                        a23
                        a24)])
         (equal? (let ([out '()] [out-mutex (make-mutex)] [error? #f])
                   (do ([i 0 (+ i 1)])
                       ((= i thread-count))
                       (fork-thread
                         (lambda ()
                           (guard (c [#t (set! error? c)])
                             (do ([j 0 (+ j 1)])
                                 ((= j iterations))
                                 (eval `(letrec-syntax
                                          ([frob (syntax-rules ()
                                                   [(_ m r) (frobh m r ,syms ,syms ())])]
                                           [frobh (syntax-rules ()
                                                    [(_ m r (s ...) () (q ...))
                                                     (module m
                                                       (r q ...)
                                                       (define-syntax r
                                                         (identifier-syntax
                                                           (list ,(+ (* i thread-count) j) q ...)))
                                                       (define q
                                                         's)
                                                       ...)]
                                                    [(_ m r (a ...) (p0 p ...) (q ...))
                                                     (frobh m r (a ...) (p ...) ($tx q ...))])])
                                          (frob ,(string->symbol (format "m~s-~s" i j)) $tx)))
                                 (let ([v (eval `(let ()
                                                   (import ,(string->symbol (format "m~s-~s" i j)))
                                                   $tx))])
                                   (with-mutex out-mutex (set! out
                                                           (cons v
                                                                 out)))))))))
                   (let f ([n 0])
                     (cond
                       [error? (raise error?)]
                       [(or (= (length out) (* thread-count iterations))
                            (= (length ($threads)) $nthreads))
                        (sort (lambda (x y) (< (car x) (car y))) out)]
                       [else
                        (when (= (modulo n 100000) 0)
                              (printf "waiting ~s ~s\n" n (length out)))
                        (f (+ n 1))])))
                 (sort (lambda (x y) (< (car x) (car y)))
                       (let f ([i 0])
                         (if (= i thread-count)
                             '()
                             (let g ([j 0])
                               (if (= j iterations)
                                   (f (+ i 1))
                                   (cons (cons (+ (* i thread-count) j)
                                               syms)
                                         (g (+ j 1))))))))))
       ($thread-check)
       (let ([thread-count 20] [iterations 100])
         (equal? (let ([out '()] [out-mutex (make-mutex)] [error? #f])
                   (do ([i 0 (+ i 1)])
                       ((= i thread-count))
                       (fork-thread
                         (lambda ()
                           (guard (c [#t (set! error? c)])
                             (do ([j 0 (+ j 1)])
                                 ((= j iterations))
                                 (eval `(letrec-syntax
                                          ([frob (syntax-rules ()
                                                   [(_ a)
                                                    (begin
                                                      (define-syntax $ty
                                                        (identifier-syntax ,(+ (* i thread-count) j)))
                                                      (define-syntax a
                                                        (identifier-syntax $ty)))])])
                                          (frob ,(string->symbol (format "a~s-~s" i j)))))
                                 (let ([v (eval (string->symbol (format "a~s-~s" i j)))])
                                   (with-mutex out-mutex (set! out
                                                           (cons v
                                                                 out)))))))))
                   (let f ([n 0])
                     (cond
                       [error? (raise error?)]
                       [(or (= (length out) (* thread-count iterations))
                            (= (length ($threads)) $nthreads)) (sort < out)]
                       [else
                        (when (= (modulo n 100000) 0)
                              (printf "waiting ~s ~s\n" n (length out)))
                        (f (+ n 1))])))
                 (sort <
                       (let f ([i 0])
                         (if (= i thread-count)
                             '()
                             (let g ([j 0])
                               (if (= j iterations)
                                   (f (+ i 1))
                                   (cons (+ (* i thread-count) j)
                                         (g (+ j 1))))))))))
       ($thread-check)
       ; this mat has some inherent starvation issues, with the main thread
       ; looping rather than waiting on a condition at initialization time and
       ; other threads looping rather than waiting on a condition when looking
       ; for work to steal.  these looping threads can hog the cpu without
       ; doing anything useful, causing progress to stall or halt.  this
       ; manifests as occasional indefinite delays under Windows and OpenBSD,
       ; and it has the potential to cause the same on other operating systems.
       ; it's not clear how to fix the mat without changing it fundamentally.
       #;
       (eqv? (let ()
               ; from Ryan Newton
               (define-syntax ASSERT
                 (lambda (x)
                   (syntax-case x ()
                     [(_ expr)
                      #'(or expr
                            (errorf 'ASSERT "failed: ~s"
                                    (IFCHEZ #'expr (format-syntax #'expr))))]
                     ;; This form is (ASSERT integer? x) returning the value of x.
                     [(_ fun val)
                      #'(let ([v val])
                          (if (fun v)
                              v
                              (errorf 'ASSERT
                                      "failed: ~s\n Value which did not satisfy above predicate: ~s"
                                      (IFCHEZ #'fun (format-syntax #'fun))
                                      v)))])))
               (define test-depth 25)
               ;; Make a tree with 2^test-depth nodes.
               (define vector-build
                 (lambda (n f)
                   (let ([v (make-vector n)])
                     (do ([i 0 (fx+ i 1)])
                         ((= i n) v)
                         (vector-set! v i (f i))))))
               ;; STATE:
               ;; Each thread's stack has a list of frames, from newest to oldest.
               ;; We use a lock-free approach for mutating/reading the frame list.
               ;; Therefore, a thief might steal an old inactive frame, but this poses no problem.
               ;; 
               ;; A thread's "stack" must be as efficient as possible, because
               ;; it essentially replaces the native scheme stack where par calls
               ;; are concerned.  (I wonder if continuations can serve any purpose here.)
               ;; Note, head is the "bottom" and tail is the "top".  We add to tail.
               (define-record shadowstack (id head tail frames))
               ;; Frames are locked individually.
               ;; status may be 'available, 'stolen, or 'done
               (define-record shadowframe (mut status oper argval))
               ;; There's also a global list of threads:
               (define allstacks '#())
               ;; This is effectively immutable.
               (define par-finished #f)
               ;; And a mutex for global state:
               (define global-mut (make-mutex))
               (define threads-registered 1)
               ;; A new stack has no frames, but has a (hopefully) unique ID:
               (define (new-stack)
                 (make-shadowstack
                   (random 10000)
                   0
                   ;; Head pointer.
                   0
                   ;; Tail pointer.
                   (vector-build 50
                     (lambda (_)
                       (make-shadowframe (make-mutex) #f #f #f)))))
               ;; A per-thread parameter.
               (define this-stack
                 (make-thread-parameter (new-stack)))
               ;; Mutated below:
               (define numprocessors #f)
               ;; We spin until everybody is awake.
               (define (wait-for-everybody)
                 (let wait-for-threads ([n 0])
                   ; attempt to prevent apparent occasional starvation on openbsd
                   (when (= n 0)
                         (printf "  ~s ~s\n"
                                 threads-registered
                                 numprocessors))
                   (unless (= threads-registered numprocessors)
                           (wait-for-threads (mod n 1000)))))
               ;; DEBUGGING:
               ;;  Pick a print:
               ;   (define (print . args) (with-mutex global-mut (apply printf args) (flush-output-port)))
               ;   (define (print . args) (apply printf args))
               (define (print . args) (void))
               ;; fizzle
               ;; ----------------------------------------
               (define (init-par num-cpus)
                 (printf "\n  Initializing PAR system for ~s threads.\n"
                         num-cpus)
                 (with-mutex global-mut
                   (ASSERT (eq? threads-registered 1))
                   (set! numprocessors num-cpus)
                   (set! allstacks (make-vector num-cpus))
                   (vector-set! allstacks 0 (this-stack))
                   ;; We fork N-1 threads (the original one counts)
                   (do ([i 1 (fx+ i 1)])
                       ([= i num-cpus] (void))
                       (vector-set! allstacks i (make-worker))))
                 (wait-for-everybody)
                 (printf "Everyone's awake!\n"))
               (define (shutdown-par)
                 (set! par-finished #t))
               (define (par-status)
                 (printf "Par status:\n  par-finished ~s\n  allstacks: ~s\n  stacksizes: ~s\n\n"
                         par-finished
                         (vector-length allstacks)
                         (map shadowstack-tail
                              (vector->list allstacks))))
               ;; ----------------------------------------
               ;; Try to do work and mark it as done.
               (define (steal-work! frame)
                 (and (eq? 'available (shadowframe-status frame))
                      (mutex-acquire (shadowframe-mut frame) #f)
                      ;; Don't block on it
                      ;; From here on out we've got the mutex:
                      (if (eq? 'available (shadowframe-status frame))
                          ;; If someone beat us here, we fizzle
                          #t
                          (begin
                            (mutex-release (shadowframe-mut frame))
                            #f))
                      (begin
                        ;;(printf "STOLE work! ~s\n" frame)
                        (set-shadowframe-status! frame 'stolen)
                        (mutex-release (shadowframe-mut frame))
                        ;; Then let go to do the real work:
                        (set-shadowframe-argval! frame
                          ((shadowframe-oper frame)
                           (shadowframe-argval frame)))
                        (set-shadowframe-status! frame 'done)
                        #t)))
               (define (find-and-steal-once!)
                 (let* ([ind (random numprocessors)]
                        [stack (vector-ref allstacks ind)])
                   (let* ([frames (shadowstack-frames stack)]
                          [tl (shadowstack-tail stack)])
                     (let frmloop ([i 0])
                       (if (fx= i tl)
                           #f
                           ;; No work on this processor, try again. 
                           (if (steal-work! (vector-ref frames i))
                               #t
                               (frmloop (fx+ 1 i))))))))
               (define (make-worker)
                 (define stack (new-stack))
                 (fork-thread
                   (lambda ()
                     (this-stack stack)
                     ;; Initialize stack. 
                     (with-mutex global-mut ;; Register our existence.
                       (set! threads-registered
                         (add1 threads-registered)))
                     ;; Steal work forever:
                     (let forever ()
                       (unless par-finished
                               (find-and-steal-once!)
                               (forever)))))
                 stack)
               (define-syntax pcall
                 (syntax-rules ()
                   [(_ op (f x) e2)
                    (let ([stack (this-stack)])
                      (define (push! oper val)
                        (let ([frame (vector-ref (shadowstack-frames stack)
                                       (shadowstack-tail stack))])
                          ;; Initialize the frame
                          (set-shadowframe-oper! frame oper)
                          (set-shadowframe-argval! frame val)
                          (set-shadowframe-status! frame 'available)
                          (set-shadowstack-tail! stack
                            (fx+ (shadowstack-tail stack) 1))
                          frame))
                      (define (pop!)
                        (set-shadowstack-tail! stack
                          (fx- (shadowstack-tail stack) 1)))
                      (let ([frame (push! f x)])
                        (let ([val1 e2])
                          ;; We're the parent, when we get to this frame, we lock it off from all other comers.
                          ;; Thieves should do non-blocking probes.
                          (let waitloop ()
                            (mutex-acquire (shadowframe-mut frame))
                            (case (shadowframe-status frame)
                              [(available)
                               (set-shadowframe-status! frame 'stolen)
                               ;; Just in case...
                               (pop!)
                               ;; Pop before we even start the thunk.
                               (mutex-release (shadowframe-mut frame))
                               (op ((shadowframe-oper frame)
                                    (shadowframe-argval frame))
                                   val1)]
                              ;; Oops, they may be waiting to get back in here and set the result, let's get out quick.
                              [(stolen)
                               ;; Let go of this so they can finish and mark it as done.
                               (mutex-release (shadowframe-mut frame))
                               (find-and-steal-once!)
                               ;; Meanwhile we should go try to make ourselves useful..                 
                               (waitloop)]
                              ;; When we're done with that come back and see if our outsourced job is done.
                              ;; It was stolen and is now completed:
                              [else
                               (pop!)
                               (mutex-release (shadowframe-mut frame))
                               (op (shadowframe-argval frame) val1)])))))]))
               ;; Returns values in a list
               (define-syntax par
                 (syntax-rules ()
                   [(_ a b) (pcall list ((lambda (_) a) #f) b)]))
               (define-syntax parmv
                 (syntax-rules ()
                   [(_ a b) (pcall values ((lambda (_) a) #f) b)]))
               ;;================================================================================
               (init-par 4)
               (let ()
                 (define (tree n)
                   (if (fxzero? n)
                       1
                       (pcall fx+ (tree (fx- n 1)) (tree (fx- n 1)))))
                 (let ([n (time (tree test-depth))])
                   (shutdown-par)
                   n)))
             33554432)
       ($thread-check)
       ; make sure thread can return zero values
       (eqv? (let ([x #f])
               (fork-thread
                 (lambda ()
                   (call/cc
                     (lambda (k)
                       (set! x 'frob)
                       (k)
                       (set! x 'borf)))))
               (let f () (unless x ($yield) (f)))
               x)
             'frob)
       ($thread-check)
       (equal? (let ()
                 (define n 10)
                 (define m (make-mutex))
                 (define c (make-condition))
                 (define-ftype A (struct (x double) (y iptr)))
                 (define a
                   (make-ftype-pointer A (foreign-alloc (ftype-sizeof A))))
                 (define ls '())
                 (ftype-set! A (x) a 3.4)
                 (ftype-set! A (y) a 1)
                 (with-mutex m
                   (do ([n n (fx- n 1)])
                       ((fx= n 0))
                       (fork-thread
                         (lambda ()
                           (define fat+
                             (lambda (x y)
                               (if (zero? y)
                                   x
                                   (fat+ (1+ x) (1- y)))))
                           (define fatfib
                             (lambda (x)
                               (if (< x 2)
                                   1
                                   (fat+ (fatfib (1- x)) (fatfib (1- (1- x)))))))
                           (do ([i (fx+ 1000 n) (fx- i 1)]
                                [q (fatfib 4) (fatfib 4)])
                               ((fx= i 0)
                                (with-mutex m
                                  (set! ls (cons q ls))
                                  (condition-signal c)))
                               (if (odd? n)
                                   (ftype-locked-incr! A (y) a)
                                   (when (ftype-locked-decr! A (y) a)
                                         (printf "woohoo!\n")))))))
                   (let loop ()
                     (if (equal? (length ls) n)
                         (list (ftype-ref A (x) a) (ftype-ref A (y) a))
                         (begin (condition-wait c m) (loop))))))
               '(3.4 -4))
       ($thread-check)
       (begin (load-shared-object "./foreign1.so") #t)
       (equal? (let ()
                 (define ff-locked-incr!
                   (foreign-procedure "locked_incr" ((* iptr)) boolean))
                 (define ff-locked-decr!
                   (foreign-procedure "locked_decr" ((* iptr)) boolean))
                 (define n 10)
                 (define m (make-mutex))
                 (define c (make-condition))
                 (define-ftype A (struct (x double) (y iptr)))
                 (define a
                   (make-ftype-pointer A (foreign-alloc (ftype-sizeof A))))
                 (define ls '())
                 (ftype-set! A (x) a 3.4)
                 (ftype-set! A (y) a 1)
                 (with-mutex m
                   (do ([n n (fx- n 1)])
                       ((fx= n 0))
                       (fork-thread
                         (lambda ()
                           (define fat+
                             (lambda (x y)
                               (if (zero? y)
                                   x
                                   (fat+ (1+ x) (1- y)))))
                           (define fatfib
                             (lambda (x)
                               (if (< x 2)
                                   1
                                   (fat+ (fatfib (1- x)) (fatfib (1- (1- x)))))))
                           (do ([i (fx+ 1000 n) (fx- i 1)]
                                [q (fatfib 10) (fatfib 10)])
                               ((fx= i 0)
                                (with-mutex m
                                  (set! ls (cons q ls))
                                  (condition-signal c)))
                               (if (odd? n)
                                   (ff-locked-incr! (ftype-&ref A (y) a))
                                   (when (ff-locked-decr! (ftype-&ref A (y) a))
                                         (printf "hoowoo!\n")))))))
                   (let loop ()
                     (if (equal? (length ls) n)
                         (list (ftype-ref A (x) a) (ftype-ref A (y) a))
                         (begin (condition-wait c m) (loop))))))
               '(3.4 -4))
       ($thread-check)
       (eqv? (let ()
               (define n 10)
               (define m (make-mutex))
               (define c (make-condition))
               (define-ftype A (struct (x double) (y iptr)))
               (define a
                 (make-ftype-pointer A (foreign-alloc (ftype-sizeof A))))
               (define ls '())
               (ftype-set! A (x) a 3.5)
               (ftype-init-lock! A (y) a)
               (with-mutex m
                 (do ([n n (fx- n 1)])
                     ((fx= n 0))
                     (fork-thread
                       (lambda ()
                         (define fat+
                           (lambda (x y)
                             (if (zero? y)
                                 x
                                 (fat+ (1+ x) (1- y)))))
                         (define fatfib
                           (lambda (x)
                             (if (< x 2)
                                 1
                                 (fat+ (fatfib (1- x)) (fatfib (1- (1- x)))))))
                         (do ([i (+ 1000 n) (fx- i 1)]
                              [q (fatfib 4) (fatfib 4)])
                             ((fx= i 0)
                              (with-mutex m
                                (set! ls (cons q ls))
                                (condition-signal c)))
                             ; disable collections so we don't rendezvous for collection while holding the lock,
                             ; leaving some other thread spinning hopelessly in ftype-spin-lock!
                             (with-interrupts-disabled
                               (if (odd? i)
                                   (let loop ()
                                     (unless (ftype-lock! A (y) a)
                                             (printf "waiting\n")
                                             (loop)))
                                   (ftype-spin-lock! A (y) a))
                               (ftype-set! A
                                 (x)
                                 a
                                 ((if (odd? n) + -) (ftype-ref A (x) a) 1.0))
                               (ftype-unlock! A (y) a))))))
                 (let loop ()
                   (if (equal? (length ls) n)
                       (ftype-ref A (x) a)
                       (begin (condition-wait c m) (loop))))))
             -1.5)
       ($thread-check)
       (parameterize ([collect-request-handler void])
         (define (expect-error what thunk)
           (guard (c [(and (message-condition? c)
                           (equal? (condition-message c)
                                   (format "~a is defunct" what)))])
                  (thunk)
                  (error #f "error expected")))
         (let ([g (make-guardian)])
           (g (make-mutex))
           (collect)
           (let ([m (g)])
             (expect-error 'mutex (lambda () (mutex-acquire m)))
             (expect-error 'mutex (lambda () (mutex-release m)))
             (expect-error 'mutex
               (lambda ()
                 (condition-wait (make-condition) m))))
           (g (make-condition))
           (collect)
           (let ([c (g)])
             (expect-error 'condition
               (lambda () (condition-wait c (make-mutex))))
             (expect-error 'condition (lambda () (condition-broadcast c)))
             (expect-error 'condition (lambda () (condition-signal c)))))))

  (mat make-thread-parameter
       (begin (define p (make-thread-parameter #f not)) #t)
       (p)
       (begin (p #f) (p))
       (begin (p #t) (not (p)))
       (begin (define q (make-thread-parameter #t)) #t)
       (q)
       (begin (q #f) (not (q)))
       (begin (q #t) (q))
       (or (= (optimize-level) 3)
           (guard (c [(and (message-condition? c)
                           (equal? (condition-message c)
                                   "~s is not a procedure")
                           (irritants-condition? c)
                           (equal? (condition-irritants c) (list 2)))])
                  (make-thread-parameter 1 2)))
       (begin
         (define p
           (make-thread-parameter 5 (lambda (x) (+ x 1))))
         #t)
       (eqv? (p) 6)
       (or (= (optimize-level) 3)
           (guard (c [(and (message-condition? c)
                           (equal? (condition-message c)
                                   "~s is not a number")
                           (irritants-condition? c)
                           (equal? (condition-irritants c) (list 'a)))])
                  (p 'a))))

  (mat cas
       (begin
         (define (check container container-ref container-cas!)
           (let ([N 1000]
                 [M 4]
                 [done 0]
                 [m (make-mutex)]
                 [c (make-condition)])
             (define (bump)
               (let loop ([i 0])
                 (unless (= i N)
                         (let ([v (container-ref container)])
                           (if (container-cas! container v (add1 v))
                               (loop (add1 i))
                               (loop i)))))
               (mutex-acquire m)
               (set! done (add1 done))
               (condition-signal c)
               (mutex-release m))
             (let loop ([j 0])
               (when (< j M)
                     (fork-thread bump)
                     (loop (add1 j))))
             (mutex-acquire m)
             (let loop ()
               (cond
                 [(= done M) (mutex-release m)]
                 [else (condition-wait c m) (loop)]))
             (= (container-ref container) (* M N))))
         (check (box 0) unbox box-cas!))
       (check (vector 1 0 2)
         (lambda (v) (vector-ref v 1))
         (lambda (v o n) (vector-cas! v 1 o n))))
  )
;;; 5_6.ms
;;; Copyright 1984-2017 Cisco Systems, Inc.
;;; 
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;; 
;;; http://www.apache.org/licenses/LICENSE-2.0
;;; 
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

(mat vector (equal? (vector 1 2 3 4) '#(1 2 3 4)) (eq? (vector) '#()))

(mat make-vector
     (eqv? (vector-length (make-vector 10)) 10)
     (eqv? (vector-length (make-vector 100)) 100)
     (eqv? (vector-length (make-vector (+ 100 17))) 117)
     (equal? (make-vector 0) '#())
     (equal? (make-vector 3 'a) '#(a a a))
     (equal? (make-vector 10 '#t) (vector #t #t #t #t #t #t #t #t #t #t))
     (equal? (make-vector (- 4 2) (+ 1 1)) (vector 2 2))
     (eqv? (make-vector (- 4 4) (+ 1 1)) (vector))
     (error? (make-vector 'a 23)))

(mat vector-length
     (eqv? (vector-length '#(a b c)) 3)
     (eqv? (vector-length '#100(a b c)) 100)
     (eqv? (vector-length '#()) 0)
     (error? (vector-length '(a b c))))

(mat $vector-ref-check?
     (let ([v (make-vector 3)]
           [imm-v (vector->immutable-vector (make-vector 3))]
           [not-v (make-fxvector 3)])
       (let ([i-1 -1]
             [i0 0]
             [i1 1]
             [i2 2]
             [i3 3]
             [ifalse #f]
             [ibig (+ (most-positive-fixnum) 1)])
         (and (not (#%$vector-ref-check? not-v i0))
              (not (#%$vector-ref-check? v ifalse))
              (not (#%$vector-ref-check? imm-v ifalse))
              (not (#%$vector-ref-check? v i-1))
              (not (#%$vector-ref-check? imm-v i-1))
              (#%$vector-ref-check? v 0)
              (#%$vector-ref-check? v 1)
              (#%$vector-ref-check? v 2)
              (#%$vector-ref-check? imm-v 0)
              (#%$vector-ref-check? imm-v 1)
              (#%$vector-ref-check? imm-v 2)
              (#%$vector-ref-check? v i0)
              (#%$vector-ref-check? v i1)
              (#%$vector-ref-check? v i2)
              (#%$vector-ref-check? imm-v i0)
              (#%$vector-ref-check? imm-v i1)
              (#%$vector-ref-check? imm-v i2)
              (not (#%$vector-ref-check? v 3))
              (not (#%$vector-ref-check? v i3))
              (not (#%$vector-ref-check? v ibig))
              (not (#%$vector-ref-check? imm-v 3))
              (not (#%$vector-ref-check? imm-v i3))
              (not (#%$vector-ref-check? imm-v ibig))))))


(mat vector-ref
     (eqv? (vector-ref '#(a b c) 0) 'a)
     (eqv? (vector-ref '#(a b c) 1) 'b)
     (eqv? (vector-ref '#(a b c) 2) 'c)
     (error? (vector-ref '#(a b c) 3))
     (error? (vector-ref '#(a b c) -1))
     (error? (vector-ref '#(a b c) 'a))
     (error? (vector-ref '(a b c) 2)))

(mat vector-set!
     (let ((v (vector 'a 'b 'c)))
       (and (begin (vector-set! v 0 'x) (equal? v '#(x b c)))
            (begin (vector-set! v 1 'y) (equal? v '#(x y c)))
            (begin (vector-set! v 2 'z) (equal? v '#(x y z)))))
     (error? (vector-set! (vector 'a 'b 'c) 3 'd))
     (error? (vector-set! (vector 'a 'b 'c) -1 'd))
     (error? (vector-set! (vector 'a 'b 'c) 'a 'd))
     (error? (vector-set! (list 'a 'b 'c) 2 'd)))

(mat vector-set-fixnum!
     (let ((v (vector 'a 'b 'c)))
       (and (begin (vector-set-fixnum! v 0 5) (equal? v '#(5 b c)))
            (begin (vector-set-fixnum! v 1 6) (equal? v '#(5 6 c)))
            (begin (vector-set-fixnum! v 2 7) (equal? v '#(5 6 7)))))
     (let ((v (vector 'a 'b 'c)) (n -1))
       (and (begin
              (set! n (+ n 1))
              (vector-set-fixnum! v n (+ (* n n) 1))
              (equal? v '#(1 b c)))
            (begin (set! n (+ n 1)) (vector-set-fixnum! v n (+ (* n n) 1)) (equal? v '#(1 2 c)))
            (begin (set! n (+ n 1)) (vector-set-fixnum! v n (+ (* n n) 1)) (equal? v '#(1 2 5)))))
     (error? (vector-set-fixnum! (vector 'a 'b 'c) 3 0))
     (error? (vector-set-fixnum! (vector 'a 'b 'c) -1 3))
     (error? (vector-set-fixnum! (vector 'a 'b 'c) 'a 4))
     (error? (vector-set-fixnum! (list 'a 'b 'c) 2 5))
     (error? (vector-set-fixnum! (vector 'a 'b 'c) 2 'd))
     (error? (vector-set-fixnum! (vector 'a 'b 'c) 2 #\d))
     (error? (let ([v (vector 'a 'b 'c)] [n -1] [x '(a b c)])
               (set! n (+ n 2))
               (vector-set-fixnum! v n x))))

(mat vector-copy
     (equal? (vector-copy '#()) '#())
     (equal? (vector-copy '#(a b c)) '#(a b c))
     (let* ((x1 (vector 1 2 3)) (x2 (vector-copy x1)))
       (and (equal? x2 x1) (not (eq? x2 x1))))
     (andmap (lambda (n)
               (let ([v (vector-map random (make-vector n 1000))])
                 (equal? (vector-copy v) v)))
             (map random (make-list 500 2500)))
     (error? (vector-copy '(a b c))))

(mat vector-fill!
     (let ([v (vector-copy '#5(a b c d e))])
       (and (equal? v '#5(a b c d e))
            (begin (vector-fill! v 9) (equal? v '#5(9)))))
     (let ([v (vector-copy '#5(a b c d e))])
       (and (equal? v '#5(a b c d e))
            (begin
              (vector-fill! v (cons 'a 'b))
              (equal? v '#5((a . b))))))
     (error? (let ([v (fxvector)]) (vector-fill! v 3)))
     (let ([v (make-vector 1000)])
       (collect 0 1)
       (let ([x (cons 'a 'b)])
         (vector-fill! v x)
         (collect 0 0)
         (andmap (lambda (y) (eq? y x)) (vector->list v)))))

(mat list->vector
     (equal? (list->vector '(a b c)) '#(a b c))
     (equal? (list->vector '()) '#())
     (error? (list->vector '#(a b c)))
     (error? (list->vector '(#\a #\b . #\c)))
     (error? (list->vector
               (let ([ls (list #\a #\b #\c)])
                 (set-cdr! (cddr ls) (cdr ls))
                 ls))))

(mat vector->list
     (equal? (vector->list '#(a b c)) '(a b c))
     (equal? (vector->list '#()) '())
     (error? (vector->list '(a b c))))

(mat fxvector
     (equal? (fxvector 1 2 3 4) '#vfx(1 2 3 4))
     (eq? (fxvector) '#vfx())
     (fxvector? (fxvector (most-positive-fixnum)))
     (fxvector? (fxvector (most-negative-fixnum)))
     (error? (fxvector (+ (most-positive-fixnum) 1)))
     (error? (fxvector (- (most-negative-fixnum) 1)))
     (error? (fxvector 1 2 'a 4)))

(mat make-fxvector
     (eqv? (fxvector-length (make-fxvector 10)) 10)
     (eqv? (fxvector-length (make-fxvector 100)) 100)
     (eqv? (fxvector-length (make-fxvector (+ 100 17))) 117)
     (eq? (make-fxvector 0) '#vfx())
     (let ([x (make-fxvector 10)])
       (and (= (fxvector-length x) 10)
            (andmap fixnum? (fxvector->list x))))
     (error? (make-fxvector 3 'a))
     (error? (make-fxvector 10 (+ (most-positive-fixnum) 1)))
     (error? (make-fxvector 10 (- (most-negative-fixnum) 1)))
     (equal? (make-fxvector 10 7) (fxvector 7 7 7 7 7 7 7 7 7 7))
     (equal? (make-fxvector (- 4 2) (+ 1 1)) (fxvector 2 2))
     (eqv? (make-fxvector (- 4 4) (+ 1 1)) (fxvector)))

(mat fxvector-syntax
     (eq? '#vfx() '#vfx())
     (eq? '#0vfx() #vfx())
     (equal? '(#vfx(1 2 3) #3vfx(1 2 3) #6vfx(1 2 3))
             (list (fxvector 1 2 3)
                   (fxvector 1 2 3)
                   (fxvector 1 2 3 3 3 3)))
     (let ([x #10vfx()])
       (and (= (fxvector-length x) 10)
            (andmap fixnum? (fxvector->list x))))
     ; the following is invalid because the reader doesn't allow graph marks
     ; and references within an fxvector
     ; (equal? '(#0=#vfx(#1=33 #2# #1# #2=44 #3#) #2# #3=55)
     ;         '(#vfx(33 44 33 44 55) 44 55))
     )

(mat fxvector-length
     (eqv? (fxvector-length '#vfx(3 4 5)) 3)
     (eqv? (fxvector-length '#100vfx(5 4 3)) 100)
     (eqv? (fxvector-length '#vfx()) 0)
     (error? (fxvector-length '(a b c))))

(mat $fxvector-ref-check?
     (let ([fv (make-fxvector 3)]
           [imm-fv (fxvector->immutable-fxvector (make-fxvector 3))]
           [not-fv (make-vector 3)])
       (let ([i-1 -1]
             [i0 0]
             [i1 1]
             [i2 2]
             [i3 3]
             [ifalse #f]
             [ibig (+ (most-positive-fixnum) 1)])
         (and (not (#%$fxvector-ref-check? not-fv i0))
              (not (#%$fxvector-ref-check? fv ifalse))
              (not (#%$fxvector-ref-check? fv i-1))
              (not (#%$fxvector-ref-check? imm-fv i-1))
              (#%$fxvector-ref-check? fv 0)
              (#%$fxvector-ref-check? fv 1)
              (#%$fxvector-ref-check? fv 2)
              (#%$fxvector-ref-check? imm-fv 0)
              (#%$fxvector-ref-check? imm-fv 1)
              (#%$fxvector-ref-check? imm-fv 2)
              (#%$fxvector-ref-check? fv i0)
              (#%$fxvector-ref-check? fv i1)
              (#%$fxvector-ref-check? fv i2)
              (#%$fxvector-ref-check? imm-fv i0)
              (#%$fxvector-ref-check? imm-fv i1)
              (#%$fxvector-ref-check? imm-fv i2)
              (not (#%$fxvector-ref-check? fv 3))
              (not (#%$fxvector-ref-check? fv i3))
              (not (#%$fxvector-ref-check? fv ibig))
              (not (#%$fxvector-ref-check? imm-fv 3))
              (not (#%$fxvector-ref-check? imm-fv i3))
              (not (#%$fxvector-ref-check? imm-fv ibig))))))

(mat fxvector-ref
     (eqv? (fxvector-ref '#vfx(3 4 5) 0) '3)
     (eqv? (fxvector-ref '#vfx(3 4 5) 1) '4)
     (eqv? (fxvector-ref '#vfx(3 4 5) 2) '5)
     (eqv? (fxvector-ref (fxvector (most-positive-fixnum)) 0)
           (most-positive-fixnum))
     (eqv? (fxvector-ref (fxvector (most-negative-fixnum)) 0)
           (most-negative-fixnum))
     (error? (fxvector-ref '#vfx(3 4 5) 3))
     (error? (fxvector-ref '#vfx(3 4 5) -1))
     (error? (fxvector-ref '#vfx(3 4 5) 'a))
     (error? (fxvector-ref '#(3 4 5) 2))
     (error? (fxvector-ref '(3 4 5) 2)))

(mat fxvector-set!
     (let ((v (fxvector '3 '4 '5)))
       (and (begin (fxvector-set! v 0 '33) (equal? v '#vfx(33 4 5)))
            (begin (fxvector-set! v 1 '44) (equal? v '#vfx(33 44 5)))
            (begin (fxvector-set! v 2 '55) (equal? v '#vfx(33 44 55)))))
     (error? (fxvector-set! (fxvector '3 '4 '5) 3 'd))
     (error? (fxvector-set! (fxvector '3 '4 '5) -1 'd))
     (error? (fxvector-set! (fxvector '3 '4 '5) 'a 'd))
     (error? (fxvector-set! (fxvector '3 '4 '5) 2 'd))
     (error? (fxvector-set! (list '3 '4 '5) 2 'd))
     (error? (fxvector-set!
               (fxvector 3 4 5)
               1
               (- (most-negative-fixnum) 1)))
     (error? (fxvector-set!
               (fxvector 3 4 5)
               0
               (+ (most-positive-fixnum) 1)))
     (begin
       (define test-fxvector-set!
         (lambda (v i x) (fxvector-set! v i x)))
       #t)
     (equal? (let ([v (fxvector 3 4 5)])
               (test-fxvector-set! v 0 -3)
               (test-fxvector-set! v 1 -4)
               (test-fxvector-set! v 2 17)
               v)
             #vfx(-3 -4 17))
     (error? (test-fxvector-set! (list 3 4 5) 0 9))
     (error? (test-fxvector-set! (vector 3 4) 0 9))
     (error? (test-fxvector-set! (fxvector 3 4 5) 3 9))
     (error? (test-fxvector-set! (fxvector 3 4 5) -3 9))
     (error? (test-fxvector-set! (fxvector 3 4 5)
               (+ (most-positive-fixnum) 1)
               9))
     (error? (test-fxvector-set! (fxvector 3 4 5)
               (- (most-negative-fixnum) 1)
               9))
     (error? (test-fxvector-set! (fxvector 3 4 5) 'a 9))
     (error? (test-fxvector-set!
               (fxvector 3 4 5)
               2
               (+ (most-positive-fixnum) 1)))
     (error? (test-fxvector-set!
               (fxvector 3 4 5)
               2
               (- (most-negative-fixnum) 1)))
     (error? (test-fxvector-set! (fxvector 3 4 5) 2 'a)))

(mat fxvector-copy
     (equal? (fxvector-copy '#vfx()) '#vfx())
     (equal? (fxvector-copy '#vfx(3 4 5)) '#vfx(3 4 5))
     (let* ((x1 (fxvector 1 2 3)) (x2 (fxvector-copy x1)))
       (and (equal? x2 x1) (not (eq? x2 x1))))
     (andmap (lambda (n)
               (let ([v (list->fxvector (map random (make-list n 1000)))])
                 (equal? (fxvector-copy v) v)))
             (map random (make-list 500 2500)))
     (error? (fxvector-copy '(a b c))))

(mat fxvector-fill!
     (let ([v (fxvector-copy '#5vfx(1 2 3 4 5))])
       (and (equal? v '#5vfx(1 2 3 4 5))
            (begin
              (fxvector-fill! v 9)
              (equal? v '#5vfx(9)))))
     (let ([v (fxvector-copy '#5vfx(1 2 3 4 5))])
       (and (equal? v '#5vfx(1 2 3 4 5))
            (begin
              (fxvector-fill! v -17)
              (equal? v '#5vfx(-17)))))
     (error? (let ([v (fxvector 1)]) (fxvector-fill! v 'a)))
     (error? (let ([v (vector 1)]) (fxvector-fill! v 3))))

(mat list->fxvector
     (equal? (list->fxvector '(1 2 3)) '#vfx(1 2 3))
     (equal? (list->fxvector '()) '#vfx())
     (error? (list->fxvector '#(a b c)))
     (error? (list->fxvector '(1 2 . 3)))
     (error? (list->fxvector
               (let ([ls (list 1 2 3)])
                 (set-cdr! (cddr ls) (cdr ls))
                 ls))))

(mat fxvector->list
     (equal? (fxvector->list '#vfx(1 2 3)) '(1 2 3))
     (equal? (fxvector->list '#vfx()) '())
     (error? (fxvector->list '(a b c))))

(mat vector-map
     (error? ; invalid number of arguments
             (vector-map))
     (error? ; invalid number of arguments
             (vector-map '#()))
     (error? ; invalid number of arguments
             (vector-map +))
     (error? ; non procedure '#()
             (vector-map '#() '#()))
     (error? ; non procedure '#()
             (vector-map '#() '#() '#()))
     (error? ; non procedure '#()
             (vector-map '#() '#() '#() '()))
     (error? ; non procedure '#()
             (vector-map '#() '#() '#() '#() '#()))
     (error? ; non vector 3
             (vector-map + 3))
     (error? ; non vector (3)
             (vector-map + '#() '(3)))
     (error? ; non vector (3)
             (vector-map + '#() '#() '(3)))
     (error? ; non vector (3)
             (vector-map + '#() '#() '(3) '#()))
     (error? ; non vector 7
             (vector-map + 7 '#() '#() '#() '#()))
     (error? ; lengths differ
             (vector-map + '#() '#(x)))
     (error? ; lengths differ
             (vector-map + '#() '#() '#(x)))
     (error? ; lengths differ
             (vector-map + '#() '#() '#(x) '#()))
     (error? ; lengths differ
             (vector-map + '#(y) '#() '#(x) '#()))
     (error? ; lengths differ
             (vector-map + '#(y) '#() '#() '#() '#()))

     (equal? (vector-map + '#()) '#())
     (equal? (vector-map + '#(1)) '#(1))
     (equal? (vector-map + '#(1 2)) '#(1 2))
     (equal? (vector-map + '#(1 2 3)) '#(1 2 3))
     (equal? (vector-map + '#(1 2 3 4)) '#(1 2 3 4))
     (equal? (vector-map + (make-vector 100 7)) '#100(7))

     (equal? (vector-map list '#() '#()) '#())
     (equal? (vector-map list '#(1) '#(5)) '#((1 5)))
     (equal? (vector-map list '#(1 2) '#(5 7)) '#((1 5) (2 7)))
     (equal? (vector-map list '#(1 2 3) '#(a b c)) '#((1 a) (2 b) (3 c)))
     (equal? (vector-map list '#(1 2 3 4) '#(a b c d))
             '#((1 a) (2 b) (3 c) (4 d)))

     (equal? (vector-map list '#() '#() '#()) '#())
     (equal? (vector-map list '#(1) '#(5) '#(a)) '#((1 5 a)))
     (equal? (vector-map list '#(1 2) '#(5 7) '#(a b)) '#((1 5 a) (2 7 b)))
     (equal? (vector-map list '#(1 2 3) '#(5 7 9) '#(a b c))
             '#((1 5 a) (2 7 b) (3 9 c)))
     (equal? (vector-map list '#(1 2 3 4) '#(5 7 9 11) '#(a b c d))
             '#((1 5 a) (2 7 b) (3 9 c) (4 11 d)))

     (equal? (vector-map list '#() '#() '#() '#()) '#())
     (equal? (vector-map list '#(#\a) '#(1) '#(5) '#(a)) '#((#\a 1 5 a)))
     (equal? (vector-map list '#(#\a #\b) '#(1 2) '#(5 7) '#(a b))
             '#((#\a 1 5 a) (#\b 2 7 b)))
     (equal? (vector-map list
               '#(#\a #\b #\c)
               '#(1 2 3)
               '#(5 7 9)
               '#(a b c))
             '#((#\a 1 5 a) (#\b 2 7 b) (#\c 3 9 c)))
     (equal? (vector-map list
               '#(#\a #\b #\c #\d)
               '#(1 2 3 4)
               '#(5 7 9 11)
               '#(a b c d))
             '#((#\a 1 5 a) (#\b 2 7 b) (#\c 3 9 c) (#\d 4 11 d)))
     (let ([orig-v #f] [orig-elts #f] [next #f])
       (let ([n 100])
         (let ([v (vector-map (lambda (x) (cons (call/cc values) x))
                    (list->vector (iota n)))])
           (if orig-v
               (unless (andmap eq? (vector->list orig-v) orig-elts)
                       (errorf #f "original vector-map elts mutated"))
               (begin
                 (set! orig-v v)
                 (set! orig-elts (vector->list v))
                 (set! next 0)))
           (let ([m next])
             (unless (= m n)
                     (set! next (fx+ next 1))
                     (let ([p (vector-ref orig-v m)])
                       (unless (eqv? (cdr p) m)
                               (errorf #f
                                       "unexpected cdr value (~s instead of ~s)"
                                       (cdr p)
                                       m))
                       ((car p) n)))))
         (eqv? next n)))
     (begin
       (define ($vector-map-f1 p x1 x2 x3 x4 x5)
         (vector (vector-map p '#())
           (vector-map p '#() x1)
           (vector-map p '#() x1 x2)
           (vector-map p '#() x1 x2 x3)
           (vector-map p '#() x1 x2 x3 x4)
           (vector-map p '#() x1 x2 x3 x4 x5)
           (vector-map p x1 '#())
           (vector-map p x1 '#() x2)
           (vector-map p x1 '#() x2 x3)
           (vector-map p x1 '#() x2 x3 x4)
           (vector-map p x1 '#() x2 x3 x4 x5)
           (vector-map p x1 x2 '#())
           (vector-map p x1 x2 '#() x3)
           (vector-map p x1 x2 '#() x3 x4)
           (vector-map p x1 x2 '#() x3 x4 x5)
           (vector-map p x1 x2 x3 '#())
           (vector-map p x1 x2 x3 '#() x4)
           (vector-map p x1 x2 x3 '#() x4 x5)
           (vector-map p x1 x2 x3 x4 '#())
           (vector-map p x1 x2 x3 x4 '#() x5)
           (vector-map p x1 x2 x3 x4 x5 '#())))
       (procedure? $vector-map-f1))
     (equal? ($vector-map-f1 vector '#() '#() '#() '#() '#())
             '#(#()
                #()
                #()
                #()
                #()
                #()
                #()
                #()
                #()
                #()
                #()
                #()
                #()
                #()
                #()
                #()
                #()
                #()
                #()
                #()
                #()))
     (begin
       (define ($vector-map-f1 p x1 x2 x3 x4 x5)
         (vector (vector-map p '#(a))
           (vector-map p '#(a) x1)
           (vector-map p '#(a) x1 x2)
           (vector-map p '#(a) x1 x2 x3)
           (vector-map p '#(a) x1 x2 x3 x4)
           (vector-map p '#(a) x1 x2 x3 x4 x5)
           (vector-map p x1 '#(a))
           (vector-map p x1 '#(a) x2)
           (vector-map p x1 '#(a) x2 x3)
           (vector-map p x1 '#(a) x2 x3 x4)
           (vector-map p x1 '#(a) x2 x3 x4 x5)
           (vector-map p x1 x2 '#(a))
           (vector-map p x1 x2 '#(a) x3)
           (vector-map p x1 x2 '#(a) x3 x4)
           (vector-map p x1 x2 '#(a) x3 x4 x5)
           (vector-map p x1 x2 x3 '#(a))
           (vector-map p x1 x2 x3 '#(a) x4)
           (vector-map p x1 x2 x3 '#(a) x4 x5)
           (vector-map p x1 x2 x3 x4 '#(a))
           (vector-map p x1 x2 x3 x4 '#(a) x5)
           (vector-map p x1 x2 x3 x4 x5 '#(a))))
       (procedure? $vector-map-f1))
     (equal? ($vector-map-f1 vector '#(1) '#(4) '#(d) '#(g) '#(7))
       '#(#(#(a))
          #(#(a 1))
          #(#(a 1 4))
          #(#(a 1 4 d))
          #(#(a 1 4 d g))
          #(#(a 1 4 d g 7))
          #(#(1 a))
          #(#(1 a 4))
          #(#(1 a 4 d))
          #(#(1 a 4 d g))
          #(#(1 a 4 d g 7))
          #(#(1 4 a))
          #(#(1 4 a d))
          #(#(1 4 a d g))
          #(#(1 4 a d g 7))
          #(#(1 4 d a))
          #(#(1 4 d a g))
          #(#(1 4 d a g 7))
          #(#(1 4 d g a))
          #(#(1 4 d g a 7))
          #(#(1 4 d g 7 a))))
     (begin
       (define ($vector-map-f1 p x1 x2 x3 x4 x5)
         (vector (vector-map p '#(a b))
           (vector-map p '#(a b) x1)
           (vector-map p '#(a b) x1 x2)
           (vector-map p '#(a b) x1 x2 x3)
           (vector-map p '#(a b) x1 x2 x3 x4)
           (vector-map p '#(a b) x1 x2 x3 x4 x5)
           (vector-map p x1 '#(a b))
           (vector-map p x1 '#(a b) x2)
           (vector-map p x1 '#(a b) x2 x3)
           (vector-map p x1 '#(a b) x2 x3 x4)
           (vector-map p x1 '#(a b) x2 x3 x4 x5)
           (vector-map p x1 x2 '#(a b))
           (vector-map p x1 x2 '#(a b) x3)
           (vector-map p x1 x2 '#(a b) x3 x4)
           (vector-map p x1 x2 '#(a b) x3 x4 x5)
           (vector-map p x1 x2 x3 '#(a b))
           (vector-map p x1 x2 x3 '#(a b) x4)
           (vector-map p x1 x2 x3 '#(a b) x4 x5)
           (vector-map p x1 x2 x3 x4 '#(a b))
           (vector-map p x1 x2 x3 x4 '#(a b) x5)
           (vector-map p x1 x2 x3 x4 x5 '#(a b))))
       (procedure? $vector-map-f1))
     (equal? ($vector-map-f1 vector
               '#(1 2)
               '#(4 5)
               '#(d e)
               '#(g h)
               '#(7 j))
       '#(#(#(a) #(b))
          #(#(a 1) #(b 2))
          #(#(a 1 4) #(b 2 5))
          #(#(a 1 4 d) #(b 2 5 e))
          #(#(a 1 4 d g) #(b 2 5 e h))
          #(#(a 1 4 d g 7) #(b 2 5 e h j))
          #(#(1 a) #(2 b))
          #(#(1 a 4) #(2 b 5))
          #(#(1 a 4 d) #(2 b 5 e))
          #(#(1 a 4 d g) #(2 b 5 e h))
          #(#(1 a 4 d g 7) #(2 b 5 e h j))
          #(#(1 4 a) #(2 5 b))
          #(#(1 4 a d) #(2 5 b e))
          #(#(1 4 a d g) #(2 5 b e h))
          #(#(1 4 a d g 7) #(2 5 b e h j))
          #(#(1 4 d a) #(2 5 e b))
          #(#(1 4 d a g) #(2 5 e b h))
          #(#(1 4 d a g 7) #(2 5 e b h j))
          #(#(1 4 d g a) #(2 5 e h b))
          #(#(1 4 d g a 7) #(2 5 e h b j))
          #(#(1 4 d g 7 a) #(2 5 e h j b))))
     (begin
       (define ($vector-map-f1 p x1 x2 x3 x4 x5)
         (vector (vector-map p '#(a b c))
           (vector-map p '#(a b c) x1)
           (vector-map p '#(a b c) x1 x2)
           (vector-map p '#(a b c) x1 x2 x3)
           (vector-map p '#(a b c) x1 x2 x3 x4)
           (vector-map p '#(a b c) x1 x2 x3 x4 x5)
           (vector-map p x1 '#(a b c))
           (vector-map p x1 '#(a b c) x2)
           (vector-map p x1 '#(a b c) x2 x3)
           (vector-map p x1 '#(a b c) x2 x3 x4)
           (vector-map p x1 '#(a b c) x2 x3 x4 x5)
           (vector-map p x1 x2 '#(a b c))
           (vector-map p x1 x2 '#(a b c) x3)
           (vector-map p x1 x2 '#(a b c) x3 x4)
           (vector-map p x1 x2 '#(a b c) x3 x4 x5)
           (vector-map p x1 x2 x3 '#(a b c))
           (vector-map p x1 x2 x3 '#(a b c) x4)
           (vector-map p x1 x2 x3 '#(a b c) x4 x5)
           (vector-map p x1 x2 x3 x4 '#(a b c))
           (vector-map p x1 x2 x3 x4 '#(a b c) x5)
           (vector-map p x1 x2 x3 x4 x5 '#(a b c))))
       (procedure? $vector-map-f1))
     (equal? ($vector-map-f1 vector
               '#(1 2 3)
               '#(4 5 6)
               '#(d e f)
               '#(g h i)
               '#(7 j 9))
       '#(#(#(a) #(b) #(c))
          #(#(a 1) #(b 2) #(c 3))
          #(#(a 1 4) #(b 2 5) #(c 3 6))
          #(#(a 1 4 d) #(b 2 5 e) #(c 3 6 f))
          #(#(a 1 4 d g) #(b 2 5 e h) #(c 3 6 f i))
          #(#(a 1 4 d g 7) #(b 2 5 e h j) #(c 3 6 f i 9))
          #(#(1 a) #(2 b) #(3 c))
          #(#(1 a 4) #(2 b 5) #(3 c 6))
          #(#(1 a 4 d) #(2 b 5 e) #(3 c 6 f))
          #(#(1 a 4 d g) #(2 b 5 e h) #(3 c 6 f i))
          #(#(1 a 4 d g 7) #(2 b 5 e h j) #(3 c 6 f i 9))
          #(#(1 4 a) #(2 5 b) #(3 6 c))
          #(#(1 4 a d) #(2 5 b e) #(3 6 c f))
          #(#(1 4 a d g) #(2 5 b e h) #(3 6 c f i))
          #(#(1 4 a d g 7) #(2 5 b e h j) #(3 6 c f i 9))
          #(#(1 4 d a) #(2 5 e b) #(3 6 f c))
          #(#(1 4 d a g) #(2 5 e b h) #(3 6 f c i))
          #(#(1 4 d a g 7) #(2 5 e b h j) #(3 6 f c i 9))
          #(#(1 4 d g a) #(2 5 e h b) #(3 6 f i c))
          #(#(1 4 d g a 7) #(2 5 e h b j) #(3 6 f i c 9))
          #(#(1 4 d g 7 a) #(2 5 e h j b) #(3 6 f i 9 c))))
     (begin
       (define ($vector-map-f1 p x1 x2 x3 x4 x5)
         (vector (vector-map p '#(a b c d))
           (vector-map p '#(a b c d) x1)
           (vector-map p '#(a b c d) x1 x2)
           (vector-map p '#(a b c d) x1 x2 x3)
           (vector-map p '#(a b c d) x1 x2 x3 x4)
           (vector-map p '#(a b c d) x1 x2 x3 x4 x5)
           (vector-map p x1 '#(a b c d))
           (vector-map p x1 '#(a b c d) x2)
           (vector-map p x1 '#(a b c d) x2 x3)
           (vector-map p x1 '#(a b c d) x2 x3 x4)
           (vector-map p x1 '#(a b c d) x2 x3 x4 x5)
           (vector-map p x1 x2 '#(a b c d))
           (vector-map p x1 x2 '#(a b c d) x3)
           (vector-map p x1 x2 '#(a b c d) x3 x4)
           (vector-map p x1 x2 '#(a b c d) x3 x4 x5)
           (vector-map p x1 x2 x3 '#(a b c d))
           (vector-map p x1 x2 x3 '#(a b c d) x4)
           (vector-map p x1 x2 x3 '#(a b c d) x4 x5)
           (vector-map p x1 x2 x3 x4 '#(a b c d))
           (vector-map p x1 x2 x3 x4 '#(a b c d) x5)
           (vector-map p x1 x2 x3 x4 x5 '#(a b c d))))
       (procedure? $vector-map-f1))
     (equal? ($vector-map-f1 vector
               '#(1 2 3 4)
               '#(f g h i)
               '#(k l m n)
               '#(p q r s)
               '#(u v w x))
       '#(#(#(a) #(b) #(c) #(d))
          #(#(a 1) #(b 2) #(c 3) #(d 4))
          #(#(a 1 f) #(b 2 g) #(c 3 h) #(d 4 i))
          #(#(a 1 f k) #(b 2 g l) #(c 3 h m) #(d 4 i n))
          #(#(a 1 f k p) #(b 2 g l q) #(c 3 h m r) #(d 4 i n s))
          #(#(a 1 f k p u) #(b 2 g l q v) #(c 3 h m r w) #(d 4 i n s x))
          #(#(1 a) #(2 b) #(3 c) #(4 d))
          #(#(1 a f) #(2 b g) #(3 c h) #(4 d i))
          #(#(1 a f k) #(2 b g l) #(3 c h m) #(4 d i n))
          #(#(1 a f k p) #(2 b g l q) #(3 c h m r) #(4 d i n s))
          #(#(1 a f k p u) #(2 b g l q v) #(3 c h m r w) #(4 d i n s x))
          #(#(1 f a) #(2 g b) #(3 h c) #(4 i d))
          #(#(1 f a k) #(2 g b l) #(3 h c m) #(4 i d n))
          #(#(1 f a k p) #(2 g b l q) #(3 h c m r) #(4 i d n s))
          #(#(1 f a k p u) #(2 g b l q v) #(3 h c m r w) #(4 i d n s x))
          #(#(1 f k a) #(2 g l b) #(3 h m c) #(4 i n d))
          #(#(1 f k a p) #(2 g l b q) #(3 h m c r) #(4 i n d s))
          #(#(1 f k a p u) #(2 g l b q v) #(3 h m c r w) #(4 i n d s x))
          #(#(1 f k p a) #(2 g l q b) #(3 h m r c) #(4 i n s d))
          #(#(1 f k p a u) #(2 g l q b v) #(3 h m r c w) #(4 i n s d x))
          #(#(1 f k p u a) #(2 g l q v b) #(3 h m r w c) #(4 i n s x d))))
     (begin
       (define ($vector-map-f1 p x1 x2 x3 x4 x5)
         (vector (vector-map p '#(a b c d e))
           (vector-map p '#(a b c d e) x1)
           (vector-map p '#(a b c d e) x1 x2)
           (vector-map p '#(a b c d e) x1 x2 x3)
           (vector-map p '#(a b c d e) x1 x2 x3 x4)
           (vector-map p '#(a b c d e) x1 x2 x3 x4 x5)
           (vector-map p x1 '#(a b c d e))
           (vector-map p x1 '#(a b c d e) x2)
           (vector-map p x1 '#(a b c d e) x2 x3)
           (vector-map p x1 '#(a b c d e) x2 x3 x4)
           (vector-map p x1 '#(a b c d e) x2 x3 x4 x5)
           (vector-map p x1 x2 '#(a b c d e))
           (vector-map p x1 x2 '#(a b c d e) x3)
           (vector-map p x1 x2 '#(a b c d e) x3 x4)
           (vector-map p x1 x2 '#(a b c d e) x3 x4 x5)
           (vector-map p x1 x2 x3 '#(a b c d e))
           (vector-map p x1 x2 x3 '#(a b c d e) x4)
           (vector-map p x1 x2 x3 '#(a b c d e) x4 x5)
           (vector-map p x1 x2 x3 x4 '#(a b c d e))
           (vector-map p x1 x2 x3 x4 '#(a b c d e) x5)
           (vector-map p x1 x2 x3 x4 x5 '#(a b c d e))))
       (procedure? $vector-map-f1))
     (equal? ($vector-map-f1 vector
               '#(1 2 3 4 5)
               '#(f g h i j)
               '#(k l m n o)
               '#(p q r s t)
               '#(u v w x y))
       '#(#(#(a) #(b) #(c) #(d) #(e))
          #(#(a 1) #(b 2) #(c 3) #(d 4) #(e 5))
          #(#(a 1 f) #(b 2 g) #(c 3 h) #(d 4 i) #(e 5 j))
          #(#(a 1 f k) #(b 2 g l) #(c 3 h m) #(d 4 i n) #(e 5 j o))
          #(#(a 1 f k p)
            #(b 2 g l q)
            #(c 3 h m r)
            #(d 4 i n s)
            #(e 5 j o t))
          #(#(a 1 f k p u)
            #(b 2 g l q v)
            #(c 3 h m r w)
            #(d 4 i n s x)
            #(e 5 j o t y))
          #(#(1 a) #(2 b) #(3 c) #(4 d) #(5 e))
          #(#(1 a f) #(2 b g) #(3 c h) #(4 d i) #(5 e j))
          #(#(1 a f k) #(2 b g l) #(3 c h m) #(4 d i n) #(5 e j o))
          #(#(1 a f k p)
            #(2 b g l q)
            #(3 c h m r)
            #(4 d i n s)
            #(5 e j o t))
          #(#(1 a f k p u)
            #(2 b g l q v)
            #(3 c h m r w)
            #(4 d i n s x)
            #(5 e j o t y))
          #(#(1 f a) #(2 g b) #(3 h c) #(4 i d) #(5 j e))
          #(#(1 f a k) #(2 g b l) #(3 h c m) #(4 i d n) #(5 j e o))
          #(#(1 f a k p)
            #(2 g b l q)
            #(3 h c m r)
            #(4 i d n s)
            #(5 j e o t))
          #(#(1 f a k p u)
            #(2 g b l q v)
            #(3 h c m r w)
            #(4 i d n s x)
            #(5 j e o t y))
          #(#(1 f k a) #(2 g l b) #(3 h m c) #(4 i n d) #(5 j o e))
          #(#(1 f k a p)
            #(2 g l b q)
            #(3 h m c r)
            #(4 i n d s)
            #(5 j o e t))
          #(#(1 f k a p u)
            #(2 g l b q v)
            #(3 h m c r w)
            #(4 i n d s x)
            #(5 j o e t y))
          #(#(1 f k p a)
            #(2 g l q b)
            #(3 h m r c)
            #(4 i n s d)
            #(5 j o t e))
          #(#(1 f k p a u)
            #(2 g l q b v)
            #(3 h m r c w)
            #(4 i n s d x)
            #(5 j o t e y))
          #(#(1 f k p u a)
            #(2 g l q v b)
            #(3 h m r w c)
            #(4 i n s x d)
            #(5 j o t y e)))))

(mat vector-for-each
     (error? ; invalid number of arguments
             (vector-for-each))
     (error? ; invalid number of arguments
             (vector-for-each '#()))
     (error? ; invalid number of arguments
             (vector-for-each +))
     (error? ; non procedure '#()
             (vector-for-each '#() '#()))
     (error? ; non procedure '#()
             (vector-for-each '#() '#() '#()))
     (error? ; non procedure '#()
             (vector-for-each '#() '#() '#() '()))
     (error? ; non procedure '#()
             (vector-for-each '#() '#() '#() '#() '#()))
     (error? ; non vector 3
             (vector-for-each + 3))
     (error? ; non vector (3)
             (vector-for-each + '#() '(3)))
     (error? ; non vector (3)
             (vector-for-each + '#() '#() '(3)))
     (error? ; non vector (3)
             (vector-for-each + '#() '#() '(3) '#()))
     (error? ; non vector 7
       (vector-for-each + 7 '#() '#() '#() '#()))
     (error? ; lengths differ
             (vector-for-each + '#() '#(x)))
     (error? ; lengths differ
             (vector-for-each + '#() '#() '#(x)))
     (error? ; lengths differ
             (vector-for-each + '#() '#() '#(x) '#()))
     (error? ; lengths differ
             (vector-for-each + '#(y) '#() '#(x) '#()))
     (error? ; lengths differ
       (vector-for-each + '#(y) '#() '#() '#() '#()))
     (equal? (vector-for-each + '#()) (void))
     (equal? (vector-for-each + '#() '#()) (void))
     (equal? (vector-for-each + '#() '#() '#()) (void))
     (equal? (vector-for-each + '#() '#() '#() '#() '#()) (void))
     (equal? (let ([ls '()])
               (vector-for-each (lambda (x) (set! ls (cons x ls)))
                 '#(a b c d e f))
               ls)
             '(f e d c b a))
     (equal? (let ([ls '()])
               (vector-for-each
                 (lambda (x y)
                   (set! ls (cons (cons x y) ls)))
                 '#(a b c d e f)
                 '#(3 2 7 6 5 4))
               ls)
             '((f . 4) (e . 5) (d . 6) (c . 7) (b . 2) (a . 3)))
     (equal? (let ([ls '()])
               (vector-for-each (lambda r (set! ls (cons r ls)))
                 '#(a b c d e f)
                 '#(3 2 7 6 5 4)
                 '#(-1 -2 -3 -4 -5 -6))
               ls)
             '((f 4 -6) (e 5 -5) (d 6 -4) (c 7 -3) (b 2 -2) (a 3 -1)))
     (equal? (let ([ls '()])
               (vector-for-each (lambda r (set! ls (cons r ls)))
                 '#(a b c d e f)
                 '#(3 2 7 6 5 4)
                 '#(-1 -2 -3 -4 -5 -6)
                 '#(m n o p q r)
                 '#(z y x w v u))
               ls)
             '((f 4 -6 r u)
               (e 5 -5 q v)
               (d 6 -4 p w)
               (c 7 -3 o x)
               (b 2 -2 n y)
               (a 3 -1 m z)))
     (begin
       (define ($vector-for-each-f1 p x1 x2 x3 x4 x5)
         (begin
           (vector-for-each p '#())
           (vector-for-each p '#() x1)
           (vector-for-each p '#() x1 x2)
           (vector-for-each p '#() x1 x2 x3)
           (vector-for-each p '#() x1 x2 x3 x4)
           (vector-for-each p '#() x1 x2 x3 x4 x5)
           (vector-for-each p x1 '#())
           (vector-for-each p x1 '#() x2)
           (vector-for-each p x1 '#() x2 x3)
           (vector-for-each p x1 '#() x2 x3 x4)
           (vector-for-each p x1 '#() x2 x3 x4 x5)
           (vector-for-each p x1 x2 '#())
           (vector-for-each p x1 x2 '#() x3)
           (vector-for-each p x1 x2 '#() x3 x4)
           (vector-for-each p x1 x2 '#() x3 x4 x5)
           (vector-for-each p x1 x2 x3 '#())
           (vector-for-each p x1 x2 x3 '#() x4)
           (vector-for-each p x1 x2 x3 '#() x4 x5)
           (vector-for-each p x1 x2 x3 x4 '#())
           (vector-for-each p x1 x2 x3 x4 '#() x5)
           (vector-for-each p x1 x2 x3 x4 x5 '#())))
       (procedure? $vector-for-each-f1))
     (equal? (let ([ls '()])
               (define q
                 (lambda args
                   (set! ls (cons (reverse args) ls))))
               ($vector-for-each-f1 q '#() '#() '#() '#() '#())
               (reverse ls))
             '())
     (begin
       (define ($vector-for-each-f1 p x1 x2 x3 x4 x5)
         (begin
           (vector-for-each p '#(a))
           (vector-for-each p '#(a) x1)
           (vector-for-each p '#(a) x1 x2)
           (vector-for-each p '#(a) x1 x2 x3)
           (vector-for-each p '#(a) x1 x2 x3 x4)
           (vector-for-each p '#(a) x1 x2 x3 x4 x5)
           (vector-for-each p x1 '#(a))
           (vector-for-each p x1 '#(a) x2)
           (vector-for-each p x1 '#(a) x2 x3)
           (vector-for-each p x1 '#(a) x2 x3 x4)
           (vector-for-each p x1 '#(a) x2 x3 x4 x5)
           (vector-for-each p x1 x2 '#(a))
           (vector-for-each p x1 x2 '#(a) x3)
           (vector-for-each p x1 x2 '#(a) x3 x4)
           (vector-for-each p x1 x2 '#(a) x3 x4 x5)
           (vector-for-each p x1 x2 x3 '#(a))
           (vector-for-each p x1 x2 x3 '#(a) x4)
           (vector-for-each p x1 x2 x3 '#(a) x4 x5)
           (vector-for-each p x1 x2 x3 x4 '#(a))
           (vector-for-each p x1 x2 x3 x4 '#(a) x5)
           (vector-for-each p x1 x2 x3 x4 x5 '#(a))))
       (procedure? $vector-for-each-f1))
     (equal? (let ([ls '()])
               (define q
                 (lambda args
                   (set! ls (cons (reverse args) ls))))
               ($vector-for-each-f1 q '#(1) '#(f) '#(k) '#(p) '#(u))
               (reverse ls))
             '((a)
               (1 a)
               (f 1 a)
               (k f 1 a)
               (p k f 1 a)
               (u p k f 1 a)
               (a 1)
               (f a 1)
               (k f a 1)
               (p k f a 1)
               (u p k f a 1)
               (a f 1)
               (k a f 1)
               (p k a f 1)
               (u p k a f 1)
               (a k f 1)
               (p a k f 1)
               (u p a k f 1)
               (a p k f 1)
               (u a p k f 1)
               (a u p k f 1)))
     (begin
       (define ($vector-for-each-f1 p x1 x2 x3 x4 x5)
         (begin
           (vector-for-each p '#(a b))
           (vector-for-each p '#(a b) x1)
           (vector-for-each p '#(a b) x1 x2)
           (vector-for-each p '#(a b) x1 x2 x3)
           (vector-for-each p '#(a b) x1 x2 x3 x4)
           (vector-for-each p '#(a b) x1 x2 x3 x4 x5)
           (vector-for-each p x1 '#(a b))
           (vector-for-each p x1 '#(a b) x2)
           (vector-for-each p x1 '#(a b) x2 x3)
           (vector-for-each p x1 '#(a b) x2 x3 x4)
           (vector-for-each p x1 '#(a b) x2 x3 x4 x5)
           (vector-for-each p x1 x2 '#(a b))
           (vector-for-each p x1 x2 '#(a b) x3)
           (vector-for-each p x1 x2 '#(a b) x3 x4)
           (vector-for-each p x1 x2 '#(a b) x3 x4 x5)
           (vector-for-each p x1 x2 x3 '#(a b))
           (vector-for-each p x1 x2 x3 '#(a b) x4)
           (vector-for-each p x1 x2 x3 '#(a b) x4 x5)
           (vector-for-each p x1 x2 x3 x4 '#(a b))
           (vector-for-each p x1 x2 x3 x4 '#(a b) x5)
           (vector-for-each p x1 x2 x3 x4 x5 '#(a b))))
       (procedure? $vector-for-each-f1))
     (equal? (let ([ls '()])
               (define q
                 (lambda args
                   (set! ls (cons (reverse args) ls))))
               ($vector-for-each-f1 q
                 '#(1 2)
                 '#(f g)
                 '#(k l)
                 '#(p q)
                 '#(u v))
               (reverse ls))
       '((a)
         (b)
         (1 a)
         (2 b)
         (f 1 a)
         (g 2 b)
         (k f 1 a)
         (l g 2 b)
         (p k f 1 a)
         (q l g 2 b)
         (u p k f 1 a)
         (v q l g 2 b)
         (a 1)
         (b 2)
         (f a 1)
         (g b 2)
         (k f a 1)
         (l g b 2)
         (p k f a 1)
         (q l g b 2)
         (u p k f a 1)
         (v q l g b 2)
         (a f 1)
         (b g 2)
         (k a f 1)
         (l b g 2)
         (p k a f 1)
         (q l b g 2)
         (u p k a f 1)
         (v q l b g 2)
         (a k f 1)
         (b l g 2)
         (p a k f 1)
         (q b l g 2)
         (u p a k f 1)
         (v q b l g 2)
         (a p k f 1)
         (b q l g 2)
         (u a p k f 1)
         (v b q l g 2)
         (a u p k f 1)
         (b v q l g 2)))
     (begin
       (define ($vector-for-each-f1 p x1 x2 x3 x4 x5)
         (begin
           (vector-for-each p '#(a b c))
           (vector-for-each p '#(a b c) x1)
           (vector-for-each p '#(a b c) x1 x2)
           (vector-for-each p '#(a b c) x1 x2 x3)
           (vector-for-each p '#(a b c) x1 x2 x3 x4)
           (vector-for-each p '#(a b c) x1 x2 x3 x4 x5)
           (vector-for-each p x1 '#(a b c))
           (vector-for-each p x1 '#(a b c) x2)
           (vector-for-each p x1 '#(a b c) x2 x3)
           (vector-for-each p x1 '#(a b c) x2 x3 x4)
           (vector-for-each p x1 '#(a b c) x2 x3 x4 x5)
           (vector-for-each p x1 x2 '#(a b c))
           (vector-for-each p x1 x2 '#(a b c) x3)
           (vector-for-each p x1 x2 '#(a b c) x3 x4)
           (vector-for-each p x1 x2 '#(a b c) x3 x4 x5)
           (vector-for-each p x1 x2 x3 '#(a b c))
           (vector-for-each p x1 x2 x3 '#(a b c) x4)
           (vector-for-each p x1 x2 x3 '#(a b c) x4 x5)
           (vector-for-each p x1 x2 x3 x4 '#(a b c))
           (vector-for-each p x1 x2 x3 x4 '#(a b c) x5)
           (vector-for-each p x1 x2 x3 x4 x5 '#(a b c))))
       (procedure? $vector-for-each-f1))
     (equal? (let ([ls '()])
               (define q
                 (lambda args
                   (set! ls (cons (reverse args) ls))))
               ($vector-for-each-f1 q
                 '#(1 2 3)
                 '#(f g h)
                 '#(k l m)
                 '#(p q r)
                 '#(u v w))
               (reverse ls))
       '((a)
         (b)
         (c)
         (1 a)
         (2 b)
         (3 c)
         (f 1 a)
         (g 2 b)
         (h 3 c)
         (k f 1 a)
         (l g 2 b)
         (m h 3 c)
         (p k f 1 a)
         (q l g 2 b)
         (r m h 3 c)
         (u p k f 1 a)
         (v q l g 2 b)
         (w r m h 3 c)
         (a 1)
         (b 2)
         (c 3)
         (f a 1)
         (g b 2)
         (h c 3)
         (k f a 1)
         (l g b 2)
         (m h c 3)
         (p k f a 1)
         (q l g b 2)
         (r m h c 3)
         (u p k f a 1)
         (v q l g b 2)
         (w r m h c 3)
         (a f 1)
         (b g 2)
         (c h 3)
         (k a f 1)
         (l b g 2)
         (m c h 3)
         (p k a f 1)
         (q l b g 2)
         (r m c h 3)
         (u p k a f 1)
         (v q l b g 2)
         (w r m c h 3)
         (a k f 1)
         (b l g 2)
         (c m h 3)
         (p a k f 1)
         (q b l g 2)
         (r c m h 3)
         (u p a k f 1)
         (v q b l g 2)
         (w r c m h 3)
         (a p k f 1)
         (b q l g 2)
         (c r m h 3)
         (u a p k f 1)
         (v b q l g 2)
         (w c r m h 3)
         (a u p k f 1)
         (b v q l g 2)
         (c w r m h 3)))
     (begin
       (define ($vector-for-each-f1 p x1 x2 x3 x4 x5)
         (begin
           (vector-for-each p '#(a b c d))
           (vector-for-each p '#(a b c d) x1)
           (vector-for-each p '#(a b c d) x1 x2)
           (vector-for-each p '#(a b c d) x1 x2 x3)
           (vector-for-each p '#(a b c d) x1 x2 x3 x4)
           (vector-for-each p '#(a b c d) x1 x2 x3 x4 x5)
           (vector-for-each p x1 '#(a b c d))
           (vector-for-each p x1 '#(a b c d) x2)
           (vector-for-each p x1 '#(a b c d) x2 x3)
           (vector-for-each p x1 '#(a b c d) x2 x3 x4)
           (vector-for-each p x1 '#(a b c d) x2 x3 x4 x5)
           (vector-for-each p x1 x2 '#(a b c d))
           (vector-for-each p x1 x2 '#(a b c d) x3)
           (vector-for-each p x1 x2 '#(a b c d) x3 x4)
           (vector-for-each p x1 x2 '#(a b c d) x3 x4 x5)
           (vector-for-each p x1 x2 x3 '#(a b c d))
           (vector-for-each p x1 x2 x3 '#(a b c d) x4)
           (vector-for-each p x1 x2 x3 '#(a b c d) x4 x5)
           (vector-for-each p x1 x2 x3 x4 '#(a b c d))
           (vector-for-each p x1 x2 x3 x4 '#(a b c d) x5)
           (vector-for-each p x1 x2 x3 x4 x5 '#(a b c d))))
       (procedure? $vector-for-each-f1))
     (equal? (let ([ls '()])
               (define q
                 (lambda args
                   (set! ls (cons (reverse args) ls))))
               ($vector-for-each-f1 q
                 '#(1 2 3 4)
                 '#(f g h i)
                 '#(k l m n)
                 '#(p q r s)
                 '#(u v w x))
               (reverse ls))
       '((a)
         (b)
         (c)
         (d)
         (1 a)
         (2 b)
         (3 c)
         (4 d)
         (f 1 a)
         (g 2 b)
         (h 3 c)
         (i 4 d)
         (k f 1 a)
         (l g 2 b)
         (m h 3 c)
         (n i 4 d)
         (p k f 1 a)
         (q l g 2 b)
         (r m h 3 c)
         (s n i 4 d)
         (u p k f 1 a)
         (v q l g 2 b)
         (w r m h 3 c)
         (x s n i 4 d)
         (a 1)
         (b 2)
         (c 3)
         (d 4)
         (f a 1)
         (g b 2)
         (h c 3)
         (i d 4)
         (k f a 1)
         (l g b 2)
         (m h c 3)
         (n i d 4)
         (p k f a 1)
         (q l g b 2)
         (r m h c 3)
         (s n i d 4)
         (u p k f a 1)
         (v q l g b 2)
         (w r m h c 3)
         (x s n i d 4)
         (a f 1)
         (b g 2)
         (c h 3)
         (d i 4)
         (k a f 1)
         (l b g 2)
         (m c h 3)
         (n d i 4)
         (p k a f 1)
         (q l b g 2)
         (r m c h 3)
         (s n d i 4)
         (u p k a f 1)
         (v q l b g 2)
         (w r m c h 3)
         (x s n d i 4)
         (a k f 1)
         (b l g 2)
         (c m h 3)
         (d n i 4)
         (p a k f 1)
         (q b l g 2)
         (r c m h 3)
         (s d n i 4)
         (u p a k f 1)
         (v q b l g 2)
         (w r c m h 3)
         (x s d n i 4)
         (a p k f 1)
         (b q l g 2)
         (c r m h 3)
         (d s n i 4)
         (u a p k f 1)
         (v b q l g 2)
         (w c r m h 3)
         (x d s n i 4)
         (a u p k f 1)
         (b v q l g 2)
         (c w r m h 3)
         (d x s n i 4)))
     (begin
       (define ($vector-for-each-f1 p x1 x2 x3 x4 x5)
         (begin
           (vector-for-each p '#(a b c d e))
           (vector-for-each p '#(a b c d e) x1)
           (vector-for-each p '#(a b c d e) x1 x2)
           (vector-for-each p '#(a b c d e) x1 x2 x3)
           (vector-for-each p '#(a b c d e) x1 x2 x3 x4)
           (vector-for-each p '#(a b c d e) x1 x2 x3 x4 x5)
           (vector-for-each p x1 '#(a b c d e))
           (vector-for-each p x1 '#(a b c d e) x2)
           (vector-for-each p x1 '#(a b c d e) x2 x3)
           (vector-for-each p x1 '#(a b c d e) x2 x3 x4)
           (vector-for-each p x1 '#(a b c d e) x2 x3 x4 x5)
           (vector-for-each p x1 x2 '#(a b c d e))
           (vector-for-each p x1 x2 '#(a b c d e) x3)
           (vector-for-each p x1 x2 '#(a b c d e) x3 x4)
           (vector-for-each p x1 x2 '#(a b c d e) x3 x4 x5)
           (vector-for-each p x1 x2 x3 '#(a b c d e))
           (vector-for-each p x1 x2 x3 '#(a b c d e) x4)
           (vector-for-each p x1 x2 x3 '#(a b c d e) x4 x5)
           (vector-for-each p x1 x2 x3 x4 '#(a b c d e))
           (vector-for-each p x1 x2 x3 x4 '#(a b c d e) x5)
           (vector-for-each p x1 x2 x3 x4 x5 '#(a b c d e))))
       (procedure? $vector-for-each-f1))
     (equal? (let ([ls '()])
               (define q
                 (lambda args
                   (set! ls (cons (reverse args) ls))))
               ($vector-for-each-f1 q
                 '#(1 2 3 4 5)
                 '#(f g h i j)
                 '#(k l m n o)
                 '#(p q r s t)
                 '#(u v w x y))
               (reverse ls))
       '((a)
         (b)
         (c)
         (d)
         (e)
         (1 a)
         (2 b)
         (3 c)
         (4 d)
         (5 e)
         (f 1 a)
         (g 2 b)
         (h 3 c)
         (i 4 d)
         (j 5 e)
         (k f 1 a)
         (l g 2 b)
         (m h 3 c)
         (n i 4 d)
         (o j 5 e)
         (p k f 1 a)
         (q l g 2 b)
         (r m h 3 c)
         (s n i 4 d)
         (t o j 5 e)
         (u p k f 1 a)
         (v q l g 2 b)
         (w r m h 3 c)
         (x s n i 4 d)
         (y t o j 5 e)
         (a 1)
         (b 2)
         (c 3)
         (d 4)
         (e 5)
         (f a 1)
         (g b 2)
         (h c 3)
         (i d 4)
         (j e 5)
         (k f a 1)
         (l g b 2)
         (m h c 3)
         (n i d 4)
         (o j e 5)
         (p k f a 1)
         (q l g b 2)
         (r m h c 3)
         (s n i d 4)
         (t o j e 5)
         (u p k f a 1)
         (v q l g b 2)
         (w r m h c 3)
         (x s n i d 4)
         (y t o j e 5)
         (a f 1)
         (b g 2)
         (c h 3)
         (d i 4)
         (e j 5)
         (k a f 1)
         (l b g 2)
         (m c h 3)
         (n d i 4)
         (o e j 5)
         (p k a f 1)
         (q l b g 2)
         (r m c h 3)
         (s n d i 4)
         (t o e j 5)
         (u p k a f 1)
         (v q l b g 2)
         (w r m c h 3)
         (x s n d i 4)
         (y t o e j 5)
         (a k f 1)
         (b l g 2)
         (c m h 3)
         (d n i 4)
         (e o j 5)
         (p a k f 1)
         (q b l g 2)
         (r c m h 3)
         (s d n i 4)
         (t e o j 5)
         (u p a k f 1)
         (v q b l g 2)
         (w r c m h 3)
         (x s d n i 4)
         (y t e o j 5)
         (a p k f 1)
         (b q l g 2)
         (c r m h 3)
         (d s n i 4)
         (e t o j 5)
         (u a p k f 1)
         (v b q l g 2)
         (w c r m h 3)
         (x d s n i 4)
         (y e t o j 5)
         (a u p k f 1)
         (b v q l g 2)
         (c w r m h 3)
         (d x s n i 4)
         (e y t o j 5)))
     ; check for proper tail recursion
     (equal? (list (let ([s (statistics)])
                     (let ([k 100000] [v '#(a b c)])
                       (let ([n k] [m 0])
                         (define (f)
                           (unless (fx= n 0)
                                   (vector-for-each foo v)))
                         (define (foo x)
                           (set! m (+ m 1))
                           (when (eq? x (vector-ref v (fx- (vector-length v) 1)))
                                 (set! n (- n 1))
                                 (f)
                                 17))
                         ; blow tail recursion here
                         (f)
                         (list (> (sstats-bytes (sstats-difference (statistics) s))
                                  10000)
                               (eqv? n 0)
                               (eqv? m (* k (vector-length v)))))))
                   (let ([s (statistics)])
                     (let ([k 100000] [v '#(a b c)])
                       (let ([n k] [m 0])
                         (define (f)
                           (unless (fx= n 0)
                                   (vector-for-each foo v)))
                         (define (foo x)
                           (set! m (+ m 1))
                           (when (eq? x (vector-ref v (fx- (vector-length v) 1)))
                                 (set! n (- n 1))
                                 (f)))
                         (f)
                         (list (<= 0
                                   (sstats-bytes (sstats-difference (statistics) s))
                                   1000)
                               (eqv? n 0)
                               (eqv? m (* k (vector-length v))))))))
             '((#t #t #t) (#t #t #t))))

(define $merge-sort
  (lambda (lt? ls)
    (define merge
      (lambda (ls1 ls2)
        (if (null? ls1)
            ls2
            (if (null? ls2)
                ls1
                (if (lt? (car ls1) (car ls2))
                    (cons (car ls1) (merge (cdr ls1) ls2))
                    (cons (car ls2) (merge ls1 (cdr ls2))))))))
    (define sort
      (lambda (ls n)
        (if (fx<= n 1)
            ls
            (let ([mid (quotient n 2)])
              (merge (sort (list-head ls mid) mid)
                     (sort (list-tail ls mid) (fx- n mid)))))))
    (sort ls (length ls))))

(mat vector-sort
     (error? ; invalid number of arguments
             (vector-sort))
     (error? ; invalid number of arguments
             (vector-sort >))
     (error? ; invalid number of arguments
             (vector-sort '#(a b c)))
     (error? ; invalid number of arguments
             (vector-sort > '#(1 2 3) #t))
     (error? ; 3 is not a proper list
             (vector-sort > 3))
     (error? ; (1 2 3) is not a vector
             (vector-sort > '(1 2 3)))
     (error? ; #(a b c) is not a procedure
             (vector-sort '#(a b c) '#(a b c)))
     (error? ; b is not a real number
             (vector-sort > '#(1 b 3)))
     (equal? (vector-sort > '#()) '#())
     (let ([v (vector 3 2 1)])
       (and (equal? (vector-sort > v) '#(3 2 1))
            (equal? v '#(3 2 1))))
     (let ([v (vector 1 2 3)])
       (and (equal? (vector-sort > v) '#(3 2 1))
            (equal? v '#(1 2 3))))
     (let ([v (vector 2 3 1)])
       (and (equal? (vector-sort > v) '#(3 2 1))
            (equal? v '#(2 3 1))))
     (let ([v (vector -2 3.0 9 8 3 -11 0 9 -5 -7 -43 8.0 5)])
       (and (equal? (vector-sort < v)
                    '#(-43 -11 -7 -5 -2 0 3.0 3 5 8 8.0 9 9))
            (equal? v '#(-2 3.0 9 8 3 -11 0 9 -5 -7 -43 8.0 5))))
     (let ([v (vector 2 5 8 -3 9 10 -5 8 -8 4 2 3 1 -1 -9)])
       (and (equal? (vector-sort (lambda (x y) (< (abs x) (abs y))) v)
                    '#(1 -1 2 2 -3 3 4 5 -5 8 8 -8 9 -9 10))
            (equal? v '#(2 5 8 -3 9 10 -5 8 -8 4 2 3 1 -1 -9))))
     (let ([v (vector 1 3 2 4)])
       (and (equal? (vector-sort < v) '#(1 2 3 4))
            (equal? v '#(1 3 2 4))))
     (equal? (with-output-to-string
               (lambda ()
                 (do ([n 1000 (fx- n 5)])
                     ((fx= n 0))
                     (write-char #\.)
                     (flush-output-port)
                     (do ([k 25 (fx- k 1)])
                         ((fx= k 0))
                         (let ([ls (map (lambda (x) (random k))
                                        (make-list n))])
                           (unless (let ([v (list->vector ls)])
                                     (and (equal? (vector-sort < v)
                                                  (list->vector ($merge-sort < ls)))
                                          (equal? v (list->vector ls))))
                                   (fprintf (console-output-port) "\n~s\n" ls)
                                   (errorf #f "failed")))))))
             (make-string 200 #\.)))

(mat vector-sort!
     (error? ; invalid number of arguments
             (vector-sort!))
     (error? ; invalid number of arguments
             (vector-sort! >))
     (error? ; invalid number of arguments
             (vector-sort! '#(a b c)))
     (error? ; invalid number of arguments
             (vector-sort! > '#(1 2 3) #t))
     (error? ; 3 is not a proper list
             (vector-sort! > 3))
     (error? ; (1 2 3) is not a vector
             (vector-sort! > '(1 2 3)))
     (error? ; #(a b c) is not a procedure
             (vector-sort! '#(a b c) '#(a b c)))
     (error? ; b is not a real number
             (vector-sort! > '#(1 b 3)))
     (equal? (vector-sort! > '#()) (void))
     (let ([v (vector 3 2 1)])
       (and (equal? (vector-sort! > v) (void))
            (equal? v '#(3 2 1))))
     (let ([v (vector 1 2 3)])
       (and (equal? (vector-sort! > v) (void))
            (equal? v '#(3 2 1))))
     (let ([v (vector 2 3 1)])
       (and (equal? (vector-sort! > v) (void))
            (equal? v '#(3 2 1))))
     (let ([v (vector -2 3.0 9 8 3 -11 0 9 -5 -7 -43 8.0 5)])
       (and (equal? (vector-sort! < v) (void))
            (equal? v '#(-43 -11 -7 -5 -2 0 3.0 3 5 8 8.0 9 9))))
     (let ([v (vector 2 5 8 -3 9 10 -5 8 -8 4 2 3 1 -1 -9)])
       (and (equal? (vector-sort! (lambda (x y) (< (abs x) (abs y))) v)
                    (void))
            (equal? v '#(1 -1 2 2 -3 3 4 5 -5 8 8 -8 9 -9 10))))
     (let ([v (vector 1 3 2 4)])
       (and (equal? (vector-sort! < v) (void))
            (equal? v '#(1 2 3 4))))
     (equal? (with-output-to-string
               (lambda ()
                 (do ([n 1000 (fx- n 5)])
                     ((fx= n 0))
                     (write-char #\.)
                     (flush-output-port)
                     (do ([k 25 (fx- k 1)])
                         ((fx= k 0))
                         (let ([ls (map (lambda (x) (random k))
                                        (make-list n))])
                           (unless (let ([v (list->vector ls)])
                                     (and (equal? (vector-sort! < v) (void))
                                          (equal? v (list->vector ($merge-sort < ls)))))
                                   (fprintf (console-output-port) "\n~s\n" ls)
                                   (errorf #f "failed")))))))
             (make-string 200 #\.)))

(mat vector->immutable-vector
     (begin
       (define immutable-123-vector
         (vector->immutable-vector (vector 1 2 3)))
       #t)
     (immutable-vector? immutable-123-vector)
     (not (mutable-vector? immutable-123-vector))
     (equal? '#(1 2 3) immutable-123-vector)
     (eq? immutable-123-vector
          (vector->immutable-vector immutable-123-vector))
     (mutable-vector? (make-vector 5))
     (not (immutable-vector? (make-vector 5)))
     (immutable-vector? (vector->immutable-vector (vector)))
     (not (mutable-vector? (vector->immutable-vector (vector))))
     (not (immutable-vector? (vector)))
     (mutable-vector? (vector))
     (not (immutable-vector? (vector-copy immutable-123-vector)))

     (error? (vector-set! immutable-123-vector 0 1))
     (error? (vector-set-fixnum! immutable-123-vector 0 1))
     (error? (vector-fill! immutable-123-vector 0))
     (error? (vector-sort! < immutable-123-vector)))



(mat fxvector->immutable-fxvector
     (begin
       (define immutable-123-fxvector
         (fxvector->immutable-fxvector (fxvector 1 2 3)))
       #t)
     (immutable-fxvector? immutable-123-fxvector)
     (not (mutable-fxvector? immutable-123-fxvector))
     (equal? '#vfx(1 2 3) immutable-123-fxvector)
     (eq? immutable-123-fxvector
          (fxvector->immutable-fxvector immutable-123-fxvector))
     (mutable-fxvector? (make-fxvector 5))
     (not (immutable-fxvector? (make-fxvector 5)))
     (immutable-fxvector? (fxvector->immutable-fxvector (fxvector)))
     (not (mutable-fxvector? (fxvector->immutable-fxvector (fxvector))))
     (not (immutable-fxvector? (fxvector)))
     (mutable-fxvector? (fxvector))
     (not (immutable-fxvector? (fxvector-copy immutable-123-fxvector)))

     (error? (fxvector-set! immutable-123-fxvector 0 1))
     (error? (fxvector-fill! immutable-123-fxvector 0)))

(mat vector-cas!
     (begin
       (define vec1 (vector 1 2 3))
       (define vec2 (vector 'apple 'banana 'coconut))
       (eq? 1 (vector-ref vec1 0)))
     (not (vector-cas! vec1 0 0 1))
     (eq? 1 (vector-ref vec1 0))
     (vector-cas! vec1 0 1 4)
     (eq? 4 (vector-ref vec1 0))
     (not (vector-cas! vec1 0 1 5))

     (not (vector-cas! vec1 1 0 1))
     (eq? 2 (vector-ref vec1 1))
     (vector-cas! vec1 1 2 5)
     (eq? 5 (vector-ref vec1 1))

     (not (vector-cas! vec2 0 'banana 'donut))
     (vector-cas! vec2 0 'apple 'donut)
     (not (vector-cas! vec2 0 'apple 'eclair))
     (eq? 'donut (vector-ref vec2 0))

     (not (vector-cas! vec2 1 'apple 'fig))
     (vector-cas! vec2 1 'banana 'fig)
     (not (vector-cas! vec2 1 'banana 'grape))
     (eq? 'fig (vector-ref vec2 1))

     (error? (vector-cas! vec1))
     ; arity
     (error? (vector-cas! vec1 1))
     ; arity
     (error? (vector-cas! vec1 1 2))
     ; arity
     (error? (vector-cas! 1 vec1 2 3))
     ; not a vector
     (error? (vector-cas! (vector->immutable-vector vec1) 1 2 3))
     ; not a mutable vector
     (error? (vector-cas! vec1 vec1 2 3))
     ; not a fixnum
     (error? (vector-cas! vec1 (expt 2 100) 2 3))
     ; not a fixnum
     (error? (vector-cas! vec1 -1 2 3))
     ; out of range
     (error? (vector-cas! vec1 5 2 3))
     ; out of range

     ;; make sure `vector-cas!` works with GC generations:
     (begin
       (collect 0)
       (let ([g1 (gensym)])
         (and (vector-cas! vec2 2 'coconut g1)
              (begin
                (collect 0)
                (eq? g1 (vector-ref vec2 2)))))))
;;; 5-7.ms
;;; Copyright 1984-2017 Cisco Systems, Inc.
;;; 
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;; 
;;; http://www.apache.org/licenses/LICENSE-2.0
;;; 
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

(mat string->symbol
     (eq? (string->symbol "foo") 'foo)
     (eq? (string->symbol "a") (string->symbol "a"))
     (error? (string->symbol 3))
     (error? (string->symbol 'a)))

(mat gensym
     (not (eq? (gensym "hi") 'hi))
     (not (eq? (gensym "hi") (gensym "hi")))
     (equal? (symbol->string (gensym "hi")) "hi")
     (error? (gensym '#(a b c))))

(mat gensym
     (error? (gensym 'hitme!))
     (error? (gensym 17))
     (error? (gensym #f))
     (error? (gensym 'hitme "a"))
     (error? (gensym 17 "a"))
     (error? (gensym #f "a"))
     (error? (gensym "a" 'hitme))
     (error? (gensym "a" 17))
     (error? (gensym "a" #f))
     (symbol? (gensym))
     (gensym? (gensym))
     (not (eq? (gensym) (gensym)))
     (not (equal? (symbol->string (gensym)) (symbol->string (gensym))))
     (parameterize ([gensym-count 1000] [gensym-prefix "xxx"])
       (equal? (symbol->string (gensym)) "xxx1000"))
     (error? (gensym-count -1))
     (error? (gensym-count 'a))
     (error? (gensym-count "3.4"))
     (equal? (parameterize ([gensym-count 73]) (format "~a" (gensym)))
             "g73")
     (equal? (let* ([g1 (with-input-from-string "#{pn1 un1}" read)]
                    [g2 (gensym "pn1" "un1")])
               (list (gensym? g1) (gensym? g2) (eq? g1 g2)))
             '(#t #t #t))
     (equal? (let* ([g1 (gensym "pn2" "un2")]
                    [g2 (with-input-from-string "#{pn2 un2}" read)])
               (list (gensym? g1) (gensym? g2) (eq? g1 g2)))
             '(#t #t #t)))

(mat gensym?
     (gensym? (gensym "foo"))
     (not (gensym? 'foo))
     (not (gensym? (string->symbol "foo")))
     (not (gensym? '(a b))))

(mat symbol->string
     (equal? (symbol->string 'foo) "foo")
     (equal? (symbol->string (string->symbol "hi")) "hi")
     (equal? (symbol->string (gensym "hi there")) "hi there")
     (error? (symbol->string 3)))

(mat gensym->unique-string
     (error? ; not a gensym
             (gensym->unique-string "spam"))
     (error? ; not a gensym
             (gensym->unique-string 3))
     (error? ; not a gensym
             (gensym->unique-string 'spam))
     (string? (gensym->unique-string (gensym)))
     (equal? (gensym->unique-string '#{g0 e6sfz8u1obe67hsew4stu0-0})
             "e6sfz8u1obe67hsew4stu0-0"))

(mat putprop-getprop
     (begin
       (putprop 'xyz 'key 'value)
       (eq? (getprop 'xyz 'key) 'value))
     (begin
       (putprop 'xyz 'key 'new-value)
       (eq? (getprop 'xyz 'key) 'new-value))
     (begin
       (putprop 'xyz 'key #f)
       (not (getprop 'xyz 'key)))
     (begin
       (putprop 'xyz 'key #t)
       (remprop 'xyz 'key)
       (not (getprop 'xyz 'key)))
     (let ([g (gensym)] [flag (box 0)])
       (and (eq? (getprop g 'a flag) flag)
            (begin
              (putprop g 'a 'b)
              (and (eq? (getprop g 'a) 'b)
                   (equal? (property-list g) '(a b))))))
     (begin
       (putprop 'x 'a 'b)
       (putprop 'x 'b 'c)
       (eq? (getprop 'x (getprop 'x (getprop 'x '? 'a) 0) 1) 'c))
     (error? (getprop 3 'key))
     (error? (putprop "hi" 'key 'value))
     (error? (property-list '(a b c))))
;;; 5-7.ms
;;; Copyright 1984-2017 Cisco Systems, Inc.
;;; 
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;; 
;;; http://www.apache.org/licenses/LICENSE-2.0
;;; 
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

(mat box
     (box? (box 3))
     (equal? (box 'a) '#&a)
     (equal? (box '(a b c)) '#& (a b c))
     (not (eq? (box '()) (box '()))))

(mat unbox (equal? (unbox '#&3) 3) (equal? (unbox (box 3)) 3))

(mat set-box!
     (let ((x (box 3)))
       (set-box! x 4)
       (and (equal? x '#&4) (equal? (unbox x) 4))))

(mat box-cas!
     (begin
       (define bx1 (box 1))
       (define bx2 (box 'apple))
       (eq? 1 (unbox bx1)))
     (not (box-cas! bx1 0 1))
     (eq? 1 (unbox bx1))
     (box-cas! bx1 1 2)
     (eq? 2 (unbox bx1))

     (not (box-cas! bx2 #f 'banana))
     (box-cas! bx2 'apple 'banana)
     (not (box-cas! bx2 'apple 'banana))
     (eq? 'banana (unbox bx2))

     (not (box-cas! (box (bitwise-arithmetic-shift-left 1 40))
                    (bitwise-arithmetic-shift-left 2 40)
                    'wrong))

     (error? (box-cas! bx1))
     ; arity
     (error? (box-cas! bx1 1))
     ; arity
     (error? (box-cas! 1 bx1 2))
     ; not a box
     (error? (box-cas! (box-immutable 1) 1 2))
     ; not a mutable box

     ;; make sure `box-cas!` works with GC generations:
     (begin
       (collect 0)
       (let ([g1 (gensym)])
         (and (box-cas! bx2 'banana g1)
              (begin (collect 0) (eq? g1 (unbox bx2)))))))
;;; 6.ms
;;; Copyright 1984-2017 Cisco Systems, Inc.
;;; 
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;; 
;;; http://www.apache.org/licenses/LICENSE-2.0
;;; 
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

;;; sections 6-1 and 6-2:

(mat current-input-port
     (port? (current-input-port))
     (input-port? (current-input-port))
     (eq? (current-input-port) (console-input-port)))

(mat current-output-port
     (port? (current-output-port))
     (output-port? (current-output-port))
     (eq? (current-output-port) (console-output-port)))

(mat port-operations
     (error? (open-input-file "nonexistent file"))
     (error? (open-input-file "nonexistent file" 'compressed))
     (error? (open-output-file "/nonexistent/directory/nonexistent/file"))
     (error? (open-output-file
               "/nonexistent/directory/nonexistent/file"
               'replace))
     (error? (open-input-output-file
               "/nonexistent/directory/nonexistent/file"))
     (error? (open-input-output-file
               "/nonexistent/directory/nonexistent/file"
               'truncate))
     ; the following several clauses test various open-output-file options
     (let ([p (open-output-file "testfile.ss" 'truncate)])
       (and (port? p)
            (output-port? p)
            (begin (close-output-port p) #t)))
     (error? (open-output-file "testfile.ss"))
     (error? (open-output-file "testfile.ss" 'error))
     (let ([p (open-output-file "testfile.ss" 'replace)])
       (and (port? p)
            (output-port? p)
            (begin (close-output-port p) #t)))
     (let ([p (open-output-file "testfile.ss" 'truncate)])
       (and (port? p)
            (output-port? p)
            (begin (close-output-port p) #t)))
     (let ([p (open-output-file "testfile.ss" 'truncate)])
       (display "\"hello" p)
       (close-output-port p)
       (let ([p (open-output-file "testfile.ss" 'append)])
         (display " there\"" p)
         (close-output-port p)
         (let ([p (open-input-file "testfile.ss")])
           (and (equal? (read p) "hello there")
                (eof-object? (read p))
                (begin (close-input-port p) #t)))))
     ; the following tests open-output-file, close-output-port, write,
     ; display, and newline---and builds testfile.ss for the next test
     (let ([p (let loop ()
                (if (file-exists? "testfile.ss")
                    (begin
                      (delete-file "testfile.ss" #f)
                      (loop))
                    (open-output-file "testfile.ss")))])
       (for-each
         (lambda (x) (write x p) (display " " p))
         '(a b c d e))
       (newline p)
       (close-output-port p)
       #t)
     ; the following tests open-input-file, close-input-port, read,
     ; and eof-object?
     (equal? (let ([p (open-input-file "testfile.ss")])
               (let f ([x (read p)])
                 (if (eof-object? x)
                     (begin (close-input-port p) '())
                     (cons x (f (read p))))))
             '(a b c d e))
     ; the following tests with-output-to-file, close-port,
     ; and write-char---and builds testfile.ss for the next test
     (equal? (call-with-values
               (lambda ()
                 (with-output-to-file "testfile.ss"
                   (lambda ()
                     (for-each
                       (lambda (c) (write-char c))
                       (string->list "a b c d e"))
                     (values 1 2 3))
                   'replace))
               list)
             '(1 2 3))
     ; the following tests with-input-from-file, close-port,
     ; read-char, unread-char, and eof-object?
     (equal? (with-input-from-file "testfile.ss"
               (lambda ()
                 (list->string
                   (let f ()
                     (let ([c (read-char)])
                       (if (eof-object? c)
                           '()
                           (begin
                             (unread-char c)
                             (let ([c (read-char)])
                               (cons c (f))))))))))
             "a b c d e")
     ; the following tests call-with-output-file, close-port,
     ; and write-char---and builds testfile.ss for the next test
     (equal? (call-with-values
               (lambda ()
                 (call-with-output-file "testfile.ss"
                   (lambda (p)
                     (for-each
                       (lambda (c) (write-char c p))
                       (string->list "a b c d e"))
                     (close-port p)
                     (values 1 2 3))
                   'replace))
               list)
             '(1 2 3))
     ; the following tests call-with-input-file, close-port,
     ; read-char, unread-char, and eof-object?
     (equal? (call-with-input-file "testfile.ss"
               (lambda (p)
                 (list->string
                   (let f ()
                     (let ([c (read-char p)])
                       (if (eof-object? c)
                           (begin (close-port p) '())
                           (begin
                             (unread-char c p)
                             (let ([c (read-char p)])
                               (cons c (f))))))))))
             "a b c d e")
     ; the following tests call-with-input-file, close-port,
     ; read-char, unread-char, and eof-object?
     (equal? (call-with-values
               (lambda ()
                 (call-with-input-file "testfile.ss"
                   (lambda (p)
                     (apply values
                       (let f ()
                         (let ([c (read-char p)])
                           (if (eof-object? c)
                               (begin (close-port p) '())
                               (begin
                                 (unread-char c p)
                                 (let ([c (read-char p)])
                                   (cons c (f)))))))))))
               (lambda ls (list->string ls)))
             "a b c d e")
     ; the following tests call-with-input-file, close-input-port,
     ; read-char, peek-char, and eof-object?
     (equal? (call-with-input-file "testfile.ss"
               (lambda (p)
                 (list->string
                   (let f ()
                     (let ([c (peek-char p)])
                       (if (eof-object? c)
                           (begin (close-input-port p) '())
                           (let ([c (read-char p)])
                             (cons c (f)))))))))
             "a b c d e")
     ; test various errors related to input ports
     (begin
       (set! ip (open-input-file "testfile.ss"))
       (and (port? ip) (input-port? ip)))
     (error? (unread-char #\a ip))
     (eqv? (read-char ip) #\a)
     (begin (unread-char #\a ip) (eqv? (read-char ip) #\a))
     (begin (clear-input-port ip) #t)
     (error? (unread-char #\a ip))
     (error? (write-char #\a ip))
     (error? (write 'a ip))
     (error? (display 'a ip))
     (error? (newline ip))
     (error? (fprintf ip "hi"))
     (error? (flush-output-port ip))
     (error? (clear-output-port ip))
     (begin (close-input-port ip) #t)
     (error? (read-char ip))
     (error? (read ip))
     (error? (char-ready? ip))
     ; test various errors related to output ports
     (begin
       (set! op (open-output-file "testfile.ss" 'replace))
       (and (port? op) (output-port? op)))
     (error? (char-ready? op))
     (error? (peek-char op))
     (error? (read-char op))
     (error? (unread-char #\a op))
     (error? (read op))
     (error? (clear-input-port op))
     (begin (close-output-port op) #t)
     (error? (write-char #\a op))
     (error? (write 'a op))
     (error? (display 'a op))
     (error? (newline op))
     (error? (fprintf op "hi"))
     (error? (flush-output-port op))
     (error? (clear-output-port op))
     (error? (current-output-port 'a))
     (error? (current-input-port 'a))
     (begin (current-output-port (console-output-port)) #t)
     (begin (current-input-port (console-input-port)) #t)

     ; the following tests open-input-string, open-output-string, read-char,
     ; eof-object?, unread-char, write-char, and get-ouptut-string
     (let ([s "hi there, mom!"])
       (let ([ip (open-input-string s)] [op (open-output-string)])
         (do ([c (read-char ip) (read-char ip)])
             ((eof-object? c) (equal? (get-output-string op) s))
             (unread-char c ip)
             (write-char (read-char ip) op))))

     (error? (with-input-from-string))
     (error? (with-input-from-string "a"))
     (error? (with-input-from-string 'a (lambda () 3)))
     (error? (with-input-from-string "a" 'foo))
     (error? (with-input-from-string (lambda () 3) "a"))
     (error? (with-input-from-string '(this too?) values))
     (error? (with-input-from-string "a" (lambda () 3) 'compressed))
     (error? (with-output-to-string))
     (error? (with-output-to-string "a"))
     (error? (with-output-to-string 'a (lambda () 3)))
     (error? (with-output-to-string '(this too?)))
     (error? (eof-object #!eof))
     (eq? (with-input-from-string "" read) #!eof)
     (eq? (with-input-from-string "" read) (eof-object))
     (eq? (eof-object) #!eof)
     (error? (with-input-from-string "'" read))
     ; the following tests with-input-from-string, with-output-to-string,
     ; read-char, eof-object?, unread-char, and write-char
     (let ([s "hi there, mom!"])
       (equal? (with-input-from-string s
                 (lambda ()
                   (with-output-to-string
                     (lambda ()
                       (do ([c (read-char) (read-char)])
                           ((eof-object? c))
                           (unread-char c)
                           (write-char (read-char)))))))
               s))

     ; the following makes sure that call-with-{in,out}put-file close the
     ; port (from Dave Boyer)---at least on systems which restrict the
     ; number of open ports to less than 20
     (let loop ((i 20))
       (or (zero? i)
           (begin
             (call-with-output-file "testfile.ss"
               (lambda (p) (write i p))
               'replace)
             (and (eq? (call-with-input-file "testfile.ss"
                         (lambda (p) (read p)))
                       i)
                  (loop (- i 1))))))

     ; test source information in error messages from read
     (error? (begin
               (with-output-to-file "testfile.ss"
                 (lambda () (display "(cons 1 2 . 3 4)"))
                 'replace)
               (let ([ip (open-input-file "testfile.ss")])
                 (dynamic-wind void
                   (lambda () (read ip))
                   (lambda () (close-input-port ip))))))

     ; test source information in error messages from read
     (error? (begin
               (with-output-to-file "testfile.ss"
                 (lambda () (display "(cons 1 2 ] 3 4)"))
                 'replace)
               (let ([ip (open-input-file "testfile.ss")])
                 (dynamic-wind void
                   (lambda () (read ip))
                   (lambda () (close-input-port ip)))))))

(mat port-operations1
     (error? (open-input-output-file))
     (error? (open-input-output-file 'furball))
     (error? (open-input-output-file "/probably/not/a/good/path"))
     (error? (open-input-output-file "testfile.ss" 'compressed))
     (error? (open-input-output-file "testfile.ss" 'uncompressed))
     (begin
       (define $ppp (open-input-output-file "testfile.ss"))
       (and (input-port? $ppp)
            (output-port? $ppp)
            (port? $ppp)))
     (error? (truncate-file $ppp -3))
     (error? (truncate-file $ppp 'all-the-way))
     (eof-object?
       (begin
         (truncate-file $ppp)
         (display "hello" $ppp)
         (flush-output-port $ppp)
         (read $ppp)))
     (eq? (begin (file-position $ppp 0) (read $ppp)) 'hello)
     (eqv? (begin
             (display "goodbye\n" $ppp)
             (truncate-file $ppp 9)
             (file-position $ppp))
           9)
     (eof-object? (read $ppp))
     (eqv? (begin (file-position $ppp 0) (file-position $ppp)) 0)
     (eq? (read $ppp) 'hellogood)
     (eqv? (begin
             (display "byebye\n" $ppp)
             (truncate-file $ppp 0)
             (file-position $ppp))
           0)
     (eof-object? (read $ppp))
     (eof-object?
       (begin
         (close-port $ppp)
         (let ([ip (open-input-file "testfile.ss")])
           (let ([c (read-char ip)])
             (close-input-port ip)
             c))))
     (error? (let ([ip (open-input-file "testfile.ss")])
               (dynamic-wind void
                 (lambda () (truncate-file ip))
                 (lambda () (close-input-port ip)))))
     (error? (truncate-file 'animal-crackers))
     (error? (truncate-file))
     (error? (truncate-file $ppp))
     (let ([op (open-output-string)])
       (and (= (file-position op) 0)
            (= (file-length op) 0)
            (begin (fresh-line op) #t)
            (= (file-length op) 0)
            (= (file-position op) 0)
            (do ([i 4000 (fx- i 1)]) ((fx= i 0) #t) (display "hello" op))
            (= (file-length op) 20000)
            (= (file-position op) 20000)
            (begin (file-position op 5000) #t)
            (= (file-position op) 5000)
            (= (file-length op) 20000)
            (begin (truncate-file op) #t)
            (= (file-length op) 0)
            (= (file-position op) 0)
            (begin (truncate-file op 17) #t)
            (= (file-length op) 17)
            (= (file-position op) 17)
            (begin (display "okay" op) #t)
            (= (file-length op) 21)
            (= (file-position op) 21)
            (equal? (substring (get-output-string op) 17 21) "okay")
            (= (file-length op) 0)
            (= (file-position op) 0)
            (begin (fresh-line op) #t)
            (= (file-length op) 0)
            (= (file-position op) 0)
            (begin (write-char #\a op) (fresh-line op) #t)
            (= (file-position op) 2)
            (begin (fresh-line op) #t)
            (= (file-position op) 2)
            (equal? (get-output-string op) "a\n")))
     (let ([ip (open-input-string "beam me up, scotty!")]
           [s (make-string 10)])
       (and (= (file-position ip) 0)
            (= (file-length ip) 19)
            (not (eof-object? (peek-char ip)))
            (equal? (read ip) 'beam)
            (= (file-position ip) 4)
            (not (eof-object? (peek-char ip)))
            (equal? (block-read ip s 10) 10)
            (equal? s " me up, sc")
            (= (file-position ip) 14)
            (equal? (block-read ip s 10) 5)
            (equal? s "otty!p, sc")
            (= (file-position ip) 19)
            (eof-object? (peek-char ip))
            (eof-object? (read-char ip))
            (eof-object? (block-read ip s 10))
            (eof-object? (block-read ip s 0))
            (begin
              (file-position ip 10)
              (= (file-position ip) 10))
            (equal? (block-read ip s 10) 9)
            (equal? s ", scotty!c")))
     (error? ; unhandled message
             (get-output-string (open-input-string "oops")))
     (error? ; unhandled message
       (let ([op (open-output-file "testfile.ss" 'replace)])
         (dynamic-wind void
           (lambda () (get-output-string op))
           (lambda () (close-output-port op))))))

(mat compression
     (let ()
       (define cp
         (lambda (mode src dst)
           (define buf-size 4096)
           (let ([buf (make-string buf-size)])
             (call-with-output-file dst
               (lambda (op)
                 (call-with-input-file src
                   (lambda (ip)
                     (let lp ()
                       (let ([n (block-read ip buf buf-size)])
                         (unless (eof-object? n)
                                 (block-write op buf n)
                                 (lp)))))))
               mode))))
       (define cmp
         (lambda (mode1 src1 mode2 src2)
           (define buf-size 4096)
           (let ([buf1 (make-string buf-size)]
                 [buf2 (make-string buf-size)])
             (call-with-input-file src1
               (lambda (ip1)
                 (call-with-input-file src2
                   (lambda (ip2)
                     (let lp ()
                       (let ([n1 (block-read ip1 buf1 buf-size)]
                             [n2 (block-read ip2 buf2 buf-size)])
                         (if (eof-object? n1)
                             (eof-object? n2)
                             (and (eqv? n1 n2)
                                  (string=? (substring buf1 0 n1)
                                            (substring buf2 0 n2))
                                  (lp))))))
                   mode2))
               mode1))))
       (and (cmp '() "prettytest.ss" '() "prettytest.ss")
            (cmp '(compressed) "prettytest.ss" '() "prettytest.ss")
            (cmp '() "prettytest.ss" '(compressed) "prettytest.ss")
            (cmp '(compressed)
                 "prettytest.ss"
                 '(compressed)
                 "prettytest.ss")
            (begin
              (cp '(replace compressed) "prettytest.ss" "testfile.ss")
              #t)
            (cmp '(compressed) "testfile.ss" '() "prettytest.ss")
            (not (= (call-with-input-file "testfile.ss" file-length)
                    (call-with-input-file "prettytest.ss" file-length)))
            ; the following test could cause an error with anything but latin-1 codec
            #;
            (not (cmp '() "testfile.ss" '() "prettytest.ss"))
            (begin
              (cp '(compressed append) "prettytest.ss" "testfile.ss")
              #t)
            (not (cmp '(compressed) "testfile.ss" '() "prettytest.ss"))))
     (error? (open-output-file "testfile.ss" '(replace append)))
     (error? (open-output-file "testfile.ss" '(append truncate)))
     ; test workaround for bogus gzclose error return for empty input files
     (and (eqv? (with-output-to-file "testfile.ss" void 'replace) (void))
          (eof-object?
            (with-input-from-file "testfile.ss" read 'compressed))))

(mat read-comment
     (equal? '
       ; this is the first comment
       (a ; second comment
          #;
          (third ; comment in comment
                 comment
                 #;
                 (comment #1=e
                          in
                          .
                          #;
                          (comment in comment in comment)
                          comment))
          b
          ; fourth comment
          c
          #| fifth comment #| more
           nesting here |# |#
          d
          ; sixth and final comment
          #1#)
       '(a b c d e))
     (equal? (read (open-input-string
                     "; this is the first comment
                                    (a ; second comment
                                    #;(third ; comment in comment
                                    comment #;(comment #1=e in
                                    . #;(comment in comment in comment)
                                    comment)) b ; fourth comment
                                    c #| fifth comment #| more
                                    nesting here |# |# d
                                    ; sixth and final comment
                                    #1#)"))
             '(a b c d e))
     (equal? (read (open-input-string
                     "(#|##|# |#|#1
                                    #||#2
                                    #|||#3
                                    #|#||#|#4
                                    #|| hello ||#5
                                    #| ; rats |#)"))
             '(1 2 3 4 5)))

(mat read-graph
     (begin
       (define read-test-graph
         (case-lambda
           [(s) (read-test-graph s s)]
           [(s1 s2)
            (string=? (parameterize ((print-graph #t))
                        (format "~s" (read (open-input-string s1))))
                      s2)]))
       #t)
     (error? ; verify that the error message is NOT "invalid memory reference"
             (let ((ip (open-input-string "(cons 0 #0#)")))
               ((#%$make-read ip #t #f) #t)))
     (let ()
       (define-record foo ((immutable x) (immutable y)))
       (record-reader 'foo (record-rtd (make-foo 3 4)))
       (and (read-test-graph "#0=#[foo (#0#) 0]")
            (read-test-graph "#0=(#[foo #0# 0])")
            (read-test-graph "#[foo #0=(a b c) #0#]")))
     (error? (read-test-graph "#0=#[foo #0# #0#]"))
     (read-test-graph "#(123 #[foo #0=(a b c) #0#])")
     (read-test-graph "#(#0=#[foo #1=(a b c) #1#] 0 #0#)")
     (read-test-graph
       "#(#1# 0 #1=#[foo #0=(a b c) #0#])"
       "#(#0=#[foo #1=(a b c) #1#] 0 #0#)")
     (read-test-graph "#(123 #0=(#0#))")
     (read-test-graph "#(123 #0=(#0#))")
     (let ()
       (define-record r1 ((mutable a) (immutable b)))
       (define-record r2 ((immutable a)))
       (let* ((x2 (make-r2 (make-r1 '* '(a b c)))) (x1 (r2-a x2)))
         (set-r1-a! x1 x2)
         (record-reader 'r1 (record-rtd (make-r1 3 4)))
         (record-reader 'r2 (record-rtd (make-r2 3)))
         (read-test-graph
           (parameterize ((print-graph #t))
             (format "~s" (list (r1-b x1) x1))))))
     (read-test-graph "(#0=(a b c) #1=#[r1 #[r2 #1#] #0#])"))

(mat block-io
     ; test block-write and build testfile.ss for the following test
     (let ([p (open-output-file "testfile.ss" 'truncate)])
       (block-write p "hi there")
       (display " mom" p)
       (block-write p ", how are you?xxxx"
         (string-length ", how are you?"))
       (newline p)
       (let ([s (make-string 100 #\X)])
         (string-set! s 99 #\newline)
         (let ([s (apply string-append (make-list 10 s))])
           (let ([s (apply string-append (make-list 10 s))])
             (block-write p s)
             (block-write p s 5000))))
       (close-output-port p)
       #t)
     ; test block-read
     (let ([random-read-up
             (lambda (p n)
               (let f ([n n] [ls '()])
                 (if (fx= n 0)
                     (apply string-append (reverse ls))
                     (if (fxodd? n)
                         (f (- n 1) (cons (string (read-char p)) ls))
                         (let ([s (make-string (random (fx+ n 1)))])
                           (let ([i (if (fx= (random 2) 0)
                                        (block-read p s)
                                        (block-read p s (string-length s)))])
                             (f (- n i) (cons (substring s 0 i) ls))))))))])
       (let ([s (make-string 100 #\X)])
         (string-set! s 99 #\newline)
         (let ([s (apply string-append (make-list 10 s))])
           (let ([s (apply string-append (make-list 10 s))])
             (let ([s (string-append "hi there mom, how are you?"
                        (string #\newline)
                        s
                        (substring s 0 5000))])
               (let ([p (open-input-file "testfile.ss")])
                 (let ([t (random-read-up p (string-length s))])
                   (and (eof-object? (read-char p))
                        (string=? t s)
                        (eqv? (close-input-port p) (void))))))))))
     ; test for bug: block-read complained when handler returned eof
     (eof-object?
       (let ((p (make-input-port (lambda args #!eof) "")))
         (block-read p (make-string 100)))))

(mat file-length-and-file-position
     (procedure? file-length)
     (procedure? file-position)
     (let ([s "hi there"])
       (let ([n (string-length s)]
             [p (open-output-file "testfile.ss" 'replace)])
         (and (eqv? (file-length p) 0)
              (begin
                (display s p)
                (= (file-position p) (file-length p) n))
              (begin
                (display #\space p)
                (= (file-position p) (file-length p) (+ n 1)))
              (eqv? (file-position p 1) (void))
              (write-char #\o p)
              (eqv? (file-position p 2000) (void))
              (begin
                (display s p)
                (= (file-length p) (file-position p) (+ 2000 n)))
              (eqv? (close-output-port p) (void)))))
     ;;; no error is reported, which isn't serious
     ;   (error? (file-position (open-input-file "testfile.ss") 10000))
     (error? (let ((p (open-input-file "testfile.ss")))
               (dynamic-wind void
                 (lambda () (file-position p -1))
                 (lambda () (close-input-port p)))))
     (guard (c [(i/o-invalid-position-error? c)])
       (let ([p (open-input-file "testfile.ss")])
         (dynamic-wind void
           (lambda ()
             (file-position p
               (if (fixnum? (expt 2 32))
                   (- (expt 2 63) 1)
                   (- (expt 2 31) 1)))
             #t)
           (lambda () (close-input-port p)))))
     (error? (let ([p (open-input-file "testfile.ss")])
               (dynamic-wind void
                 (lambda () (file-position p (expt 2 64)))
                 (lambda () (close-input-port p)))))
     (error? (file-position 1))
     (error? (file-length 1))
     (let ([s "hi there"])
       (let ([n (string-length s)] [p (open-input-file "testfile.ss")])
         (and (eqv? (file-length p) (+ 2000 n))
              (eq? (read p) 'ho)
              (eq? (read p) 'there)
              (eqv? (file-position p) n)
              (eqv? (file-position p 2000) (void))
              (eq? (read p) 'hi)
              (eq? (read p) 'there)
              (= (file-position p) (file-length p) (+ 2000 n))
              (eqv? (close-input-port p) (void))))))

(mat string-port-file-position
     (let ([ip (open-input-string "hit me")])
       (and (eq? (read ip) 'hit)
            (eq? (file-position ip) 3)
            (begin (file-position ip 1) (eq? (read ip) 'it))
            (begin
              (file-position ip 6)
              (eof-object? (read ip)))
            (begin
              (file-position ip 0)
              (eq? (read ip) 'hit))))
     (error? (file-position (open-input-string "hi") 3))
     (error? (file-position (open-input-string "hi") -1))
     (let ()
       (define f
         (lambda (n)
           (let ([op (open-output-string)])
             (and (begin (write 'ab op) (eq? (file-position op) 2))
                  (begin
                    (file-position op 4)
                    (write 'ef op)
                    (eq? (file-position op) 6))
                  (begin
                    (file-position op 2)
                    (write 'cd op)
                    (eq? (file-position op) 4))
                  (begin
                    (set-port-length! op n)
                    (get-output-string op))))))
       (and (equal? (f 6) "abcdef")
            (equal? (f 4) "abcd")
            (equal? (f 2) "ab")
            (equal? (f 0) "")
            (equal? (f 5) "abcde")
            (let ((s (f 2000)))
              (and s (= (string-length s) 2000)))))
     (error? (file-position (open-output-string) -1)))

(mat fresh-line
     (procedure? fresh-line)
     (error? (fresh-line 3))
     (error? (fresh-line (open-input-string "hello")))
     (equal? (with-output-to-string
               (lambda ()
                 (fresh-line)
                 (fresh-line)
                 (display "hello")
                 (fresh-line)
                 (fresh-line)))
             "hello\n")
     (begin
       (with-output-to-file "testfile.ss"
         (lambda ()
           (fresh-line)
           (fresh-line)
           (display "hello")
           (fresh-line)
           (fresh-line))
         'replace)
       #t)
     (call-with-input-file "testfile.ss"
       (lambda (p)
         (let ([s (make-string 100)])
           (and (= (block-read p s (string-length s)) 6)
                (string=? (substring s 0 6) "hello\n")
                (eof-object? (read-char p))))))
     (begin
       (with-output-to-file "testfile.ss"
         (lambda ()
           (write-char #\a)
           (fresh-line)
           (flush-output-port)
           (set-port-bol! (current-output-port) #f)
           (fresh-line)
           (write-char #\b)
           (flush-output-port)
           (set-port-bol! (current-output-port) #t)
           (fresh-line)
           (fresh-line)
           (write-char #\c)
           (fresh-line)
           (fresh-line))
         'replace)
       #t)
     (call-with-input-file "testfile.ss"
       (lambda (p)
         (let ([s (make-string 100)])
           (and (= (block-read p s (string-length s)) 6)
                (string=? (substring s 0 6) "a\n\nbc\n")
                (eof-object? (read-char p)))))))

(mat char-ready?
     (procedure? char-ready?)
     (let ([x (open-input-string "a")])
       (and (char-ready? x)
            (eqv? (read-char x) #\a)
            (char-ready? x)
            (eof-object? (read-char x)))))

(mat clear-input-port ; test interactively
     (procedure? clear-input-port))

;;; pretty-equal? is like equal? except that it considers gensyms
;;; with equal print names to be equal and any two nans to be equal.
(define pretty-equal?
  (rec equal?
       (lambda (x y)
         ; mostly snarfed from 5_1.ss
         (or (cond
               [(eq? x y) #t]
               [(pair? x)
                (and (pair? y)
                     (equal? (car x) (car y))
                     (equal? (cdr x) (cdr y)))]
               [(symbol? x)
                (and (gensym? x)
                     (gensym? y)
                     (string=? (symbol->string x) (symbol->string y)))]
               [(or (null? x) (null? y)) #f]
               [(or (char? x) (char? y)) #f]
               [(flonum? x)
                (and (flonum? y)
                     (or (let ([nan? (lambda (x) (not (fl= x x)))])
                           (and (nan? x) (nan? y)))
                         (fl= x y)))]
               [(number? x)
                (and (number? y)
                     (if (exact? x)
                         (and (exact? y) (= x y))
                         (and (equal? (real-part x) (real-part y))
                              (equal? (imag-part x) (imag-part y)))))]
               [(string? x) (and (string? y) (string=? x y))]
               [(box? x) (and (box? y) (equal? (unbox x) (unbox y)))]
               [(vector? x)
                (and (vector? y)
                     (= (vector-length x) (vector-length y))
                     (let f ([i (- (vector-length x) 1)])
                       (or (< i 0)
                           (and (equal? (vector-ref x i) (vector-ref y i))
                                (f (1- i))))))]
               [(fxvector? x)
                (and (fxvector? y)
                     (= (fxvector-length x) (fxvector-length y))
                     (let f ([i (- (fxvector-length x) 1)])
                       (or (< i 0)
                           (and (fx= (fxvector-ref x i) (fxvector-ref y i))
                                (f (1- i))))))]
               [(bytevector? x) (and (bytevector? y) (bytevector=? x y))]
               [else #f])
             (parameterize ([print-length 6] [print-level 3])
               (display "----------------------\n")
               (pretty-print x)
               (pretty-print '=/=)
               (pretty-print y)
               (display "----------------------\n")
               #f)))))

(mat pretty-print
     (let ([pretty-copy
             (lambda (ifn ofn)
               (let ([ip (open-input-file ifn)]
                     [op (open-output-file ofn 'replace)])
                 (dynamic-wind (lambda () #f)
                   (rec loop
                        (lambda ()
                          (let ([x (read ip)])
                            (or (eof-object? x)
                                (parameterize ([print-unicode #f])
                                  (pretty-print x op)
                                  (newline op)
                                  (loop))))))
                   (lambda ()
                     (close-input-port ip)
                     (close-output-port op)))))])
       (pretty-copy "prettytest.ss" "testfile.ss"))
     (let ([p1 (open-input-file "prettytest.ss")]
           [p2 (open-input-file "testfile.ss")])
       (dynamic-wind (lambda () #f)
         (rec loop
              (lambda ()
                (let ([x1 (read p1)] [x2 (read p2)])
                  (unless (pretty-equal? x1 x2)
                          (errorf 'pretty-equal
                                  "~s is not equal to ~s"
                                  x1
                                  x2))
                  (or (eof-object? x1) (loop)))))
         (lambda ()
           (close-input-port p1)
           (close-input-port p2))))
     (error? (pretty-format))
     (error? (pretty-format 'foo 'x 'x))
     (error? (pretty-format 3 'x))
     (error? (pretty-format 'foo '(bad 0 ... ... 0 format)))
     (list? (pretty-format 'let))
     (let ([x (pretty-format 'let)])
       (pretty-format 'let x)
       (equal? x (pretty-format 'let)))
     (string=? (parameterize
                 ([pretty-standard-indent 2] [pretty-one-line-limit 1])
                 (pretty-format 'frob
                   '(frob (x 1 ...) 3 (x #f ...) 4 (x y 3 ...) ...))
                 (with-output-to-string
                   (lambda ()
                     (pretty-print
                       '(frob (alpha b c d)
                              (peter o n m)
                              (zero 1 2 3)
                              (nine 8 7 6))))))
               "(frob (alpha\n        b\n        c\n        d)\n    (peter\n       o\n       n\n       m)\n     (zero 1\n         2\n         3)\n     (nine 8\n         7\n         6))\n")
     (eqv? (begin (pretty-format 'frob #f) (pretty-format 'frob)) #f)
     (equal? (with-output-to-string
               (lambda ()
                 (pretty-print ''#'#`#,#,@,,@`(a b c))))
             "'#'#`#,#,@,,@`(a b c)\n"))

(mat write
     (let ([unpretty-copy
             (lambda (ifn ofn)
               (let ([ip (open-input-file ifn)]
                     [op (open-output-file ofn 'replace)])
                 (dynamic-wind (lambda () #f)
                   (rec loop
                        (lambda ()
                          (let ([x (read ip)])
                            (or (eof-object? x)
                                (parameterize ([print-unicode #f])
                                  (write x op)
                                  (newline op)
                                  (loop))))))
                   (lambda ()
                     (close-input-port ip)
                     (close-output-port op)))))])
       (unpretty-copy "prettytest.ss" "testfile.ss"))
     (let ([p1 (open-input-file "prettytest.ss")]
           [p2 (open-input-file "testfile.ss")])
       (dynamic-wind (lambda () #f)
         (rec loop
              (lambda ()
                (let ([x1 (read p1)] [x2 (read p2)])
                  (unless (pretty-equal? x1 x2)
                          (errorf 'pretty-equal
                                  "~s is not equal to ~s"
                                  x1
                                  x2))
                  (or (eof-object? x1) (loop)))))
         (lambda ()
           (close-input-port p1)
           (close-input-port p2)))))

(mat fasl
     (pretty-equal?
       (begin
         (call-with-port
           (open-file-output-port "testfile.ss" (file-options replace))
           (lambda (p) (fasl-write +nan.0 p)))
         (call-with-port (open-file-input-port "testfile.ss") fasl-read))
       (/ 0.0 0.0))
     (let ([ls (with-input-from-file "prettytest.ss"
                 (rec f
                      (lambda ()
                        (let ([x (read)])
                          (if (eof-object? x)
                              '()
                              (cons x (f)))))))])
       (define-record frob
         (x1 (uptr x2)
             (fixnum x3)
             (float x4)
             (double x5)
             (wchar_t x6)
             (integer-64 x7)
             (char x8)
             (unsigned-64 x9)))
       (let ([x (make-frob
                  '#(#&3+4i 3.456+723i 3/4)
                  7500000
                  (most-negative-fixnum)
                  +nan.0
                  3.1415
                  #\x3d0
                  (- (expt 2 63) 5)
                  #\$
                  (- (expt 2 64) 5))])
         (define put-stuff
           (lambda (p)
             (fasl-write (cons x x) p)
             (fasl-write (list +nan.0 +inf.0 -inf.0 -0.0) p)
             (for-each (lambda (x) (fasl-write x p)) ls)))
         (define (get-stuff fasl-read)
           (lambda (p)
             (let ([y (fasl-read p)])
               (and (equal? ($record->vector (car y)) ($record->vector x))
                    (eq? (cdr y) (car y))
                    (pretty-equal? (fasl-read p)
                      (list +nan.0 +inf.0 -inf.0 -0.0))
                    (let loop ([ls ls])
                      (let ([x1 (fasl-read p)]
                            [x2 (if (null? ls) #!eof (car ls))])
                        (unless (pretty-equal? x1 x2)
                                (errorf #f "~s is not equal to ~s" x1 x2))
                        (or (eof-object? x1)
                            (loop (cdr ls)))))))))
         (call-with-port
           (open-file-output-port "testfile.ss" (file-options replace))
           put-stuff)
         (and (call-with-port (open-file-input-port "testfile.ss")
                (get-stuff fasl-read))
              (call-with-port
                (open-file-input-port "testfile.ss"
                  (file-options compressed))
                (get-stuff fasl-read))
              (call-with-port
                (open-file-input-port "testfile.ss"
                  (file-options compressed))
                (get-stuff
                  (lambda (p)
                    (when (eof-object? (lookahead-u8 p))
                          (printf "done\n"))
                    (fasl-read p))))
              (begin
                (call-with-port
                  (open-file-output-port "testfile.ss"
                    (file-options compressed replace))
                  put-stuff)
                (call-with-port
                  (open-file-input-port "testfile.ss"
                    (file-options compressed))
                  (get-stuff fasl-read)))
              (call-with-port
                (open-bytevector-input-port
                  (call-with-bytevector-output-port put-stuff))
                (get-stuff fasl-read)))))
     (eqv? (fasl-file "prettytest.ss" "testfile.ss") (void))
     (let ([ls (with-input-from-file "prettytest.ss"
                 (rec f
                      (lambda ()
                        (let ([x (read)])
                          (if (eof-object? x)
                              '()
                              (cons x (f)))))))])
       (call-with-port (open-file-input-port "testfile.ss")
         (lambda (p)
           (let loop ([ls ls])
             (let ([x1 (fasl-read p)] [x2 (if (null? ls) #!eof (car ls))])
               (unless (pretty-equal? x1 x2)
                       (errorf #f "~s is not equal to ~s" x1 x2))
               (or (eof-object? x1) (loop (cdr ls))))))))
     (equal? (with-interrupts-disabled
               (let ([ls (cons (weak-cons 'a 'b)
                               (weak-cons 'c (cons 'd (weak-cons 'e #f))))])
                 (call-with-port
                   (open-file-output-port "testfile.ss"
                     (file-options replace))
                   (lambda (p) (fasl-write ls p))))
               (let ([ls (call-with-port
                           (open-file-input-port "testfile.ss")
                           fasl-read)])
                 (list (equal? ls '((a . b) c d e . #f))
                       (weak-pair? ls)
                       (weak-pair? (car ls))
                       (weak-pair? (cdr ls))
                       (weak-pair? (cddr ls))
                       (weak-pair? (cdddr ls)))))
             '(#t #f #t #t #f #t)))

(mat clear-output-port ; test interactively
     (procedure? clear-output-port))

(mat flush-output-port ; test interactively
     (procedure? flush-output-port))

;;; section 6-3:

(mat format
     (equal? (format "abcde") "abcde")
     (equal? (format "~s ~a ~c ~~ ~%" "hi" "there" #\X)
             (string-append "\"hi\" there X ~ " (string #\newline)))
     (equal? (format "~s" car) "#<procedure car>")
     (equal? (format "~s" (lambda () #f)) "#<procedure>"))

(mat printf
     (let ([p (open-output-string)])
       (parameterize ([current-output-port p]) (printf "~s:~s" 3 4))
       (equal? (get-output-string p) "3:4")))

(mat fprintf
     (let ([p (open-output-string)])
       (fprintf p "~s.~s:~s" 'abc 345 "xyz")
       (equal? (get-output-string p) "abc.345:\"xyz\"")))

(mat cp1in-verify-format-warnings
     (warning? (parameterize ([#%$suppress-primitive-inlining #f])
                 (eval '(lambda () (import scheme) (format "~a~~~s" 5)))))
     (warning? (parameterize ([#%$suppress-primitive-inlining #f])
                 (eval '(lambda ()
                          (import scheme)
                          (format "~a~a~a~s" 1 2 3 4 5 6)))))
     (warning? (parameterize ([#%$suppress-primitive-inlining #f])
                 (eval '(mat/cf (lambda ()
                                  (import scheme)
                                  (format "~a~~~s" 5))))))
     (warning? (parameterize ([#%$suppress-primitive-inlining #f])
                 (eval '(mat/cf (lambda ()
                                  (import scheme)
                                  (format "~a~a~a~s" 1 2 3 4 5 6))))))

     (warning? (parameterize ([#%$suppress-primitive-inlining #f])
                 (eval '(lambda () (import scheme) (printf "abc~s")))))
     (warning? (parameterize ([#%$suppress-primitive-inlining #f])
                 (eval '(lambda ()
                          (import scheme)
                          (printf "~%~abc~adef~ag~s~~~%" 1 2 3 4 5)))))
     (warning? (parameterize ([#%$suppress-primitive-inlining #f])
                 (eval '(mat/cf (lambda () (import scheme) (printf "abc~s"))))))
     (warning? (parameterize ([#%$suppress-primitive-inlining #f])
                 (eval '(mat/cf (lambda ()
                                  (import scheme)
                                  (printf "~%~abc~adef~ag~s~~~%" 1 2 3 4 5))))))

     (warning? (parameterize ([#%$suppress-primitive-inlining #f])
                 (eval '(lambda (p) (import scheme) (fprintf p "abc~s")))))
     (warning? (parameterize ([#%$suppress-primitive-inlining #f])
                 (eval '(lambda (p)
                          (import scheme)
                          (fprintf p "~%~abc~adef~ag~s~~~%" 1 2 3 4 5)))))
     (warning? (parameterize ([#%$suppress-primitive-inlining #f])
                 (eval '(mat/cf (lambda (p)
                                  (import scheme)
                                  (fprintf p "abc~s"))))))
     (warning? (parameterize ([#%$suppress-primitive-inlining #f])
                 (eval '(mat/cf (lambda (p)
                                  (import scheme)
                                  (fprintf p "~%~abc~adef~ag~s~~~%" 1 2 3 4 5)))))))

(mat print-parameters
     (equal? (parameterize ([print-level 3])
               (format "~s" (let ([x (list 'a)]) (set-car! x x) x)))
             "((((...))))")
     (equal? (parameterize ([print-length 3])
               (format "~s" (let ([x (list 'a)]) (set-cdr! x x) x)))
             "(a a a ...)")
     (equal? (parameterize ([print-graph #t])
               (format "~s" (let ([x (list 'a)]) (set-car! x x) x)))
             "#0=(#0#)")
     (equal? (parameterize ([print-graph #t])
               (format "~s" (let ([x (list 'a)]) (set-cdr! x x) x)))
             "#0=(a . #0#)")
     (equal? (parameterize ([print-graph #t])
               (format "~s"
                 (let ([x (list 'a)] [y (list 'b)])
                   (list x y y x))))
             "(#0=(a) #1=(b) #1# #0#)")
     (equal? (parameterize ([print-graph #t])
               (format "~s"
                 (let ([x (list 'a)] [y (list 'b)])
                   (vector x y y x))))
             "#(#0=(a) #1=(b) #1# #0#)")
     (equal? (parameterize ([print-graph #t])
               (format "~s" '(#2# #2=#{a b})))
             "(#0=#{a b} #0#)")
     (error? (guard (c [(and (warning? c) (format-condition? c))
                        (apply errorf
                          (condition-who c)
                          (condition-message c)
                          (condition-irritants c))])
                    (format "~s"
                      (let ([x (list '*)])
                        (set-car! x x)
                        (set-cdr! x x)
                        x))))
     (equal? (parameterize ([print-vector-length #f])
               (format "~s ~s" '#5(1 2 3) '#8vfx(5 7 9 8 8 9 -1)))
             "#(1 2 3 3 3) #vfx(5 7 9 8 8 9 -1 -1)")
     (equal? (parameterize ([print-vector-length #t])
               (format "~s ~s" '#(1 2 3 3 3) '#vfx(5 7 9 8 8 9 -1 -1)))
             "#5(1 2 3) #8vfx(5 7 9 8 8 9 -1)")
     (equal? (parameterize ([print-vector-length #f])
               (format "~a ~a" '#5(1 2 3) '#8vfx(5 7 9 8 8 9 -1)))
             "#(1 2 3 3 3) #vfx(5 7 9 8 8 9 -1 -1)")
     (equal? (parameterize ([print-vector-length #t])
               (format "~a ~a" '#(1 2 3 3 3) '#vfx(5 7 9 8 8 9 -1 -1)))
             "#(1 2 3 3 3) #vfx(5 7 9 8 8 9 -1 -1)")
     (equal? (parameterize ([print-vector-length #f])
               (with-output-to-string
                 (lambda ()
                   (pretty-print '#5(1 2 3))
                   (pretty-print '#8vfx(5 7 9 8 8 9 -1)))))
             "#(1 2 3 3 3)\n#vfx(5 7 9 8 8 9 -1 -1)\n")
     (equal? (parameterize ([print-vector-length #t])
               (with-output-to-string
                 (lambda ()
                   (pretty-print '#(1 2 3 3 3))
                   (pretty-print '#vfx(5 7 9 8 8 9 -1 -1)))))
             "#5(1 2 3)\n#8vfx(5 7 9 8 8 9 -1)\n")
     (equal? (parameterize ([print-extended-identifiers #f])
               (with-output-to-string
                 (lambda ()
                   (for-each
                     pretty-print
                     '(1+ +++ .. |12| xyz aBc |-155| |.5e7| |.5e|)))))
             "\\x31;+\n\\x2B;++\n\\x2E;.\n\\x31;2\nxyz\naBc\n\\x2D;155\n\\x2E;5e7\n\\x2E;5e\n")
     (equal? (parameterize ([print-extended-identifiers #t])
               (with-output-to-string
                 (lambda ()
                   (for-each
                     pretty-print
                     '(1+ +++ .. |12| xyz aBc |-155| |.5e7| |.5e|)))))
             "1+\n+++\n..\n\\x31;2\nxyz\naBc\n\\x2D;155\n\\x2E;5e7\n.5e\n")
     (equal? (parameterize ([print-gensym #f])
               (format "~s" '(#3# #3=#{g0 fool})))
             "(g0 g0)")
     (equal? (parameterize ([print-graph #t] [print-gensym #f])
               (format "~s" '(#4# #4=#{g0 fool})))
             "(#0=g0 #0#)")
     (equal? (parameterize ([print-gensym 'pretty])
               (format "~s" '(#5# #5=#{g0 fool})))
             "(#:g0 #:g0)")
     (equal? (parameterize ([print-graph #t] [print-gensym 'pretty])
               (format "~s" '(#6# #6=#{g0 fool})))
             "(#0=#:g0 #0#)")
     (equal? (parameterize ([print-gensym 'pretty])
               (format "~s" '(#7# #7=#:g0)))
             "(#:g0 #:g0)")
     (let ([g (gensym "x")])
       (parameterize ([print-gensym 'pretty/suffix])
         (equal? (format "~s" g) (format "~s" g))))
     (do ([i 100 (fx- i 1)])
         ((fx= i 0) #t)
         (let ([g (gensym "x")])
           (unless (< (string-length
                        (parameterize ([print-gensym 'pretty/suffix])
                          (format "~s" g)))
                      (string-length
                        (parameterize ([print-gensym #t]) (format "~s" g))))
                   (error #f "failed"))))
     (let ([g (gensym "x")])
       (let ([x (with-input-from-string
                  (parameterize ([print-gensym 'pretty/suffix])
                    (format "~s" g))
                  read)])
         (and (symbol? x) (not (gensym? x)))))
     (equal? (parameterize ([print-gensym 'pretty/suffix])
               (format "~s" '#{g0 cfdhkxfnlo6opm0x-c}))
             "g0.cfdhkxfnlo6opm0x-c")
     (equal? (parameterize ([print-graph #t] [print-gensym 'pretty])
               (format "~s" '(#8# #8=#:g0)))
             "(#0=#:g0 #0#)")
     (equal? (parameterize ([print-brackets #t])
               (let ([p (open-output-string)])
                 (pretty-print '(let ((x 3)) x) p)
                 (get-output-string p)))
             (format "~a~%" "(let ([x 3]) x)"))
     (equal? (parameterize ([print-brackets #f])
               (let ([p (open-output-string)])
                 (pretty-print '(let ((x 3)) x) p)
                 (get-output-string p)))
             (format "~a~%" "(let ((x 3)) x)"))
     (equal? (parameterize ([case-sensitive #t])
               (format "~s" (string->symbol "AbcDEfg")))
             "AbcDEfg")
     (equal? (format "~s" (read (open-input-string "abCdEfG"))) "abCdEfG")
     (equal? (parameterize ([case-sensitive #f])
               (format "~s" (read (open-input-string "abCdEfG"))))
             "abcdefg")
     (equal? (parameterize ([print-radix 36]) (format "~s" 35)) "#36rZ")
     (equal? (parameterize ([print-radix 36]) (format "~a" 35)) "Z"))

(mat general-port
     (<= (port-input-index (console-input-port))
         (port-input-size (console-input-port))
         (string-length (port-input-buffer (console-input-port))))
     (<= (port-input-count (console-input-port))
         (string-length (port-input-buffer (console-input-port))))
     (<= (port-output-index (console-output-port))
         (port-output-size (console-output-port))
         (string-length (port-output-buffer (console-output-port))))
     (<= (port-output-count (console-output-port))
         (string-length (port-output-buffer (console-output-port))))
     (equal? (let ([sip (open-string-input-port "hello")])
               (let ([n1 (port-input-count sip)])
                 (read-char sip)
                 (list n1 (port-input-count sip))))
             '(5 4))
     (equal? (let ([op (make-output-port (lambda args (error #f "oops"))
                         (make-string 10))])
               (let ([n1 (port-output-count op)])
                 (display "hey!" op)
                 (list n1 (port-output-count op))))
             '(10 6))
     (let ()
       (define make-two-way-port
         ; no local buffering
         ; close-port passed through
         (lambda (ip op)
           (define handler
             (lambda (msg . args)
               (record-case (cons msg args)
                 [block-read (p s n) (block-read ip s n)]
                 [block-write (p s n) (block-write op s n)]
                 [char-ready? (p) (char-ready? ip)]
                 [clear-input-port (p) (clear-input-port ip)]
                 [clear-output-port (p) (clear-output-port op)]
                 [close-port (p)
                   (close-port ip)
                   (close-port op)
                   (mark-port-closed! p)]
                 ;                     [file-length (p) #f]
                 [file-position (p . pos)
                   (if (null? pos)
                       (most-negative-fixnum)
                       (errorf 'two-way-port "cannot reposition"))]
                 [flush-output-port (p) (flush-output-port op)]
                 [peek-char (p) (peek-char ip)]
                 [port-name (p) "two-way port"]
                 [read-char (p) (read-char ip)]
                 [unread-char (c p) (unread-char c ip)]
                 [write-char (c p) (write-char c op)]
                 [else
                  (errorf 'two-way-port "operation ~s not handled" msg)])))
           (make-input/output-port handler "" "")))
       (let ([sip (open-input-string "far out")]
             [sop (open-output-string)])
         (let ([p1 (make-two-way-port sip sop)])
           (and (port? p1)
                (begin
                  (write (read p1) p1)
                  (string=? (get-output-string sop) "far"))
                (char-ready? p1)
                (char=? (read-char p1) #\space)
                (char=? (read-char p1) #\o)
                (begin
                  (unread-char #\o p1)
                  (char=? (read-char p1) #\o))
                ; can't count on clear-output-port doing anything for
                ; string output ports, so next two checks are bogus
                #;
                (begin
                  (write-char #\a p1)
                  (clear-output-port p1)
                  (string=? (get-output-string sop) ""))
                (begin
                  (file-position sip (file-length sip))
                  (char-ready? p1))
                (eof-object? (peek-char p1))
                ; make sure these don't error out
                (eq? (clear-input-port p1) (void))
                (eq? (clear-output-port p1) (void))
                (begin (close-port p1) (port-closed? p1))
                (port-closed? sip)
                (port-closed? sop)))))
     (let ()
       (define make-broadcast-port
         ; local buffering
         ; closed-port not passed through
         ; critical sections used where necessary to protect against interrupts
         ; uses block-write to dump buffers to subordinate ports
         ; check cltl2 to see what it says about local buffering,
         ;    and about passing through flush, clear, and close
         ; size set so that buffer always has room for character to be written,
         ;   allowing buffer to be flushed as soon as it becomes full
         (lambda ports
           (define handler
             (lambda (msg . args)
               (record-case (cons msg args)
                 ;                     [block-read (p s n) #f]
                 [block-write (p s n)
                   (unless (null? ports)
                           (with-interrupts-disabled (flush-output-port p)
                             (for-each
                               (lambda (p)
                                 (block-write p s n))
                               ports)))]
                 ;                     [char-ready? (p) (char-ready? ip)]
                 ;                     [clear-input-port (p) (clear-input-port ip)]
                 [clear-output-port (p) (set-port-output-index! p 0)]
                 [close-port (p)
                   (set-port-output-size! p 0)
                   (mark-port-closed! p)]
                 ;                     [file-length (p) #f]
                 [file-position (p . pos)
                   (if (null? pos)
                       (most-negative-fixnum)
                       (errorf 'broadcast-port "cannot reposition"))]
                 [flush-output-port (p)
                   (with-interrupts-disabled
                     (unless (null? ports)
                             (let ([b (port-output-buffer p)]
                                   [i (port-output-index p)])
                               (for-each
                                 (lambda (p)
                                   (block-write p b i))
                                 ports)))
                     (set-port-output-index! p 0))]
                 ;                     [peek-char (p) (peek-char ip)]
                 [port-name (p) "broadcast port"]
                 ;                     [read-char (p) (read-char ip)]
                 ;                     [unread-char (c p) (unread-char c ip)]
                 [write-char (c p)
                   (with-interrupts-disabled
                     (unless (null? ports)
                             (let ([b (port-output-buffer p)]
                                   [i (port-output-index p)])
                               ; could check here to be sure that we really need
                               ; to flush
                               (string-set! b i c)
                               (for-each
                                 (lambda (p)
                                   (block-write p b (fx+ i 1)))
                                 ports)))
                     (set-port-output-index! p 0))]
                 [else
                  (errorf 'broadcast-port "operation ~s not handled" msg)])))
           (let ([len 1024])
             (let ([p (make-output-port handler (make-string len))])
               (set-port-output-size! p (fx- len 1))
               p))))
       (let ([p (make-broadcast-port)])
         (and (port? p)
              (let ([x (make-string 1000 #\a)])
                (let loop ([i 1000])
                  (if (fx= i 0)
                      (fx<= (port-output-index p)
                            (port-output-size p)
                            (string-length (port-output-buffer p)))
                      (begin (display x p) (loop (fx- i 1))))))
              (begin (close-port p) (port-closed? p))))
       (let ([sop (open-output-string)])
         (let ([p (make-broadcast-port sop sop)])
           (and (port? p)
                (let ([x "abcde"])
                  (display x p)
                  (and (string=? (get-output-string sop) "")
                       (begin
                         (flush-output-port p)
                         (string=? (get-output-string sop)
                                   (string-append x x)))))
                (begin
                  (close-output-port p)
                  (port-closed? p))))))

     (let ()
       (define make-transcript-port
         ; local buffering; run into problems with unread-char and
         ;     clear-output-port otherwise
         ; close-port passed through to tp only
         (lambda (ip op tp)
           (define handler
             (lambda (msg . args)
               (record-case (cons msg args)
                 [block-read (p str cnt)
                   (with-interrupts-disabled
                     (let ([b (port-input-buffer p)]
                           [i (port-input-index p)]
                           [s (port-input-size p)])
                       (if (< i s)
                           (let ([cnt (fxmin cnt (fx- s i))])
                             (do ([i i (fx+ i 1)] [j 0 (fx+ j 1)])
                                 ((fx= j cnt) (set-port-input-index! p i) cnt)
                                 (string-set! str j (string-ref b i))))
                           (let ([cnt (block-read ip str cnt)])
                             (unless (eof-object? cnt)
                                     (block-write tp str cnt))
                             cnt))))]
                 [char-ready? (p)
                   (or (< (port-input-index p) (port-input-size p))
                       (char-ready? ip))]
                 [clear-input-port (p)
                   ; set size to zero rather than index to size
                   ; in order to invalidate unread-char
                   (set-port-input-size! p 0)]
                 [clear-output-port (p) (set-port-output-index! p 0)]
                 [close-port (p)
                   (flush-output-port p)
                   (close-port tp)
                   (set-port-output-size! p 0)
                   (set-port-input-size! p 0)
                   (mark-port-closed! p)]
                 ;                     [file-length (p) #f]
                 [file-position (p . pos)
                   (if (null? pos)
                       (most-negative-fixnum)
                       (errorf 'transcript-port "cannot reposition"))]
                 [flush-output-port (p)
                   (with-interrupts-disabled
                     (let ([b (port-output-buffer p)]
                           [i (port-output-index p)])
                       (block-write op b i)
                       (block-write tp b i)
                       (set-port-output-index! p 0)
                       (flush-output-port op)
                       (flush-output-port tp)))]
                 [peek-char (p)
                   (with-interrupts-disabled
                     (let ([b (port-input-buffer p)]
                           [i (port-input-index p)]
                           [s (port-input-size p)])
                       (if (fx< i s)
                           (string-ref b i)
                           (begin
                             (flush-output-port p)
                             (let ([s (block-read ip b)])
                               (if (eof-object? s)
                                   s
                                   (begin
                                     (block-write tp b s)
                                     (set-port-input-size! p s)
                                     (string-ref b 0))))))))]
                 [port-name (p) "transcript"]
                 [read-char (p)
                   (with-interrupts-disabled
                     (let ([c (peek-char p)])
                       (unless (eof-object? c)
                               (set-port-input-index! p
                                 (fx+ (port-input-index p) 1)))
                       c))]
                 [unread-char (c p)
                   (with-interrupts-disabled
                     (let ([b (port-input-buffer p)]
                           [i (port-input-index p)]
                           [s (port-input-size p)])
                       (when (fx= i 0)
                             (errorf 'unread-char
                                     "tried to unread too far on ~s"
                                     p))
                       (set-port-input-index! p (fx- i 1))
                       ; following could be skipped; supposed to be
                       ; same character
                       (string-set! b (fx- i 1) c)))]
                 [write-char (c p)
                   (with-interrupts-disabled
                     (let ([b (port-output-buffer p)]
                           [i (port-output-index p)]
                           [s (port-output-size p)])
                       (string-set! b i c)
                       ; could check here to be sure that we really need
                       ; to flush
                       (block-write op b (fx+ i 1))
                       (block-write tp b (fx+ i 1))
                       (set-port-output-index! p 0)))]
                 [block-write (p str cnt)
                   (with-interrupts-disabled
                     (let ([b (port-output-buffer p)]
                           [i (port-output-index p)])
                       ; flush buffered data
                       (when (fx> i 0)
                             (block-write op b i)
                             (block-write tp b i))
                       ; write new data
                       (block-write op str cnt)
                       (block-write tp str cnt)
                       (set-port-output-index! p 0)))]
                 [else
                  (errorf 'transcript-port "operation ~s not handled" msg)])))
           (let ([ib (make-string 100)] [ob (make-string 100)])
             (let ([p (make-input/output-port handler ib ob)])
               (if (char-ready? ip)
                   ; kludge so that old input doesn't show up after later
                   ; output (e.g., input newline after output prompt)
                   (let ((n (block-read ip ib (string-length ib))))
                     (if (eof-object? n)
                         (set-port-input-size! p 0)
                         (set-port-input-size! p n)))
                   (set-port-input-size! p 0))
               (set-port-output-size! p (fx- (string-length ob) 1))
               p))))
       ;      (define-record tp-frame (cip cop tp))
       ;      (define tp-stack '())
       ;      (define transcript-on
       ;        (lambda (fn)
       ;          (with-interrupts-disabled
       ;            (let ((cip (console-input-port))
       ;                  (cop (console-output-port)))
       ;              (let ((tp (make-transcript-port cip cop
       ;                          (open-output-file fn 'replace))))
       ;                (set! tp-stack (cons (make-tp-frame cip cop tp) tp-stack))
       ;               (console-output-port tp)
       ;               (console-input-port tp)
       ;               (when (eq? (current-input-port) cip)
       ;                  (current-input-port tp))
       ;               (when (eq? (current-output-port) cop)
       ;                  (current-output-port tp)))))))
       ;      (define transcript-off
       ;        (lambda ()
       ;          (with-interrupts-disabled
       ;            (when (null? tp-stack) (errorf 'transcript-off "no transcript running"))
       ;            (let ((frame (car tp-stack)))
       ;              (let ((cip (tp-frame-cip frame))
       ;                    (cop (tp-frame-cop frame))
       ;                    (tp (tp-frame-tp frame)))
       ;                (console-input-port cip)
       ;                (console-output-port cop)
       ;                (when (eq? (current-input-port) tp) (current-input-port cip))
       ;                (when (eq? (current-output-port) tp) (current-output-port cop))
       ;                (set! tp-stack (cdr tp-stack))
       ;                (close-port tp))))))
       (let ([ip (open-input-string (format "2"))]
             [op (open-output-string)]
             [tp (open-output-string)])
         (let ([p (make-transcript-port ip op tp)])
           (and (begin (display "1" p) (eq? (read p) 2))
                (begin
                  (display "3" p)
                  (flush-output-port p)
                  (and (string=? (get-output-string op) "13")
                       ; 2 doesn't show up since we scan past available
                       ; input (see "kludge" above)
                       (string=? (get-output-string tp) "13")))
                (begin
                  (close-port p)
                  (and (port-closed? p) (port-closed? tp))))))))

(mat port-handler
     (begin
       (set! ph (port-handler (current-output-port)))
       (procedure? ph))
     (string? (ph 'port-name (current-output-port)))
     (error? (ph))
     (error? (ph 'foo))
     (error? (ph 'foo (current-output-port)))
     (error? (ph 'read-char))
     (error? (ph 'write-char))
     (error? (ph 'write-char 3))
     (error? (ph 'write-char (current-input-port)))
     (error? (ph 'write-char 'a (current-output-port)))
     (error? (ph 'write-char #\a 'a))
     (error? (ph 'write-char #\a (open-input-string "hello")))
     (error? (ph 'write-char #\a (current-output-port) 'a))
     (boolean? (ph 'char-ready? (current-input-port))))

(mat char-name
     (eqv? (char-name 'space) #\space)
     (eqv? (char-name #\space) 'space)
     (eqv? (char-name 'tab) #\tab)
     (eqv? (char-name #\tab) 'tab)
     (eqv? (char-name 'return) #\return)
     (eqv? (char-name #\return) 'return)
     (eqv? (char-name 'page) #\page)
     (eqv? (char-name #\page) 'page)
     (eqv? (char-name 'linefeed) #\linefeed)
     (eqv? (char-name #\linefeed) 'newline)
     (eqv? (char-name 'newline) #\newline)
     (eqv? (char-name #\newline) 'newline)
     (eqv? (char-name #\backspace) 'backspace)
     (eqv? (char-name 'backspace) #\backspace)
     (eqv? (char-name #\rubout) 'delete)
     (eqv? (char-name 'rubout) #\rubout)
     (eqv? (char-name #\nul) 'nul)
     (eqv? (char-name 'nul) #\nul)
     (eqv? (char-name 'foo) #f)
     (eqv? (char-name 'delete) #\delete)
     (eqv? (char-name #\delete) 'delete)
     (eqv? (char-name 'vtab) #\vtab)
     (eqv? (char-name #\vtab) 'vtab)
     (eqv? (char-name 'alarm) #\alarm)
     (eqv? (char-name #\alarm) 'alarm)
     (eqv? (char-name 'esc) #\esc)
     (eqv? (char-name #\esc) 'esc)
     (error? (read (open-input-string "#\\foo")))
     (and (eqv? (char-name 'foo #\003) (void))
          (eqv? (char-name 'foo) #\003)
          (eqv? (char-name #\003) 'foo)
          (eqv? (read (open-input-string "#\\foo")) #\003))
     (equal? (begin
               (char-name 'foo #f)
               (list (char-name 'foo) (char-name #\003)))
             '(#f #f))
     (error? (read (open-input-string "#\\new\\line")))
     (error? (read (open-input-string "#\\new\\x6c;ine"))))

(mat string-escapes
     (eqv? (string-ref "ab\b" 2) #\backspace)
     (eqv? (string-ref "\n" 0) #\newline)
     (eqv? (string-ref "a\fb" 1) #\page)
     (eqv? (string-ref "ab\r" 2) #\return)
     (eqv? (string-ref "\t" 0) #\tab)
     (eqv? (string-ref "\a\v" 0) #\bel)
     (eqv? (string-ref "\a\v" 1) #\vt)
     (eqv? (string-ref "\000" 0) #\nul)
     (eqv? (string-ref "\x00;" 0) #\nul)
     (eqv? (string-ref "a\x20;b" 1) #\space)
     (eqv? (string-ref "\\\"\'" 0) #\\)
     (eqv? (string-ref "\\\"\'" 1) #\")
     (eqv? (string-ref "\\\"\'" 2) #\')
     (= (char->integer (string-ref "a\012" 1)) #o12 10)
     (= (char->integer (string-ref "a\015" 1)) #o15 13)
     (= (char->integer (string-ref "a\177" 1)) #o177 127)
     (= (char->integer (string-ref "a\377" 1)) #o377 255)
     (error? (read (open-input-string "\"ab\\\"")))
     (error? (read (open-input-string "\"ab\\0\"")))
     (error? (read (open-input-string "\"ab\\01\"")))
     (error? (read (open-input-string "\"ab\\*\"")))
     (error? (read (open-input-string "\"ab\\x\"")))
     (error? (read (open-input-string "\"ab\\x*\"")))
     (error? (read (open-input-string "\"ab\\xg\"")))
     (equal? (format "~s" "\bab\nc\f\rd\t\v\a")
             "\"\\bab\\nc\\f\\rd\\t\\v\\a\""))

(mat read-token
     (let ([ip (open-input-string "(cons 33 #;hello \"rot\")")])
       (and (let-values ([vals (read-token ip)])
              (equal? vals '(lparen #f 0 1)))
            (let-values ([vals (read-token ip)]) (equal? vals '(atomic cons 1 5)))
            (let-values ([vals (read-token ip)]) (equal? vals '(atomic 33 6 8)))
            (let-values ([vals (read-token ip)]) (equal? vals '(quote datum-comment 9 11)))
            (let-values ([vals (read-token ip)]) (equal? vals '(atomic hello 11 16)))
            (let-values ([vals (read-token ip)]) (equal? vals '(atomic "rot" 17 22)))
            (let-values ([vals (read-token ip)]) (equal? vals '(rparen #f 22 23)))))
     (let ()
       (define with-input-from-string
         (lambda (s p)
           (parameterize ([current-input-port (open-input-string s)]) (p))))
       (with-input-from-string "\n#17#\n"
         (lambda ()
           (let-values ([vals (read-token)])
             (equal? vals '(insert 17 1 5))))))
     (let ()
       (with-output-to-file "testfile.ss"
         (lambda () (display "\n#eat\n"))
         'replace)
       #t)
     (error? (let* ([ip (open-file-input-port "testfile.ss")]
                    [sfd (#%$source-file-descriptor "testfile.ss" ip)]
                    [ip (transcoded-port ip (native-transcoder))])
               (dynamic-wind void
                 (lambda () (read-token ip sfd))
                 (lambda () (close-input-port ip)))))
     (let ()
       (with-output-to-file "testfile.ss"
         (lambda () (display "\neat\n"))
         'replace)
       #t)
     ; $transcoded-source-port is no more
     #;
     (equal? (let-values
               ([vals (let* ([ip (open-file-input-port "testfile.ss")]
                             [sfd (#%$source-file-descriptor "testfile.ss" ip)]
                             [ip (#%$transcoded-source-port ip (native-transcoder))])
                        (dynamic-wind void
                          (lambda () (read-token ip sfd))
                          (lambda () (close-input-port ip))))])
               vals)
             '(atomic eat 1 4)))

(define read-test
  (lambda (s)
    (with-output-to-file "testfile.ss" (lambda () (display s)) 'replace)
    (load "testfile.ss" values)
    #t))
(define load-test
  (lambda (s)
    (with-output-to-file "testfile.ss" (lambda () (display s)) 'replace)
    (load "testfile.ss")
    #t))
(define compile-test
  (lambda (s)
    (with-output-to-file "testfile.ss" (lambda () (display s)) 'replace)
    (compile-file "testfile.ss")
    (load "testfile.so")
    #t))

(define-syntax xmat
  (syntax-rules ()
    [(_ string ...)
     (begin
       (mat read-test (error? (read-test string)) ...)
       (mat load-test (error? (load-test string)) ...)
       (mat compile-test (error? (compile-test string)) ...))]))

(begin
  (define-record f800 (a b))
  (record-reader "zinjanthropus" (type-descriptor f800)))
(begin
  (define-record $acyclic ((immutable notme)))
  (record-reader '$acyclic (type-descriptor $acyclic)))

(xmat "; Test error \"fasl object created by different release\"\n; This one is the list (a b c d) created by version 5.9b\n\n#@\x2;\x4;\x0;\x0;\x0;5.9b\x0;\x4;\x0;\x0;\x0;\x2;\x1;\x0;\x0;\x0;a\x2;\x1;\x0;\x0;\x0;b\x2;\x1;\x0;\x0;\x0;c\x2;\x1;\x0;\x0;\x0;d\f&\x0;\x0;\x0;\n")

(xmat "; Test error \"bracketed list terminated by close parenthesis\"\n\n(define nil '[))\n\n"
      "; Test error \"bracketed list terminated by close parenthesis\"\n\n(cond [(foobar) 'baz) [else 'ok])\n\n"
      "; Test error \"bracketed list terminated by close parenthesis\"\n\n(define pair '[a . b))\n\n"
      "; Test error \"duplicate mark #~s= seen\"\n\n(#327=(a b c #327=d) #327#)\n\n"
      "; Test error \"expected close brace terminating gensym syntax\"\n\n(define #{foo |bar|\n  (lambda (zap doodle)\n    zap))\n\n"
      "; Test error \"expected close brace terminating gensym syntax\"\n\n(define foo\n  (lambda (#{foo |bar| none)\n    'quack))\n\n"
      "; Test error \"expected one item after dot (.)\"\n\n(define foo\n  (lambda (a b . )\n    'zapp))\n\n"
      "; Test error \"expected one item after dot (.)\"\n\n(define foo\n  (lambda [a b . ]\n    'zapp))\n\n"
      "; Test error \"invalid character #\\\\~a~a~a\"\n\n(memv #\\401 (string->list \"abcd\"))\n\n"
      "; Test error \"invalid character #\\\\~a~a\"\n\n(make-list 25 (make-string 100 #\\37d))\n"
      "; Test error \"invalid character name\"\n\n(memv #\\bugsbunny (string->list \"looneytunes\"))\n"
      "; Test error \"invalid character name\"\n\n(memv #\\new (string->list \"deal\"))\n"
      "; Test error \"invalid character name\"\n\n(memv #\\Space (string->list \"no deal\"))\n"
      "; Test error \"invalid character name\"\n\n(memv #\\SPACE (string->list \"no deal\"))\n"
      "; Test error \"invalid number syntax\"\n\n(list #e23q3 'a 'b 'c)\n\n"
      "; Test error \"invalid number syntax\"\n\n(list #e3_4i 'a 'b 'c)\n\n"
      "; Test error \"invalid number syntax\"\n\n(list #e3+)"
      "; Test error \"invalid number syntax\"\n\n(sqrt #36r1+1i)\n\n"
      "; Test error \"invalid number syntax\"\n\n(sqrt #36r1+i)\n\n"
      "; Test error \"invalid number syntax\"\n\n(sqrt #36r1+1i)\n\n"
      "; Test error \"invalid number syntax\"\n\n(sqrt #36r1+i)\n\n"
      "; Test error \"cannot represent\"\n\n(sqrt 1/0)\n\n"
      "; Test error \"cannot represent\"\n\n(sqrt 1/0)\n\n"
      "; Test error \"cannot represent\"\n\n(sqrt 1#/0)\n\n"
      "; Test error \"cannot represent\"\n\n(sqrt 1##/0)\n\n"
      "; Test error \"cannot represent\"\n\n(sqrt #e1/0#)\n\n"
      "; Test error \"cannot represent\"\n\n(sqrt #e1/0###)\n\n"
      "; Test error \"cannot represent\"\n\n(sqrt #e1/0###)\n\n"
      "; Test error \"cannot represent\"\n\n(sqrt #e1/0###)\n\n"
      "; Test error \"cannot represent\"\n\n(sqrt #e1/0###)\n\n"
      "; Test error \"cannot represent\"\n\n(sqrt #e+inf.0)\n\n"
      "; Test error \"cannot represent\"\n\n(sqrt #e-inf.0)\n\n"
      "; Test error \"cannot represent\"\n\n(sqrt #e+nan.0)\n\n"
      "; Test error \"cannot represent\"\n\n(sqrt #e0/0e20)\n\n"
      "; Test error \"cannot represent\"\n\n(sqrt #e1@1)\n\n"
      "; Test error \"invalid number syntax\"\n\n(sqrt #e+nan.5)\n\n"
      "; Test error \"invalid sharp-sign prefix #~c\"\n\n(if #T #N #T)\n"
      "; Test error \"invalid sharp-sign prefix ~a~a\"\n\n(if (optimize-til-it-hurts?) (#7%super-fast+ 1 2) (+ 1 2))\n"
      "; Test error \"invalid sharp-sign prefix ~a~a\"\n\n(when #2_3_4 'huh?)\n"
      "; Test error \"invalid string character \\\\~c~c~c\"\n\n  (define s \"james stock \\707!\")\n"
      "; Test error \"invalid string character \\\\~c~c\"\n\n\"=tofu\\07gnorefsefawd2slivne\"\n\n"
      "; Test error \"invalid string character \\\\~c\"\n\n\"I need \\3d glasses\"\n"
      "; Test error \"invalid string character\"\n\n(pretty-print \"this is \\xa fine mess\")\n"
      "; Test error \"invalid string character\"\n\n(pretty-print \"this is \\x\")\n"
      "; Test error \"invalid string character\"\n\n(pretty-print \"this is \\xGreat news!\")\n"
      "; Test error \"invalid string character \\\\~c\"\n\n\"status \\quo\"\n"
      "; Test error \"invalid syntax #!~s\"\n\n(when #!whuppo! 1 2 3)\n\n"
      "; Test error \"invalid syntax #!~s\"\n\n(when #!eo 1 2 3)\n\n"
      "; Test error \"invalid syntax #v~s\"\n\n(list #vxx())\n"
      "; Test error \"invalid syntax #~v,'0dv~s\"\n\n(list #073vxx())\n"
      "; Test error \"invalid syntax #v~s\"\n\n(list #vf())\n"
      "; Test error \"invalid syntax #~v,'0dv~s\"\n\n(list #073vf())\n"
      "; Test error \"invalid syntax #v~s\"\n\n(list #vfx[])\n"
      "; Test error \"invalid syntax #~v,'0dv~s\"\n\n(list #073vfx[])\n"
      "; Test error \"invalid vector length\"\n\n(vector-length #999999999999999999999999999999(a b c))\n\n"
      "; Test error \"invalid fxvector length\"\n\n(fxvector-length #999999999999999999999999999999vfx(1 2 3))\n\n"
      "; Test error \"invalid bytevector length\"\n\n(bytevector-length #999999999999999999999999999999vu8(1 2 3))\n\n"
      "; Test error \"mark #~s= missing\"\n\n'(what about this?) ; separate top-level S-expression, so ok.\n\n(begin\n  (reverse '(a b . #77#))\n  (cons 1 2))"
      "; Test error \"more than one item found after dot (.)\"\n\n(define foo\n  (lambda (able baker . charlie delta epsilon)\n    'wow))\n\n"
      "; Test error \"more than one item found after dot (.)\"\n\n(define foo\n  (lambda [able baker . charlie delta epsilon]\n    'wow))\n\n"
      "; Test error \"non-symbol found after #[\"\n\n(pretty-print '#[(a \"b c\" #\\d) 1 2 3])\n"
      "; Test error \"outdated object file format\"\n\n\"What is\"   #3q\n'(1 2 3)\n\n"
      "; Test error \"parenthesized list terminated by close bracket\"\n\n(define nil '(])\n\n"
      "; Test error \"parenthesized list terminated by close bracket\"\n\n(cond [(foobar) 'baz] (else 'ok])\n\n"
      "; Test error \"parenthesized list terminated by close bracket\"\n\n(define pair '(a . b])\n\n"
      "; Test error \"too many vector elements supplied\"\n\n(pretty-print '#3(one two three four five six seven))\n"
      "; Test error \"non-fixnum found in fxvector\"\n\n(pretty-print '#vfx(1 2.0 3 4))\n"
      "; Test error \"non-fixnum found in fxvector\"\n\n(pretty-print '#3vfx(1 2.0 3 4))\n"
      "; Test error \"too many fxvector elements supplied\"\n\n(pretty-print '#3vfx(1 2 3 4))\n"
      "; Test error \"invalid value 2.0 found in bytevector\"\n\n(pretty-print '#vu8(1 2.0 3 4))\n"
      "; Test error \"invalid value -1 found in bytevector\"\n\n(pretty-print '#3vu8(1 -1 3 4))\n"
      "; Test error \"too many bytevector elements supplied\"\n\n(pretty-print '#3vu8(1 2 3 4))\n"
      "; Test error \"too few fields supplied for record ~s\"\n\n(define x '#[zinjanthropus 3])"
      "; Test error \"too many fields supplied for record ~s\"\n\n(define x '#[zinjanthropus 3 4 5])"
      "; Test error \"unexpected close bracket\"\n\n1 2 3 ]\n"
      "; Test error \"unexpected close parenthesis\"\n\n(define x 3))\n"
      "; Test error \"unexpected dot\"\n\n(lambda (x . . y) x)\n\n"
      "; Test error \"unexpected dot\"\n\n(lambda ( . y) y)\n\n"
      "; Test error \"unexpected dot\"\n\n(define x '(a . b . c))\n"
      "; Test error \"unexpected dot\"\n\n(define x '[a . b . c])\n"
      "; Test error \"unexpected end-of-file reading block comment\"\n(pretty-print\n #| foo\n   #| bar |#\n    baz \"pickle  ; not eof on string since we're in block comment"
      "; Test error \"unexpected end-of-file reading block comment\"\n(pretty-print\n #| foo\n   #"
      "; Test error \"unexpected end-of-file reading block comment\"\n(pretty-print\n #| foo\n   |"
      "; Test error \"unexpected end-of-file reading box\"\n\n   #& ; box is empty!\n"
      "; Test error \"unexpected end-of-file reading bracketed list\" (before first element)\n\n(lambda (x y z)\n  (cond\n    [\n\n   "
      "; Test error \"unexpected end-of-file reading bracketed list\"\n\n(lambda (x y z)\n  (cond\n    [(< x 1) y\n    [else z]\n\n\n"
      "; Test error \"unexpected end-of-file reading bracketed list\" (after dot)\n\n(car '[a b . c\n\n"
      "; Test error \"unexpected end-of-file reading bracketed list\" (after element after dot)\n\n(car '[a b . c\n\n"
      "; Test error \"unexpected end-of-file reading character\"\n#\\"
      "; Test error \"unexpected end-of-file reading character\"\n#\\new"
      "; Test error \"unexpected end-of-file reading character\"\n#\\02"
      "; Test error \"unexpected end-of-file reading expression comment\"\n\n(define oops '#; ; that's all I've got!\n"
      "; Test error \"unexpected end-of-file reading gensym\"\n(pretty-print '#{"
      "; Test error \"unexpected end-of-file reading gensym\"\n(pretty-print '#{foo"
      "; Test error \"unexpected end-of-file reading gensym\"\n(pretty-print '#{foo |bar|"
      "; Test error \"unexpected end-of-file reading graph mark\"\n(define x '#1=\n"
      "; Test error \"unexpected end-of-file reading hash-bang syntax\"\n\n(list #!eo"
      "; Test error \"unexpected end-of-file reading #v syntax\"\n\"would this be cool?\" #v"
      "; Test error \"unexpected end-of-file reading #~v,'0dv syntax\"\n\"would this be cool?\" #01v"
      "; Test error \"unexpected end-of-file reading #v syntax\"\n\"would this be cool?\" #vf"
      "; Test error \"unexpected end-of-file reading #~v,'0dv syntax\"\n\"would this be cool?\" #01vf"
      "; Test error \"unexpected end-of-file reading #v syntax\"\n\"would this be cool?\" #vfx"
      "; Test error \"unexpected end-of-file reading #~v,'0dv syntax\"\n\"would this be cool?\" #01vfx"
      "; Test error \"unexpected end-of-file reading list\" (before first element) \n\n  (\n\n   "
      "; Test error \"unexpected end-of-file reading list\"\n\n(lambda (x y z\n  (cond\n    [(< x 1) y]\n    [else z]))\n\n"
      "; Test error \"unexpected end-of-file reading list\" (after dot)\n\n(car '(a b . \n\n"
      "; Test error \"unexpected end-of-file reading list\" (after element after dot)\n\n(car '(a b . c\n\n"
      "; Test error \"unexpected end-of-file reading # prefix\"\n\"would this be cool?\" #"
      "; Test error \"unexpected end-of-file reading # prefix\"\n\"would this be cool?\" #35"
      "; Test error \"unexpected end-of-file reading number\"\n\n(list #e3+"
      "; Test error \"unexpected end-of-file reading quote\"\n(define fido '   \n\n\n"
      "; Test error \"unexpected end-of-file reading quasiquote\"\n(define e `   \n"
      "; Test error \"unexpected end-of-file reading unquote\"\n(define e `(+ ,(* 2 3) ,   \n\n"
      "; Test error \"unexpected end-of-file reading unquote-splicing\"\n(define r (list 1 2 3))\n(set! r `(0 ,@   \n\n"
      "; Test error \"unexpected end-of-file reading quasisyntax\"\n(define e #`   \n"
      "; Test error \"unexpected end-of-file reading unsyntax\"\n(define e #`(+ #,(* 2 3) #,   \n\n"
      "; Test error \"unexpected end-of-file reading unsyntax-splicing\"\n(define r (list 1 2 3))\n(set! r #`(0 #,@   \n\n"
      "; Test error \"unexpected end-of-file reading record\"\n\n(define oops '#[   \n\n"
      "; Test error \"unexpected end-of-file reading record\"\n\n(define oops '#[$acyclic   \n\n"
      "; Test error \"unexpected end-of-file reading string\"\n\n(printf \"This is \\\"not\\\" what I meant)\n\n"
      "; Test error \"unexpected end-of-file reading string\"\n\n(define s \"hello \\"
      "; Test error \"unexpected end-of-file reading string\"\n\n(define s \"hello \\0"
      "; Test error \"unexpected end-of-file reading string\"\n\n(define s \"hello \\03"
      "; Test error \"unexpected end-of-file reading string\"\n\n(define s \"hello \\x"
      "; Test error \"unexpected end-of-file reading string\"\n\n(define s \"hello \\x2"
      "; Test error \"unexpected end-of-file reading string\"\n\n(list \"abc\\x3c3"
      "; Test error \"invalid code point value 2097152 in string hex escape\"\n\n(list \"abc\\x200000;\")"
      "; Test error \"invalid character q in string hex escape\"\n\n(list \"abc\\xq;\")"
      "; Test error \"invalid character \" in string hex escape\"\n\n(list \"abc\\x\")"
      "; Test error \"unexpected end-of-file reading symbol\"\n\n(list 'abc\\"
      "; Test error \"unexpected end-of-file reading symbol\"\n\n(cons '|froma\\|gerie\\ %dq|jl&"
      "; Test error \"unexpected end-of-file reading symbol\"\n(pretty-print\n #| foo\n   #| bar |#\n |#\n|# #| oops |#"
      "; Test error \"unexpected end-of-file reading symbol\"\n\n(list 'abc\\x"
      "; Test error \"unexpected end-of-file reading symbol\"\n\n(list 'abc\\x3c3"
      "; Test error \"invalid code point value 2097152 in symbol hex escape\"\n\n(list 'abc\\x200000;)"
      "; Test error \"invalid character q in symbol hex escape\"\n\n(list 'abc\\xq;)"
      "; Test error \"unexpected end-of-file reading vector\"\n\n  (define v '#(a b \n"
      "; Test error \"unexpected end-of-file reading vector\"\n\n  (define v '#35(a b \n"
      "; Test error \"unexpected end-of-file reading fxvector\"\n\n  (define v '#vfx(0 1 \n"
      "; Test error \"unexpected end-of-file reading fxvector\"\n\n  (define v '#35vfx(0 1 \n"
      "; Test error \"unexpected end-of-file reading bytevector\"\n\n  (define v '#vu8(0 1 \n"
      "; Test error \"unexpected end-of-file reading bytevector\"\n\n  (define v '#35vu8(0 1 \n"
      "; Test error \"unrecognized record name ~s\"\n#[zsunekunvliwndwalv 1 2 3 4]"
      "; Test error \"unresolvable cycle\"\n\n(define oops '#1=#[$acyclic #1#])\n"
      "; Test error \"open brace syntax not allowed in #!r6rs mode\"\n\n#!r6rs '{\n"
      "; Test error \"close brace syntax not allowed in #!r6rs mode\"\n\n#!r6rs '}\n"
      "; Test error \"#[...] record syntax not allowed in #!r6rs mode\"\n\n#!r6rs '#[abc]\n"
      "; Test error \"#{...} gensym syntax not allowed in #!r6rs mode\"\n\n#!r6rs '#{abc def}\n"
      "; Test error \"#& box syntax not allowed in #!r6rs mode\"\n\n#!r6rs '#&box\n"
      "; Test error \"#% primitive syntax not allowed in #!r6rs mode\"\n\n#!r6rs #%car\n"
      "; Test error \"#: gensym syntax not allowed in #!r6rs mode\"\n\n#!r6rs #:g0\n"
      "; Test error \"#<n>(...) vector syntax not allowed in #!r6rs mode\"\n\n#!r6rs '#3(a b c)\n"
      "; Test error \"#<n>r number syntax not allowed in #!r6rs mode\"\n\n#!r6rs '#3r1201\n"
      "; Test error \"#<n># insert syntax not allowed in #!r6rs mode\"\n\n#!r6rs '#3#\n"
      "; Test error \"#<n>= mark syntax not allowed in #!r6rs mode\"\n\n#!r6rs '#3=\n"
      "; Test error \"#<n>% primitive syntax not allowed in #!r6rs mode\"\n\n#!r6rs #3%car\n"
      "; Test error \"octal character syntax not allowed in #!r6rs mode\"\n\n#!r6rs #\\010\n"
      "; Test error \"invalid delimiter 1 for character\"\n\n#\\0001\n"
      "; Test error \"delimiter { is not allowed in #!r6rs mode\"\n\n#!r6rs #\\0{\n"
      "; Test error \"#!eof syntax not allowed in #!r6rs mode\"\n\n#!r6rs #!eof\n"
      "; Test error \"#!bwp syntax not allowed in #!r6rs mode\"\n\n#!r6rs #!bwp\n"
      "; Test error \"#vfx(...) fxvector syntax not allowed in #!r6rs mode\"\n\n#!r6rs '#vfx(1 2 3)\n"
      "; Test error \"#<n>vfx(...) fxvector syntax not allowed in #!r6rs mode\"\n\n#!r6rs '#3vfx(1 2 3)\n"
      "; Test error \"#<n>vu8(...) fxvector syntax not allowed in #!r6rs mode\"\n\n#!r6rs '#3vu8(1 2 3)\n"
      "; Test error \"octal string-character syntax not allowed in #!r6rs mode\"\n\n#!r6rs \"a\\010b\"\n"
      "; Test error \"back-slash symbol escape syntax not allowed in #!r6rs mode\"\n\n#!r6rs ab\\ cd\n"
      "; Test error \"|...| symbol escape syntax not allowed in #!r6rs mode\"\n\n#!r6rs |ab  cd|\n"
      "; Test error \"@abc symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs @abc\n"
      "; Test error \"123a symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs 123a\n"
      "; Test error \"123# number syntax not allowed in #!r6rs mode\"\n\n#!r6rs 123#\n"
      "; Test error \"#x1/2e2 number syntax not allowed in #!r6rs mode\"\n\n#!r6rs 1/2e2\n"
      "; Test error \"#x.3 number syntax not allowed in #!r6rs mode\"\n\n#!r6rs #x.3\n"

      ; following tests adapted from the read0 benchmark distributed by Will
      ; Clinger, which as of 08/08/2009 appears to be in the public domain,
      ; with no license, copyright notice, author name, or date.
      "; Test error \"\x488; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x488;\n"
      "; Test error \"@ symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs @\n"
      "; Test error \"@b symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs @b\n"
      "; Test error \"@ symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs @\n"
      "; Test error \"\x488; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x488;\n"
      "; Test error \"\x489; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x489;\n"
      "; Test error \"\x660; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x660;\n"
      "; Test error \"\x661; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x661;\n"
      "; Test error \"\x662; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x662;\n"
      "; Test error \"\x663; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x663;\n"
      "; Test error \"\x664; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x664;\n"
      "; Test error \"\x665; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x665;\n"
      "; Test error \"\x666; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x666;\n"
      "; Test error \"\x667; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x667;\n"
      "; Test error \"\x668; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x668;\n"
      "; Test error \"\x669; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x669;\n"
      #;
      "; Test error \"\x6DE; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x6DE;\n"
      ; switched from Me to So in Unicode 7.0
      "; Test error \"\x6F0; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x6F0;\n"
      "; Test error \"\x6F1; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x6F1;\n"
      "; Test error \"\x6F2; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x6F2;\n"
      "; Test error \"\x6F3; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x6F3;\n"
      "; Test error \"\x6F4; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x6F4;\n"
      "; Test error \"\x6F5; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x6F5;\n"
      "; Test error \"\x6F6; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x6F6;\n"
      "; Test error \"\x6F7; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x6F7;\n"
      "; Test error \"\x6F8; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x6F8;\n"
      "; Test error \"\x6F9; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x6F9;\n"
      "; Test error \"\x7C0; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x7C0;\n"
      "; Test error \"\x7C1; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x7C1;\n"
      "; Test error \"\x7C2; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x7C2;\n"
      "; Test error \"\x7C3; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x7C3;\n"
      "; Test error \"\x7C4; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x7C4;\n"
      "; Test error \"\x7C5; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x7C5;\n"
      "; Test error \"\x7C6; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x7C6;\n"
      "; Test error \"\x7C7; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x7C7;\n"
      "; Test error \"\x7C8; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x7C8;\n"
      "; Test error \"\x7C9; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x7C9;\n"
      "; Test error \"\x903; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x903;\n"
      "; Test error \"\x93E; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x93E;\n"
      "; Test error \"\x93F; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x93F;\n"
      "; Test error \"\x940; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x940;\n"
      "; Test error \"\x949; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x949;\n"
      "; Test error \"\x94A; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x94A;\n"
      "; Test error \"\x94B; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x94B;\n"
      "; Test error \"\x94C; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x94C;\n"
      "; Test error \"\x966; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x966;\n"
      "; Test error \"\x967; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x967;\n"
      "; Test error \"\x968; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x968;\n"
      "; Test error \"\x969; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x969;\n"
      "; Test error \"\x96A; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x96A;\n"
      "; Test error \"\x96B; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x96B;\n"
      "; Test error \"\x96C; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x96C;\n"
      "; Test error \"\x96D; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x96D;\n"
      "; Test error \"\x96E; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x96E;\n"
      "; Test error \"\x96F; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x96F;\n"
      "; Test error \"\x982; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x982;\n"
      "; Test error \"\x983; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x983;\n"
      "; Test error \"\x9BE; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x9BE;\n"
      "; Test error \"\x9BF; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x9BF;\n"
      "; Test error \"\x9C0; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x9C0;\n"
      "; Test error \"\x9C7; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x9C7;\n"
      "; Test error \"\x9C8; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x9C8;\n"
      "; Test error \"\x9CB; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x9CB;\n"
      "; Test error \"\x9CC; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x9CC;\n"
      "; Test error \"\x9D7; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x9D7;\n"
      "; Test error \"\x9E6; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x9E6;\n"
      "; Test error \"\x9E7; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x9E7;\n"
      "; Test error \"\x9E8; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x9E8;\n"
      "; Test error \"\x9E9; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x9E9;\n"
      "; Test error \"\x9EA; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x9EA;\n"
      "; Test error \"\x9EB; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x9EB;\n"
      "; Test error \"\x9EC; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x9EC;\n"
      "; Test error \"\x9ED; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x9ED;\n"
      "; Test error \"\x9EE; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x9EE;\n"
      "; Test error \"\x9EF; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x9EF;\n"
      "; Test error \"\xA03; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xA03;\n"
      "; Test error \"\xA3E; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xA3E;\n"
      "; Test error \"\xA3F; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xA3F;\n"
      "; Test error \"\xA40; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xA40;\n"
      "; Test error \"\xA66; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xA66;\n"
      "; Test error \"\xA67; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xA67;\n"
      "; Test error \"\xA68; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xA68;\n"
      "; Test error \"\xA69; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xA69;\n"
      "; Test error \"\xA6A; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xA6A;\n"
      "; Test error \"\xA6B; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xA6B;\n"
      "; Test error \"\xA6C; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xA6C;\n"
      "; Test error \"\xA6D; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xA6D;\n"
      "; Test error \"\xA6E; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xA6E;\n"
      "; Test error \"\xA6F; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xA6F;\n"
      "; Test error \"\xA83; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xA83;\n"
      "; Test error \"\xABE; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xABE;\n"
      "; Test error \"\xABF; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xABF;\n"
      "; Test error \"\xAC0; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xAC0;\n"
      "; Test error \"\xAC9; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xAC9;\n"
      "; Test error \"\xACB; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xACB;\n"
      "; Test error \"\xACC; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xACC;\n"
      "; Test error \"\xAE6; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xAE6;\n"
      "; Test error \"\xAE7; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xAE7;\n"
      "; Test error \"\xAE8; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xAE8;\n"
      "; Test error \"\xAE9; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xAE9;\n"
      "; Test error \"\xAEA; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xAEA;\n"
      "; Test error \"\xAEB; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xAEB;\n"
      "; Test error \"\xAEC; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xAEC;\n"
      "; Test error \"\xAED; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xAED;\n"
      "; Test error \"\xAEE; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xAEE;\n"
      "; Test error \"\xAEF; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xAEF;\n"
      "; Test error \"\xB02; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xB02;\n"
      "; Test error \"\xB03; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xB03;\n"
      "; Test error \"\xB3E; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xB3E;\n"
      "; Test error \"\xB40; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xB40;\n"
      "; Test error \"\xB47; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xB47;\n"
      "; Test error \"\xB48; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xB48;\n"
      "; Test error \"\xB4B; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xB4B;\n"
      "; Test error \"\xB4C; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xB4C;\n"
      "; Test error \"\xB57; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xB57;\n"
      "; Test error \"\xB66; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xB66;\n"
      "; Test error \"\xB67; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xB67;\n"
      "; Test error \"\xB68; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xB68;\n"
      "; Test error \"\xB69; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xB69;\n"
      "; Test error \"\xB6A; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xB6A;\n"
      "; Test error \"\xB6B; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xB6B;\n"
      "; Test error \"\xB6C; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xB6C;\n"
      "; Test error \"\xB6D; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xB6D;\n"
      "; Test error \"\xB6E; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xB6E;\n"
      "; Test error \"\xB6F; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xB6F;\n"
      "; Test error \"\xBBE; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xBBE;\n"
      "; Test error \"\xBBF; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xBBF;\n"
      "; Test error \"\xBC1; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xBC1;\n"
      "; Test error \"\xBC2; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xBC2;\n"
      "; Test error \"\xBC6; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xBC6;\n"
      "; Test error \"\xBC7; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xBC7;\n"
      "; Test error \"\xBC8; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xBC8;\n"
      "; Test error \"\xBCA; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xBCA;\n"
      "; Test error \"\xBCB; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xBCB;\n"
      "; Test error \"\xBCC; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xBCC;\n"
      "; Test error \"\xBD7; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xBD7;\n"
      "; Test error \"\xBE6; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xBE6;\n"
      "; Test error \"\xBE7; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xBE7;\n"
      "; Test error \"\xBE8; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xBE8;\n"
      "; Test error \"\xBE9; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xBE9;\n"
      "; Test error \"\xBEA; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xBEA;\n"
      "; Test error \"\xBEB; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xBEB;\n"
      "; Test error \"\xBEC; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xBEC;\n"
      "; Test error \"\xBED; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xBED;\n"
      "; Test error \"\xBEE; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xBEE;\n"
      "; Test error \"\xBEF; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xBEF;\n"
      "; Test error \"\xC01; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xC01;\n"
      "; Test error \"\xC02; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xC02;\n"
      "; Test error \"\xC03; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xC03;\n"
      "; Test error \"\xC41; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xC41;\n"
      "; Test error \"\xC42; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xC42;\n"
      "; Test error \"\xC43; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xC43;\n"
      "; Test error \"\xC44; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xC44;\n"
      "; Test error \"\xC66; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xC66;\n"
      "; Test error \"\xC67; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xC67;\n"
      "; Test error \"\xC68; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xC68;\n"
      "; Test error \"\xC69; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xC69;\n"
      "; Test error \"\xC6A; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xC6A;\n"
      "; Test error \"\xC6B; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xC6B;\n"
      "; Test error \"\xC6C; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xC6C;\n"
      "; Test error \"\xC6D; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xC6D;\n"
      "; Test error \"\xC6E; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xC6E;\n"
      "; Test error \"\xC6F; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xC6F;\n"
      "; Test error \"\xC82; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xC82;\n"
      "; Test error \"\xC83; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xC83;\n"
      "; Test error \"\xCBE; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xCBE;\n"
      "; Test error \"\xCC0; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xCC0;\n"
      "; Test error \"\xCC1; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xCC1;\n"
      "; Test error \"\xCC2; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xCC2;\n"
      "; Test error \"\xCC3; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xCC3;\n"
      "; Test error \"\xCC4; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xCC4;\n"
      "; Test error \"\xCC7; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xCC7;\n"
      "; Test error \"\xCC8; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xCC8;\n"
      "; Test error \"\xCCA; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xCCA;\n"
      "; Test error \"\xCCB; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xCCB;\n"
      "; Test error \"\xCD5; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xCD5;\n"
      "; Test error \"\xCD6; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xCD6;\n"
      "; Test error \"\xCE6; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xCE6;\n"
      "; Test error \"\xCE7; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xCE7;\n"
      "; Test error \"\xCE8; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xCE8;\n"
      "; Test error \"\xCE9; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xCE9;\n"
      "; Test error \"\xCEA; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xCEA;\n"
      "; Test error \"\xCEB; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xCEB;\n"
      "; Test error \"\xCEC; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xCEC;\n"
      "; Test error \"\xCED; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xCED;\n"
      "; Test error \"\xCEE; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xCEE;\n"
      "; Test error \"\xCEF; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xCEF;\n"
      "; Test error \"\xD02; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xD02;\n"
      "; Test error \"\xD03; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xD03;\n"
      "; Test error \"\xD3E; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xD3E;\n"
      "; Test error \"\xD3F; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xD3F;\n"
      "; Test error \"\xD40; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xD40;\n"
      "; Test error \"\xD46; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xD46;\n"
      "; Test error \"\xD47; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xD47;\n"
      "; Test error \"\xD48; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xD48;\n"
      "; Test error \"\xD4A; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xD4A;\n"
      "; Test error \"\xD4B; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xD4B;\n"
      "; Test error \"\xD4C; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xD4C;\n"
      "; Test error \"\xD57; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xD57;\n"
      "; Test error \"\xD66; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xD66;\n"
      "; Test error \"\xD67; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xD67;\n"
      "; Test error \"\xD68; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xD68;\n"
      "; Test error \"\xD69; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xD69;\n"
      "; Test error \"\xD6A; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xD6A;\n"
      "; Test error \"\xD6B; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xD6B;\n"
      "; Test error \"\xD6C; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xD6C;\n"
      "; Test error \"\xD6D; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xD6D;\n"
      "; Test error \"\xD6E; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xD6E;\n"
      "; Test error \"\xD6F; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xD6F;\n"
      "; Test error \"\xD82; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xD82;\n"
      "; Test error \"\xD83; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xD83;\n"
      "; Test error \"\xDCF; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xDCF;\n"
      "; Test error \"\xDD0; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xDD0;\n"
      "; Test error \"\xDD1; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xDD1;\n"
      "; Test error \"\xDD8; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xDD8;\n"
      "; Test error \"\xDD9; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xDD9;\n"
      "; Test error \"\xDDA; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xDDA;\n"
      "; Test error \"\xDDB; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xDDB;\n"
      "; Test error \"\xDDC; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xDDC;\n"
      "; Test error \"\xDDD; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xDDD;\n"
      "; Test error \"\xDDE; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xDDE;\n"
      "; Test error \"\xDDF; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xDDF;\n"
      "; Test error \"\xDF2; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xDF2;\n"
      "; Test error \"\xDF3; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xDF3;\n"
      "; Test error \"\xE50; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xE50;\n"
      "; Test error \"\xE51; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xE51;\n"
      "; Test error \"\xE52; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xE52;\n"
      "; Test error \"\xE53; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xE53;\n"
      "; Test error \"\xE54; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xE54;\n"
      "; Test error \"\xE55; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xE55;\n"
      "; Test error \"\xE56; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xE56;\n"
      "; Test error \"\xE57; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xE57;\n"
      "; Test error \"\xE58; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xE58;\n"
      "; Test error \"\xE59; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xE59;\n"
      "; Test error \"\xED0; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xED0;\n"
      "; Test error \"\xED1; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xED1;\n"
      "; Test error \"\xED2; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xED2;\n"
      "; Test error \"\xED3; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xED3;\n"
      "; Test error \"\xED4; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xED4;\n"
      "; Test error \"\xED5; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xED5;\n"
      "; Test error \"\xED6; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xED6;\n"
      "; Test error \"\xED7; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xED7;\n"
      "; Test error \"\xED8; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xED8;\n"
      "; Test error \"\xED9; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xED9;\n"
      "; Test error \"\xF20; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xF20;\n"
      "; Test error \"\xF21; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xF21;\n"
      "; Test error \"\xF22; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xF22;\n"
      "; Test error \"\xF23; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xF23;\n"
      "; Test error \"\xF24; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xF24;\n"
      "; Test error \"\xF25; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xF25;\n"
      "; Test error \"\xF26; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xF26;\n"
      "; Test error \"\xF27; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xF27;\n"
      "; Test error \"\xF28; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xF28;\n"
      "; Test error \"\xF29; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xF29;\n"
      "; Test error \"\xF3E; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xF3E;\n"
      "; Test error \"\xF3F; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xF3F;\n"
      "; Test error \"\xF7F; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xF7F;\n"
      "; Test error \"\x102B; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x102B;\n"
      "; Test error \"\x102C; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x102C;\n"
      "; Test error \"\x1031; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1031;\n"
      "; Test error \"\x1038; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1038;\n"
      "; Test error \"\x103B; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x103B;\n"
      "; Test error \"\x103C; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x103C;\n"
      "; Test error \"\x1040; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1040;\n"
      "; Test error \"\x1041; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1041;\n"
      "; Test error \"\x1042; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1042;\n"
      "; Test error \"\x1043; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1043;\n"
      "; Test error \"\x1044; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1044;\n"
      "; Test error \"\x1045; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1045;\n"
      "; Test error \"\x1046; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1046;\n"
      "; Test error \"\x1047; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1047;\n"
      "; Test error \"\x1048; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1048;\n"
      "; Test error \"\x1049; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1049;\n"
      "; Test error \"\x1056; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1056;\n"
      "; Test error \"\x1057; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1057;\n"
      "; Test error \"\x1062; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1062;\n"
      "; Test error \"\x1063; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1063;\n"
      "; Test error \"\x1064; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1064;\n"
      "; Test error \"\x1067; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1067;\n"
      "; Test error \"\x1068; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1068;\n"
      "; Test error \"\x1069; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1069;\n"
      "; Test error \"\x106A; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x106A;\n"
      "; Test error \"\x106B; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x106B;\n"
      "; Test error \"\x106C; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x106C;\n"
      "; Test error \"\x106D; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x106D;\n"
      "; Test error \"\x1083; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1083;\n"
      "; Test error \"\x1084; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1084;\n"
      "; Test error \"\x1087; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1087;\n"
      "; Test error \"\x1088; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1088;\n"
      "; Test error \"\x1089; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1089;\n"
      "; Test error \"\x108A; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x108A;\n"
      "; Test error \"\x108B; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x108B;\n"
      "; Test error \"\x108C; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x108C;\n"
      "; Test error \"\x108F; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x108F;\n"
      "; Test error \"\x1090; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1090;\n"
      "; Test error \"\x1091; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1091;\n"
      "; Test error \"\x1092; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1092;\n"
      "; Test error \"\x1093; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1093;\n"
      "; Test error \"\x1094; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1094;\n"
      "; Test error \"\x1095; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1095;\n"
      "; Test error \"\x1096; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1096;\n"
      "; Test error \"\x1097; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1097;\n"
      "; Test error \"\x1098; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1098;\n"
      "; Test error \"\x1099; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1099;\n"
      "; Test error \"\x17B6; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x17B6;\n"
      "; Test error \"\x17BE; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x17BE;\n"
      "; Test error \"\x17BF; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x17BF;\n"
      "; Test error \"\x17C0; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x17C0;\n"
      "; Test error \"\x17C1; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x17C1;\n"
      "; Test error \"\x17C2; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x17C2;\n"
      "; Test error \"\x17C3; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x17C3;\n"
      "; Test error \"\x17C4; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x17C4;\n"
      "; Test error \"\x17C5; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x17C5;\n"
      "; Test error \"\x17C7; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x17C7;\n"
      "; Test error \"\x17C8; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x17C8;\n"
      "; Test error \"\x17E0; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x17E0;\n"
      "; Test error \"\x17E1; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x17E1;\n"
      "; Test error \"\x17E2; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x17E2;\n"
      "; Test error \"\x17E3; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x17E3;\n"
      "; Test error \"\x17E4; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x17E4;\n"
      "; Test error \"\x17E5; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x17E5;\n"
      "; Test error \"\x17E6; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x17E6;\n"
      "; Test error \"\x17E7; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x17E7;\n"
      "; Test error \"\x17E8; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x17E8;\n"
      "; Test error \"\x17E9; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x17E9;\n"
      "; Test error \"\x1810; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1810;\n"
      "; Test error \"\x1811; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1811;\n"
      "; Test error \"\x1812; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1812;\n"
      "; Test error \"\x1813; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1813;\n"
      "; Test error \"\x1814; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1814;\n"
      "; Test error \"\x1815; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1815;\n"
      "; Test error \"\x1816; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1816;\n"
      "; Test error \"\x1817; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1817;\n"
      "; Test error \"\x1818; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1818;\n"
      "; Test error \"\x1819; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1819;\n"
      "; Test error \"\x1923; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1923;\n"
      "; Test error \"\x1924; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1924;\n"
      "; Test error \"\x1925; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1925;\n"
      "; Test error \"\x1926; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1926;\n"
      "; Test error \"\x1929; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1929;\n"
      "; Test error \"\x192A; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x192A;\n"
      "; Test error \"\x192B; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x192B;\n"
      "; Test error \"\x1930; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1930;\n"
      "; Test error \"\x1931; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1931;\n"
      "; Test error \"\x1933; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1933;\n"
      "; Test error \"\x1934; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1934;\n"
      "; Test error \"\x1935; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1935;\n"
      "; Test error \"\x1936; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1936;\n"
      "; Test error \"\x1937; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1937;\n"
      "; Test error \"\x1938; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1938;\n"
      "; Test error \"\x1946; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1946;\n"
      "; Test error \"\x1947; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1947;\n"
      "; Test error \"\x1948; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1948;\n"
      "; Test error \"\x1949; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1949;\n"
      "; Test error \"\x194A; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x194A;\n"
      "; Test error \"\x194B; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x194B;\n"
      "; Test error \"\x194C; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x194C;\n"
      "; Test error \"\x194D; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x194D;\n"
      "; Test error \"\x194E; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x194E;\n"
      "; Test error \"\x194F; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x194F;\n"
      "; Test error \"\x19B0; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x19B0;\n"
      "; Test error \"\x19B1; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x19B1;\n"
      "; Test error \"\x19B2; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x19B2;\n"
      "; Test error \"\x19B3; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x19B3;\n"
      "; Test error \"\x19B4; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x19B4;\n"
      "; Test error \"\x19B5; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x19B5;\n"
      "; Test error \"\x19B6; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x19B6;\n"
      "; Test error \"\x19B7; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x19B7;\n"
      "; Test error \"\x19B8; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x19B8;\n"
      "; Test error \"\x19B9; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x19B9;\n"
      "; Test error \"\x19BA; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x19BA;\n"
      "; Test error \"\x19BB; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x19BB;\n"
      "; Test error \"\x19BC; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x19BC;\n"
      "; Test error \"\x19BD; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x19BD;\n"
      "; Test error \"\x19BE; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x19BE;\n"
      "; Test error \"\x19BF; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x19BF;\n"
      "; Test error \"\x19C0; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x19C0;\n"
      "; Test error \"\x19C8; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x19C8;\n"
      "; Test error \"\x19C9; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x19C9;\n"
      "; Test error \"\x19D0; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x19D0;\n"
      "; Test error \"\x19D1; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x19D1;\n"
      "; Test error \"\x19D2; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x19D2;\n"
      "; Test error \"\x19D3; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x19D3;\n"
      "; Test error \"\x19D4; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x19D4;\n"
      "; Test error \"\x19D5; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x19D5;\n"
      "; Test error \"\x19D6; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x19D6;\n"
      "; Test error \"\x19D7; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x19D7;\n"
      "; Test error \"\x19D8; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x19D8;\n"
      "; Test error \"\x19D9; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x19D9;\n"
      "; Test error \"\x1A19; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1A19;\n"
      "; Test error \"\x1A1A; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1A1A;\n"
      #;
      "; Test error \"\x1A1B; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1A1B;\n"
      ; switched from Mc to Mn in Unicode 7.0
      "; Test error \"\x1B04; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1B04;\n"
      "; Test error \"\x1B35; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1B35;\n"
      "; Test error \"\x1B3B; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1B3B;\n"
      "; Test error \"\x1B3D; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1B3D;\n"
      "; Test error \"\x1B3E; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1B3E;\n"
      "; Test error \"\x1B3F; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1B3F;\n"
      "; Test error \"\x1B40; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1B40;\n"
      "; Test error \"\x1B41; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1B41;\n"
      "; Test error \"\x1B43; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1B43;\n"
      "; Test error \"\x1B44; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1B44;\n"
      "; Test error \"\x1B50; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1B50;\n"
      "; Test error \"\x1B51; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1B51;\n"
      "; Test error \"\x1B52; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1B52;\n"
      "; Test error \"\x1B53; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1B53;\n"
      "; Test error \"\x1B54; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1B54;\n"
      "; Test error \"\x1B55; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1B55;\n"
      "; Test error \"\x1B56; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1B56;\n"
      "; Test error \"\x1B57; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1B57;\n"
      "; Test error \"\x1B58; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1B58;\n"
      "; Test error \"\x1B59; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1B59;\n"
      "; Test error \"\x1B82; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1B82;\n"
      "; Test error \"\x1BA1; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1BA1;\n"
      "; Test error \"\x1BA6; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1BA6;\n"
      "; Test error \"\x1BA7; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1BA7;\n"
      "; Test error \"\x1BAA; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1BAA;\n"
      "; Test error \"\x1BB0; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1BB0;\n"
      "; Test error \"\x1BB1; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1BB1;\n"
      "; Test error \"\x1BB2; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1BB2;\n"
      "; Test error \"\x1BB3; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1BB3;\n"
      "; Test error \"\x1BB4; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1BB4;\n"
      "; Test error \"\x1BB5; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1BB5;\n"
      "; Test error \"\x1BB6; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1BB6;\n"
      "; Test error \"\x1BB7; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1BB7;\n"
      "; Test error \"\x1BB8; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1BB8;\n"
      "; Test error \"\x1BB9; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1BB9;\n"
      "; Test error \"\x1C24; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1C24;\n"
      "; Test error \"\x1C25; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1C25;\n"
      "; Test error \"\x1C26; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1C26;\n"
      "; Test error \"\x1C27; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1C27;\n"
      "; Test error \"\x1C28; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1C28;\n"
      "; Test error \"\x1C29; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1C29;\n"
      "; Test error \"\x1C2A; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1C2A;\n"
      "; Test error \"\x1C2B; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1C2B;\n"
      "; Test error \"\x1C34; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1C34;\n"
      "; Test error \"\x1C35; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1C35;\n"
      "; Test error \"\x1C40; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1C40;\n"
      "; Test error \"\x1C41; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1C41;\n"
      "; Test error \"\x1C42; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1C42;\n"
      "; Test error \"\x1C43; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1C43;\n"
      "; Test error \"\x1C44; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1C44;\n"
      "; Test error \"\x1C45; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1C45;\n"
      "; Test error \"\x1C46; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1C46;\n"
      "; Test error \"\x1C47; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1C47;\n"
      "; Test error \"\x1C48; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1C48;\n"
      "; Test error \"\x1C49; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1C49;\n"
      "; Test error \"\x1C50; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1C50;\n"
      "; Test error \"\x1C51; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1C51;\n"
      "; Test error \"\x1C52; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1C52;\n"
      "; Test error \"\x1C53; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1C53;\n"
      "; Test error \"\x1C54; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1C54;\n"
      "; Test error \"\x1C55; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1C55;\n"
      "; Test error \"\x1C56; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1C56;\n"
      "; Test error \"\x1C57; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1C57;\n"
      "; Test error \"\x1C58; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1C58;\n"
      "; Test error \"\x1C59; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1C59;\n"
      "; Test error \"\x20DD; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x20DD;\n"
      "; Test error \"\x20DE; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x20DE;\n"
      "; Test error \"\x20DF; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x20DF;\n"
      "; Test error \"\x20E0; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x20E0;\n"
      "; Test error \"\x20E2; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x20E2;\n"
      "; Test error \"\x20E3; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x20E3;\n"
      "; Test error \"\x20E4; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x20E4;\n"
      "; Test error \"\xA620; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xA620;\n"
      "; Test error \"\xA621; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xA621;\n"
      "; Test error \"\xA622; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xA622;\n"
      "; Test error \"\xA623; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xA623;\n"
      "; Test error \"\xA624; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xA624;\n"
      "; Test error \"\xA625; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xA625;\n"
      "; Test error \"\xA626; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xA626;\n"
      "; Test error \"\xA627; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xA627;\n"
      "; Test error \"\xA628; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xA628;\n"
      "; Test error \"\xA629; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xA629;\n"
      "; Test error \"\xA670; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xA670;\n"
      "; Test error \"\xA671; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xA671;\n"
      "; Test error \"\xA672; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xA672;\n"
      "; Test error \"\xA823; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xA823;\n"
      "; Test error \"\xA824; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xA824;\n"
      "; Test error \"\xA827; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xA827;\n"
      "; Test error \"\xA880; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xA880;\n"
      "; Test error \"\xA881; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xA881;\n"
      "; Test error \"\xA8B4; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xA8B4;\n"
      "; Test error \"\xA8B5; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xA8B5;\n"
      "; Test error \"\xA8B6; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xA8B6;\n"
      "; Test error \"\xA8B7; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xA8B7;\n"
      "; Test error \"\xA8B8; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xA8B8;\n"
      "; Test error \"\xA8B9; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xA8B9;\n"
      "; Test error \"\xA8BA; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xA8BA;\n"
      "; Test error \"\xA8BB; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xA8BB;\n"
      "; Test error \"\xA8BC; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xA8BC;\n"
      "; Test error \"\xA8BD; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xA8BD;\n"
      "; Test error \"\xA8BE; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xA8BE;\n"
      "; Test error \"\xA8BF; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xA8BF;\n"
      "; Test error \"\xA8C0; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xA8C0;\n"
      "; Test error \"\xA8C1; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xA8C1;\n"
      "; Test error \"\xA8C2; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xA8C2;\n"
      "; Test error \"\xA8C3; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xA8C3;\n"
      "; Test error \"\xA8D0; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xA8D0;\n"
      "; Test error \"\xA8D1; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xA8D1;\n"
      "; Test error \"\xA8D2; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xA8D2;\n"
      "; Test error \"\xA8D3; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xA8D3;\n"
      "; Test error \"\xA8D4; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xA8D4;\n"
      "; Test error \"\xA8D5; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xA8D5;\n"
      "; Test error \"\xA8D6; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xA8D6;\n"
      "; Test error \"\xA8D7; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xA8D7;\n"
      "; Test error \"\xA8D8; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xA8D8;\n"
      "; Test error \"\xA8D9; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xA8D9;\n"
      "; Test error \"\xA900; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xA900;\n"
      "; Test error \"\xA901; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xA901;\n"
      "; Test error \"\xA902; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xA902;\n"
      "; Test error \"\xA903; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xA903;\n"
      "; Test error \"\xA904; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xA904;\n"
      "; Test error \"\xA905; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xA905;\n"
      "; Test error \"\xA906; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xA906;\n"
      "; Test error \"\xA907; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xA907;\n"
      "; Test error \"\xA908; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xA908;\n"
      "; Test error \"\xA909; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xA909;\n"
      "; Test error \"\xA952; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xA952;\n"
      "; Test error \"\xA953; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xA953;\n"
      "; Test error \"\xAA2F; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xAA2F;\n"
      "; Test error \"\xAA30; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xAA30;\n"
      "; Test error \"\xAA33; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xAA33;\n"
      "; Test error \"\xAA34; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xAA34;\n"
      "; Test error \"\xAA4D; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xAA4D;\n"
      "; Test error \"\xAA50; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xAA50;\n"
      "; Test error \"\xAA51; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xAA51;\n"
      "; Test error \"\xAA52; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xAA52;\n"
      "; Test error \"\xAA53; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xAA53;\n"
      "; Test error \"\xAA54; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xAA54;\n"
      "; Test error \"\xAA55; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xAA55;\n"
      "; Test error \"\xAA56; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xAA56;\n"
      "; Test error \"\xAA57; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xAA57;\n"
      "; Test error \"\xAA58; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xAA58;\n"
      "; Test error \"\xAA59; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xAA59;\n"
      "; Test error \"\xFF10; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xFF10;\n"
      "; Test error \"\xFF11; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xFF11;\n"
      "; Test error \"\xFF12; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xFF12;\n"
      "; Test error \"\xFF13; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xFF13;\n"
      "; Test error \"\xFF14; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xFF14;\n"
      "; Test error \"\xFF15; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xFF15;\n"
      "; Test error \"\xFF16; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xFF16;\n"
      "; Test error \"\xFF17; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xFF17;\n"
      "; Test error \"\xFF18; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xFF18;\n"
      "; Test error \"\xFF19; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \xFF19;\n"
      "; Test error \"\x104A0; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x104A0;\n"
      "; Test error \"\x104A1; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x104A1;\n"
      "; Test error \"\x104A2; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x104A2;\n"
      "; Test error \"\x104A3; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x104A3;\n"
      "; Test error \"\x104A4; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x104A4;\n"
      "; Test error \"\x104A5; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x104A5;\n"
      "; Test error \"\x104A6; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x104A6;\n"
      "; Test error \"\x104A7; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x104A7;\n"
      "; Test error \"\x104A8; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x104A8;\n"
      "; Test error \"\x104A9; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x104A9;\n"
      "; Test error \"\x1D165; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1D165;\n"
      "; Test error \"\x1D166; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1D166;\n"
      "; Test error \"\x1D16D; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1D16D;\n"
      "; Test error \"\x1D16E; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1D16E;\n"
      "; Test error \"\x1D16F; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1D16F;\n"
      "; Test error \"\x1D170; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1D170;\n"
      "; Test error \"\x1D171; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1D171;\n"
      "; Test error \"\x1D172; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1D172;\n"
      "; Test error \"\x1D7CE; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1D7CE;\n"
      "; Test error \"\x1D7CF; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1D7CF;\n"
      "; Test error \"\x1D7D0; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1D7D0;\n"
      "; Test error \"\x1D7D1; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1D7D1;\n"
      "; Test error \"\x1D7D2; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1D7D2;\n"
      "; Test error \"\x1D7D3; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1D7D3;\n"
      "; Test error \"\x1D7D4; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1D7D4;\n"
      "; Test error \"\x1D7D5; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1D7D5;\n"
      "; Test error \"\x1D7D6; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1D7D6;\n"
      "; Test error \"\x1D7D7; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1D7D7;\n"
      "; Test error \"\x1D7D8; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1D7D8;\n"
      "; Test error \"\x1D7D9; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1D7D9;\n"
      "; Test error \"\x1D7DA; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1D7DA;\n"
      "; Test error \"\x1D7DB; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1D7DB;\n"
      "; Test error \"\x1D7DC; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1D7DC;\n"
      "; Test error \"\x1D7DD; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1D7DD;\n"
      "; Test error \"\x1D7DE; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1D7DE;\n"
      "; Test error \"\x1D7DF; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1D7DF;\n"
      "; Test error \"\x1D7E0; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1D7E0;\n"
      "; Test error \"\x1D7E1; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1D7E1;\n"
      "; Test error \"\x1D7E2; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1D7E2;\n"
      "; Test error \"\x1D7E3; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1D7E3;\n"
      "; Test error \"\x1D7E4; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1D7E4;\n"
      "; Test error \"\x1D7E5; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1D7E5;\n"
      "; Test error \"\x1D7E6; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1D7E6;\n"
      "; Test error \"\x1D7E7; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1D7E7;\n"
      "; Test error \"\x1D7E8; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1D7E8;\n"
      "; Test error \"\x1D7E9; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1D7E9;\n"
      "; Test error \"\x1D7EA; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1D7EA;\n"
      "; Test error \"\x1D7EB; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1D7EB;\n"
      "; Test error \"\x1D7EC; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1D7EC;\n"
      "; Test error \"\x1D7ED; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1D7ED;\n"
      "; Test error \"\x1D7EE; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1D7EE;\n"
      "; Test error \"\x1D7EF; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1D7EF;\n"
      "; Test error \"\x1D7F0; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1D7F0;\n"
      "; Test error \"\x1D7F1; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1D7F1;\n"
      "; Test error \"\x1D7F2; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1D7F2;\n"
      "; Test error \"\x1D7F3; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1D7F3;\n"
      "; Test error \"\x1D7F4; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1D7F4;\n"
      "; Test error \"\x1D7F5; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1D7F5;\n"
      "; Test error \"\x1D7F6; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1D7F6;\n"
      "; Test error \"\x1D7F7; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1D7F7;\n"
      "; Test error \"\x1D7F8; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1D7F8;\n"
      "; Test error \"\x1D7F9; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1D7F9;\n"
      "; Test error \"\x1D7FA; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1D7FA;\n"
      "; Test error \"\x1D7FB; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1D7FB;\n"
      "; Test error \"\x1D7FC; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1D7FC;\n"
      "; Test error \"\x1D7FD; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1D7FD;\n"
      "; Test error \"\x1D7FE; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1D7FE;\n"
      "; Test error \"\x1D7FF; symbol syntax not allowed in #!r6rs mode\"\n\n#!r6rs \x1D7FF;\n")

(mat record-annotation
     ; regression check: make sure annotations do not slip into records
     ; by way of graph references
     (let ([p (open-output-file "testfile.ss" 'truncate)])
       (display "(define-record #{%foo %bar} (x y))
(define $$rats (list '#0=(a b) #;'#1=(d e) '#[#{%foo %bar} #0# #1#]))
"
                p)
       (close-output-port p)
       #t)
     (begin (load "testfile.ss") #t)
     (record? (cadr $$rats) (type-descriptor #{%foo %bar}))
     (let ([r (cadr $$rats)])
       (eq? (%foo-x r) (car $$rats))
       (equal? (%foo-y r) '(d e))))

(mat annotation-tests
     (let ([x (read (open-input-string "#1=#2=(#1# . #2#)"))])
       (and (eq? (car x) x) (eq? (cdr x) x)))
     (let ([x (read (open-input-string "(#1=#1# . #1#)"))]
           [y (read (open-input-string "#2=#2#"))])
       (and (eq? (car x) (cdr x)) (eq? (car x) y)))
     (vector? '#(annotation 3 #f 3))
     (vector? (eval (read (open-input-string
                            "'#(annotation #1=(a . #1#) #f #f)"))))
     (load-test
       "(define-record #{$elmer fudd} (c))\n(define x '#[#{$elmer fudd} 3])\n")
     (and ($elmer? x) (eq? ($elmer-c x) 3))
     (compile-test
       "(define-record #{$bugs bunny} (c))\n(define x '#[#{$bugs bunny} 3])\n")
     (and ($bugs? x) (eq? ($bugs-c x) 3))
     (load-test
       "(define-syntax $kwote (lambda (x) `(,#'quote ,x)))\n(define $argh #1=($kwote . #1#))\n")
     (eq? $argh (cdr $argh))
     (compile-test
       "(define-syntax $kwoat (lambda (x) `(,#'quote ,x)))\n(define $argh #1=($kwoat #1#))\n")
     (eq? $argh (cadr $argh))
     (load-test
       "(define-syntax $quoat (lambda (x) `(,#'quote ,x)))\n(begin (define x #1=($quoat a)) (define y #1#))\n")
     (eq? x y)
     (load-test
       "(define x '#1=(17 . #1#))\n(define y '#1=#2=(#1# . #2#))\n(define z '(#1=#1# . #1#))\n(define w '#2=(#1# . #1=#2#))\n")
     (and (eq? (car x) 17) (eq? (cdr x) x))
     (and (eq? (car y) y) (eq? (cdr y) y))
     (and (eq? (car z) (cdr z))
          (eq? (car z) (read (open-input-string "#1=#1#"))))
     (and (eq? (car w) w) (eq? (cdr w) w))
     (compile-test
       "(define x1 '#1=(17 . #1#))\n(define y1 '#1=#2=(#1# . #2#))\n(define z1 '(#1=#1# . #1#))\n(define w1 '#2=(#1# . #1=#2#))\n")
     (and (eq? (car x1) 17) (eq? (cdr x1) x1))
     (and (eq? (car y1) y1) (eq? (cdr y1) y1))
     (and (eq? (car z1) (cdr z1))
          (eq? (car z1) (read (open-input-string "#1=#1#"))))
     (and (eq? (car w1) w1) (eq? (cdr w1) w1))
     (load-test
       "(define-record #{$eager beaver} ((immutable busy)))\n(define x '(#[#{$eager beaver} #1=(a b)] #1#))\n")
     (and ($eager? (car x))
          (equal? ($eager-busy (car x)) '(a b))
          (eq? ($eager-busy (car x)) (cadr x)))
     (compile-test
       "(define-record #{$beaver eager} ((immutable busy)))\n(define x '(#[#{$beaver eager} #1=(a b)] #1#))\n")
     (and ($beaver? (car x))
          (equal? ($beaver-busy (car x)) '(a b))
          (eq? ($beaver-busy (car x)) (cadr x)))
     ; w/quote on record
     (load-test
       "(define-record #{$tony tiger} ((immutable great!)))\n(define x (list '#[#{$tony tiger} #1=(a b)] '#1#))\n")
     (and ($tony? (car x))
          (equal? ($tony-great! (car x)) '(a b))
          (eq? ($tony-great! (car x)) (cadr x)))
     ; missing quote on record; see if annotation still comes back
     (load-test
       "(define-record #{$tiger tony} ((immutable great!)))\n(define x (list '#[#{$tiger tony} #1=(a b)] '#1#))\n")
     (and ($tiger? (car x))
          (equal? ($tiger-great! (car x)) '(a b))
          (eq? ($tiger-great! (car x)) (cadr x)))
     (load-test
       "(define-record #{$slow joe} ((double-float pokey)))\n(define x '#[#{$slow joe} 3.4])\n")
     (and ($slow? x) (eqv? ($slow-pokey x) 3.4))
     (load-test
       "(define-syntax $silly (syntax-rules () ((_ #(a b c) #2(d e)) (list 'a 'b 'c 'd 'e '#(a b c) '#2(d e) '#3(a b c) '#(d e)))))\n(define x ($silly #(#(1 2) #3(3 4 5) #()) #(#0() #3(#&8))))\n")
     (equal? x
       '(#2(1 2)
         #3(3 4 5)
         #0()
         #0()
         #3(#&8)
         #3(#2(1 2) #3(3 4 5) #0())
         #2(#0() #3(#&8))
         #3(#2(1 2) #3(3 4 5) #0())
         #2(#0() #3(#&8))))
     (load-test
       "(define-record #{james kirk} ((double-float girls)))\n(define x '(#2=253.5 . #[#{james kirk} #2#]))\n")
     (and (= (car x) 253.5) (= (james-girls (cdr x)) 253.5))
     (load-test
       "(define-syntax $peabrain (identifier-syntax (a 4) ((set! a b) (list a b))))\n(define x (+ $peabrain 1))\n(define y (set! $peabrain (* x $peabrain)))\n")
     (and (equal? x 5) (equal? y '(4 20))))

(mat symbol-printing
     (equal? (format "~s" '\#foo\|bar) "\\x23;foo\\x7C;bar")
     (eq? '\x23;foo\x7C;bar '\#foo\|bar))

(mat with-source-path
     (equal? (source-directories) '("."))
     (equal? (with-source-path 'test "I should not be here" list)
             '("I should not be here"))
     (equal? (with-source-path 'test "/I/should/not/be/here" list)
             '("/I/should/not/be/here"))
     (equal? (with-source-path 'test "fatfib.ss" list) '("fatfib.ss"))
     (equal? (parameterize ([source-directories '("")])
               (with-source-path 'test "fatfib.ss" list))
             '("fatfib.ss"))
     (error? ; Error in test: file "fatfib.ss" not found in source directories
             (parameterize ([source-directories '("." ".")])
               (with-source-path 'test "fatfib.ss" list)))
     (error? ; Error in test: file "I should not be here" not found in source directories
             (parameterize ([source-directories '("." "../examples")])
               (with-source-path 'test "I should not be here" list)))
     (equal? (parameterize ([source-directories '("." "../examples")])
               (with-source-path 'test "mat.ss" list))
             '("mat.ss"))
     (equal? (with-source-path 'test "mat.ss" list) '("mat.ss"))
     (equal? (parameterize ([source-directories '("" "../examples")])
               (with-source-path 'test "mat.ss" list))
             '("mat.ss"))
     (error? ; Error in test: file "mat.ss" not found in source directories
             (parameterize ([source-directories '()])
               (with-source-path 'test "mat.ss" list)))
     (error? ; Error in test: file "mat.ss" not found in source directories
             (parameterize ([source-directories '("../examples")])
               (with-source-path 'test "mat.ss" list)))
     (equal? (parameterize ([source-directories '("." "../examples")])
               (with-source-path 'test "fatfib.ss" list))
             '("../examples/fatfib.ss"))
     (equal? (parameterize ([source-directories '("." "../examples")])
               (with-source-path 'test "./fatfib.ss" list))
             '("./fatfib.ss"))
     (begin
       (parameterize ([source-directories '("." "../examples")])
         (load "fatfib.ss" compile))
       (procedure? fatfib))
     (equal? ((inspect/object fatfib) 'type) 'procedure)
     (equal? (call-with-values
               (lambda ()
                 (((inspect/object fatfib) 'code) 'source-path))
               list)
             '("../examples/fatfib.ss" 16 4))
     (equal? (parameterize ([source-directories '("." "../examples")])
               (call-with-values
                 (lambda ()
                   (((inspect/object fatfib) 'code) 'source-path))
                 list))
             '("../examples/fatfib.ss" 16 4))
     (begin
       (load "../examples/fatfib.ss" compile)
       (procedure? fatfib))
     (equal? ((inspect/object fatfib) 'type) 'procedure)
     (equal? (call-with-values
               (lambda ()
                 (((inspect/object fatfib) 'code) 'source-path))
               list)
             '("../examples/fatfib.ss" 16 4))
     (or (windows?)
         (equal? (parameterize ([cd "/"] [source-directories (list (cd))])
                   (call-with-values
                     (lambda ()
                       (((inspect/object fatfib) 'code) 'source-path))
                     list))
                 (list (format "~a/../examples/fatfib.ss" (cd)) 16 4)))
     (begin
       (parameterize
         ([source-directories (list (parameterize ([cd ".."]) (cd)))])
         (load "examples/fatfib.ss" compile))
       (procedure? fatfib))
     (equal? ((inspect/object fatfib) 'type) 'procedure)
     (equal? (call-with-values
               (lambda ()
                 (((inspect/object fatfib) 'code) 'source-path))
               (lambda (x y z) (list (path-last x) y z)))
             '("fatfib.ss" 16 4))
     (equal? (parameterize
               ([source-directories (list (parameterize ([cd ".."]) (cd)))])
               (call-with-values
                 (lambda ()
                   (((inspect/object fatfib) 'code) 'source-path))
                 list))
             (list (format "~a/examples/fatfib.ss"
                           (parameterize ([cd ".."]) (cd)))
                   16
                   4))
     (equal? (parameterize ([cd ".."] [source-directories '("examples")])
               (call-with-values
                 (lambda ()
                   (((inspect/object fatfib) 'code) 'source-path))
                 (lambda (x y z) (list (path-last x) y z))))
             '("fatfib.ss" 16 4))
     (or (windows?)
         (embedded?)
         (begin
           (system "ln -s ../examples .")
           (load "examples/fatfib.ss" compile)
           (system "/bin/rm examples")
           #t))
     (or (windows?)
         (embedded?)
         (equal? (call-with-values
                   (lambda ()
                     (((inspect/object fatfib) 'code) 'source-path))
                   list)
                 '("examples/fatfib.ss" 359)))
     (or (windows?)
         (embedded?)
         (equal? (parameterize ([source-directories '("..")])
                   (call-with-values
                     (lambda ()
                       (((inspect/object fatfib) 'code) 'source-path))
                     list))
                 '("../examples/fatfib.ss" 16 4)))
     (or (windows?)
         (embedded?)
         (equal? (parameterize ([source-directories '("../examples")])
                   (call-with-values
                     (lambda ()
                       (((inspect/object fatfib) 'code) 'source-path))
                     list))
                 '("../examples/fatfib.ss" 16 4)))
     (or (windows?)
         (embedded?)
         (equal? (parameterize
                   ([source-directories
                      (list (format "~a/examples"
                                    (parameterize ([cd ".."]) (cd))))])
                   (call-with-values
                     (lambda ()
                       (((inspect/object fatfib) 'code) 'source-path))
                     list))
                 (list (format "~a/examples/fatfib.ss"
                               (parameterize ([cd ".."]) (cd)))
                       16
                       4))))

(mat filesystem-operations
     (eqv? (directory-separator) (if (windows?) #\\ #\/))
     (directory-separator? #\/)
     (or (not (windows?)) (directory-separator? #\\))
     (error? (directory-separator? '/))
     (error? (directory-separator? ' "/"))
     (begin
       (delete-file "testfile.ss" #f)
       (delete-file "testfile.ss" #f)
       (delete-file "testfile.ss")
       #t)
     (begin
       (with-output-to-file "testfile.ss" values)
       (r6rs:delete-file "testfile.ss")
       (not (file-exists? "testfile.ss")))
     (error? (delete-file "testfile.ss" #t))
     (error? (r6rs:delete-file "testfile.ss"))
     (and (not (file-exists? "testfile.ss"))
          (not (file-exists? "testfile.ss" #t))
          (not (file-exists? "testfile.ss" #f)))
     (and (not (file-regular? "testfile.ss"))
          (not (file-regular? "testfile.ss" #t))
          (not (file-regular? "testfile.ss" #f)))
     (and (not (file-directory? "testfile.ss"))
          (not (file-directory? "testfile.ss" #t))
          (not (file-directory? "testfile.ss" #f)))
     (not (file-symbolic-link? "testfile.ss"))
     (begin (rm-rf "testdir") #t)
     (and (not (file-exists? "testdir"))
          (not (file-exists? "testdir" #t))
          (not (file-exists? "testdir" #f)))
     (and (not (file-regular? "testdir"))
          (not (file-regular? "testdir" #t))
          (not (file-regular? "testdir" #f)))
     (and (not (file-directory? "testdir"))
          (not (file-directory? "testdir" #t))
          (not (file-directory? "testdir" #f)))
     (not (file-symbolic-link? "testdir"))
     (begin
       (mkdir "testdir")
       (and (file-exists? "testdir")
            (file-exists? "testdir" #t)
            (file-exists? "testdir" #f)))
     (and (not (file-regular? "testdir"))
          (not (file-regular? "testdir" #t))
          (not (file-regular? "testdir" #f)))
     (and (file-directory? "testdir")
          (file-directory? "testdir" #t)
          (file-directory? "testdir" #f))
     (not (file-symbolic-link? "testdir"))
     (eqv? (directory-list "testdir") '())
     (begin
       (with-output-to-file "testdir/testfile.ss" values)
       (and (file-exists? "testdir/testfile.ss")
            (file-exists? "testdir/testfile.ss" #t)
            (file-exists? "testdir/testfile.ss" #f)))
     (and (file-regular? "testdir/testfile.ss")
          (file-regular? "testdir/testfile.ss" #t)
          (file-regular? "testdir/testfile.ss" #f))
     (and (not (file-directory? "testdir/testfile.ss"))
          (not (file-directory? "testdir/testfile.ss" #t))
          (not (file-directory? "testdir/testfile.ss" #f)))
     (not (file-symbolic-link? "testdir/testfile.ss"))
     (equal? (directory-list "testdir") '("testfile.ss"))
     (begin
       (with-output-to-file "testdir/foo" values)
       (and (file-exists? "testdir/foo")
            (file-exists? "testdir/foo" #t)
            (file-exists? "testdir/foo" #f)))
     (begin
       (with-output-to-file "testdir/bar" values)
       (and (file-exists? "testdir/bar")
            (file-exists? "testdir/bar" #t)
            (file-exists? "testdir/bar" #f)))
     (file-regular? "testdir/foo")
     (not (file-directory? "testdir/foo"))
     (not (file-symbolic-link? "testdir/foo"))
     (file-regular? "testdir/bar")
     (not (file-directory? "testdir/bar"))
     (not (file-symbolic-link? "testdir/bar"))
     (equal? (sort string<? (directory-list "testdir"))
             '("bar" "foo" "testfile.ss"))
     (guard (c [(and (i/o-filename-error? c)
                     (equal? (i/o-error-filename c) "testdir"))])
            (delete-directory "testdir" #t))
     (eqv? (delete-directory "testdir" #f) #f)
     (eqv? (delete-directory "testdir") #f)
     (guard (c [(and (i/o-filename-error? c)
                     (equal? (i/o-error-filename c) "testdir/testfile.ss"))])
            (delete-directory "testdir/testfile.ss" #t))
     (not (delete-directory "testdir/testfile.ss" #f))
     (not (delete-directory "testdir/testfile.ss"))
     (guard (c [(and (i/o-filename-error? c)
                     (equal? (i/o-error-filename c) "testdir"))])
            (delete-file "testdir" #t))
     (not (delete-file "testdir"))
     (not (delete-file "testdir" #f))
     (eqv? (delete-file "testdir/testfile.ss" #t) (void))
     (eqv? (delete-file "testdir/foo" #f) #t)
     (eqv? (delete-file "testdir/bar") #t)
     (not (delete-file "testdir" #f))
     (not (delete-file "testdir"))
     (eqv? (delete-directory "testdir" #f) #t)
     (begin (mkdir "testdir") (file-exists? "testdir"))
     (eqv? (delete-directory "testdir" #t) (void))
     (begin (mkdir "testdir") (file-exists? "testdir"))
     (eqv? (delete-directory "testdir") #t)
     (error? (file-exists? 'foo))
     (error? (file-regular? 'foo))
     (error? (file-directory? 'foo))
     (error? (file-symbolic-link? 'foo))
     (error? (file-exists? 'foo #t))
     (error? (file-regular? 'foo #t))
     (error? (file-directory? 'foo #t))
     (error? (file-exists? 'foo #f))
     (error? (file-regular? 'foo #f))
     (error? (file-directory? 'foo #f))
     (error? (delete-file 'foo #t))
     (error? (delete-file 'foo #f))
     (error? (delete-file 'foo))
     (error? (delete-directory 'foo #t))
     (error? (delete-directory 'foo #f))
     (error? (delete-directory 'foo))
     (error? (directory-list 'foo))
     (begin
       (mkdir "testdir")
       (with-output-to-file "testdir/rats" values)
       (file-exists? "testdir"))
     (eqv? (rename-file "testdir" "testdirx") (void))
     (eqv? (rename-file "testdirx/rats" "testdirx/star") (void))
     (not (delete-file "testdirx/rats" #f))
     (eqv? (delete-file "testdirx/star" #t) (void))
     (not (delete-directory "testdir" #f))
     (eqv? (delete-directory "testdirx" #t) (void))
     (or (embedded?) (> (length (directory-list "~")) 0))
     (or (embedded?) (> (length (directory-list "~/")) 0))
     (or (not (windows?))
         (> (length (directory-list "c:")) 0))
     (or (not (windows?))
         (> (length (directory-list "c:/")) 0))
     (or (not (windows?))
         (> (length (directory-list "\\\\?\\c:\\")) 0))
     (or (not (windows?))
         (> (length (directory-list "\\\\?\\C:\\")) 0))
     (file-directory? "/")
     (file-directory? "/.")
     (file-exists? ".")
     (file-exists? "./")
     (if (windows?)
         (and (file-directory? "c:")
              (file-directory? "c:/")
              (file-directory? "c:/."))
         (not (file-directory? "c:")))
     (if (windows?)
         (and (not (file-directory? "\\\\?\\c:"))
              (file-directory? "\\\\?\\c:\\"))
         (not (file-directory? "\\\\?\\c:")))
     (if (windows?)
         (and (file-exists? "c:")
              (file-exists? "c:/")
              (file-exists? "c:/."))
         (not (file-exists? "c:")))
     (if (windows?)
         (and (not (file-exists? "\\\\?\\c:"))
              (file-exists? "\\\\?\\c:\\"))
         (not (file-exists? "\\\\?\\c:")))
     (if (windows?)
         (and (not (file-regular? "\\\\?\\c:"))
              (not (file-regular? "\\\\?\\c:\\"))
              (or (not (file-exists? "\\\\?\\c:\\autoexec.bat"))
                  (file-regular? "\\\\?\\c:\\autoexec.bat")))
         (not (file-regular? "\\\\?\\c:\\autoexec.bat")))
     (error? (get-mode 'foo))
     (error? (get-mode 'foo #t))
     (error? (get-mode 'foo #f))
     (error? (get-mode "probably/not/there"))
     (error? (get-mode "probably/not/there" #f))
     (error? (get-mode "probably/not/there" #t))
     (if (or (windows?) (embedded?))
         (fixnum? (get-mode "mat.ss"))
         (let ([m (get-mode "mat.ss")])
           (and (logtest m #o400) (not (logtest m #o111)))))
     (or (not (windows?))
         (and (fixnum? (get-mode "c:/"))
              (eqv? (get-mode "c:/") (get-mode "C:\\"))
              (eqv? (get-mode "c:/") (get-mode "c:\\."))))
     (if (or (windows?) (embedded?))
         (fixnum? (get-mode "../mats"))
         (eqv? (logand (get-mode "../mats") #o700) #o700))
     (and (eqv? (get-mode "../mats") (get-mode "../mats/"))
          (eqv? (get-mode "../mats") (get-mode "../mats/.")))
     ; access times are unreliable on contemporary file systems
     (time? (file-access-time "../../mats/mat.ss"))
     (time<=? (file-change-time "mat.ss") (file-change-time "mat.so"))
     (time<=? (file-modification-time "mat.ss")
              (file-modification-time "mat.so"))
     (equal? (list (time? (file-access-time "../mats"))
                   (time? (file-change-time "../mats"))
                   (time? (file-modification-time "../mats")))
             '(#t #t #t))
     (equal? (list (time? (file-access-time "../mats/"))
                   (time? (file-change-time "../mats/"))
                   (time? (file-modification-time "../mats/")))
             '(#t #t #t))
     (or (not (windows?))
         (and (time? (file-access-time "c:"))
              (time? (file-change-time "c:"))
              (time? (file-modification-time "c:"))))
     (or (not (windows?))
         (and (time? (file-access-time "c:/"))
              (time? (file-change-time "c:/"))
              (time? (file-modification-time "c:/"))))
     (or (not (windows?))
         (and (time? (file-access-time "\\\\?\\C:\\"))
              (time? (file-change-time "\\\\?\\C:\\"))
              (time? (file-modification-time "\\\\?\\C:\\"))))
     (or (not (windows?))
         (and (time? (file-access-time "\\\\?\\c:\\"))
              (time? (file-change-time "\\\\?\\c:\\"))
              (time? (file-modification-time "\\\\?\\c:\\"))))
     (or (windows?)
         (embedded?)
         (time=? (file-access-time "Makefile")
                 (file-access-time (format "Mf-~a" (machine-type)))))
     (or (windows?)
         (embedded?)
         (time=? (file-change-time "Makefile")
                 (file-change-time (format "Mf-~a" (machine-type)))))
     (or (windows?)
         (embedded?)
         (time=? (file-modification-time "Makefile")
                 (file-modification-time (format "Mf-~a" (machine-type)))))
     (error? (file-access-time "probably/not/there"))
     (error? (file-access-time "probably/not/there" #f))
     (error? (file-access-time "probably/not/there" #t))
     (error? (file-change-time "probably/not/there"))
     (error? (file-change-time "probably/not/there" #f))
     (error? (file-change-time "probably/not/there" #t))
     (error? (file-modification-time "probably/not/there"))
     (error? (file-modification-time "probably/not/there" #f))
     (error? (file-modification-time "probably/not/there" #t)))

(mat unicode-filesystem-operations
     (begin
       (delete-file "testfile\x3bb;.ss" #f)
       (delete-file "testfile\x3bb;.ss" #f)
       (delete-file "testfile\x3bb;.ss")
       #t)
     (begin
       (with-output-to-file "testfile\x3bb;.ss" values)
       (r6rs:delete-file "testfile\x3bb;.ss")
       (not (file-exists? "testfile\x3bb;.ss")))
     (error? (delete-file "testfile\x3bb;.ss" #t))
     (error? (r6rs:delete-file "testfile\x3bb;.ss"))
     (and (not (file-exists? "testfile\x3bb;.ss"))
          (not (file-exists? "testfile\x3bb;.ss" #t))
          (not (file-exists? "testfile\x3bb;.ss" #f)))
     (and (not (file-regular? "testfile\x3bb;.ss"))
          (not (file-regular? "testfile\x3bb;.ss" #t))
          (not (file-regular? "testfile\x3bb;.ss" #f)))
     (and (not (file-directory? "testfile\x3bb;.ss"))
          (not (file-directory? "testfile\x3bb;.ss" #t))
          (not (file-directory? "testfile\x3bb;.ss" #f)))
     (not (file-symbolic-link? "testfile\x3bb;.ss"))
     (and (not (file-exists? "testdir\x3bb;"))
          (not (file-exists? "testdir\x3bb;" #t))
          (not (file-exists? "testdir\x3bb;" #f)))
     (and (not (file-regular? "testdir\x3bb;"))
          (not (file-regular? "testdir\x3bb;" #t))
          (not (file-regular? "testdir\x3bb;" #f)))
     (and (not (file-directory? "testdir\x3bb;"))
          (not (file-directory? "testdir\x3bb;" #t))
          (not (file-directory? "testdir\x3bb;" #f)))
     (not (file-symbolic-link? "testdir\x3bb;"))
     (begin
       (mkdir "testdir\x3bb;")
       (and (file-exists? "testdir\x3bb;")
            (file-exists? "testdir\x3bb;" #t)
            (file-exists? "testdir\x3bb;" #f)))
     (and (not (file-regular? "testdir\x3bb;"))
          (not (file-regular? "testdir\x3bb;" #t))
          (not (file-regular? "testdir\x3bb;" #f)))
     (and (file-directory? "testdir\x3bb;")
          (file-directory? "testdir\x3bb;" #t)
          (file-directory? "testdir\x3bb;" #f))
     (not (file-symbolic-link? "testdir\x3bb;"))
     (eqv? (directory-list "testdir\x3bb;") '())
     (begin
       (with-output-to-file "testdir\x3bb;/testfile\x3bb;.ss" values)
       (and (file-exists? "testdir\x3bb;/testfile\x3bb;.ss")
            (file-exists? "testdir\x3bb;/testfile\x3bb;.ss" #t)
            (file-exists? "testdir\x3bb;/testfile\x3bb;.ss" #f)))
     (and (file-regular? "testdir\x3bb;/testfile\x3bb;.ss")
          (file-regular? "testdir\x3bb;/testfile\x3bb;.ss" #t)
          (file-regular? "testdir\x3bb;/testfile\x3bb;.ss" #f))
     (and (not (file-directory? "testdir\x3bb;/testfile\x3bb;.ss"))
          (not (file-directory? "testdir\x3bb;/testfile\x3bb;.ss" #t))
          (not (file-directory? "testdir\x3bb;/testfile\x3bb;.ss" #f)))
     (not (file-symbolic-link? "testdir\x3bb;/testfile\x3bb;.ss"))
     (equal? (directory-list "testdir\x3bb;") '("testfile\x3bb;.ss"))
     (begin
       (with-output-to-file "testdir\x3bb;/foo" values)
       (and (file-exists? "testdir\x3bb;/foo")
            (file-exists? "testdir\x3bb;/foo" #t)
            (file-exists? "testdir\x3bb;/foo" #f)))
     (begin
       (with-output-to-file "testdir\x3bb;/bar" values)
       (and (file-exists? "testdir\x3bb;/bar")
            (file-exists? "testdir\x3bb;/bar" #t)
            (file-exists? "testdir\x3bb;/bar" #f)))
     (file-regular? "testdir\x3bb;/foo")
     (not (file-directory? "testdir\x3bb;/foo"))
     (not (file-symbolic-link? "testdir\x3bb;/foo"))
     (file-regular? "testdir\x3bb;/bar")
     (not (file-directory? "testdir\x3bb;/bar"))
     (not (file-symbolic-link? "testdir\x3bb;/bar"))
     (equal? (sort string<? (directory-list "testdir\x3bb;"))
             '("bar" "foo" "testfile\x3bb;.ss"))
     (guard (c [(and (i/o-filename-error? c)
                     (equal? (i/o-error-filename c) "testdir\x3bb;"))])
            (delete-directory "testdir\x3bb;" #t))
     (eqv? (delete-directory "testdir\x3bb;" #f) #f)
     (eqv? (delete-directory "testdir\x3bb;") #f)
     (guard (c [(and (i/o-filename-error? c)
                     (equal? (i/o-error-filename c)
                             "testdir\x3bb;/testfile\x3bb;.ss"))])
            (delete-directory "testdir\x3bb;/testfile\x3bb;.ss" #t))
     (not (delete-directory "testdir\x3bb;/testfile\x3bb;.ss" #f))
     (not (delete-directory "testdir\x3bb;/testfile\x3bb;.ss"))
     (guard (c [(and (i/o-filename-error? c)
                     (equal? (i/o-error-filename c) "testdir\x3bb;"))])
            (delete-file "testdir\x3bb;" #t))
     (not (delete-file "testdir\x3bb;"))
     (not (delete-file "testdir\x3bb;" #f))
     (eqv? (delete-file "testdir\x3bb;/testfile\x3bb;.ss" #t) (void))
     (eqv? (delete-file "testdir\x3bb;/foo" #f) #t)
     (eqv? (delete-file "testdir\x3bb;/bar") #t)
     (not (delete-file "testdir\x3bb;" #f))
     (not (delete-file "testdir\x3bb;"))
     (eqv? (delete-directory "testdir\x3bb;" #f) #t)
     (begin
       (mkdir "testdir\x3bb;")
       (file-exists? "testdir\x3bb;"))
     (eqv? (delete-directory "testdir\x3bb;" #t) (void))
     (begin
       (mkdir "testdir\x3bb;")
       (file-exists? "testdir\x3bb;"))
     (eqv? (delete-directory "testdir\x3bb;") #t)
     (begin
       (mkdir "testdir\x3bb;")
       (with-output-to-file "testdir\x3bb;/ra\x3bb;ts" values)
       (file-exists? "testdir\x3bb;"))
     (fixnum? (get-mode "testdir\x3bb;/ra\x3bb;ts"))
     (time? (file-access-time "testdir\x3bb;/ra\x3bb;ts"))
     (time? (file-change-time "testdir\x3bb;/ra\x3bb;ts"))
     (time? (file-modification-time "testdir\x3bb;/ra\x3bb;ts"))
     (eqv? (rename-file "testdir\x3bb;" "testdir\x3bb;x") (void))
     (eqv? (rename-file
             "testdir\x3bb;x/ra\x3bb;ts"
             "testdir\x3bb;x/sta\x3bb;r")
           (void))
     (not (delete-file "testdir\x3bb;x/ra\x3bb;ts" #f))
     (eqv? (delete-file "testdir\x3bb;x/sta\x3bb;r" #t) (void))
     (not (delete-directory "testdir\x3bb;" #f))
     (eqv? (delete-directory "testdir\x3bb;x" #t) (void))
     (error? (get-mode "probably/not/there\x3bb;"))
     (error? (get-mode "probably/not/there\x3bb;" #f))
     (error? (get-mode "probably/not/there\x3bb;" #t))
     (error? (file-access-time "probably/not/\x3bb;there"))
     (error? (file-access-time "probably/not/\x3bb;there" #f))
     (error? (file-access-time "probably/not/\x3bb;there" #t))
     (error? (file-change-time "probably/not/\x3bb;there"))
     (error? (file-change-time "probably/not/\x3bb;there" #f))
     (error? (file-change-time "probably/not/\x3bb;there" #t))
     (error? (file-modification-time "probably/not/\x3bb;there"))
     (error? (file-modification-time "probably/not/\x3bb;there" #f))
     (error? (file-modification-time "probably/not/\x3bb;there" #t)))

(mat pathprocs
     (error? (path-absolute? 'a/b/c))
     (error? (path-parent 'a/b/c))
     (error? (path-last 'a/b/c))
     (error? (path-root 'a/b/c))
     (error? (path-extension 'a/b/c))

     (eq? (path-absolute? "") #f)
     (eq? (path-absolute? "a") #f)
     (eq? (path-absolute? "/") #t)
     (eq? (path-absolute? "//bar/rot") #t)
     (eq? (path-absolute? "~foo/bar") #t)
     (eq? (path-absolute? "~/foo") #t)
     (eq? (path-absolute? "../") #f)
     (eq? (path-absolute? "./") #f)
     (eq? (path-absolute? "/abc") #t)
     (eq? (path-absolute? "foo") #f)
     (eq? (path-absolute? "foo/bar/a.b") #f)
     (eq? (path-absolute? "c:abc") #f)

     (equal? (path-parent "") "")
     (equal? (path-parent "a") "")
     (equal? (path-parent "/") "/")
     (equal? (path-parent "../") "..")
     (equal? (path-parent "./") ".")
     (equal? (path-parent "/abc") "/")
     (equal? (path-parent "foo/bar") "foo")
     (equal? (path-parent "foo/bar/") "foo/bar")
     (equal? (path-parent "foo/bar/a") "foo/bar")
     (equal? (path-parent "foo/bar/a.b") "foo/bar")
     (equal? (path-parent "foo/bar.b.q/a.b") "foo/bar.b.q")
     (equal? (path-parent "c:abc") (if (windows?) "c:" ""))
     (equal? (path-parent "Z:abc") (if (windows?) "Z:" ""))

     (equal? (path-last "") "")
     (equal? (path-last "a") "a")
     (equal? (path-last "/") "")
     (equal? (path-last "../") "")
     (equal? (path-last "./") "")
     (equal? (path-last "//") "")
     (equal? (path-last "/abc") "abc")
     (equal? (path-last "foo/bar") "bar")
     (equal? (path-last "foo/bar/") "")
     (equal? (path-last "foo/bar/a") "a")
     (equal? (path-last "foo/bar/a.b") "a.b")
     (equal? (path-last "foo/bar.b.q/a.b") "a.b")
     (equal? (path-last "c:abc") (if (windows?) "abc" "c:abc"))
     (equal? (path-last "Z:abc") (if (windows?) "abc" "Z:abc"))

     (equal? (path-root "") "")
     (equal? (path-root "a") "a")
     (equal? (path-root "..") "..")
     (equal? (path-root ".") ".")
     (equal? (path-root "..abc") ".")
     (equal? (path-root "abc.") "abc")
     (equal? (path-root "a.b.c") "a.b")
     (equal? (path-root "a.b.c.ss") "a.b.c")
     (equal? (path-last "foo") "foo")
     (equal? (path-root "/foo/bar.b.q/a.b.c") "/foo/bar.b.q/a.b")
     (equal? (path-root "c:/foo/bar.b.q/a.b.c") "c:/foo/bar.b.q/a.b")
     (equal? (path-root "c:") "c:")

     (equal? (path-extension "") "")
     (equal? (path-extension "a") "")
     (equal? (path-extension "..") "")
     (equal? (path-extension ".") "")
     (equal? (path-extension "..abc") "abc")
     (equal? (path-extension "abc.") "")
     (equal? (path-extension "a.b.c") "c")
     (equal? (path-extension "a.b.c.ss") "ss")
     (equal? (path-extension "/foo/bar.b.q/a.b.c") "c")
     (equal? (path-extension "c:/foo/bar.b.q/a.b.c") "c")
     (equal? (path-extension "c:..") "")
     (equal? (path-extension "c:") "")

     ; if this test fails, search for the asterisks in the printed table
     (let ([okay? #t])
       (define print-table
         (lambda (x* expected**)
           (define print-row
             (lambda (abs? path first rest parent last root extension)
               (printf "~a~11t~a~17t~a~28t~a~39t~a~50t~a~61t~a~73t~a\n"
                       abs?
                       path
                       first
                       rest
                       parent
                       last
                       root
                       extension)))
           (print-row
             "path"
             " abs"
             " first"
             " rest"
             " parent"
             " last"
             " root"
             " ext")
           (let ([actual** (map (lambda (x)
                                  (list (if (path-absolute? x) "t" "f")
                                        (path-first x)
                                        (path-rest x)
                                        (path-parent x)
                                        (path-last x)
                                        (path-root x)
                                        (path-extension x)))
                                x*)])
             (for-each
               (lambda (x expected* actual*)
                 (define uscore
                   (lambda (s) (if (eqv? s "") "_" s)))
                 (apply print-row x
                        (map (lambda (expected actual)
                               (format "~a~a"
                                 (if (string=? expected actual)
                                     " "
                                     (begin
                                       (set! okay? #f)
                                       "*"))
                                 (uscore actual)))
                             expected*
                             actual*)))
               x*
               expected**
               actual**))))

       (define-syntax table
         (syntax-rules ()
           [(_ (path abs? first rest parent last root extension) ...)
            (print-table '(path ...)
              '((abs? first rest parent last root extension) ...))]))

       ; common
       (table ("c" "f" "" "c" "" "c" "c" "")
         ("c." "f" "" "c." "" "c." "c" "")
         ("c.q" "f" "" "c.q" "" "c.q" "c" "q")
         ("c.qq" "f" "" "c.qq" "" "c.qq" "c" "qq")
         ("c.qqqqq" "f" "" "c.qqqqq" "" "c.qqqqq" "c" "qqqqq")
         ("c.qqq." "f" "" "c.qqq." "" "c.qqq." "c.qqq" "")
         ("c.qqq.zz" "f" "" "c.qqq.zz" "" "c.qqq.zz" "c.qqq" "zz")
         ("c./" "f" "c." "" "c." "" "c./" "")
         ("c.q/" "f" "c.q" "" "c.q" "" "c.q/" "")
         ("c.qq.z/" "f" "c.qq.z" "" "c.qq.z" "" "c.qq.z/" "")
         (".qq" "f" "" ".qq" "" ".qq" "" "qq")
         (".qq.z" "f" "" ".qq.z" "" ".qq.z" ".qq" "z")
         ("/" "t" "/" "" "/" "" "/" "")
         ("/abc" "t" "/" "abc" "/" "abc" "/abc" "")
         ("/abc/" "t" "/" "abc/" "/abc" "" "/abc/" "")
         ("abc" "f" "" "abc" "" "abc" "abc" "")
         ("/abc/def" "t" "/" "abc/def" "/abc" "def" "/abc/def" "")
         ("abc//def" "f" "abc" "def" "abc" "def" "abc//def" "")
         (".." "f" ".." "" ".." "" ".." "")
         ("../.." "f" ".." ".." ".." ".." "../.." "")
         ("../" "f" ".." "" ".." "" "../" "")
         ("../a" "f" ".." "a" ".." "a" "../a" "")
         ("../a/b" "f" ".." "a/b" "../a" "b" "../a/b" "")
         ("." "f" "." "" "." "" "." "")
         ("./." "f" "." "." "." "." "./." "")
         ("./" "f" "." "" "." "" "./" "")
         ("./a" "f" "." "a" "." "a" "./a" "")
         ("./a/b" "f" "." "a/b" "./a" "b" "./a/b" "")
         ("..." "f" "" "..." "" "..." ".." "")
         (".../" "f" "..." "" "..." "" ".../" "")
         (".../a" "f" "..." "a" "..." "a" ".../a" "")
         (".foo" "f" "" ".foo" "" ".foo" "" "foo")
         (".foo/" "f" ".foo" "" ".foo" "" ".foo/" "")
         (".foo/a" "f" ".foo" "a" ".foo" "a" ".foo/a" "")
         (".foo/a.q" "f" ".foo" "a.q" ".foo" "a.q" ".foo/a" "q")
         ("~" "t" "~" "" "~" "" "~" "")
         ("~/a" "t" "~" "a" "~" "a" "~/a" "")
         ("~/a/" "t" "~" "a/" "~/a" "" "~/a/" "")
         ("~/a/b" "t" "~" "a/b" "~/a" "b" "~/a/b" "")
         ("~a" "t" "~a" "" "~a" "" "~a" "")
         ("~a.b" "t" "~a.b" "" "~a.b" "" "~a.b" "")
         ("~a/" "t" "~a" "" "~a" "" "~a/" "")
         ("~a/b" "t" "~a" "b" "~a" "b" "~a/b" "")
         ("~a/b/" "t" "~a" "b/" "~a/b" "" "~a/b/" "")
         ("~a/b/c" "t" "~a" "b/c" "~a/b" "c" "~a/b/c" ""))

       ; windows
       (if (windows?)
           (table ("c:" "f" "c:" "" "c:" "" "c:" "")
             ("c:/" "t" "c:/" "" "c:/" "" "c:/" "")
             ("c:.." "f" "c:" ".." "c:" ".." "c:.." "")
             ("c:../" "f" "c:" "../" "c:.." "" "c:../" "")
             ("c:../a" "f" "c:" "../a" "c:.." "a" "c:../a" "")
             ("c:." "f" "c:" "." "c:" "." "c:." "")
             ("c:./" "f" "c:" "./" "c:." "" "c:./" "")
             ("c:./a" "f" "c:" "./a" "c:." "a" "c:./a" "")
             ("c:/abc" "t" "c:/" "abc" "c:/" "abc" "c:/abc" "")
             ("c:abc" "f" "c:" "abc" "c:" "abc" "c:abc" "")
             ("c:abc/def" "f" "c:" "abc/def" "c:abc" "def" "c:abc/def" "")
             ("c:/abc/def"
               "t"
               "c:/"
               "abc/def"
               "c:/abc"
               "def"
               "c:/abc/def"
               "")
             ("//abc" "t" "//abc" "" "//abc" "" "//abc" "")
             ("//abc/" "t" "//abc" "" "//abc" "" "//abc/" "")
             ("//abc/def" "t" "//abc" "def" "//abc" "def" "//abc/def" "")
             ("//x.com" "t" "//x.com" "" "//x.com" "" "//x.com" "")
             ("\\\\?\\" "t" "\\\\?\\" "" "\\\\?\\" "" "\\\\?\\" "")
             ("\\\\?\\c:" "t" "\\\\?\\c:" "" "\\\\?\\c:" "" "\\\\?\\c:" "")
             ("\\\\?\\c:\\"
               "t"
               "\\\\?\\c:\\"
               ""
               "\\\\?\\c:\\"
               ""
               "\\\\?\\c:\\"
               "")
             ("\\\\?\\UNC\\"
               "t"
               "\\\\?\\UNC\\"
               ""
               "\\\\?\\UNC\\"
               ""
               "\\\\?\\UNC\\"
               "")
             ("\\\\?\\Unc\\"
               "t"
               "\\\\?\\Unc\\"
               ""
               "\\\\?\\Unc\\"
               ""
               "\\\\?\\Unc\\"
               "")
             ("\\\\?\\uNc\\\\"
               "t"
               "\\\\?\\uNc\\\\"
               ""
               "\\\\?\\uNc\\\\"
               ""
               "\\\\?\\uNc\\\\"
               "")
             ("\\\\?\\unc\\x.com"
               "t"
               "\\\\?\\unc\\x.com"
               ""
               "\\\\?\\unc\\x.com"
               ""
               "\\\\?\\unc\\x.com"
               "")
             ("\\\\?\\unc\\x.com\\rot.foo"
               "t"
               "\\\\?\\unc\\x.com"
               "rot.foo"
               "\\\\?\\unc\\x.com"
               "rot.foo"
               "\\\\?\\unc\\x.com\\rot"
               "foo")
             ("\\\\?\\unc\\\\x.com\\rot.foo"
               "t"
               "\\\\?\\unc\\\\x.com"
               "rot.foo"
               "\\\\?\\unc\\\\x.com"
               "rot.foo"
               "\\\\?\\unc\\\\x.com\\rot"
               "foo")
             ("\\\\?\\unc\\x.com/rot.foo"
               "t"
               "\\\\?\\unc\\x.com/rot.foo"
               ""
               "\\\\?\\unc\\x.com/rot.foo"
               ""
               "\\\\?\\unc\\x.com/rot.foo"
               ""))
           (table ("c:" "f" "" "c:" "" "c:" "c:" "")
             ("c:/" "f" "c:" "" "c:" "" "c:/" "")
             ("c:.." "f" "" "c:.." "" "c:.." "c:." "")
             ("c:../" "f" "c:.." "" "c:.." "" "c:../" "")
             ("c:../a" "f" "c:.." "a" "c:.." "a" "c:../a" "")
             ("c:." "f" "" "c:." "" "c:." "c:" "")
             ("c:./" "f" "c:." "" "c:." "" "c:./" "")
             ("c:./a" "f" "c:." "a" "c:." "a" "c:./a" "")
             ("c:/abc" "f" "c:" "abc" "c:" "abc" "c:/abc" "")
             ("c:abc" "f" "" "c:abc" "" "c:abc" "c:abc" "")
             ("c:abc/def" "f" "c:abc" "def" "c:abc" "def" "c:abc/def" "")
             ("c:/abc/def"
               "f"
               "c:"
               "abc/def"
               "c:/abc"
               "def"
               "c:/abc/def"
               "")
             ("//abc" "t" "/" "abc" "/" "abc" "//abc" "")
             ("//abc/" "t" "/" "abc/" "//abc" "" "//abc/" "")
             ("//abc/def" "t" "/" "abc/def" "//abc" "def" "//abc/def" "")
             ("//x.com" "t" "/" "x.com" "/" "x.com" "//x" "com")))
       okay?))

(mat binary-vs-textual-port
     (textual-port? (current-input-port))
     (not (binary-port? (current-input-port)))
     (textual-port? (current-output-port))
     (not (binary-port? (current-output-port)))

     (begin
       (define $handler-standin
         (#%$port-handler (open-string-input-port "hi")))
       #t)

     (binary-port? (#%$make-binary-input-port "" $handler-standin '#vu8()))
     (not (textual-port?
            (#%$make-binary-input-port "" $handler-standin '#vu8())))
     (not (binary-port?
            (#%$make-textual-input-port "" $handler-standin "")))
     (textual-port? (#%$make-textual-input-port "" $handler-standin ""))
     (not (binary-port? (make-input-port values "")))
     (textual-port? (make-input-port values ""))

     (binary-port? (#%$make-binary-output-port "" $handler-standin '#vu8()))
     (not (textual-port?
            (#%$make-binary-output-port "" $handler-standin '#vu8())))
     (not (binary-port?
            (#%$make-textual-output-port "" $handler-standin "")))
     (textual-port? (#%$make-textual-output-port "" $handler-standin ""))
     (not (binary-port? (make-output-port values "")))
     (textual-port? (make-output-port values ""))

     (let ((x (make-input-port values "")))
       (and (port? x)
            (and (input-port? x) (textual-port? x))
            (not (and (output-port? x) (binary-port? x)))
            (not (output-port? x))
            (not (binary-port? x))))
     (let ((x (#%$make-binary-input-port "" $handler-standin '#vu8())))
       (and (port? x)
            (and (input-port? x) (binary-port? x))
            (not (and (output-port? x) (textual-port? x)))
            (not (output-port? x))
            (not (textual-port? x))))
     (let ((x (#%$make-textual-input-port "" $handler-standin "")))
       (and (port? x)
            (and (input-port? x) (textual-port? x))
            (not (and (output-port? x) (binary-port? x)))
            (not (output-port? x))
            (not (binary-port? x))))
     (let ((x (make-output-port values "")))
       (and (port? x)
            (and (output-port? x) (textual-port? x))
            (not (and (input-port? x) (binary-port? x)))
            (not (input-port? x))
            (not (binary-port? x))))
     (let ((x (#%$make-binary-output-port "" $handler-standin '#vu8())))
       (and (port? x)
            (and (output-port? x) (binary-port? x))
            (not (and (input-port? x) (textual-port? x)))
            (not (input-port? x))
            (not (textual-port? x))))
     (let ((x (#%$make-textual-output-port "" $handler-standin "")))
       (and (port? x)
            (and (output-port? x) (textual-port? x))
            (not (and (input-port? x) (binary-port? x)))
            (not (input-port? x))
            (not (binary-port? x)))))

(mat port-name
     (equal? "foo"
       (port-name
         (#%$make-binary-output-port "foo" $handler-standin #vu8())))
     (equal? "foo"
       (port-name (#%$make-textual-output-port "foo" $handler-standin "")))
     (equal? "foo"
       (let ([x (#%$make-binary-output-port "rot" $handler-standin #vu8())])
         (set-port-name! x "foo")
         (port-name x)))
     (equal? "foo"
       (let ([x (#%$make-textual-output-port "#f" $handler-standin "")])
         (set-port-name! x "foo")
         (port-name x)))
     (equal? "foo" (port-name (make-output-port (lambda args "foo") "")))
     (equal? "generic"
       (port-name (make-output-port (lambda args (errorf 'foo "foo")) ""))))

(mat procedure-name
     (equal? (format "~s" car) "#<procedure car>")
     (equal? (format "~s" (lambda (x) x)) "#<procedure>")
     (begin
       (with-output-to-file "testfile.ss"
         (lambda ()
           (pretty-print '(define ($pn-q x) (lambda (y) (+ x y)))))
         'replace)
       (load "testfile.ss" compile)
       #t)
     (equal? (format "~s" $pn-q) "#<procedure $pn-q at testfile.ss:0>")
     (equal? (format "~s" ($pn-q 3)) "#<procedure at testfile.ss:18>"))

(mat bignum-printing
     (let ()
       (define wrint
         (let ([digit->char
                 (lambda (d)
                   (string-ref "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" d))])
           (lambda (n b)
             (if (< n b)
                 (write-char (digit->char n))
                 (begin
                   (wrint (quotient n b) b)
                   (write-char (digit->char (remainder n b))))))))
       (do ([i 4000 (fx- i 1)])
           ((fx= i 0))
           (let ([n (random (expt 2 (random (* (fixnum-width) 30))))]
                 [b (+ 2 (random 35))])
             (unless (let ([s (with-output-to-string (lambda () (wrint n b)))])
                       (and (string=? (parameterize ([print-radix b]) (format "~a" n))
                                      s)
                            (or (= n 0)
                                (string=? (parameterize ([print-radix b])
                                            (format "~a" (- n)))
                                          (format "-~a" s)))))
                     (errorf #f "failed in base ~s for ~s" b n))
             (unless (string=? (format "~a" n)
                       (with-output-to-string (lambda () (wrint n 10))))
                     (errorf #f "failed in base 10 for ~s" n))))
       #t))

(mat process
     (begin
       (set! p (process (patch-exec-path $cat_flush)))
       (= (length p) 3))
     (and (port? (car p))
          (input-port? (car p))
          (port? (cadr p))
          (output-port? (cadr p))
          (integer? (caddr p)))
     (and (file-port? (car p)) (file-port? (cadr p)))
     (and (fixnum? (port-file-descriptor (car p)))
          (fixnum? (port-file-descriptor (cadr p))))
     (let ([ip (car p)])
       (and (not (port-has-port-position? ip))
            (not (port-has-set-port-position!? ip))
            (not (port-has-port-length? ip))
            (not (port-has-set-port-length!? ip))))
     (let ([op (car p)])
       (and (not (port-has-port-position? op))
            (not (port-has-set-port-position!? op))
            (not (port-has-port-length? op))
            (not (port-has-set-port-length!? op))))
     (not (char-ready? (car p)))
     (begin
       (display "hello " (cadr p))
       (flush-output-port (cadr p))
       #t)
     (begin (sleep (make-time 'time-duration 0 3)) #t)
     ; wait for subprocess to catch up
     (char-ready? (car p))
     (eq? (read (car p)) 'hello)
     (char-ready? (car p))
     (char=? (read-char (car p)) #\space)
     (not (char-ready? (car p)))
     (begin (close-output-port (cadr p)) #t)
     (begin (sleep (make-time 'time-duration 0 3)) #t)
     ; wait for subprocess to catch up
     (sanitized-error? (write-char #\a (cadr p)))
     (sanitized-error? (write-char #\newline (cadr p)))
     (sanitized-error? (flush-output-port (cadr p)))
     (char-ready? (car p))
     (eof-object? (read-char (car p)))
     (begin (close-input-port (car p)) #t)
     (sanitized-error? (char-ready? (car p)))
     (sanitized-error? (read-char (car p)))
     (sanitized-error? (clear-input-port (cadr p))))
;;; io.ms
;;; Copyright 1984-2017 Cisco Systems, Inc.
;;; 
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;; 
;;; http://www.apache.org/licenses/LICENSE-2.0
;;; 
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

(define (native-string->bytevector s)
  (string->bytevector s (native-transcoder)))

; convert uses of custom-port-warning? to warning? if custom-port warnings
; are enabled in io.ss
(define (custom-port-warning? x) #t)

(mat port-operations
     (error? (close-port cons))
     ; the following several clauses test various open-file-output-port options
     (let ([p (open-file-output-port "testfile.ss" (file-options no-fail))])
       (and (port? p)
            (output-port? p)
            (begin (close-port p) #t)))
     (error? ; file already exists
             (open-file-output-port "testfile.ss"))
     (error? ; file already exists
       (open-file-output-port "testfile.ss" (file-options compressed)))
     (let ([p (open-file-output-port "testfile.ss" (file-options replace))])
       (and (port? p)
            (output-port? p)
            (begin (close-port p) #t)))
     (let ([p (open-file-output-port "testfile.ss" (file-options no-fail))])
       (and (port? p)
            (output-port? p)
            (begin (close-port p) #t)))
     (let ([p (open-file-output-port "testfile.ss" (file-options no-fail))])
       (put-bytevector p (native-string->bytevector "\"hello"))
       (close-port p)
       (let ([p (open-file-output-port "testfile.ss"
                  (file-options no-fail no-truncate append))])
         (put-bytevector p (native-string->bytevector " there\""))
         (close-port p)
         (let ([p (open-file-input-port "testfile.ss")])
           (and (equal? (get-bytevector-all p)
                        (native-string->bytevector "\"hello there\""))
                (eof-object? (get-u8 p))
                (begin (close-port p) #t)))))
     (let ([p (let loop ()
                (if (file-exists? "testfile.ss")
                    (begin
                      (delete-file "testfile.ss" #f)
                      (loop))
                    (open-file-output-port "testfile.ss")))])
       (for-each
         (lambda (x)
           (put-bytevector p (native-string->bytevector x))
           (put-bytevector p (native-string->bytevector " ")))
         '("a" "b" "c" "d" "e"))
       (put-bytevector p (native-string->bytevector "\n"))
       (close-port p)
       #t)
     (equal? (let ([p (open-file-input-port "testfile.ss")])
               (let f ([x (get-u8 p)])
                 (if (eof-object? x)
                     (begin (close-port p) '())
                     (cons (integer->char x) (f (get-u8 p))))))
             (if (eq? (native-eol-style) 'crlf)
                 '(#\a #\space
                       #\b
                       #\space
                       #\c
                       #\space
                       #\d
                       #\space
                       #\e
                       #\space
                       #\return
                       #\newline)
                 '(#\a #\space
                       #\b
                       #\space
                       #\c
                       #\space
                       #\d
                       #\space
                       #\e
                       #\space
                       #\newline)))
     (error? (call-with-port 3 values))
     (error? (call-with-port (current-input-port) 'a))
     (equal? (call-with-values
               (lambda ()
                 (call-with-port
                   (open-file-output-port "testfile.ss"
                     (file-options replace))
                   (lambda (p)
                     (for-each
                       (lambda (c)
                         (put-u8 p (char->integer c)))
                       (string->list "a b c d e"))
                     (values 1 2 3))))
               list)
             '(1 2 3))
     (equal? (call-with-port (open-file-input-port "testfile.ss")
               (lambda (p)
                 (list->string
                   (let f ()
                     (let ([c (get-u8 p)])
                       (if (eof-object? c)
                           '()
                           (begin
                             (unget-u8 p c)
                             (let ([c (get-u8 p)])
                               (cons (integer->char c) (f))))))))))
             "a b c d e")
     (equal? (call-with-port (open-file-input-port "testfile.ss")
               (lambda (p)
                 (list->string
                   (let f ()
                     (let ([c (get-u8 p)])
                       (unget-u8 p c)
                       (if (eof-object? c)
                           (begin
                             (unless (and (eof-object? (lookahead-u8 p))
                                          (port-eof? p)
                                          (eof-object? (get-u8 p)))
                                     (errorf #f "unget of eof apparently failed"))
                             '())
                           (let ([c (get-u8 p)])
                             (cons (integer->char c) (f)))))))))
             "a b c d e")
     (andmap (lambda (p)
               (equal? (call-with-port p
                         (lambda (p)
                           (list->string
                             (let f ()
                               (let ([c (lookahead-u8 p)])
                                 (if (eof-object? c)
                                     '()
                                     (let ([c (get-u8 p)])
                                       (cons (integer->char c)
                                             (f)))))))))
                       "a b c d e"))
             (list (open-file-input-port "testfile.ss")
                   (open-bytevector-input-port
                     '#vu8(97 32 98 32 99 32 100 32 101))
                   (open-bytevector-input-port
                     (bytevector->immutable-bytevector
                       '#vu8(97 32 98 32 99 32 100 32 101)))))
     ; test various errors related to input ports
     (begin
       (set! ip (open-file-input-port "testfile.ss"))
       (and (port? ip) (input-port? ip)))
     (error? ; unget can only follow get
             (unget-u8 ip 40))
     (eqv? (get-u8 ip) (char->integer #\a))
     (begin
       (unget-u8 ip (char->integer #\a))
       (eqv? (get-u8 ip) (char->integer #\a)))
     (error? (put-u8 ip (char->integer #\a)))
     (error? (put-bytevector ip #vu8()))
     (error? (flush-output-port ip))
     (begin (close-port ip) #t)
     (begin (close-port ip) #t)
     (error? (port-eof? ip))
     (error? (input-port-ready? ip))
     (error? (get-u8? ip))
     (error? (lookahead-u8? ip))
     (error? (unget-u8? ip))
     (error? (get-bytevector-n ip 1))
     (error? (get-bytevector-n! ip (make-bytevector 10) 0 10))
     (error? (get-bytevector-some ip))
     (error? (get-bytevector-all ip))
     ; test various errors related to output ports
     (begin
       (set! op
         (open-file-output-port "testfile.ss" (file-options replace)))
       (and (port? op) (output-port? op)))
     (error? (input-port-ready? op))
     (error? (lookahead-u8 op))
     (error? (get-u8 op))
     (error? (unget-u8 op 40))
     (error? (get-bytevector-n op 1))
     (error? (get-bytevector-n! op (make-bytevector 10) 0 10))
     (error? (get-bytevector-some op))
     (error? (get-bytevector-all op))
     (begin (close-port op) #t)
     (begin (close-port op) #t)
     (error? (put-u8 op (char->integer #\a)))
     (error? (put-bytevector op #vu8(1)))
     (error? (flush-output-port op))

     (let ([s (native-string->bytevector "hi there, mom!")])
       (let ([ip (open-bytevector-input-port s)])
         (let-values ([(op op-ex) (open-bytevector-output-port)])
           (do ([c (get-u8 ip) (get-u8 ip)])
               ((eof-object? c) (equal? (op-ex) s))
               (unget-u8 ip c)
               (put-u8 op (get-u8 ip))))))

     (error? (eof-object #!eof))
     (eq? (call-with-port (open-bytevector-input-port #vu8()) get-u8) #!eof)
     (eq? (call-with-port (open-bytevector-input-port #vu8()) get-u8)
          (eof-object))
     (eq? (eof-object) #!eof)
     (let ([s (native-string->bytevector "hi there, mom!")])
       (equal? (call-with-port (open-bytevector-input-port s)
                 (lambda (i)
                   (call-with-bytevector-output-port
                     (lambda (o)
                       (do ([c (get-u8 i) (get-u8 i)])
                           ((eof-object? c))
                           (unget-u8 i c)
                           (put-u8 o (get-u8 i)))))))
               s))

     ; the following makes sure that call-with-port closes the at least on
     ; systems which restrict the number of open ports to less than 2048
     (let ([filename "testfile.ss"])
       (let loop ((i 2048))
         (or (zero? i)
             (begin
               (call-with-port
                 (open-file-output-port filename (file-options replace))
                 (lambda (p)
                   (put-u8 p (quotient i 256))
                   (put-u8 p (modulo i 256))))
               (and (eq? (call-with-port (open-file-input-port filename)
                           (lambda (p)
                             (let* ([hi (get-u8 p)] [lo (get-u8 p)])
                               (+ (* 256 hi) lo))))
                         i)
                    (loop (- i 1)))))))
     (begin
       (close-input-port #%$console-input-port)
       (not (port-closed? #%$console-input-port)))
     (begin
       (close-output-port #%$console-output-port)
       (not (port-closed? #%$console-output-port))))

(mat port-operations1
     (error? ; incorrect number of arguments
             (open-file-input-port))
     (error? ; furball is not a string
             (open-file-input-port 'furball))
     (error? ; not a file-options object
             (open-file-input-port "testfile.ss" '()))
     (error? ; not a valid buffer mode
             (open-file-input-port "testfile.ss" (file-options) 17))
     (error? ; not a transcoder
       (open-file-input-port "testfile.ss"
         (file-options)
         (buffer-mode block)
         'wow))
     (error? ; incorrect number of arguments
       (open-file-input-port "testfile.ss"
         (file-options)
         (buffer-mode block)
         #f
         'now?))
     (error? ; cannot open
       (open-file-input-port "/probably/not/a/good/path"))
     (error? ; cannot open
       (open-file-input-port "/probably/not/a/good/path"
         (file-options compressed)))
     (error? ; invalid options
       (open-file-input-port "testfile.ss" (file-options uncompressed)))
     (error? ; invalid options
       (open-file-input-port "testfile.ss" (file-options truncate)))
     (error? ; incorrect number of arguments
             (open-file-output-port))
     (error? ; furball is not a string
             (open-file-output-port 'furball))
     (error? ; not a file-options object
             (open-file-output-port "testfile.ss" '(no-create)))
     (error? ; not a valid buffer mode
             (open-file-output-port "testfile.ss" (file-options) 17))
     (error? ; not a transcoder
       (open-file-output-port "testfile.ss"
         (file-options)
         (buffer-mode block)
         'wow))
     (error? ; incorrect number of arguments
       (open-file-output-port "testfile.ss"
         (file-options)
         (buffer-mode block)
         #f
         'now?))
     (error? ; cannot open
       (open-file-output-port "/probably/not/a/good/path"))
     (error? ; invalid options
       (open-file-output-port "testfile.ss" (file-options uncompressed)))
     (error? ; invalid options
       (open-file-output-port "testfile.ss" (file-options truncate)))
     (error? ; incorrect number of arguments
             (open-file-input/output-port))
     (error? ; furball is not a string
             (open-file-input/output-port 'furball))
     (error? ; not a file-options object
             (open-file-input/output-port "testfile.ss" '(no-create)))
     (error? ; not a valid buffer mode
       (open-file-input/output-port "testfile.ss" (file-options) 17))
     (error? ; not a transcoder
       (open-file-input/output-port "testfile.ss"
         (file-options)
         (buffer-mode block)
         'wow))
     (error? ; incorrect number of arguments
       (open-file-input/output-port "testfile.ss"
         (file-options)
         (buffer-mode block)
         #f
         'now?))
     (error? ; cannot open
       (open-file-input/output-port "/probably/not/a/good/path"))
     (error? ; invalid options
       (open-file-input/output-port "testfile.ss"
         (file-options uncompressed)))
     (error? ; invalid options
       (open-file-input/output-port "testfile.ss" (file-options truncate)))
     (begin (delete-file "testfile.ss") #t)
     (error? ; no such file
             (open-file-input-port "testfile.ss"))
     (error? ; no such file
       (open-file-output-port "testfile.ss" (file-options no-create)))
     (error? ; no such file
       (open-file-input/output-port "testfile.ss" (file-options no-create)))
     (begin (mkdir "testfile.ss") #t)
     (guard (c [(and (i/o-filename-error? c)
                     (equal? (i/o-error-filename c) "testfile.ss"))])
            (open-file-output-port "testfile.ss" (file-options no-create)))
     (guard (c [(and (i/o-filename-error? c)
                     (equal? (i/o-error-filename c) "testfile.ss"))])
            (open-file-input/output-port "testfile.ss"
              (file-options no-create)))
     (begin (delete-directory "testfile.ss") #t)
     (begin
       (define $ppp
         (open-file-input/output-port "testfile.ss" (file-options replace)))
       (and (input-port? $ppp)
            (output-port? $ppp)
            (port? $ppp)))
     (error? (set-port-length! $ppp -3))
     (error? (set-port-length! $ppp 'all-the-way))
     (eof-object?
       (begin
         (set-port-length! $ppp 0)
         (set-port-position! $ppp 0)
         (put-bytevector $ppp (native-string->bytevector "hello"))
         (flush-output-port $ppp)
         (get-u8 $ppp)))
     (equal? (begin (set-port-position! $ppp 0) (get-bytevector-all $ppp))
             (native-string->bytevector "hello"))
     (eqv? (begin
             (put-bytevector $ppp (native-string->bytevector "goodbye\n"))
             (truncate-port $ppp 9)
             (port-position $ppp))
           9)
     (eof-object? (get-u8 $ppp))
     (eqv? (begin (set-port-position! $ppp 0) (port-position $ppp)) 0)
     (equal? (get-bytevector-all $ppp)
             (native-string->bytevector "hellogood"))
     (eqv? (begin
             (put-bytevector $ppp (native-string->bytevector "byebye\n"))
             (truncate-port $ppp 0)
             (port-position $ppp))
           0)
     (eof-object? (get-u8 $ppp))
     (eof-object?
       (begin
         (close-port $ppp)
         (let ([ip (open-file-input-port "testfile.ss")])
           (let ([c (get-u8 ip)])
             (close-port $ppp)
             (close-port ip)
             c))))
     (error? (let ([ip (open-file-input-port "testfile.ss")])
               (dynamic-wind void
                 (lambda () (truncate-port ip))
                 (lambda () (close-port ip)))))
     (error? (truncate-port 'animal-crackers))
     (error? (truncate-port))
     (error? (truncate-port $ppp))
     (let-values ([(op get) (open-bytevector-output-port)])
       (and (= (port-position op) 0)
            (= (port-length op) 0)
            (do ([i 4000 (fx- i 1)])
                ((fx= i 0) #t)
                (put-bytevector op (string->utf8 "hello")))
            (= (port-length op) 20000)
            (= (port-position op) 20000)
            (begin (set-port-position! op 5000) #t)
            (= (port-position op) 5000)
            (= (port-length op) 20000)
            (begin (truncate-port op) #t)
            (= (port-position op) 0)
            (= (port-length op) 0)
            (begin (truncate-port op 17) #t)
            (= (port-position op) 17)
            (= (port-length op) 17)
            (begin
              (put-bytevector op (string->utf8 "okay"))
              #t)
            (= (port-position op) 21)
            (= (port-length op) 21)
            (let ([bv (get)])
              (and (= (char->integer #\o) (bytevector-u8-ref bv 17))
                   (= (char->integer #\k) (bytevector-u8-ref bv 18))
                   (= (char->integer #\a) (bytevector-u8-ref bv 19))
                   (= (char->integer #\y) (bytevector-u8-ref bv 20))))
            (= (port-position op) 0)
            (= (port-length op) 0)
            (begin
              (put-u8 op (char->integer #\a))
              (put-u8 op (char->integer #\newline))
              #t)
            (= (port-position op) 2)
            (equal? (get) (string->utf8 "a\n"))))
     (let ([ip (open-bytevector-input-port
                 (native-string->bytevector "beam me up, scotty!"))]
           [bv (make-bytevector 10)])
       (and (= (port-position ip) 0)
            (= (port-length ip) 19)
            (not (eof-object? (lookahead-u8 ip)))
            (equal? (get-bytevector-n ip 4)
                    (native-string->bytevector "beam"))
            (= (port-position ip) 4)
            (not (eof-object? (lookahead-u8 ip)))
            (equal? (get-bytevector-n! ip bv 0 10) 10)
            (equal? bv (native-string->bytevector " me up, sc"))
            (= (port-position ip) 14)
            (equal? (get-bytevector-n! ip bv 0 10) 5)
            (equal? bv (native-string->bytevector "otty!p, sc"))
            (= (port-position ip) 19)
            (eof-object? (lookahead-u8 ip))
            (eof-object? (get-u8 ip))
            (eof-object? (get-bytevector-n! ip bv 0 10))
            (= (get-bytevector-n! ip bv 0 0) 0)
            ;; TODO: check w/ Kent about this
            (begin
              (set-port-position! ip 10)
              (= (port-position ip) 10))
            (equal? (get-bytevector-n! ip bv 0 10) 9)
            (equal? bv (native-string->bytevector ", scotty!c")))))

(mat port-operations2
     (equal? (let* ([op (open-file-output-port "testfile.ss"
                          (file-options replace)
                          (buffer-mode none))]
                    [ip (open-file-input-port "testfile.ss")])
               (put-u8 op 97)
               (let* ([b1 (get-u8 ip)] [b2 (get-u8 ip)])
                 (put-u8 op 98)
                 (let* ([b3 (get-u8 ip)] [b4 (get-u8 ip)])
                   (put-u8 op 99)
                   (let ([b5 (get-u8 ip)])
                     (close-port op)
                     (let ([b6 (get-u8 ip)])
                       (close-port ip)
                       (list b1 b2 b3 b4 b5 b6))))))
             '(97 #!eof 98 #!eof 99 #!eof))
     (equal? (let* ([op (open-file-output-port "testfile.ss"
                          (file-options replace)
                          (buffer-mode none))]
                    [ip (open-file-input-port "testfile.ss")])
               (let ([eof1? (port-eof? ip)])
                 (put-u8 op 97)
                 ; the port-eof? call above buffers the eof, so b1 should be #!eof
                 (let* ([b1 (get-u8 ip)] [b2 (get-u8 ip)])
                   (put-u8 op 98)
                   (let* ([eof2? (port-eof? ip)] [b3 (get-u8 ip)])
                     (let ([b4 (get-u8 ip)])
                       (put-u8 op 99)
                       (let* ([b5 (get-u8 ip)])
                         (close-port op)
                         (let* ([b6 (get-u8 ip)] [eof3? (port-eof? ip)])
                           (close-port ip)
                           (list eof1? b1 b2 eof2? b3 b4 b5 b6 eof3?))))))))
             '(#t #!eof 97 #f 98 #!eof 99 #!eof #t))
     (equal? ; following assumes block buffering really doesn't cause any writes until
       ; at least after a few bytes have been written
       (let* ([op (open-file-output-port "testfile.ss"
                    (file-options replace)
                    (buffer-mode block))]
              [ip (open-file-input-port "testfile.ss")])
         (put-u8 op 97)
         (let ([b1 (get-u8 ip)])
           (put-u8 op 98)
           (let ([b2 (get-u8 ip)])
             (close-port op)
             (let* ([b3 (get-u8 ip)] [b4 (get-u8 ip)] [b5 (get-u8 ip)])
               (close-port ip)
               (list b1 b2 b3 b4 b5)))))
       '(#!eof #!eof 97 98 #!eof))
     ; test switching between input and output modes
     ; should be adapted for textual ports
     (equal? (begin
               (call-with-port
                 (open-file-output-port "testfile.ss"
                   (file-options replace))
                 (lambda (p)
                   (put-bytevector p #vu8(1 2 3 4 5))))
               (let ([iop (open-file-input/output-port "testfile.ss"
                            (file-options no-fail no-truncate))])
                 (let ([b1 (get-u8 iop)])
                   (put-u8 iop 17)
                   (let ([b2 (get-u8 iop)])
                     (close-port iop)
                     (list b1 b2
                           (call-with-port
                             (open-file-input-port "testfile.ss")
                             get-bytevector-all))))))
             '(1 3 #vu8(1 17 3 4 5)))
     ; test switching between input and output modes
     ; old implementation is broken---uncomment for new implementation
     ; and move to set of mats testing convenience i/o
     #;
     (equal? (begin
               (with-output-to-file "testfile.ss"
                 (lambda () (display "hi there"))
                 'replace)
               (let ([iop (open-input-output-file "testfile.ss")])
                 (let ([c1 (read-char iop)])
                   (write-char #\! iop)
                   (let ([c2 (read-char iop)])
                     (close-port iop)
                     (list c1 c2
                           (with-input-from-file "testfile.ss"
                             (lambda ()
                               (list->string
                                 (let f ()
                                   (let ([c (read-char)])
                                     (if (eof-object? c)
                                         '()
                                         (cons c (f)))))))))))))
             '(#\h #\space "h! there"))
     (equal? (let-values ([(p g) (open-string-output-port)])
               (fresh-line p)
               (fresh-line p)
               (display "hello" p)
               (fresh-line p)
               (fresh-line p)
               (newline p)
               (fresh-line p)
               (display "goodbye" p)
               (newline p)
               (fresh-line p)
               (g))
             "hello\n\ngoodbye\n")
     ; check for bug fix in transcoded-port-put-some
     (let f ([n 1000])
       (or (fx= n 0)
           (begin
             (let ([op (open-file-output-port "testfile.ss"
                         (file-options replace)
                         (buffer-mode line)
                         (native-transcoder))])
               (do ([i 1000 (- i 1)]) ((fx= i 0)) (display #!eof op))
               (close-port op))
             (and (equal? (call-with-port
                            (open-file-input-port "testfile.ss"
                              (file-options)
                              (buffer-mode block)
                              (native-transcoder))
                            get-string-all)
                          (apply string-append (make-list 1000 "#!eof")))
                  (f (- n 1)))))))

(mat port-operations3
     (error? (file-port? "not a port"))
     (error? (port-file-descriptor 'oops))
     (error? (port-file-descriptor (open-input-string "hello")))
     (or (threaded?) (file-port? (console-input-port)))
     (or (threaded?) (file-port? (console-output-port)))
     (not (file-port? (open-input-string "hello")))
     (or (threaded?)
         (= (port-file-descriptor (console-input-port)) 0))
     (or (threaded?)
         (= (port-file-descriptor (console-output-port)) 1))
     (> (let ([ip (open-input-file "mat.ss")])
          (let ([n (and (file-port? ip) (port-file-descriptor ip))])
            (close-port ip)
            n))
        1)
     (> (let ([ip (open-input-file "mat.ss" 'compressed)])
          (let ([n (and (file-port? ip) (port-file-descriptor ip))])
            (close-port ip)
            n))
        1)
     (> (let ([op (open-output-file "testfile.ss" '(replace))])
          (let ([n (and (file-port? op) (port-file-descriptor op))])
            (close-port op)
            n))
        1)
     (> (let ([op (open-output-file "testfile.ss" '(replace compressed))])
          (let ([n (and (file-port? op) (port-file-descriptor op))])
            (close-port op)
            n))
        1))

(if (embedded?)
    (mat iconv-codec
         (error? (errorf 'iconv-codec "-73 is not a string"))
         (error? (errorf 'transcoded-port "unsupported encoding almost certainly bogus"))
         (error? (errorf 'close-port "iconv CP1252 codec cannot encode #\\x3BB"))
         (error? (errorf 'close-port "iconv CP1252 codec cannot encode #\\newline with eol-style ls"))
         (error? (errorf 'close-port "latin-1 codec cannot encode #\\newline with eol-style ls")))
    (mat iconv-codec
         (error? ; invalid codec
                 (iconv-codec -73))
         (error? ; unsupported encoding
           (let ()
             (define codec
               (iconv-codec "almost certainly bogus"))
             (define transcoder
               (make-transcoder codec
                 (eol-style none)
                 (error-handling-mode ignore)))
             (define-values (bp get) (open-bytevector-output-port))
             (define op (transcoded-port bp transcoder))
             (newline op)
             (close-port op)))
         (let ()
           (define codec (iconv-codec "UTF-8"))
           (define transcoder
             (make-transcoder codec
               (eol-style none)
               (error-handling-mode ignore)))
           (define op
             (open-file-output-port "testfile.ss"
               (file-options replace)
               (buffer-mode line)
               transcoder))
           (define p1)
           (define p2)
           (define p3)
           (define p4)
           (newline op)
           (display "hello l\x0;ambda:\n\x3bb;!\n" op)
           (close-port op)
           (and (equal? (call-with-port
                          (open-file-input-port "testfile.ss"
                            (file-options)
                            (buffer-mode block)
                            (make-transcoder (utf-8-codec)
                              (eol-style none)
                              (error-handling-mode raise)))
                          (lambda (ip)
                            (set! p1 (port-position ip))
                            (let ([s (get-string-all ip)])
                              (set! p2 (port-position ip))
                              s)))
                        "\nhello l\x0;ambda:\n\x3bb;!\n")
                (equal? (call-with-port
                          (open-file-input-port "testfile.ss"
                            (file-options)
                            (buffer-mode block)
                            transcoder)
                          (lambda (ip)
                            (set! p3 (port-position ip))
                            (let ([s (get-string-all ip)])
                              (set! p4 (port-position ip))
                              s)))
                        "\nhello l\x0;ambda:\n\x3bb;!\n")
                (eq? p1 0)
                (eq? p2 20)
                (eq? p3 0)
                (eq? p4 20)))
         (let ()
           ; same but eol-style lf
           (define codec (iconv-codec "UTF-8"))
           (define transcoder
             (make-transcoder codec
               (eol-style lf)
               (error-handling-mode ignore)))
           (define op
             (open-file-output-port "testfile.ss"
               (file-options replace)
               (buffer-mode line)
               transcoder))
           (define p1)
           (define p2)
           (define p3)
           (define p4)
           (newline op)
           (display "hello l\x0;ambda:\n\x3bb;!\n" op)
           (close-port op)
           (and (equal? (call-with-port
                          (open-file-input-port "testfile.ss"
                            (file-options)
                            (buffer-mode block)
                            (make-transcoder (utf-8-codec)
                              (eol-style lf)
                              (error-handling-mode raise)))
                          (lambda (ip)
                            (set! p1 (port-position ip))
                            (let ([s (get-string-all ip)])
                              (set! p2 (port-position ip))
                              s)))
                        "\nhello l\x0;ambda:\n\x3bb;!\n")
                (equal? (call-with-port
                          (open-file-input-port "testfile.ss"
                            (file-options)
                            (buffer-mode block)
                            transcoder)
                          (lambda (ip)
                            (set! p3 (port-position ip))
                            (let ([s (get-string-all ip)])
                              (set! p4 (port-position ip))
                              s)))
                        "\nhello l\x0;ambda:\n\x3bb;!\n")
                (eq? p1 0)
                (eq? p2 20)
                (eq? p3 0)
                (eq? p4 20)))
         (let ()
           ; same but eol-style crlf
           (define codec (iconv-codec "UTF-8"))
           (define transcoder
             (make-transcoder codec
               (eol-style crlf)
               (error-handling-mode ignore)))
           (define op
             (open-file-output-port "testfile.ss"
               (file-options replace)
               (buffer-mode line)
               transcoder))
           (define p1)
           (define p2)
           (define p3)
           (define p4)
           (newline op)
           (display "hello l\x0;ambda:\n\x3bb;!\n" op)
           (close-port op)
           (and (equal? (call-with-port
                          (open-file-input-port "testfile.ss"
                            (file-options)
                            (buffer-mode block)
                            (make-transcoder (utf-8-codec)
                              (eol-style crlf)
                              (error-handling-mode raise)))
                          (lambda (ip)
                            (set! p1 (port-position ip))
                            (let ([s (get-string-all ip)])
                              (set! p2 (port-position ip))
                              s)))
                        "\nhello l\x0;ambda:\n\x3bb;!\n")
                (equal? (call-with-port
                          (open-file-input-port "testfile.ss"
                            (file-options)
                            (buffer-mode block)
                            transcoder)
                          (lambda (ip)
                            (set! p3 (port-position ip))
                            (let ([s (get-string-all ip)])
                              (set! p4 (port-position ip))
                              s)))
                        "\nhello l\x0;ambda:\n\x3bb;!\n")
                (eq? p1 0)
                (eq? p2 23)
                (eq? p3 0)
                (eq? p4 23)))
         (let ()
           (define codec (iconv-codec "GB18030"))
           (define transcoder
             (make-transcoder codec
               (eol-style none)
               (error-handling-mode raise)))
           (define op
             (open-file-output-port "testfile.ss"
               (file-options replace)
               (buffer-mode line)
               transcoder))
           (newline op)
           (display "hello l\x0;ambda:\n\x3bb;!\n" op)
           (close-port op)
           (and (equal? (call-with-port
                          (open-file-input-port "testfile.ss")
                          get-bytevector-all)
                        #vu8(#x0a #x68 #x65 #x6c #x6c #x6f #x20 #x6c #x00
                             #x61 #x6d #x62 #x64 #x61 #x3a #x0a #xa6 #xcb
                             #x21 #x0a))
                (equal? (call-with-port
                          (open-file-input-port "testfile.ss"
                            (file-options)
                            (buffer-mode block)
                            transcoder)
                          get-string-all)
                        "\nhello l\x0;ambda:\n\x3bb;!\n")))
         (let ()
           (define codec (iconv-codec "CP1252"))
           (define transcoder
             (make-transcoder codec
               (eol-style none)
               (error-handling-mode replace)))
           (define op
             (open-file-output-port "testfile.ss"
               (file-options replace)
               (buffer-mode line)
               transcoder))
           (newline op)
           (display "hello l\x0;ambda:\n\x3bb;!\n" op)
           (close-port op)
           (and (equal? (call-with-port
                          (open-file-input-port "testfile.ss")
                          get-bytevector-all)
                        #vu8(#x0a #x68 #x65 #x6c #x6c #x6f #x20 #x6c #x00
                             #x61 #x6d #x62 #x64 #x61 #x3a #x0a #x3f #x21
                             #x0a))
                (equal? (call-with-port
                          (open-file-input-port "testfile.ss"
                            (file-options)
                            (buffer-mode block)
                            transcoder)
                          get-string-all)
                        "\nhello l\x0;ambda:\n?!\n")))
         (let ()
           ; same but eol-style lf
           (define codec (iconv-codec "CP1252"))
           (define transcoder
             (make-transcoder codec
               (eol-style lf)
               (error-handling-mode replace)))
           (define op
             (open-file-output-port "testfile.ss"
               (file-options replace)
               (buffer-mode line)
               transcoder))
           (newline op)
           (display "hello l\x0;ambda:\n\x3bb;!\n" op)
           (close-port op)
           (and (equal? (call-with-port
                          (open-file-input-port "testfile.ss")
                          get-bytevector-all)
                        #vu8(#x0a #x68 #x65 #x6c #x6c #x6f #x20 #x6c #x00
                             #x61 #x6d #x62 #x64 #x61 #x3a #x0a #x3f #x21
                             #x0a))
                (equal? (call-with-port
                          (open-file-input-port "testfile.ss"
                            (file-options)
                            (buffer-mode block)
                            transcoder)
                          get-string-all)
                        "\nhello l\x0;ambda:\n?!\n")))
         (let ()
           ; same but eol-style crlf
           (define codec (iconv-codec "CP1252"))
           (define transcoder
             (make-transcoder codec
               (eol-style crlf)
               (error-handling-mode replace)))
           (define op
             (open-file-output-port "testfile.ss"
               (file-options replace)
               (buffer-mode line)
               transcoder))
           (newline op)
           (display "hello l\x0;ambda:\n\x3bb;!\n" op)
           (close-port op)
           (and (equal? (call-with-port
                          (open-file-input-port "testfile.ss")
                          get-bytevector-all)
                        #vu8(#x0d #x0a #x68 #x65 #x6c #x6c #x6f #x20 #x6c
                             #x00 #x61 #x6d #x62 #x64 #x61 #x3a #x0d #x0a
                             #x3f #x21 #x0d #x0a))
                (equal? (call-with-port
                          (open-file-input-port "testfile.ss"
                            (file-options)
                            (buffer-mode block)
                            transcoder)
                          get-string-all)
                        "\nhello l\x0;ambda:\n?!\n")))
         (let ()
           (define codec (iconv-codec "CP1252"))
           (define transcoder
             (make-transcoder codec
               (eol-style none)
               (error-handling-mode ignore)))
           (define op
             (open-file-output-port "testfile.ss"
               (file-options replace)
               (buffer-mode line)
               transcoder))
           (newline op)
           (display "hello l\x0;ambda:\n\x3bb;!\n" op)
           (close-port op)
           (and (equal? (call-with-port
                          (open-file-input-port "testfile.ss")
                          get-bytevector-all)
                        #vu8(#x0a #x68 #x65 #x6c #x6c #x6f #x20 #x6c #x00
                             #x61 #x6d #x62 #x64 #x61 #x3a #x0a #x21 #x0a))
                (equal? (call-with-port
                          (open-file-input-port "testfile.ss"
                            (file-options)
                            (buffer-mode block)
                            transcoder)
                          get-string-all)
                        "\nhello l\x0;ambda:\n!\n")))
         (error? ; encoding error
           (let-values ([(bp get) (open-bytevector-output-port)])
             (define codec (iconv-codec "CP1252"))
             (define transcoder
               (make-transcoder codec
                 (eol-style none)
                 (error-handling-mode raise)))
             (define op (transcoded-port bp transcoder))
             (newline op)
             (display "hello l\x0;ambda: \x3bb;!\n" op)
             (close-port op)))
         (error? ; encoding error
           (let-values ([(bp get) (open-bytevector-output-port)])
             (define codec (iconv-codec "CP1252"))
             (define transcoder
               (make-transcoder codec
                 (eol-style ls)
                 (error-handling-mode raise)))
             (define op (transcoded-port bp transcoder))
             (newline op)
             (close-port op)))
         ; some (older?) versions of iconv don't handle unassigned code-page 1252
         ; characters properly.  c'est la vie.
         #;
         (let ()
           (define bp
             (open-bytevector-input-port
               #vu8(#x80 #x81 #x82 #x8c #x8d #x8e #x8f #x90 #x91 #x9c #x9d
                    #x9e)))
           (define codec (iconv-codec "CP1252"))
           (define transcoder
             (make-transcoder codec
               (eol-style none)
               (error-handling-mode replace)))
           (define ip (transcoded-port bp transcoder))
           (equal? (get-string-all ip)
                   "\x20ac;\xfffd;\x201a;\x0152;\xfffd;\x017d;\xfffd;\xfffd;\x2018;\x0153;\xfffd;\x017e;"))
         #;
         (let ()
           (define bp
             (open-bytevector-input-port
               #vu8(#x80 #x81 #x82 #x8c #x8d #x8e #x8f #x90 #x91 #x9c #x9d
                    #x9e)))
           (define codec (iconv-codec "CP1252"))
           (define transcoder
             (make-transcoder codec
               (eol-style none)
               (error-handling-mode ignore)))
           (define ip (transcoded-port bp transcoder))
           (equal? (get-string-all ip)
                   "\x20ac;\x201a;\x0152;\x017d;\x2018;\x0153;\x017e;"))
         #;
         (error? ; decoding error
           (let ()
             (define bp
               (open-bytevector-input-port
                 #vu8(#x80 #x81 #x82 #x8c #x8d #x8e #x8f #x90 #x91 #x9c #x9d
                      #x9e)))
             (define codec (iconv-codec "CP1252"))
             (define transcoder
               (make-transcoder codec
                 (eol-style none)
                 (error-handling-mode raise)))
             (define ip (transcoded-port bp transcoder))
             (equal? (get-string-all ip)
                     "\x20ac;\xfffd;\x201a;\x0152;\xfffd;\x017d;\xfffd;\xfffd;\x2018;\x0153;\xfffd;\x017e;")))
         (let ()
           ; SBCS CP1252
           (define cp1252
             '((#x00 #x0000)
               (#x01 #x0001)
               (#x02 #x0002)
               (#x03 #x0003)
               (#x04 #x0004)
               (#x05 #x0005)
               (#x06 #x0006)
               (#x07 #x0007)
               (#x08 #x0008)
               (#x09 #x0009)
               (#x0A #x000A)
               (#x0B #x000B)
               (#x0C #x000C)
               (#x0D #x000D)
               (#x0E #x000E)
               (#x0F #x000F)
               (#x10 #x0010)
               (#x11 #x0011)
               (#x12 #x0012)
               (#x13 #x0013)
               (#x14 #x0014)
               (#x15 #x0015)
               (#x16 #x0016)
               (#x17 #x0017)
               (#x18 #x0018)
               (#x19 #x0019)
               (#x1A #x001A)
               (#x1B #x001B)
               (#x1C #x001C)
               (#x1D #x001D)
               (#x1E #x001E)
               (#x1F #x001F)
               (#x20 #x0020)
               (#x21 #x0021)
               (#x22 #x0022)
               (#x23 #x0023)
               (#x24 #x0024)
               (#x25 #x0025)
               (#x26 #x0026)
               (#x27 #x0027)
               (#x28 #x0028)
               (#x29 #x0029)
               (#x2A #x002A)
               (#x2B #x002B)
               (#x2C #x002C)
               (#x2D #x002D)
               (#x2E #x002E)
               (#x2F #x002F)
               (#x30 #x0030)
               (#x31 #x0031)
               (#x32 #x0032)
               (#x33 #x0033)
               (#x34 #x0034)
               (#x35 #x0035)
               (#x36 #x0036)
               (#x37 #x0037)
               (#x38 #x0038)
               (#x39 #x0039)
               (#x3A #x003A)
               (#x3B #x003B)
               (#x3C #x003C)
               (#x3D #x003D)
               (#x3E #x003E)
               (#x3F #x003F)
               (#x40 #x0040)
               (#x41 #x0041)
               (#x42 #x0042)
               (#x43 #x0043)
               (#x44 #x0044)
               (#x45 #x0045)
               (#x46 #x0046)
               (#x47 #x0047)
               (#x48 #x0048)
               (#x49 #x0049)
               (#x4A #x004A)
               (#x4B #x004B)
               (#x4C #x004C)
               (#x4D #x004D)
               (#x4E #x004E)
               (#x4F #x004F)
               (#x50 #x0050)
               (#x51 #x0051)
               (#x52 #x0052)
               (#x53 #x0053)
               (#x54 #x0054)
               (#x55 #x0055)
               (#x56 #x0056)
               (#x57 #x0057)
               (#x58 #x0058)
               (#x59 #x0059)
               (#x5A #x005A)
               (#x5B #x005B)
               (#x5C #x005C)
               (#x5D #x005D)
               (#x5E #x005E)
               (#x5F #x005F)
               (#x60 #x0060)
               (#x61 #x0061)
               (#x62 #x0062)
               (#x63 #x0063)
               (#x64 #x0064)
               (#x65 #x0065)
               (#x66 #x0066)
               (#x67 #x0067)
               (#x68 #x0068)
               (#x69 #x0069)
               (#x6A #x006A)
               (#x6B #x006B)
               (#x6C #x006C)
               (#x6D #x006D)
               (#x6E #x006E)
               (#x6F #x006F)
               (#x70 #x0070)
               (#x71 #x0071)
               (#x72 #x0072)
               (#x73 #x0073)
               (#x74 #x0074)
               (#x75 #x0075)
               (#x76 #x0076)
               (#x77 #x0077)
               (#x78 #x0078)
               (#x79 #x0079)
               (#x7A #x007A)
               (#x7B #x007B)
               (#x7C #x007C)
               (#x7D #x007D)
               (#x7E #x007E)
               (#x7F #x007F)
               (#x80 #x20AC)
               (#x82 #x201A)
               (#x83 #x0192)
               (#x84 #x201E)
               (#x85 #x2026)
               (#x86 #x2020)
               (#x87 #x2021)
               (#x88 #x02C6)
               (#x89 #x2030)
               (#x8A #x0160)
               (#x8B #x2039)
               (#x8C #x0152)
               (#x8E #x017D)
               (#x91 #x2018)
               (#x92 #x2019)
               (#x93 #x201C)
               (#x94 #x201D)
               (#x95 #x2022)
               (#x96 #x2013)
               (#x97 #x2014)
               (#x98 #x02DC)
               (#x99 #x2122)
               (#x9A #x0161)
               (#x9B #x203A)
               (#x9C #x0153)
               (#x9E #x017E)
               (#x9F #x0178)
               (#xA0 #x00A0)
               (#xA1 #x00A1)
               (#xA2 #x00A2)
               (#xA3 #x00A3)
               (#xA4 #x00A4)
               (#xA5 #x00A5)
               (#xA6 #x00A6)
               (#xA7 #x00A7)
               (#xA8 #x00A8)
               (#xA9 #x00A9)
               (#xAA #x00AA)
               (#xAB #x00AB)
               (#xAC #x00AC)
               (#xAD #x00AD)
               (#xAE #x00AE)
               (#xAF #x00AF)
               (#xB0 #x00B0)
               (#xB1 #x00B1)
               (#xB2 #x00B2)
               (#xB3 #x00B3)
               (#xB4 #x00B4)
               (#xB5 #x00B5)
               (#xB6 #x00B6)
               (#xB7 #x00B7)
               (#xB8 #x00B8)
               (#xB9 #x00B9)
               (#xBA #x00BA)
               (#xBB #x00BB)
               (#xBC #x00BC)
               (#xBD #x00BD)
               (#xBE #x00BE)
               (#xBF #x00BF)
               (#xC0 #x00C0)
               (#xC1 #x00C1)
               (#xC2 #x00C2)
               (#xC3 #x00C3)
               (#xC4 #x00C4)
               (#xC5 #x00C5)
               (#xC6 #x00C6)
               (#xC7 #x00C7)
               (#xC8 #x00C8)
               (#xC9 #x00C9)
               (#xCA #x00CA)
               (#xCB #x00CB)
               (#xCC #x00CC)
               (#xCD #x00CD)
               (#xCE #x00CE)
               (#xCF #x00CF)
               (#xD0 #x00D0)
               (#xD1 #x00D1)
               (#xD2 #x00D2)
               (#xD3 #x00D3)
               (#xD4 #x00D4)
               (#xD5 #x00D5)
               (#xD6 #x00D6)
               (#xD7 #x00D7)
               (#xD8 #x00D8)
               (#xD9 #x00D9)
               (#xDA #x00DA)
               (#xDB #x00DB)
               (#xDC #x00DC)
               (#xDD #x00DD)
               (#xDE #x00DE)
               (#xDF #x00DF)
               (#xE0 #x00E0)
               (#xE1 #x00E1)
               (#xE2 #x00E2)
               (#xE3 #x00E3)
               (#xE4 #x00E4)
               (#xE5 #x00E5)
               (#xE6 #x00E6)
               (#xE7 #x00E7)
               (#xE8 #x00E8)
               (#xE9 #x00E9)
               (#xEA #x00EA)
               (#xEB #x00EB)
               (#xEC #x00EC)
               (#xED #x00ED)
               (#xEE #x00EE)
               (#xEF #x00EF)
               (#xF0 #x00F0)
               (#xF1 #x00F1)
               (#xF2 #x00F2)
               (#xF3 #x00F3)
               (#xF4 #x00F4)
               (#xF5 #x00F5)
               (#xF6 #x00F6)
               (#xF7 #x00F7)
               (#xF8 #x00F8)
               (#xF9 #x00F9)
               (#xFA #x00FA)
               (#xFB #x00FB)
               (#xFC #x00FC)
               (#xFD #x00FD)
               (#xFE #x00FE)
               (#xFF #x00FF)))
           (define transcoder
             (make-transcoder (iconv-codec "CP1252")
               (eol-style none)
               (error-handling-mode raise)))
           (define ls
             (append cp1252
               (let ([v (list->vector cp1252)])
                 (let f ([n 100000])
                   (if (fx= n 0)
                       '()
                       (cons (vector-ref v (random (vector-length v)))
                             (f (fx- n 1))))))))
           (define s
             (apply string (map integer->char (map cadr ls))))
           (define op
             (open-file-output-port "testfile.ss"
               (file-options replace)
               (buffer-mode block)
               transcoder))
           #;
           (put-string op s)
           (let loop ([i 0] [n (string-length s)])
             (unless (fx= n 0)
                     (let ([k (fx+ (random n) 1)])
                       (put-string op s i k)
                       (loop (fx+ i k) (fx- n k)))))
           (close-port op)
           (and (equal? (call-with-port
                          (open-file-input-port "testfile.ss")
                          get-bytevector-all)
                        (apply bytevector (map car ls)))
                (equal? (call-with-port
                          (open-file-input-port "testfile.ss"
                            (file-options)
                            (buffer-mode block)
                            transcoder)
                          #;
                          get-string-all
                          (lambda (ip)
                            (let ([t (make-string (string-length s))])
                              (let loop ([i 0] [n (string-length s)])
                                (unless (fx= n 0)
                                        (let ([k (fx+ (random n) 1)])
                                          (get-string-n! ip t i k)
                                          (loop (fx+ i k) (fx- n k)))))
                              t)))
                        s)))
         (let ()
           ; MBCS UTF-8
           (define transcoder
             (make-transcoder (iconv-codec "UTF-8")
               (eol-style none)
               (error-handling-mode raise)))
           (define ls1
             (let f ([i 0])
               (if (fx= i #x11000)
                   '()
                   (if (fx= i #xD800)
                       (f #xE000)
                       (cons i (f (fx+ i 1)))))))
           (define ls2
             (let f ([n 1000000])
               (if (fx= n 0)
                   '()
                   (cons (let ([n (random (- #x110000 (- #xE000 #xD800)))])
                           (if (<= #xD800 n #xDFFF)
                               (+ n (- #xE000 #xD800))
                               n))
                         (f (fx- n 1))))))
           (define s
             (apply string (map integer->char (append ls1 ls2))))
           #;
           (define s (apply string (map integer->char ls1)))
           #;
           (define s "hello\x1447A;")
           (define op
             (open-file-output-port "testfile.ss"
               (file-options replace)
               (buffer-mode block)
               transcoder))
           #;
           (put-string op s)
           (let loop ([i 0] [n (string-length s)])
             (unless (fx= n 0)
                     (let ([k (fx+ (random n) 1)])
                       (put-string op s i k)
                       (loop (fx+ i k) (fx- n k)))))
           (close-port op)
           (and (equal? (call-with-port
                          (open-file-input-port "testfile.ss"
                            (file-options)
                            (buffer-mode block)
                            (make-transcoder (utf-8-codec)
                              (eol-style none)
                              (error-handling-mode raise)))
                          get-string-all)
                        s)
                (equal? (call-with-port
                          (open-file-input-port "testfile.ss"
                            (file-options)
                            (buffer-mode block)
                            transcoder)
                          #;
                          get-string-all
                          (lambda (ip)
                            (let ([t (make-string (string-length s))])
                              (let loop ([i 0] [n (string-length s)])
                                (unless (fx= n 0)
                                        (let ([k (fx+ (random n) 1)])
                                          (get-string-n! ip t i k)
                                          (loop (fx+ i k) (fx- n k)))))
                              t)))
                        s)))
         (error? ; encoding error
           (let ()
             (define transcoder
               (make-transcoder (latin-1-codec)
                 (eol-style ls)
                 (error-handling-mode raise)))
             (define-values (bp get) (open-bytevector-output-port))
             (define op (transcoded-port bp transcoder))
             (newline op)
             (close-port op)))
         ; NB: keep this last among the iconv-codec mats
         ; close any files left open by failing iconv tests.  this is particulary
         ; important on windows when the iconv dll isn't available and where keeping
         ; file open can prevent it from being reopened.
         (begin (collect (collect-maximum-generation)) #t)))

(mat port-operations4
     (begin
       (define po4-tx
         (make-transcoder (latin-1-codec)
           (eol-style none)
           (error-handling-mode raise)))
       #t)
     (transcoder? po4-tx)
     (not (transcoder? (latin-1-codec)))
     (eq? (call-with-port
            (open-file-output-port "testfile.ss"
              (file-options replace)
              (buffer-mode block)
              po4-tx)
            (lambda (op) (put-string op "hi there")))
          (void))
     ; binary input port
     (begin
       (define po4-p (open-file-input-port "testfile.ss"))
       #t)
     (and (input-port? po4-p)
          (binary-port? po4-p)
          (file-port? po4-p))
     (error? (put-string po4-p "hello"))
     (error? (put-bytevector po4-p #vu8(100)))
     (error? (get-string-all po4-p))
     (error? (get-char po4-p))
     (error? (lookahead-char po4-p))
     (fixnum? (port-file-descriptor po4-p))
     (port-has-port-position? po4-p)
     (eqv? (port-position po4-p) 0)
     (port-has-set-port-position!? po4-p)
     (eq? (set-port-position! po4-p 3) (void))
     (eqv? (port-position po4-p) 3)
     (equal? (get-bytevector-n po4-p 5)
             (string->bytevector "there" po4-tx))
     (eof-object? (get-bytevector-n po4-p 1))
     (port-has-port-length? po4-p)
     (eqv? (port-length po4-p) 8)
     (not (port-has-set-port-length!? po4-p))
     (error? (set-port-length! po4-p 7))
     (eq? (close-port po4-p) (void))
     ; textual input port
     (begin
       (define po4-p
         (open-file-input-port "testfile.ss"
           (file-options)
           (buffer-mode block)
           po4-tx))
       #t)
     (and (input-port? po4-p)
          (textual-port? po4-p)
          (file-port? po4-p))
     (error? (put-string po4-p "hello"))
     (error? (put-bytevector po4-p #vu8(100)))
     (error? (get-bytevector-all po4-p))
     (error? (get-u8 po4-p))
     (error? (lookahead-u8 po4-p))
     (fixnum? (port-file-descriptor po4-p))
     (port-has-port-position? po4-p)
     (eqv? (port-position po4-p) 0)
     (port-has-set-port-position!? po4-p)
     (eqv? (set-port-position! po4-p 3) (void))
     (eqv? (port-position po4-p) 3)
     (equal? (get-string-n po4-p 5) "there")
     (eof-object? (get-string-n po4-p 1))
     (port-has-port-length? po4-p)
     (eqv? (port-length po4-p) 8)
     (not (port-has-set-port-length!? po4-p))
     (error? (set-port-length! po4-p 7))
     (eq? (close-port po4-p) (void))
     ; binary output port
     (begin
       (define po4-p
         (open-file-output-port "testfile.ss" (file-options replace)))
       #t)
     (and (output-port? po4-p)
          (binary-port? po4-p)
          (file-port? po4-p))
     (error? (get-string-all po4-p))
     (error? (get-char po4-p))
     (error? (lookahead-char po4-p))
     (error? (get-bytevector-all po4-p))
     (error? (get-u8 po4-p))
     (error? (lookahead-u8 po4-p))
     (error? (put-string po4-p "hello"))
     (fixnum? (port-file-descriptor po4-p))
     (port-has-port-position? po4-p)
     (eqv? (port-position po4-p) 0)
     (port-has-set-port-position!? po4-p)
     (eq? (set-port-position! po4-p 3) (void))
     (eqv? (port-position po4-p) 3)
     (eq? (put-bytevector po4-p (string->bytevector "123456" po4-tx))
          (void))
     (port-has-port-length? po4-p)
     (eqv? (port-length po4-p) 9)
     (port-has-set-port-length!? po4-p)
     (eq? (set-port-length! po4-p 7) (void))
     (eq? (set-port-position! po4-p 0) (void))
     (eq? (put-bytevector po4-p (string->bytevector "abcd" po4-tx)) (void))
     (eq? (close-port po4-p) (void))
     (equal? (call-with-port
               (open-file-input-port "testfile.ss"
                 (file-options)
                 (buffer-mode block)
                 po4-tx)
               get-string-all)
             "abcd234")
     ; textual output port
     (begin
       (define po4-p
         (open-file-output-port "testfile.ss"
           (file-options replace)
           (buffer-mode block)
           po4-tx))
       #t)
     (and (output-port? po4-p)
          (textual-port? po4-p)
          (file-port? po4-p))
     (error? (get-string-all po4-p))
     (error? (get-char po4-p))
     (error? (lookahead-char po4-p))
     (error? (get-bytevector-all po4-p))
     (error? (get-u8 po4-p))
     (error? (lookahead-u8 po4-p))
     (error? (put-bytevector po4-p #vu8()))
     (fixnum? (port-file-descriptor po4-p))
     (port-has-port-position? po4-p)
     (eqv? (port-position po4-p) 0)
     (port-has-set-port-position!? po4-p)
     (eq? (set-port-position! po4-p 3) (void))
     (eqv? (port-position po4-p) 3)
     (eq? (put-string po4-p "abcdef") (void))
     (port-has-port-length? po4-p)
     (eqv? (port-length po4-p) 9)
     (port-has-set-port-length!? po4-p)
     (eq? (set-port-length! po4-p 7) (void))
     (eq? (set-port-position! po4-p 0) (void))
     (eq? (put-string po4-p "1234") (void))
     (eq? (close-port po4-p) (void))
     (equal? (call-with-port
               (open-file-input-port "testfile.ss"
                 (file-options)
                 (buffer-mode block)
                 po4-tx)
               get-string-all)
             "1234bcd")
     ; binary input/output port
     (begin
       (define po4-p
         (open-file-input/output-port "testfile.ss" (file-options replace)))
       #t)
     (and (output-port? po4-p)
          (binary-port? po4-p)
          (file-port? po4-p))
     (and (input-port? po4-p)
          (binary-port? po4-p)
          (file-port? po4-p))
     (fixnum? (port-file-descriptor po4-p))
     (port-has-port-position? po4-p)
     (eqv? (port-position po4-p) 0)
     (port-has-set-port-position!? po4-p)
     (eq? (set-port-position! po4-p 3) (void))
     (eqv? (port-position po4-p) 3)
     (eq? (put-bytevector po4-p (string->bytevector "foobar" po4-tx))
          (void))
     (port-has-port-length? po4-p)
     (eqv? (port-length po4-p) 9)
     (port-has-set-port-length!? po4-p)
     (eq? (set-port-length! po4-p 7) (void))
     (eq? (set-port-position! po4-p 0) (void))
     (eq? (put-bytevector po4-p (string->bytevector "4321" po4-tx)) (void))
     (equal? (get-bytevector-all po4-p) (string->bytevector "oob" po4-tx))
     (eq? (set-port-position! po4-p 0) (void))
     (equal? (get-bytevector-all po4-p)
             (string->bytevector "4321oob" po4-tx))
     (eq? (close-port po4-p) (void))
     (equal? (call-with-port
               (open-file-input-port "testfile.ss"
                 (file-options)
                 (buffer-mode block)
                 po4-tx)
               get-string-all)
             "4321oob")
     ; textual input/output port
     (begin
       (define po4-p
         (open-file-input/output-port "testfile.ss"
           (file-options replace)
           (buffer-mode block)
           po4-tx))
       #t)
     (and (output-port? po4-p)
          (textual-port? po4-p)
          (file-port? po4-p))
     (and (input-port? po4-p)
          (textual-port? po4-p)
          (file-port? po4-p))
     (fixnum? (port-file-descriptor po4-p))
     (port-has-port-position? po4-p)
     (eqv? (port-position po4-p) 0)
     (port-has-set-port-position!? po4-p)
     (eq? (set-port-position! po4-p 3) (void))
     (eqv? (port-position po4-p) 3)
     (eq? (put-string po4-p "abcdef") (void))
     (port-has-port-length? po4-p)
     (eqv? (port-length po4-p) 9)
     (port-has-set-port-length!? po4-p)
     (eq? (set-port-length! po4-p 7) (void))
     (eq? (set-port-position! po4-p 0) (void))
     (eq? (put-string po4-p "1234") (void))
     (equal? (get-string-all po4-p) "bcd")
     (eq? (set-port-position! po4-p 0) (void))
     (equal? (get-string-all po4-p) "1234bcd")
     (eq? (close-port po4-p) (void))
     (equal? (call-with-port
               (open-file-input-port "testfile.ss"
                 (file-options)
                 (buffer-mode block)
                 po4-tx)
               get-string-all)
             "1234bcd"))

(mat get-line
     (error? ; not a port
             (get-line "current-input-port"))
     (error? ; not a port
             (get-line 3))
     (error? ; not a textual input port
             (get-line (open-bytevector-input-port #vu8(1 2 3 4 5))))
     (begin
       (with-output-to-file "testfile.ss"
         (lambda ()
           (display "hello from line 1!\n")
           (display (make-string 1017 #\a))
           (display " hello from line 2!\n")
           (display "goodbye from (incomplete) line 3!"))
         'replace)
       (define $tip (open-input-file "testfile.ss"))
       #t)
     (equal? (get-line $tip) "hello from line 1!")
     (equal? (get-line $tip)
       (format "~a hello from line 2!" (make-string 1017 #\a)))
     (equal? (get-line $tip) "goodbye from (incomplete) line 3!")
     (eof-object? (get-line $tip))
     (eqv? (close-port $tip) (void))
     (begin
       (with-output-to-file "testfile.ss"
         (lambda ()
           (display "hello from line 1!\n")
           (display "\n")
           (display "goodbye from (complete) line 3!\n"))
         'replace)
       (define $tip (open-input-file "testfile.ss"))
       #t)
     (equal? (get-line $tip) "hello from line 1!")
     (equal? (get-line $tip) "")
     (equal? (get-line $tip) "goodbye from (complete) line 3!")
     (eof-object? (get-line $tip))
     (eqv? (close-port $tip) (void)))

(mat low-level-port-operations
     (<= (textual-port-input-index (console-input-port))
         (textual-port-input-size (console-input-port))
         (string-length (textual-port-input-buffer (console-input-port))))
     (<= (textual-port-input-count (console-input-port))
         (string-length (textual-port-input-buffer (console-input-port))))
     (<= (textual-port-output-index (console-output-port))
         (textual-port-output-size (console-output-port))
         (string-length (textual-port-output-buffer (console-output-port))))
     (<= (textual-port-output-count (console-output-port))
         (string-length (textual-port-output-buffer (console-output-port))))
     (begin
       (define $tip (open-string-input-port "hello"))
       (define $top
         (let-values ([(op get) (open-string-output-port)])
           (set-textual-port-output-buffer! op "hello")
           op))
       (define $bip
         (open-bytevector-input-port #vu8(1 2 3 4 5)))
       (define $bop
         (let-values ([(op get) (open-bytevector-output-port)])
           (set-binary-port-output-buffer! op #vu8(1 2 3 4 5))
           op))
       #t)
     ; textual input
     (andmap (lambda (str)
               (equal? (let ([ip (open-string-input-port str)])
                         (let ([buffer0 (textual-port-input-buffer ip)]
                               [index0 (textual-port-input-index ip)]
                               [size0 (textual-port-input-size ip)]
                               [count0 (textual-port-input-count ip)])
                           (read-char ip)
                           (list (list buffer0 index0 size0 count0)
                                 (list (textual-port-input-buffer ip)
                                       (textual-port-input-index ip)
                                       (textual-port-input-size ip)
                                       (textual-port-input-count ip)))))
                       '(("hello" 0 5 5) ("hello" 1 5 4))))
             (list "hello" (string->immutable-string "hello")))
     (equal? (let ([ip (open-string-input-port "hello")])
               (let ([buffer0 (textual-port-input-buffer ip)]
                     [index0 (textual-port-input-index ip)]
                     [size0 (textual-port-input-size ip)]
                     [count0 (textual-port-input-count ip)])
                 (read-char ip)
                 (set-textual-port-input-buffer! ip "goodbye")
                 (read-char ip)
                 (list (list buffer0 index0 size0 count0)
                       (list (textual-port-input-buffer ip)
                             (textual-port-input-index ip)
                             (textual-port-input-size ip)
                             (textual-port-input-count ip)))))
             '(("hello" 0 5 5) ("goodbye" 1 7 6)))
     (equal? (let ([ip (open-string-input-port "hello")])
               (let ([buffer0 (textual-port-input-buffer ip)]
                     [index0 (textual-port-input-index ip)]
                     [size0 (textual-port-input-size ip)]
                     [count0 (textual-port-input-count ip)])
                 (read-char ip)
                 (set-textual-port-input-size! ip 4)
                 (read-char ip)
                 (list (list buffer0 index0 size0 count0)
                       (list (textual-port-input-buffer ip)
                             (textual-port-input-index ip)
                             (textual-port-input-size ip)
                             (textual-port-input-count ip)))))
             '(("hello" 0 5 5) ("hello" 1 4 3)))
     (equal? (let ([ip (open-string-input-port "hello")])
               (let ([buffer0 (textual-port-input-buffer ip)]
                     [index0 (textual-port-input-index ip)]
                     [size0 (textual-port-input-size ip)]
                     [count0 (textual-port-input-count ip)])
                 (read-char ip)
                 (set-textual-port-input-index! ip 4)
                 (read-char ip)
                 (list (list buffer0 index0 size0 count0)
                       (list (textual-port-input-buffer ip)
                             (textual-port-input-index ip)
                             (textual-port-input-size ip)
                             (textual-port-input-count ip)))))
             '(("hello" 0 5 5) ("hello" 5 5 0)))
     (error? ; not a textual input port
             (textual-port-input-buffer $top))
     (error? ; not a textual input port
             (textual-port-input-buffer $bip))
     (error? ; not a textual input port
             (textual-port-input-buffer $bop))
     (error? ; not a textual input port
             (textual-port-input-buffer 75))
     (error? ; not a textual input port
             (textual-port-input-index $top))
     (error? ; not a textual input port
             (textual-port-input-index $bip))
     (error? ; not a textual input port
             (textual-port-input-index $bop))
     (error? ; not a textual input port
             (textual-port-input-index 75))
     (error? ; not a textual input port
             (textual-port-input-size $top))
     (error? ; not a textual input port
             (textual-port-input-size $bip))
     (error? ; not a textual input port
             (textual-port-input-size $bop))
     (error? ; not a textual input port
             (textual-port-input-size 75))
     (error? ; not a textual input port
             (textual-port-input-count $top))
     (error? ; not a textual input port
             (textual-port-input-count $bip))
     (error? ; not a textual input port
             (textual-port-input-count $bop))
     (error? ; not a textual input port
             (textual-port-input-count 75))
     (error? ; not a textual input port
             (set-textual-port-input-buffer! $top ""))
     (error? ; not a textual input port
             (set-textual-port-input-buffer! $bip ""))
     (error? ; not a textual input port
             (set-textual-port-input-buffer! $bop ""))
     (error? ; not a textual input port
             (set-textual-port-input-buffer! 75 ""))
     (error? ; not a textual input port
             (set-textual-port-input-index! $top 0))
     (error? ; not a textual input port
             (set-textual-port-input-index! $bip 0))
     (error? ; not a textual input port
             (set-textual-port-input-index! $bop 0))
     (error? ; not a textual input port
             (set-textual-port-input-index! 75 0))
     (error? ; not a textual input port
             (set-textual-port-input-size! $top 0))
     (error? ; not a textual input port
             (set-textual-port-input-size! $bip 0))
     (error? ; not a textual input port
             (set-textual-port-input-size! $bop 0))
     (error? ; not a textual input port
             (set-textual-port-input-size! 75 0))
     (error? ; not a string
       (set-textual-port-input-buffer! $tip #vu8(1 2 3)))
     (error? ; not a string
       (set-textual-port-input-buffer! $tip 0))
     (error? ; invalid index
       (set-textual-port-input-index! $tip "hello"))
     (error? ; invalid index
       (set-textual-port-input-index! $tip -1))
     (error? ; invalid index
             (set-textual-port-input-index! $tip 6))
     (error? ; invalid size
       (set-textual-port-input-size! $tip "hello"))
     (error? ; invalid size
       (set-textual-port-input-size! $tip -1))
     (error? ; invalid size
       (set-textual-port-input-size! $tip 6))
     ; textual output
     (equal? (let ([op (make-output-port (lambda args (error #f "oops"))
                         (make-string 10 #\$))])
               (let ([buffer0 (string-copy (textual-port-output-buffer op))]
                     [index0 (textual-port-output-index op)]
                     [size0 (textual-port-output-size op)]
                     [count0 (textual-port-output-count op)])
                 (display "hey!" op)
                 (list (list buffer0 index0 size0 count0)
                       (list (textual-port-output-buffer op)
                             (textual-port-output-index op)
                             (textual-port-output-size op)
                             (textual-port-output-count op)))))
             '(("$$$$$$$$$$" 0 10 10) ("hey!$$$$$$" 4 10 6)))
     (equal? (let-values ([(op get) (open-string-output-port)])
               (let ([buffer (make-string 8 #\$)])
                 (set-textual-port-output-buffer! op buffer)
                 (let ([buffer0 (string-copy (textual-port-output-buffer op))]
                       [index0 (textual-port-output-index op)]
                       [size0 (textual-port-output-size op)]
                       [count0 (textual-port-output-count op)])
                   (display "yo!" op)
                   (list buffer
                         (list buffer0 index0 size0 count0)
                         (list (textual-port-output-buffer op)
                               (textual-port-output-index op)
                               (textual-port-output-size op)
                               (textual-port-output-count op))))))
             '("yo!$$$$$" ("$$$$$$$$" 0 8 8) ("yo!$$$$$" 3 8 5)))
     (equal? (let-values ([(op get) (open-string-output-port)])
               (let ([buffer (make-string 8 #\$)])
                 (set-textual-port-output-buffer! op buffer)
                 (let ([buffer0 (string-copy (textual-port-output-buffer op))]
                       [index0 (textual-port-output-index op)]
                       [size0 (textual-port-output-size op)]
                       [count0 (textual-port-output-count op)])
                   (display "yo" op)
                   (set-textual-port-output-buffer! op
                     (string #\a #\b #\c))
                   (display "!?" op)
                   (list buffer
                         (list buffer0 index0 size0 count0)
                         (list (textual-port-output-buffer op)
                               (textual-port-output-index op)
                               (textual-port-output-size op)
                               (textual-port-output-count op))))))
             '("yo$$$$$$" ("$$$$$$$$" 0 8 8) ("!?c" 2 3 1)))
     (equal? (let-values ([(op get) (open-string-output-port)])
               (let ([buffer (make-string 8 #\$)])
                 (set-textual-port-output-buffer! op buffer)
                 (let ([buffer0 (string-copy (textual-port-output-buffer op))]
                       [index0 (textual-port-output-index op)]
                       [size0 (textual-port-output-size op)]
                       [count0 (textual-port-output-count op)])
                   (display "yo" op)
                   (set-textual-port-output-index! op 4)
                   (display "!?" op)
                   (list buffer
                         (list buffer0 index0 size0 count0)
                         (list (textual-port-output-buffer op)
                               (textual-port-output-index op)
                               (textual-port-output-size op)
                               (textual-port-output-count op))))))
             '("yo$$!?$$" ("$$$$$$$$" 0 8 8) ("yo$$!?$$" 6 8 2)))
     (equal? (let-values ([(op get) (open-string-output-port)])
               (let ([buffer (make-string 8 #\$)])
                 (set-textual-port-output-buffer! op buffer)
                 (let ([buffer0 (string-copy (textual-port-output-buffer op))]
                       [index0 (textual-port-output-index op)]
                       [size0 (textual-port-output-size op)]
                       [count0 (textual-port-output-count op)])
                   (display "yo" op)
                   (set-textual-port-output-size! op 4)
                   (display "!?" op)
                   (list buffer
                         (list buffer0 index0 size0 count0)
                         (list (textual-port-output-buffer op)
                               (textual-port-output-index op)
                               (textual-port-output-size op)
                               (textual-port-output-count op))))))
             '("!?$$$$$$" ("$$$$$$$$" 0 8 8) ("!?$$$$$$" 2 4 2)))
     (error? ; not a textual output port
             (textual-port-output-buffer $tip))
     (error? ; not a textual output port
             (textual-port-output-buffer $bip))
     (error? ; not a textual output port
             (textual-port-output-buffer $bop))
     (error? ; not a textual output port
             (textual-port-output-buffer 75))
     (error? ; not a textual output port
             (textual-port-output-index $tip))
     (error? ; not a textual output port
             (textual-port-output-index $bip))
     (error? ; not a textual output port
             (textual-port-output-index $bop))
     (error? ; not a textual output port
             (textual-port-output-index 75))
     (error? ; not a textual output port
             (textual-port-output-size $tip))
     (error? ; not a textual output port
             (textual-port-output-size $bip))
     (error? ; not a textual output port
             (textual-port-output-size $bop))
     (error? ; not a textual output port
             (textual-port-output-size 75))
     (error? ; not a textual output port
             (textual-port-output-count $tip))
     (error? ; not a textual output port
             (textual-port-output-count $bip))
     (error? ; not a textual output port
             (textual-port-output-count $bop))
     (error? ; not a textual output port
             (textual-port-output-count 75))
     (error? ; not a textual output port
             (set-textual-port-output-buffer! $tip ""))
     (error? ; not a textual output port
             (set-textual-port-output-buffer! $bip ""))
     (error? ; not a textual output port
             (set-textual-port-output-buffer! $bop ""))
     (error? ; not a textual output port
             (set-textual-port-output-buffer! 75 ""))
     (error? ; not a textual output port
             (set-textual-port-output-index! $tip 0))
     (error? ; not a textual output port
             (set-textual-port-output-index! $bip 0))
     (error? ; not a textual output port
             (set-textual-port-output-index! $bop 0))
     (error? ; not a textual output port
             (set-textual-port-output-index! 75 0))
     (error? ; not a textual output port
             (set-textual-port-output-size! $tip 0))
     (error? ; not a textual output port
             (set-textual-port-output-size! $bip 0))
     (error? ; not a textual output port
             (set-textual-port-output-size! $bop 0))
     (error? ; not a textual output port
             (set-textual-port-output-size! 75 0))
     (error? ; not a string
       (set-textual-port-output-buffer! $top #vu8(1 2 3)))
     (error? ; not a string
       (set-textual-port-output-buffer! $top 0))
     (error? ; invalid index
       (set-textual-port-output-index! $top "hello"))
     (error? ; invalid index
       (set-textual-port-output-index! $top -1))
     (error? ; invalid index
       (set-textual-port-output-index! $top 6))
     (error? ; invalid size
       (set-textual-port-output-size! $top "hello"))
     (error? ; invalid size
       (set-textual-port-output-size! $top -1))
     (error? ; invalid size
       (set-textual-port-output-size! $top 6))
     ; binary input
     (equal? (let ([ip (open-bytevector-input-port (string->utf8 "hello"))])
               (let ([buffer0 (binary-port-input-buffer ip)]
                     [index0 (binary-port-input-index ip)]
                     [size0 (binary-port-input-size ip)]
                     [count0 (binary-port-input-count ip)])
                 (get-u8 ip)
                 (list (list buffer0 index0 size0 count0)
                       (list (binary-port-input-buffer ip)
                             (binary-port-input-index ip)
                             (binary-port-input-size ip)
                             (binary-port-input-count ip)))))
             `((,(string->utf8 "hello") 0 5 5)
               (,(string->utf8 "hello") 1 5 4)))
     (equal? (let ([ip (open-bytevector-input-port (string->utf8 "hello"))])
               (let ([buffer0 (binary-port-input-buffer ip)]
                     [index0 (binary-port-input-index ip)]
                     [size0 (binary-port-input-size ip)]
                     [count0 (binary-port-input-count ip)])
                 (get-u8 ip)
                 (set-binary-port-input-buffer! ip
                   (string->utf8 "goodbye"))
                 (get-u8 ip)
                 (list (list buffer0 index0 size0 count0)
                       (list (binary-port-input-buffer ip)
                             (binary-port-input-index ip)
                             (binary-port-input-size ip)
                             (binary-port-input-count ip)))))
             `((,(string->utf8 "hello") 0 5 5)
               (,(string->utf8 "goodbye") 1 7 6)))
     (equal? (let ([ip (open-bytevector-input-port (string->utf8 "hello"))])
               (let ([buffer0 (binary-port-input-buffer ip)]
                     [index0 (binary-port-input-index ip)]
                     [size0 (binary-port-input-size ip)]
                     [count0 (binary-port-input-count ip)])
                 (get-u8 ip)
                 (set-binary-port-input-size! ip 3)
                 (get-u8 ip)
                 (list (list buffer0 index0 size0 count0)
                       (list (binary-port-input-buffer ip)
                             (binary-port-input-index ip)
                             (binary-port-input-size ip)
                             (binary-port-input-count ip)))))
             `((,(string->utf8 "hello") 0 5 5)
               (,(string->utf8 "hello") 1 3 2)))
     (equal? (let ([ip (open-bytevector-input-port (string->utf8 "hello"))])
               (let ([buffer0 (binary-port-input-buffer ip)]
                     [index0 (binary-port-input-index ip)]
                     [size0 (binary-port-input-size ip)]
                     [count0 (binary-port-input-count ip)])
                 (get-u8 ip)
                 (set-binary-port-input-index! ip 3)
                 (get-u8 ip)
                 (list (list buffer0 index0 size0 count0)
                       (list (binary-port-input-buffer ip)
                             (binary-port-input-index ip)
                             (binary-port-input-size ip)
                             (binary-port-input-count ip)))))
             `((,(string->utf8 "hello") 0 5 5)
               (,(string->utf8 "hello") 4 5 1)))
     (error? ; not a binary input port
             (binary-port-input-buffer $tip))
     (error? ; not a binary input port
             (binary-port-input-buffer $top))
     (error? ; not a binary input port
             (binary-port-input-buffer $bop))
     (error? ; not a binary input port
             (binary-port-input-buffer 75))
     (error? ; not a binary input port
             (binary-port-input-index $tip))
     (error? ; not a binary input port
             (binary-port-input-index $top))
     (error? ; not a binary input port
             (binary-port-input-index $bop))
     (error? ; not a binary input port
             (binary-port-input-index 75))
     (error? ; not a binary input port
             (binary-port-input-size $tip))
     (error? ; not a binary input port
             (binary-port-input-size $top))
     (error? ; not a binary input port
             (binary-port-input-size $bop))
     (error? ; not a binary input port
             (binary-port-input-size 75))
     (error? ; not a binary input port
             (binary-port-input-count $tip))
     (error? ; not a binary input port
             (binary-port-input-count $top))
     (error? ; not a binary input port
             (binary-port-input-count $bop))
     (error? ; not a binary input port
             (binary-port-input-count 75))
     (error? ; not a binary input port
             (set-binary-port-input-buffer! $tip ""))
     (error? ; not a binary input port
             (set-binary-port-input-buffer! $top ""))
     (error? ; not a binary input port
             (set-binary-port-input-buffer! $bop ""))
     (error? ; not a binary input port
             (set-binary-port-input-buffer! 75 ""))
     (error? ; not a binary input port
             (set-binary-port-input-index! $tip 0))
     (error? ; not a binary input port
             (set-binary-port-input-index! $top 0))
     (error? ; not a binary input port
             (set-binary-port-input-index! $bop 0))
     (error? ; not a binary input port
             (set-binary-port-input-index! 75 0))
     (error? ; not a binary input port
             (set-binary-port-input-size! $tip 0))
     (error? ; not a binary input port
             (set-binary-port-input-size! $top 0))
     (error? ; not a binary input port
             (set-binary-port-input-size! $bop 0))
     (error? ; not a binary input port
             (set-binary-port-input-size! 75 0))
     (error? ; not a bytevector
             (set-binary-port-input-buffer! $bip "hello"))
     (error? ; not a bytevector
             (set-binary-port-input-buffer! $bip 0))
     (error? ; invalid index
       (set-binary-port-input-index! $bip #vu8(1 2 3)))
     (error? ; invalid index
             (set-binary-port-input-index! $bip -1))
     (error? ; invalid index
             (set-binary-port-input-index! $bip 6))
     (error? ; invalid size
       (set-binary-port-input-size! $bip #vu8(1 2 3)))
     (error? ; invalid size
       (set-binary-port-input-size! $bip -1))
     (error? ; invalid size
             (set-binary-port-input-size! $bip 6))
     ; binary output
     (equal? (let-values ([(op get) (open-bytevector-output-port)])
               (let ([buffer (string->utf8 "hello")])
                 (set-binary-port-output-buffer! op buffer)
                 (let ([buffer0 (bytevector-copy (binary-port-output-buffer op))]
                       [index0 (binary-port-output-index op)]
                       [size0 (binary-port-output-size op)]
                       [count0 (binary-port-output-count op)])
                   (put-u8 op (char->integer #\j))
                   (list buffer
                         (list buffer0 index0 size0 count0)
                         (list (binary-port-output-buffer op)
                               (binary-port-output-index op)
                               (binary-port-output-size op)
                               (binary-port-output-count op))))))
             `(,(string->utf8 "jello")
               (,(string->utf8 "hello") 0 5 5)
               (,(string->utf8 "jello") 1 5 4)))
     (equal? (let-values ([(op get) (open-bytevector-output-port)])
               (let ([buffer (string->utf8 "hello")])
                 (set-binary-port-output-buffer! op buffer)
                 (let ([buffer0 (bytevector-copy (binary-port-output-buffer op))]
                       [index0 (binary-port-output-index op)]
                       [size0 (binary-port-output-size op)]
                       [count0 (binary-port-output-count op)])
                   (put-u8 op (char->integer #\j))
                   (set-binary-port-output-buffer! op
                     (bytevector 1 2 3 4 5 6))
                   (put-u8 op 31)
                   (list buffer
                         (list buffer0 index0 size0 count0)
                         (list (binary-port-output-buffer op)
                               (binary-port-output-index op)
                               (binary-port-output-size op)
                               (binary-port-output-count op))))))
             `(,(string->utf8 "jello")
               (,(string->utf8 "hello") 0 5 5)
               (#vu8(31 2 3 4 5 6) 1 6 5)))
     (equal? (let-values ([(op get) (open-bytevector-output-port)])
               (let ([buffer (string->utf8 "hello")])
                 (set-binary-port-output-buffer! op buffer)
                 (let ([buffer0 (bytevector-copy (binary-port-output-buffer op))]
                       [index0 (binary-port-output-index op)]
                       [size0 (binary-port-output-size op)]
                       [count0 (binary-port-output-count op)])
                   (put-u8 op (char->integer #\j))
                   (set-binary-port-output-index! op 4)
                   (put-u8 op (char->integer #\y))
                   (list buffer
                         (list buffer0 index0 size0 count0)
                         (list (binary-port-output-buffer op)
                               (binary-port-output-index op)
                               (binary-port-output-size op)
                               (binary-port-output-count op))))))
             `(,(string->utf8 "jelly")
               (,(string->utf8 "hello") 0 5 5)
               (,(string->utf8 "jelly") 5 5 0)))
     (equal? (let-values ([(op get) (open-bytevector-output-port)])
               (let ([buffer (string->utf8 "hello")])
                 (set-binary-port-output-buffer! op buffer)
                 (let ([buffer0 (bytevector-copy (binary-port-output-buffer op))]
                       [index0 (binary-port-output-index op)]
                       [size0 (binary-port-output-size op)]
                       [count0 (binary-port-output-count op)])
                   (put-u8 op (char->integer #\j))
                   (set-binary-port-output-size! op 4)
                   (put-u8 op (char->integer #\b))
                   (list buffer
                         (list buffer0 index0 size0 count0)
                         (list (binary-port-output-buffer op)
                               (binary-port-output-index op)
                               (binary-port-output-size op)
                               (binary-port-output-count op))))))
             `(,(string->utf8 "bello")
               (,(string->utf8 "hello") 0 5 5)
               (,(string->utf8 "bello") 1 4 3)))
     (error? ; not a binary output port
             (binary-port-output-buffer $tip))
     (error? ; not a binary output port
             (binary-port-output-buffer $top))
     (error? ; not a binary output port
             (binary-port-output-buffer $bip))
     (error? ; not a binary output port
             (binary-port-output-buffer 75))
     (error? ; not a binary output port
             (binary-port-output-index $tip))
     (error? ; not a binary output port
             (binary-port-output-index $top))
     (error? ; not a binary output port
             (binary-port-output-index $bip))
     (error? ; not a binary output port
             (binary-port-output-index 75))
     (error? ; not a binary output port
             (binary-port-output-size $tip))
     (error? ; not a binary output port
             (binary-port-output-size $top))
     (error? ; not a binary output port
             (binary-port-output-size $bip))
     (error? ; not a binary output port
             (binary-port-output-size 75))
     (error? ; not a binary output port
             (binary-port-output-count $tip))
     (error? ; not a binary output port
             (binary-port-output-count $top))
     (error? ; not a binary output port
             (binary-port-output-count $bip))
     (error? ; not a binary output port
             (binary-port-output-count 75))
     (error? ; not a binary output port
             (set-binary-port-output-buffer! $tip ""))
     (error? ; not a binary output port
             (set-binary-port-output-buffer! $top ""))
     (error? ; not a binary output port
             (set-binary-port-output-buffer! $bip ""))
     (error? ; not a binary output port
             (set-binary-port-output-buffer! 75 ""))
     (error? ; not a binary output port
             (set-binary-port-output-index! $tip 0))
     (error? ; not a binary output port
             (set-binary-port-output-index! $top 0))
     (error? ; not a binary output port
             (set-binary-port-output-index! $bip 0))
     (error? ; not a binary output port
             (set-binary-port-output-index! 75 0))
     (error? ; not a binary output port
             (set-binary-port-output-size! $tip 0))
     (error? ; not a binary output port
             (set-binary-port-output-size! $top 0))
     (error? ; not a binary output port
             (set-binary-port-output-size! $bip 0))
     (error? ; not a binary output port
             (set-binary-port-output-size! 75 0))
     (error? ; not a string
       (set-binary-port-output-buffer! $bop "hello"))
     (error? ; not a string
       (set-binary-port-output-buffer! $bop 0))
     (error? ; invalid index
       (set-binary-port-output-index! $bop #vu8(1 2 3)))
     (error? ; invalid index
       (set-binary-port-output-index! $bop -1))
     (error? ; invalid index
             (set-binary-port-output-index! $bop 6))
     (error? ; invalid size
       (set-binary-port-output-size! $bop #vu8(1 2 3)))
     (error? ; invalid size
       (set-binary-port-output-size! $bop -1))
     (error? ; invalid size
       (set-binary-port-output-size! $bop 6))
     (begin
       (define $handler-standin
         (#%$port-handler (open-string-input-port "hi")))
       #t)
     (let ([name "foo"] [ib "hey!"])
       (let ([p (#%$make-textual-input-port name $handler-standin ib)])
         (and (port? p)
              (textual-port? p)
              (not (binary-port? p))
              (input-port? p)
              (not (output-port? p))
              (eq? (port-name p) name)
              (eq? (#%$port-handler p) $handler-standin)
              (eq? (#%$port-info p) #f)
              (eq? (textual-port-input-buffer p) ib)
              (eqv? (textual-port-input-size p) (string-length ib))
              (eqv? (textual-port-input-index p) 0)
              (eqv? (textual-port-input-count p) (string-length ib)))))
     (let ([name "foo"] [info "info"] [ib "hey!"])
       (let ([p (#%$make-textual-input-port name $handler-standin ib info)])
         (and (port? p)
              (textual-port? p)
              (not (binary-port? p))
              (input-port? p)
              (not (output-port? p))
              (eq? (port-name p) name)
              (eq? (#%$port-handler p) $handler-standin)
              (eq? (#%$port-info p) info)
              (eq? (textual-port-input-buffer p) ib)
              (eqv? (textual-port-input-size p) (string-length ib))
              (eqv? (textual-port-input-index p) 0)
              (eqv? (textual-port-input-count p) (string-length ib)))))
     (let ([name "foo"] [ob "hey!"])
       (let ([p (#%$make-textual-output-port name $handler-standin ob)])
         (and (port? p)
              (textual-port? p)
              (not (binary-port? p))
              (not (input-port? p))
              (output-port? p)
              (eq? (port-name p) name)
              (eq? (#%$port-handler p) $handler-standin)
              (eq? (#%$port-info p) #f)
              (eq? (textual-port-output-buffer p) ob)
              (eqv? (textual-port-output-size p) (string-length ob))
              (eqv? (textual-port-output-index p) 0)
              (eqv? (textual-port-output-count p) (string-length ob)))))
     (let ([name "foo"] [info "info"] [ob "hey!"])
       (let ([p (#%$make-textual-output-port name $handler-standin ob info)])
         (and (port? p)
              (textual-port? p)
              (not (binary-port? p))
              (not (input-port? p))
              (output-port? p)
              (eq? (port-name p) name)
              (eq? (#%$port-handler p) $handler-standin)
              (eq? (#%$port-info p) info)
              (eq? (textual-port-output-buffer p) ob)
              (eqv? (textual-port-output-size p) (string-length ob))
              (eqv? (textual-port-output-index p) 0)
              (eqv? (textual-port-output-count p) (string-length ob)))))
     (let ([name "foo"] [ib "hay!"] [ob "hey!"])
       (let ([p (#%$make-textual-input/output-port
                  name
                  $handler-standin
                  ib
                  ob)])
         (and (port? p)
              (textual-port? p)
              (not (binary-port? p))
              (input-port? p)
              (output-port? p)
              (eq? (port-name p) name)
              (eq? (#%$port-handler p) $handler-standin)
              (eq? (#%$port-info p) #f)
              (eq? (textual-port-input-buffer p) ib)
              (eqv? (textual-port-input-size p) (string-length ib))
              (eqv? (textual-port-input-index p) 0)
              (eqv? (textual-port-input-count p) (string-length ib))
              (eq? (textual-port-output-buffer p) ob)
              (eqv? (textual-port-output-size p) (string-length ob))
              (eqv? (textual-port-output-index p) 0)
              (eqv? (textual-port-output-count p) (string-length ob)))))
     (let ([name "foo"] [info "info"] [ib "hay!"] [ob "hey!"])
       (let ([p (#%$make-textual-input/output-port
                  name
                  $handler-standin
                  ib
                  ob
                  info)])
         (and (port? p)
              (textual-port? p)
              (not (binary-port? p))
              (input-port? p)
              (output-port? p)
              (eq? (port-name p) name)
              (eq? (#%$port-handler p) $handler-standin)
              (eq? (#%$port-info p) info)
              (eq? (textual-port-input-buffer p) ib)
              (eqv? (textual-port-input-size p) (string-length ib))
              (eqv? (textual-port-input-index p) 0)
              (eqv? (textual-port-input-count p) (string-length ib))
              (eq? (textual-port-output-buffer p) ob)
              (eqv? (textual-port-output-size p) (string-length ob))
              (eqv? (textual-port-output-index p) 0)
              (eqv? (textual-port-output-count p) (string-length ob)))))
     (let ([name "foo"] [ib #vu8(1 2 3 4)])
       (let ([p (#%$make-binary-input-port name $handler-standin ib)])
         (and (port? p)
              (not (textual-port? p))
              (binary-port? p)
              (input-port? p)
              (not (output-port? p))
              (eq? (port-name p) name)
              (eq? (#%$port-handler p) $handler-standin)
              (eq? (#%$port-info p) #f)
              (eq? (binary-port-input-buffer p) ib)
              (eqv? (binary-port-input-size p) (bytevector-length ib))
              (eqv? (binary-port-input-index p) 0)
              (eqv? (binary-port-input-count p) (bytevector-length ib)))))
     (let ([name "foo"] [info "info"] [ib #vu8(1 2 3 4)])
       (let ([p (#%$make-binary-input-port name $handler-standin ib info)])
         (and (port? p)
              (not (textual-port? p))
              (binary-port? p)
              (input-port? p)
              (not (output-port? p))
              (eq? (port-name p) name)
              (eq? (#%$port-handler p) $handler-standin)
              (eq? (#%$port-info p) info)
              (eq? (binary-port-input-buffer p) ib)
              (eqv? (binary-port-input-size p) (bytevector-length ib))
              (eqv? (binary-port-input-index p) 0)
              (eqv? (binary-port-input-count p) (bytevector-length ib)))))
     (let ([name "foo"] [ob #vu8(1 2 3 4)])
       (let ([p (#%$make-binary-output-port name $handler-standin ob)])
         (and (port? p)
              (not (textual-port? p))
              (binary-port? p)
              (not (input-port? p))
              (output-port? p)
              (eq? (port-name p) name)
              (eq? (#%$port-handler p) $handler-standin)
              (eq? (#%$port-info p) #f)
              (eq? (binary-port-output-buffer p) ob)
              (eqv? (binary-port-output-size p) (bytevector-length ob))
              (eqv? (binary-port-output-index p) 0)
              (eqv? (binary-port-output-count p) (bytevector-length ob)))))
     (let ([name "foo"] [info "info"] [ob #vu8(1 2 3 4)])
       (let ([p (#%$make-binary-output-port name $handler-standin ob info)])
         (and (port? p)
              (not (textual-port? p))
              (binary-port? p)
              (not (input-port? p))
              (output-port? p)
              (eq? (port-name p) name)
              (eq? (#%$port-handler p) $handler-standin)
              (eq? (#%$port-info p) info)
              (eq? (binary-port-output-buffer p) ob)
              (eqv? (binary-port-output-size p) (bytevector-length ob))
              (eqv? (binary-port-output-index p) 0)
              (eqv? (binary-port-output-count p) (bytevector-length ob)))))
     (let ([name "foo"] [ib #vu8(4 3 2 1)] [ob #vu8(1 2 3 4)])
       (let ([p (#%$make-binary-input/output-port
                  name
                  $handler-standin
                  ib
                  ob)])
         (and (port? p)
              (not (textual-port? p))
              (binary-port? p)
              (input-port? p)
              (output-port? p)
              (eq? (port-name p) name)
              (eq? (#%$port-handler p) $handler-standin)
              (eq? (#%$port-info p) #f)
              (eq? (binary-port-input-buffer p) ib)
              (eqv? (binary-port-input-size p) (bytevector-length ib))
              (eqv? (binary-port-input-index p) 0)
              (eqv? (binary-port-input-count p) (bytevector-length ib))
              (eq? (binary-port-output-buffer p) ob)
              (eqv? (binary-port-output-size p) (bytevector-length ob))
              (eqv? (binary-port-output-index p) 0)
              (eqv? (binary-port-output-count p) (bytevector-length ob)))))
     (let ([name "foo"]
           [info "info"]
           [ib #vu8(4 3 2 1)]
           [ob #vu8(1 2 3 4)])
       (let ([p (#%$make-binary-input/output-port
                  name
                  $handler-standin
                  ib
                  ob
                  info)])
         (and (port? p)
              (not (textual-port? p))
              (binary-port? p)
              (input-port? p)
              (output-port? p)
              (eq? (port-name p) name)
              (eq? (#%$port-handler p) $handler-standin)
              (eq? (#%$port-info p) info)
              (eq? (binary-port-input-buffer p) ib)
              (eqv? (binary-port-input-size p) (bytevector-length ib))
              (eqv? (binary-port-input-index p) 0)
              (eqv? (binary-port-input-count p) (bytevector-length ib))
              (eq? (binary-port-output-buffer p) ob)
              (eqv? (binary-port-output-size p) (bytevector-length ob))
              (eqv? (binary-port-output-index p) 0)
              (eqv? (binary-port-output-count p) (bytevector-length ob))))))

(mat file-buffer-size
     (let ([x (file-buffer-size)])
       (and (fixnum? x) (> x 0)))
     (error? (file-buffer-size 1024 15))
     (error? (file-buffer-size 'shoe))
     (error? (file-buffer-size 0))
     (error? (file-buffer-size -15))
     (error? (file-buffer-size (+ (most-positive-fixnum) 1)))
     (error? (file-buffer-size 1024.0))
     (parameterize ([file-buffer-size (* (file-buffer-size) 2)])
       (let ([ip (open-file-input-port "prettytest.ss")])
         (let ([n (bytevector-length (binary-port-input-buffer ip))])
           (close-input-port ip)
           (eqv? n (file-buffer-size))))))

(mat custom-port-buffer-size
     (let ([x (custom-port-buffer-size)])
       (and (fixnum? x) (> x 0)))
     (error? (custom-port-buffer-size 1024 15))
     (error? (custom-port-buffer-size 'shoe))
     (error? (custom-port-buffer-size 0))
     (error? (custom-port-buffer-size -15))
     (error? (custom-port-buffer-size (+ (most-positive-fixnum) 1)))
     (error? (custom-port-buffer-size 1024.0))
     (parameterize
       ([custom-port-buffer-size (* (custom-port-buffer-size) 2)])
       (let ([q #f])
         (let ([ip (make-custom-textual-input-port "foo"
                     (lambda (str s c) (set! q c) 0)
                     #f
                     #f
                     #f)])
           (read-char ip)
           (= q (custom-port-buffer-size))))))

(mat compress-parameters
     (error? ; unsupported format
             (compress-format 'foo))
     (error? ; unsupported format
             (compress-format "gzip"))
     (eq? (compress-format) 'lz4)
     (eq? (parameterize ([compress-format 'gzip]) (compress-format)) 'gzip)
     (eq? (parameterize ([compress-format 'lz4]) (compress-format)) 'lz4)
     (error? ; unsupported level
             (compress-level 'foo))
     (error? ; unsupported level
             (compress-level 1))
     (eq? (compress-level) 'medium)
     (eq? (parameterize ([compress-level 'low]) (compress-level)) 'low)
     (eq? (parameterize ([compress-level 'medium]) (compress-level))
          'medium)
     (eq? (parameterize ([compress-level 'high]) (compress-level)) 'high)
     (eq? (parameterize ([compress-level 'maximum]) (compress-level))
          'maximum)
     (begin
       (define (fnlength ifn)
         (call-with-port (open-file-input-port ifn) port-length))
       (define (compress-file ifn ofn fmt lvl)
         (call-with-port (open-file-input-port ifn)
           (lambda (ip)
             (call-with-port
               (parameterize ([compress-format fmt] [compress-level lvl])
                 (open-file-output-port ofn
                   (file-options compressed replace)))
               (lambda (op)
                 (put-bytevector op (get-bytevector-all ip))))))
         (fnlength ofn))
       (define (compress-file-test fmt)
         (let ([orig (fnlength "prettytest.ss")]
               [low (compress-file "prettytest.ss" "testfile.ss" fmt 'low)]
               [medium (compress-file
                         "prettytest.ss"
                         "testfile.ss"
                         fmt
                         'medium)]
               [high (compress-file
                       "prettytest.ss"
                       "testfile.ss"
                       fmt
                       'high)]
               [maximum (compress-file
                          "prettytest.ss"
                          "testfile.ss"
                          fmt
                          'maximum)])
           (define-syntax test1
             (syntax-rules ()
               [(_ level)
                (unless (< level orig)
                        (errorf #f "~s ~s did not compress" fmt 'level))]))
           (define-syntax test2
             (syntax-rules ()
               [(_ level1 level2)
                (unless (<= level2 level1)
                        (errorf #f
                                "~s ~s did worse than ~s"
                                fmt
                                'level2
                                'level1))]))
           (test1 low)
           (test1 medium)
           (test1 high)
           (test1 maximum)
           (test2 low medium)
           (test2 medium high)
           (test2 high maximum)
           (unless (< maximum low)
                   (errorf #f "~s maximum didn't do better than low" fmt))))
       (compress-file-test 'lz4)
       (compress-file-test 'gzip)
       #t))

(mat compression
     (parameters [compress-format 'gzip 'lz4]
       [compress-level 'low 'medium 'high 'maximum])
     (and (memq (compress-format) '(gzip lz4)) #t)
     (and (memq (compress-level) '(low medium high maximum))
          #t)
     (let ()
       (define cp
         (lambda (src dst)
           (define buf-size 4096)
           (let ([buf (make-bytevector buf-size)])
             (call-with-port dst
               (lambda (op)
                 (call-with-port src
                   (lambda (ip)
                     (let loop ()
                       (let ([n (get-bytevector-n! ip buf 0 buf-size)])
                         (unless (eof-object? n)
                                 (put-bytevector op buf 0 n)
                                 (loop)))))))))))

       (define cmp
         (lambda (src1 src2)
           (define buf-size 4096)
           (let ([buf1 (make-bytevector buf-size)]
                 [buf2 (make-bytevector buf-size)])
             (call-with-port src1
               (lambda (ip1)
                 (call-with-port src2
                   (lambda (ip2)
                     (let loop ()
                       (let ([n1 (get-bytevector-n! ip1 buf1 0 buf-size)]
                             [n2 (get-bytevector-n! ip2 buf2 0 buf-size)])
                         (if (eof-object? n1)
                             (eof-object? n2)
                             (and (= n1 n2)
                                  (let test ([i 0])
                                    (or (= i n1)
                                        (and (= (bytevector-u8-ref buf1 i)
                                                (bytevector-u8-ref buf2 i))
                                             (test (+ 1 i)))))
                                  (loop))))))))))))
       (and (cmp (open-file-input-port "prettytest.ss")
                 (open-file-input-port "prettytest.ss"))
            (cmp (open-file-input-port "prettytest.ss"
                   (file-options compressed))
                 (open-file-input-port "prettytest.ss"))
            (cmp (open-file-input-port "prettytest.ss")
                 (open-file-input-port "prettytest.ss"
                   (file-options compressed)))
            (cmp (open-file-input-port "prettytest.ss"
                   (file-options compressed))
                 (open-file-input-port "prettytest.ss"
                   (file-options compressed)))
            (begin
              (cp (open-file-input-port "prettytest.ss")
                  (open-file-output-port "testfile.ss"
                    (file-options replace compressed)))
              #t)
            (cmp (open-file-input-port "testfile.ss"
                   (file-options compressed))
                 (open-file-input-port "prettytest.ss"))
            (not (cmp (open-file-input-port "testfile.ss")
                      (open-file-input-port "prettytest.ss")))
            (begin
              (cp (open-file-input-port "prettytest.ss")
                  (open-file-output-port "testfile.ss"
                    (file-options no-fail no-truncate append compressed)))
              #t)
            (not (cmp (open-file-input-port "testfile.ss"
                        (file-options compressed))
                      (open-file-input-port "prettytest.ss")))))
     ; test workaround for bogus gzclose error return for empty input files
     (and (eqv? (call-with-port
                  (open-file-output-port "testfile.ss"
                    (file-options replace))
                  (lambda (x) (void)))
                (void))
          (eof-object?
            (call-with-port
              (open-file-input-port "testfile.ss"
                (file-options compressed))
              get-u8)))
     (begin
       (let ([op (open-file-output-port "testfile.ss"
                   (file-options replace))])
         (put-bytevector op #vu8(#x23 #x88 #x09 #x72 #xf3 #x72))
         (port-file-compressed! op)
         (put-bytevector op #vu8(#x93 #x21 #x88 #xe7 #x67))
         (let ([op (transcoded-port op (native-transcoder))])
           (display "hello!\n" op)
           (close-port op)))
       #t)
     (equal? (let ([ip (open-file-input-port "testfile.ss")])
               (let ([bv1 (get-bytevector-n ip 6)])
                 (port-file-compressed! ip)
                 (let ([bv2 (get-bytevector-n ip 5)])
                   (let ([ip (transcoded-port ip (native-transcoder))])
                     (let ([s (get-string-all ip)])
                       (close-port ip)
                       (list bv1 bv2 s))))))
             '(#vu8(#x23 #x88 #x09 #x72 #xf3 #x72)
               #vu8(#x93 #x21 #x88 #xe7 #x67)
               "hello!\n"))
     (not (equal? (let ([ip (open-file-input-port "testfile.ss")])
                    (let ([bv1 (get-bytevector-n ip 6)])
                      (let ([bv2 (get-bytevector-n ip 5)])
                        (close-port ip)
                        (list bv1 bv2))))
                  '(#vu8(#x23 #x88 #x09 #x72 #xf3 #x72)
                    #vu8(#x93 #x21 #x88 #xe7 #x67))))
     (begin
       (let ([op (open-file-output-port "testfile.ss"
                   (file-options replace)
                   (buffer-mode block)
                   (native-transcoder))])
         (put-string op "uncompressed string")
         (port-file-compressed! op)
         (put-string op "compressed string")
         (close-port op))
       #t)
     (equal? (let ([ip (open-file-input-port "testfile.ss"
                         (file-options)
                         (buffer-mode block)
                         (native-transcoder))])
               (let ([s1 (get-string-n ip
                           (string-length "uncompressed string"))])
                 (port-file-compressed! ip)
                 (let ([s2 (get-string-all ip)])
                   (close-port ip)
                   (list s1 s2))))
             '("uncompressed string" "compressed string"))
     (error? ; not a file port
       (call-with-string-output-port port-file-compressed!))
     (error? ; input/output ports aren't supported
       (let ([iop (open-file-input/output-port "testfile.ss"
                    (file-options replace))])
         (guard (c [else (close-port iop) (raise c)])
                (port-file-compressed! iop))))
     (begin
       (let ([op (open-file-output-port "testfile.ss"
                   (file-options compressed replace)
                   (buffer-mode block)
                   (native-transcoder))])
         (port-file-compressed! op)
         (put-string op "compressed string")
         (close-port op))
       #t)
     (equal? (let ([ip (open-file-input-port "testfile.ss"
                         (file-options compressed)
                         (buffer-mode block)
                         (native-transcoder))])
               (port-file-compressed! ip)
               (let ([s (get-string-all ip)])
                 (close-port ip)
                 s))
             '
             "compressed string"))

(mat bytevector-input-port
     (error? ; incorrect number of arguments
             (open-bytevector-input-port))
     (error? ; not a bytevector
             (open-bytevector-input-port '#(1 2 3 4)))
     (error? ; none is not a transcoder
             (open-bytevector-input-port #vu8(1 2 3 4) 'none))
     (error? ; incorrect number of arguments
             (open-bytevector-input-port #vu8(1 2 3 4) #f 'none))
     (let ()
       (define x (open-bytevector-input-port #vu8(1 2 3 4)))
       (and (eq? (get-u8 x) 1)
            (eq? (get-u8 x) 2)
            (eq? (get-u8 x) 3)
            (eq? (get-u8 x) 4)
            (eq? (get-u8 x) (eof-object))))
     (let ()
       (define x (open-bytevector-input-port #vu8(1 2 3 4)))
       (and (port-has-port-position? x)
            (eq? (port-position x) 0)
            (eq? (get-u8 x) 1)
            (eq? (port-position x) 1)
            (eq? (get-u8 x) 2)
            (eq? (port-position x) 2)
            (eq? (get-u8 x) 3)
            (eq? (port-position x) 3)
            (eq? (get-u8 x) 4)
            (eq? (port-position x) 4)
            (eq? (get-u8 x) #!eof)
            (eq? (port-position x) 4)
            (eq? (get-u8 x) #!eof)
            (eq? (port-position x) 4)
            (eq? (get-u8 x) #!eof)
            (eq? (port-position x) 4)))
     (let ()
       (define x (open-bytevector-input-port #vu8(1 2 3 4)))
       (and (port-has-set-port-position!? x)
            (eq? (port-position x) 0)
            (eq? (get-u8 x) 1)
            (eq? (port-position x) 1)
            (eq? (get-u8 x) 2)
            (eq? (port-position x) 2)
            (begin (set-port-position! x 0) #t)
            (eq? (get-u8 x) 1)
            (begin (set-port-position! x 4) #t)
            (eq? (get-u8 x) #!eof)))
     (error? (set-port-position!
               (open-bytevector-input-port #vu8(1 2 3 4))
               -1))
     (error? (set-port-position!
               (open-bytevector-input-port #vu8(1 2 3 4))
               5))

     (let ()
       (define x (open-bytevector-input-port #vu8(1 2 3 4)))
       (and (eq? (lookahead-u8 x) 1)
            (eq? (lookahead-u8 x) 1)
            (eq? (lookahead-u8 x) 1)
            (eq? (get-u8 x) 1)
            (eq? (lookahead-u8 x) 2)
            (eq? (get-u8 x) 2)
            (eq? (lookahead-u8 x) 3)
            (eq? (get-u8 x) 3)
            (eq? (lookahead-u8 x) 4)
            (eq? (get-u8 x) 4)
            (eq? (lookahead-u8 x) #!eof)
            (eq? (get-u8 x) #!eof)
            (eq? (lookahead-u8 x) #!eof)
            (eq? (get-u8 x) #!eof)))
     (eq? (buffer-mode none) 'none)
     (eq? (buffer-mode line) 'line)
     (eq? (buffer-mode block) 'block)
     (error? (buffer-mode bar))
     (error? (buffer-mode 'none))
     (eq? (buffer-mode? 'none) #t)
     (eq? (buffer-mode? 'line) #t)
     (eq? (buffer-mode? 'block) #t)
     (eq? (buffer-mode? 'foo) #f))

(mat bytevector-output-port
     (error? ; not a transcoder
             (open-bytevector-output-port 'oops))
     (error? ; incorrect number of arguments
             (open-bytevector-output-port #f 'none)))

(mat custom-binary-ports
     (begin
       (define $cp-ip
         (let ([pos 0])
           (make-custom-binary-input-port "foo"
             (lambda (bv s c)
               (let loop ([i s])
                 (unless (eq? i (+ s c))
                         (bytevector-u8-set! bv i (modulo (+ pos i) 256))
                         (loop (+ 1 i))))
               (set! pos (+ pos c))
               c)
             (lambda () pos)
             (lambda (x) (set! pos x))
             #f)))
       #t)
     (eq? (port-position $cp-ip) 0)
     (error? ; cannot unget
             (unget-u8 $cp-ip 255))
     (begin (unget-u8 $cp-ip (eof-object)) #t)
     (port-eof? $cp-ip)
     (eof-object? (lookahead-u8 $cp-ip))
     (eof-object? (get-u8 $cp-ip))
     (equal? (get-bytevector-n $cp-ip 10) #vu8(0 1 2 3 4 5 6 7 8 9))
     (eqv? (port-position $cp-ip) 10)
     (eqv? (get-u8 $cp-ip) 10)
     (begin (set-port-position! $cp-ip 256000) #t)
     (eqv? (get-u8 $cp-ip) 0)
     (eqv? (port-position $cp-ip) 256001)
     (error? ; not a binary output port
             (put-u8 $cp-ip 255))
     (not (port-has-port-length? $cp-ip))
     (not (port-has-set-port-length!? $cp-ip))
     (not (port-has-port-nonblocking?? $cp-ip))
     (not (port-has-set-port-nonblocking!? $cp-ip))
     (error? ; not supported
             (port-length $cp-ip))
     (error? ; not supported
             (set-port-length! $cp-ip 50))
     (error? ; not supported
             (port-nonblocking? $cp-ip))
     (error? ; not supported
             (set-port-nonblocking! $cp-ip #t))
     (error? ; not supported
             (set-port-nonblocking! $cp-ip #f))
     (begin
       (define $cp-op
         (let ([pos 0])
           (make-custom-binary-output-port "foo"
             (lambda (bv s c)
               (set! pos (+ pos c))
               (printf "write ~s\n" c)
               c)
             (lambda () pos)
             (lambda (x) (set! pos x))
             (lambda () (printf "closed\n")))))
       #t)
     (eq? (port-position $cp-op) 0)
     (error? ; not a binary input port
             (unget-u8 $cp-op 255))
     (not (port-has-port-length? $cp-op))
     (not (port-has-set-port-length!? $cp-op))
     (not (port-has-port-nonblocking?? $cp-op))
     (not (port-has-set-port-nonblocking!? $cp-op))
     (error? ; not supported
             (port-length $cp-op))
     (error? ; not supported
             (set-port-length! $cp-op 50))
     (error? ; not supported
             (port-nonblocking? $cp-op))
     (error? ; not supported
             (set-port-nonblocking! $cp-op #t))
     (error? ; not supported
             (set-port-nonblocking! $cp-op #f))
     (begin (put-u8 $cp-op 255) #t)
     (eqv? (port-position $cp-op) 1)
     (begin (set-port-position! $cp-op 17) #t)
     (equal? (with-output-to-string
               (lambda ()
                 (put-bytevector $cp-op #vu8(17 18 19 20))
                 (put-bytevector $cp-op #vu8(20 21 22 23 24 25) 1)
                 (put-bytevector $cp-op #vu8(24 25 26 27 28 29) 1 4)))
             "")
     (equal? ; in our current implementation...
       (with-output-to-string
         (lambda ()
           (printf "pos = ~s\n" (port-position $cp-op))))
       "pos = 30\n")
     (equal? ; ... actual flush won't happen until here
             (with-output-to-string
               (lambda () (r6rs:flush-output-port $cp-op)))
             "write 13\n")
     (equal? (with-output-to-string
               (lambda ()
                 (printf "pos = ~s\n" (port-position $cp-op))))
             "pos = 30\n")
     (equal? (with-output-to-string
               (lambda ()
                 (put-bytevector $cp-op #vu8(17 18 19 20))
                 (put-bytevector $cp-op #vu8(20 21 22 23 24 25) 1)
                 (put-bytevector $cp-op #vu8(24 25 26 27 28 29) 1 4)))
             "")
     (equal? (with-output-to-string (lambda () (close-port $cp-op)))
             "write 13\nclosed\n")
     (error? ; closed
             (put-u8 $cp-op 0))
     (error? ; closed
       (put-bytevector $cp-op #vu8(3)))
     (error? ; closed
       (r6rs:flush-output-port $cp-op))
     (begin
       (define $cp-iop
         (let ([pos 0])
           (make-custom-binary-input/output-port "foo"
             (lambda (bv s c)
               (let loop ([i s])
                 (unless (eq? i (+ s c))
                         (bytevector-u8-set! bv i (modulo (+ pos i) 256))
                         (loop (+ 1 i))))
               (set! pos (+ pos c))
               c)
             (lambda (bv s c)
               (set! pos (+ pos c))
               (printf "write ~s\n" c)
               c)
             (lambda () pos)
             (lambda (x) (set! pos x))
             (lambda () (printf "closed\n")))))
       #t)
     (eq? (port-position $cp-iop) 0)
     (error? ; cannot unget
             (unget-u8 $cp-iop 255))
     (begin (unget-u8 $cp-iop (eof-object)) #t)
     (port-eof? $cp-iop)
     (eof-object? (lookahead-u8 $cp-iop))
     (eof-object? (get-u8 $cp-iop))
     (equal? (get-bytevector-n $cp-iop 10) #vu8(0 1 2 3 4 5 6 7 8 9))
     (eqv? (port-position $cp-iop) 10)
     (eqv? (lookahead-u8 $cp-iop) 10)
     (eqv? (get-u8 $cp-iop) 10)
     (begin (set-port-position! $cp-iop 256000) #t)
     (eqv? (get-u8 $cp-iop) 0)
     (eqv? (port-position $cp-iop) 256001)
     (not (port-has-port-length? $cp-iop))
     (not (port-has-set-port-length!? $cp-iop))
     (not (port-has-port-nonblocking?? $cp-iop))
     (not (port-has-set-port-nonblocking!? $cp-iop))
     (error? ; not supported
             (port-length $cp-iop))
     (error? ; not supported
             (set-port-length! $cp-iop 50))
     (error? ; not supported
             (port-nonblocking? $cp-iop))
     (error? ; not supported
             (set-port-nonblocking! $cp-iop #t))
     (error? ; not supported
             (set-port-nonblocking! $cp-iop #f))
     (begin (put-u8 $cp-iop 255) #t)
     (eqv? (port-position $cp-iop) 256002)
     (begin (set-port-position! $cp-iop 17) #t)
     (equal? (with-output-to-string
               (lambda ()
                 (put-bytevector $cp-iop #vu8(17 18 19 20))
                 (put-bytevector $cp-iop #vu8(20 21 22 23 24 25) 1)
                 (put-bytevector $cp-iop #vu8(24 25 26 27 28 29) 1 4)))
             "")
     (equal? ; in our current implementation...
       (with-output-to-string
         (lambda ()
           (printf "pos = ~s\n" (port-position $cp-iop))))
       "pos = 30\n")
     (equal? ; ... actual flush won't happen until here
             (with-output-to-string
               (lambda () (r6rs:flush-output-port $cp-iop)))
             "write 13\n")
     (equal? (with-output-to-string
               (lambda ()
                 (printf "pos = ~s\n" (port-position $cp-iop))))
             "pos = 30\n")
     (equal? (with-output-to-string
               (lambda ()
                 (put-bytevector $cp-iop #vu8(17 18 19 20))
                 (put-bytevector $cp-iop #vu8(20 21 22 23 24 25) 1)
                 (put-bytevector $cp-iop #vu8(24 25 26 27 28 29) 1 4)))
             "")
     (equal? (with-output-to-string (lambda () (close-port $cp-iop)))
             "write 13\nclosed\n")
     (error? ; closed
             (put-u8 $cp-iop 0))
     (error? ; closed
       (put-bytevector $cp-iop #vu8(3)))
     (error? ; closed
       (r6rs:flush-output-port $cp-iop))

     (begin
       (define $cp-iop
         (let ([pos 0])
           (make-custom-binary-input/output-port "foo"
             (lambda (bv s c)
               (let loop ([i s])
                 (unless (eq? i (+ s c))
                         (bytevector-u8-set! bv i (modulo (+ pos i) 256))
                         (loop (+ 1 i))))
               (set! pos (+ pos c))
               c)
             (lambda (bv s c)
               (set! pos (+ pos c))
               (printf "write ~s\n" c)
               c)
             #f
             (lambda (x) (set! pos x))
             (lambda () (printf "closed\n")))))
       #t)
     (not (port-has-port-position? $cp-iop))
     (error? ; operation not supported
             (port-position $cp-iop))
     (begin
       (guard (c [(warning? c) (errorf #f "unexpected warning ~s" c)])
              (put-u8 $cp-iop 255))
       #t)
     (eqv? (get-u8 $cp-iop) 1)
     (custom-port-warning? ; can't determine position for write
       (put-u8 $cp-iop 255))
     (begin (set-port-position! $cp-iop 50) #t)
     (begin
       (guard (c [(warning? c) (errorf #f "unexpected warning ~s" c)])
              (put-u8 $cp-iop 255))
       #t)
     (eqv? (get-u8 $cp-iop) 51)
     (custom-port-warning? ; can't determine position for write
       (put-bytevector $cp-iop #vu8(17)))

     (begin
       (define $cp-iop
         (let ([pos 0])
           (make-custom-binary-input/output-port "foo"
             (lambda (bv s c)
               (let loop ([i s])
                 (unless (eq? i (+ s c))
                         (bytevector-u8-set! bv i (modulo (+ pos i) 256))
                         (loop (+ 1 i))))
               (set! pos (+ pos c))
               c)
             (lambda (bv s c)
               (set! pos (+ pos c))
               (printf "write ~s\n" c)
               c)
             (lambda () pos)
             #f
             (lambda () (printf "closed\n")))))
       #t)
     (not (port-has-set-port-position!? $cp-iop))
     (error? ; operation not supported
             (set-port-position! $cp-iop 3))
     (begin
       (guard (c [(warning? c) (errorf #f "unexpected warning ~s" c)])
              (put-u8 $cp-iop 255))
       #t)
     (eqv? (get-u8 $cp-iop) 1)
     (custom-port-warning? ; can't set position for write
       ; convoluted because we want warning to return normally so that operation
       ; is completed
       (let ([hit? #f])
         (with-exception-handler
           (lambda (c)
             (if (warning? c) (set! hit? c) (raise c)))
           (lambda () (put-u8 $cp-iop 255)))
         (when hit? (raise hit?))))
     (begin
       (guard (c [(warning? c) (errorf #f "unexpected warning ~s" c)])
              (put-u8 $cp-iop 255))
       #t)
     (begin (get-u8 $cp-iop) #t)
     ; position undefined, so value undefined
     (custom-port-warning? ; can't set position for write
       (put-bytevector $cp-iop #vu8(17)))

     (begin
       (define $cp-iop
         (let ([pos 0])
           (make-custom-binary-input/output-port "foo"
             (lambda (bv s c)
               (let loop ([i s])
                 (unless (eq? i (+ s c))
                         (bytevector-u8-set! bv i (modulo (+ pos i) 256))
                         (loop (+ 1 i))))
               (set! pos (+ pos c))
               c)
             (lambda (bv s c)
               (set! pos (+ pos c))
               (printf "write ~s\n" c)
               c)
             #f
             #f
             (lambda () (printf "closed\n")))))
       #t)
     (not (port-has-port-position? $cp-iop))
     (error? ; operation not supported
             (port-position $cp-iop))
     (not (port-has-set-port-position!? $cp-iop))
     (error? ; operation not supported
             (set-port-position! $cp-iop 3))
     (begin
       (guard (c [(warning? c) (errorf #f "unexpected warning ~s" c)])
              (put-u8 $cp-iop 255))
       #t)
     (eqv? (get-u8 $cp-iop) 1)
     (custom-port-warning? ; can't determine position for write
       ; convoluted because we want warning to return normally so that operation
       ; is completed
       (let ([hit? #f])
         (with-exception-handler
           (lambda (c)
             (if (warning? c) (set! hit? c) (raise c)))
           (lambda () (put-u8 $cp-iop 255)))
         (when hit? (raise hit?))))
     (begin
       (guard (c [(warning? c) (errorf #f "unexpected warning ~s" c)])
              (put-u8 $cp-iop 255))
       #t)
     (begin (get-u8 $cp-iop) #t)
     ; position undefined, so value undefined
     (custom-port-warning? ; can't determine position for write
       (put-bytevector $cp-iop #vu8(17))))

(mat custom-textual-ports
     (begin
       (define $cp-ip
         (let ([pos 0] [chars "0123456789abcdefghijklmnopqrstuvwxyz"])
           (make-custom-textual-input-port "foo"
             (lambda (str s c)
               (let loop ([i s])
                 (unless (eq? i (+ s c))
                         (string-set! str i
                           (string-ref chars (modulo (+ pos i) 36)))
                         (loop (+ 1 i))))
               (set! pos (+ pos c))
               c)
             (lambda () pos)
             (lambda (x) (set! pos x))
             #f)))
       #t)
     (eq? (port-position $cp-ip) 0)
     (error? ; cannot unget
             (unget-char $cp-ip #\q))
     (begin (unget-char $cp-ip (eof-object)) #t)
     (port-eof? $cp-ip)
     (eof-object? (lookahead-char $cp-ip))
     (eof-object? (get-char $cp-ip))
     (equal? (get-string-n $cp-ip 10) "0123456789")
     (eqv? (port-position $cp-ip) 10)
     (eqv? (get-char $cp-ip) #\a)
     (begin (set-port-position! $cp-ip 36000) #t)
     (eqv? (get-char $cp-ip) #\0)
     (custom-port-warning? (port-position $cp-ip))
     (error? ; not a textual output port
             (put-char $cp-ip #\a))
     (not (port-has-port-length? $cp-ip))
     (not (port-has-set-port-length!? $cp-ip))
     (not (port-has-port-nonblocking?? $cp-ip))
     (not (port-has-set-port-nonblocking!? $cp-ip))
     (error? ; not supported
             (port-length $cp-ip))
     (error? ; not supported
             (set-port-length! $cp-ip 50))
     (error? ; not supported
             (port-nonblocking? $cp-ip))
     (error? ; not supported
             (set-port-nonblocking! $cp-ip #t))
     (error? ; not supported
             (set-port-nonblocking! $cp-ip #f))

     (begin
       (define $cp-op
         (let ([pos 0])
           (make-custom-textual-output-port "foo"
             (lambda (str s c)
               (set! pos (+ pos c))
               (printf "write ~s\n" c)
               c)
             (lambda () pos)
             (lambda (x) (set! pos x))
             (lambda () (printf "closed\n")))))
       #t)
     (eq? (port-position $cp-op) 0)
     (error? ; not a textual output port
             (unget-char $cp-op 255))
     (not (port-has-port-length? $cp-op))
     (not (port-has-set-port-length!? $cp-op))
     (not (port-has-port-nonblocking?? $cp-op))
     (not (port-has-set-port-nonblocking!? $cp-op))
     (error? ; not supported
             (port-length $cp-op))
     (error? ; not supported
             (set-port-length! $cp-op 50))
     (error? ; not supported
             (port-nonblocking? $cp-op))
     (error? ; not supported
             (set-port-nonblocking! $cp-op #t))
     (error? ; not supported
             (set-port-nonblocking! $cp-op #f))
     (begin (put-char $cp-op #\$) #t)
     (eqv? (port-position $cp-op) 1)
     (begin (set-port-position! $cp-op 17) #t)
     (equal? (with-output-to-string
               (lambda ()
                 (put-string $cp-op "abcd")
                 (put-string $cp-op "defghi" 1)
                 (put-string $cp-op "hijklm" 1 4)))
             "")
     (equal? ; in our current implementation...
       (with-output-to-string
         (lambda ()
           (printf "pos = ~s\n" (port-position $cp-op))))
       "write 13\npos = 30\n")
     (equal? (with-output-to-string
               (lambda ()
                 (printf "pos = ~s\n" (port-position $cp-op))))
             "pos = 30\n")
     (equal? (with-output-to-string
               (lambda ()
                 (put-string $cp-op "abcd")
                 (put-string $cp-op "defghi" 1)
                 (put-string $cp-op "hijklm" 1 4)))
             "")
     (equal? (with-output-to-string (lambda () (close-port $cp-op)))
             "write 13\nclosed\n")
     (error? ; closed
             (put-char $cp-op #\$))
     (error? ; closed
             (put-string $cp-op "3"))
     (error? ; closed
       (r6rs:flush-output-port $cp-op))

     (begin
       (define $cp-iop
         (let ([pos 0] [chars "0123456789abcdefghijklmnopqrstuvwxyz"])
           (make-custom-textual-input/output-port "foo"
             (lambda (str s c)
               (let loop ([i s])
                 (unless (eq? i (+ s c))
                         (string-set! str i
                           (string-ref chars (modulo (+ pos i) 36)))
                         (loop (+ 1 i))))
               (set! pos (+ pos c))
               c)
             (lambda (str s c)
               (set! pos (+ pos c))
               (printf "write ~s\n" c)
               c)
             (lambda () pos)
             (lambda (x) (set! pos x))
             (lambda () (printf "closed\n")))))
       #t)
     (eq? (port-position $cp-iop) 0)
     (error? ; cannot unget
             (unget-char $cp-iop #\$))
     (begin (unget-char $cp-iop (eof-object)) #t)
     (port-eof? $cp-iop)
     (eof-object? (lookahead-char $cp-iop))
     (eof-object? (get-char $cp-iop))
     (equal? (get-string-n $cp-iop 10) "0123456789")
     (eqv? (port-position $cp-iop) 10)
     (eqv? (get-char $cp-iop) #\a)
     (begin (set-port-position! $cp-iop 36000) #t)
     (eqv? (get-char $cp-iop) #\0)
     (custom-port-warning? (port-position $cp-iop))
     (not (port-has-port-length? $cp-iop))
     (not (port-has-set-port-length!? $cp-iop))
     (not (port-has-port-nonblocking?? $cp-iop))
     (not (port-has-set-port-nonblocking!? $cp-iop))
     (error? ; not supported
             (port-length $cp-iop))
     (error? ; not supported
             (set-port-length! $cp-iop 50))
     (error? ; not supported
             (port-nonblocking? $cp-iop))
     (error? ; not supported
             (set-port-nonblocking! $cp-iop #t))
     (error? ; not supported
             (set-port-nonblocking! $cp-iop #f))
     (custom-port-warning? (put-char $cp-iop #\$))
     (begin (set-port-position! $cp-iop 17) #t)
     (eqv? (port-position $cp-iop) 17)
     (equal? (with-output-to-string
               (lambda ()
                 (put-string $cp-iop "abcd")
                 (put-string $cp-iop "defghi" 1)
                 (put-string $cp-iop "hijklm" 1 4)))
             "")
     (equal? ; in our current implementation...
       (with-output-to-string
         (lambda ()
           (printf "pos = ~s\n" (port-position $cp-iop))))
       "write 13\npos = 30\n")
     (equal? (with-output-to-string
               (lambda ()
                 (printf "pos = ~s\n" (port-position $cp-iop))))
             "pos = 30\n")
     (equal? (with-output-to-string
               (lambda ()
                 (put-string $cp-iop "abcd")
                 (put-string $cp-iop "defghi" 1)
                 (put-string $cp-iop "hijklm" 1 4)))
             "")
     (equal? (with-output-to-string (lambda () (close-port $cp-iop)))
             "write 13\nclosed\n")
     (error? ; closed
             (put-char $cp-iop #\$))
     (error? ; closed
             (put-string $cp-iop "3"))
     (error? ; closed
       (r6rs:flush-output-port $cp-iop))

     (begin
       (define $cp-iop
         (let ([pos 0] [chars "0123456789abcdefghijklmnopqrstuvwxyz"])
           (make-custom-textual-input/output-port "foo"
             (lambda (str s c)
               (let loop ([i s])
                 (unless (eq? i (+ s c))
                         (string-set! str i
                           (string-ref chars (modulo (+ pos i) 36)))
                         (loop (+ 1 i))))
               (set! pos (+ pos c))
               c)
             (lambda (str s c)
               (set! pos (+ pos c))
               (printf "write ~s\n" c)
               c)
             #f
             (lambda (x) (set! pos x))
             (lambda () (printf "closed\n")))))
       #t)
     (not (port-has-port-position? $cp-iop))
     (error? ; operation not supported
             (port-position $cp-iop))
     (begin
       (guard (c [(warning? c) (errorf #f "unexpected warning ~s" c)])
              (put-char $cp-iop #\$))
       #t)
     (eqv? (get-char $cp-iop) #\1)
     (custom-port-warning? ; can't determine position for write
       (put-char $cp-iop #\$))
     (begin (set-port-position! $cp-iop 50) #t)
     (begin
       (guard (c [(warning? c) (errorf #f "unexpected warning ~s" c)])
              (put-char $cp-iop #\$))
       #t)
     (eqv? (get-char $cp-iop) #\f)
     (custom-port-warning? ; can't determine position for write
       (put-string $cp-iop "a"))

     (begin
       (define $cp-iop
         (let ([pos 0] [chars "0123456789abcdefghijklmnopqrstuvwxyz"])
           (make-custom-textual-input/output-port "foo"
             (lambda (str s c)
               (let loop ([i s])
                 (unless (eq? i (+ s c))
                         (string-set! str i
                           (string-ref chars (modulo (+ pos i) 36)))
                         (loop (+ 1 i))))
               (set! pos (+ pos c))
               c)
             (lambda (str s c)
               (set! pos (+ pos c))
               (printf "write ~s\n" c)
               c)
             (lambda () pos)
             #f
             (lambda () (printf "closed\n")))))
       #t)
     (not (port-has-set-port-position!? $cp-iop))
     (error? ; operation not supported
             (set-port-position! $cp-iop 3))
     (begin
       (guard (c [(warning? c) (errorf #f "unexpected warning ~s" c)])
              (put-char $cp-iop #\$))
       #t)
     (eqv? (get-char $cp-iop) #\1)
     (custom-port-warning? ; can't set position for write
       ; convoluted because we want warning to return normally so that operation
       ; is completed
       (let ([hit? #f])
         (with-exception-handler
           (lambda (c)
             (if (warning? c) (set! hit? c) (raise c)))
           (lambda () (put-char $cp-iop #\$)))
         (when hit? (raise hit?))))
     (begin
       (guard (c [(warning? c) (errorf #f "unexpected warning ~s" c)])
              (put-char $cp-iop #\$))
       #t)
     (begin (get-char $cp-iop) #t)
     ; position undefined, so value undefined
     (custom-port-warning? ; can't set position for write
       (put-string $cp-iop "a"))

     (begin
       (define $cp-iop
         (let ([pos 0] [chars "0123456789abcdefghijklmnopqrstuvwxyz"])
           (make-custom-textual-input/output-port "foo"
             (lambda (str s c)
               (let loop ([i s])
                 (unless (eq? i (+ s c))
                         (string-set! str i
                           (string-ref chars (modulo (+ pos i) 36)))
                         (loop (+ 1 i))))
               (set! pos (+ pos c))
               c)
             (lambda (str s c)
               (set! pos (+ pos c))
               (printf "write ~s\n" c)
               c)
             #f
             #f
             (lambda () (printf "closed\n")))))
       #t)
     (not (port-has-port-position? $cp-iop))
     (error? ; operation not supported
             (port-position $cp-iop))
     (not (port-has-set-port-position!? $cp-iop))
     (error? ; operation not supported
             (set-port-position! $cp-iop 3))
     (begin
       (guard (c [(warning? c) (errorf #f "unexpected warning ~s" c)])
              (put-char $cp-iop #\$))
       #t)
     (eqv? (get-char $cp-iop) #\1)
     (custom-port-warning? ; can't determine position for write
       ; convoluted because we want warning to return normally so that operation
       ; is completed
       (let ([hit? #f])
         (with-exception-handler
           (lambda (c)
             (if (warning? c) (set! hit? c) (raise c)))
           (lambda () (put-char $cp-iop #\$)))
         (when hit? (raise hit?))))
     (begin
       (guard (c [(warning? c) (errorf #f "unexpected warning ~s" c)])
              (put-char $cp-iop #\$))
       #t)
     (begin (get-char $cp-iop) #t)
     ; position undefined, so value undefined
     (custom-port-warning? ; can't determine position for write
       (put-string $cp-iop "a"))

     (equal? (let-values ([(sop get) (open-string-output-port)])
               (define op
                 (make-custom-textual-output-port "foo"
                   (lambda (str s c)
                     (put-string sop str s c)
                     c)
                   #f
                   #f
                   #f))
               (fresh-line op)
               (fresh-line op)
               (put-string op "hello")
               (fresh-line op)
               (fresh-line op)
               (put-string op "hello")
               (flush-output-port op)
               (fresh-line op)
               (fresh-line op)
               (put-string op "hello\n")
               (flush-output-port op)
               (fresh-line op)
               (fresh-line op)
               (put-string op "hello\n")
               (fresh-line op)
               (close-port op)
               (get))
             "hello\nhello\nhello\nhello\n")

     (equal? (let-values ([(sop get) (open-string-output-port)])
               (define op
                 (make-custom-textual-input/output-port "foo"
                   (lambda (str s c) (errorf #f "oops"))
                   (lambda (str s c)
                     (put-string sop str s c)
                     c)
                   #f
                   #f
                   #f))
               (fresh-line op)
               (fresh-line op)
               (put-string op "hello")
               (fresh-line op)
               (fresh-line op)
               (put-string op "hello")
               (flush-output-port op)
               (fresh-line op)
               (fresh-line op)
               (put-string op "hello\n")
               (flush-output-port op)
               (fresh-line op)
               (fresh-line op)
               (put-string op "hello\n")
               (fresh-line op)
               (close-port op)
               (get))
             "hello\nhello\nhello\nhello\n"))

(mat compression-textual
     (parameters [compress-format 'gzip 'lz4]
       [compress-level 'low 'medium 'high 'maximum])
     (let ()
       (define cp
         (lambda (src dst)
           (define buf-size 103)
           (let ([buf (make-string buf-size)])
             (call-with-port dst
               (lambda (op)
                 (call-with-port src
                   (lambda (ip)
                     (let loop ()
                       (do ([i 0 (fx+ i 1)])
                           ((fx= i buf-size))
                           (let ([c (get-char ip)])
                             (unless (eof-object? c)
                                     (put-char op c))))
                       (let ([n (get-string-n! ip buf 0 buf-size)])
                         (unless (eof-object? n)
                                 (put-string op buf 0 n)
                                 (loop)))))))))))
       (define cmp
         (lambda (src1 src2)
           (define buf-size 128)
           (let ([buf (make-string buf-size)])
             (call-with-port src1
               (lambda (ip1)
                 (call-with-port src2
                   (lambda (ip2)
                     (let loop ([pos 0])
                       (let ([n (get-string-n! ip1 buf 0 buf-size)])
                         (if (eof-object? n)
                             (unless (eof-object? (lookahead-char ip2))
                                     (errorf #f "ip1 eof before ip2"))
                             (if (eof-object? (lookahead-char ip2))
                                 (errorf #f "ip2 eof before ip1")
                                 (let test ([i 0] [pos pos])
                                   (if (= i n)
                                       (loop pos)
                                       (let ([c1 (string-ref buf i)] [c2 (get-char ip2)])
                                         (if (char=? c1 c2)
                                             (test (+ 1 i) (+ pos 1))
                                             (errorf #f
                                                     "ip1 c = ~s =/= ip2 c = ~s at pos ~s"
                                                     c1
                                                     c2
                                                     pos))))))))))))))))
       (define (in fn compressed? codec)
         (open-file-input-port fn
           (if compressed?
               (file-options compressed)
               (file-options))
           (buffer-mode block)
           (make-transcoder codec)))
       (define (out fn compressed? codec)
         (open-file-output-port fn
           (if compressed?
               (file-options compressed replace)
               (file-options replace))
           (buffer-mode block)
           (make-transcoder codec)))
       (time (cmp (in "prettytest.ss" #f (latin-1-codec))
                  (in "prettytest.ss" #f (latin-1-codec))))
       (time (cmp (in "prettytest.ss" #t (latin-1-codec))
                  (in "prettytest.ss" #f (latin-1-codec))))
       (time (cmp (in "prettytest.ss" #f (latin-1-codec))
                  (in "prettytest.ss" #t (latin-1-codec))))
       (time (cmp (in "prettytest.ss" #t (latin-1-codec))
                  (in "prettytest.ss" #t (latin-1-codec))))
       (time (cmp (in "prettytest.ss" #f (utf-8-codec))
                  (in "prettytest.ss" #f (utf-8-codec))))
       (time (cmp (in "prettytest.ss" #t (utf-8-codec))
                  (in "prettytest.ss" #f (utf-8-codec))))
       (time (cmp (in "prettytest.ss" #f (utf-8-codec))
                  (in "prettytest.ss" #t (utf-8-codec))))
       (time (cmp (in "prettytest.ss" #t (utf-8-codec))
                  (in "prettytest.ss" #t (utf-8-codec))))
       (cp (in "prettytest.ss" #f (latin-1-codec))
           (out "testfile.ss" #t (latin-1-codec)))
       (cmp (in "prettytest.ss" #f (latin-1-codec))
            (in "testfile.ss" #t (latin-1-codec)))
       (cmp (in "prettytest.ss" #t (latin-1-codec))
            (in "testfile.ss" #t (latin-1-codec)))
       (cmp (in "prettytest.ss" #f (utf-8-codec))
            (in "testfile.ss" #t (utf-8-codec)))
       (cmp (in "prettytest.ss" #t (utf-8-codec))
            (in "testfile.ss" #t (utf-8-codec)))
       (cp (in "prettytest.ss" #f (utf-8-codec))
           (out "testfile.ss" #t (utf-8-codec)))
       (cmp (in "prettytest.ss" #f (latin-1-codec))
            (in "testfile.ss" #t (latin-1-codec)))
       (cmp (in "prettytest.ss" #t (latin-1-codec))
            (in "testfile.ss" #t (latin-1-codec)))
       (cmp (in "prettytest.ss" #f (utf-8-codec))
            (in "testfile.ss" #t (utf-8-codec)))
       (cmp (in "prettytest.ss" #t (utf-8-codec))
            (in "testfile.ss" #t (utf-8-codec)))
       #t)
     ; test workaround for bogus gzclose error return for empty input files
     (and (eqv? (call-with-port
                  (open-file-output-port "testfile.ss"
                    (file-options replace)
                    (buffer-mode block)
                    (native-transcoder))
                  (lambda (x) (void)))
                (void))
          (eof-object?
            (call-with-port
              (open-file-input-port "testfile.ss"
                (file-options compressed)
                (buffer-mode block)
                (native-transcoder))
              get-char))))

(mat string-ports
     (let ()
       (define pretty-test-string
         (call-with-port
           (open-file-input-port "prettytest.ss"
             (file-options)
             (buffer-mode none)
             (native-transcoder))
           get-string-all))
       (define cp
         ; doesn't close the ports
         (lambda (ip op)
           (define buf-size 103)
           (let ([buf (make-string buf-size)])
             (let loop ()
               (do ([i 0 (fx+ i 1)])
                   ((fx= i buf-size))
                   (let ([c (get-char ip)])
                     (unless (eof-object? c)
                             (put-char op c))))
               (let ([n (get-string-n! ip buf 0 buf-size)])
                 (unless (eof-object? n)
                         (put-string op buf 0 n)
                         (loop)))))))
       (define cmp
         (lambda (src1 src2)
           (define buf-size 64)
           (let ([buf (make-string buf-size)])
             (call-with-port src1
               (lambda (ip1)
                 (call-with-port src2
                   (lambda (ip2)
                     (let loop ([pos 0])
                       (let ([n (get-string-n! ip1 buf 0 buf-size)])
                         (if (eof-object? n)
                             (unless (eof-object? (lookahead-char ip2))
                                     (errorf #f "ip1 eof before ip2"))
                             (if (eof-object? (lookahead-char ip2))
                                 (errorf #f "ip2 eof before ip1")
                                 (let test ([i 0] [pos pos])
                                   (if (= i n)
                                       (loop pos)
                                       (let ([c1 (string-ref buf i)] [c2 (get-char ip2)])
                                         (if (char=? c1 c2)
                                             (test (+ 1 i) (+ pos 1))
                                             (errorf #f
                                                     "ip1 c = ~s =/= ip2 c = ~s at pos ~s"
                                                     c1
                                                     c2
                                                     pos))))))))))))))))
       (define (in fn compressed? codec)
         (open-file-input-port fn
           (if compressed?
               (file-options compressed)
               (file-options))
           (buffer-mode block)
           (make-transcoder codec)))
       (define (out fn compressed? codec)
         (open-file-output-port fn
           (if compressed?
               (file-options compressed replace)
               (file-options replace))
           (buffer-mode block)
           (make-transcoder codec)))
       (time (cmp (in "prettytest.ss" #f (latin-1-codec))
                  (open-string-input-port pretty-test-string)))
       (time (cmp (open-string-input-port pretty-test-string)
                  (in "prettytest.ss" #f (latin-1-codec))))
       (let-values ([(op retrieve) (open-string-output-port)])
         (cp (open-string-input-port pretty-test-string) op)
         (cmp (in "prettytest.ss" #f (latin-1-codec))
              (open-string-input-port (retrieve))))
       #t))

(mat current-ports
     (input-port? (current-input-port))
     (textual-port? (current-input-port))
     (not (output-port? (open-input-string "hello")))
     (output-port? (current-output-port))
     (textual-port? (current-output-port))
     (output-port? (current-error-port))
     (textual-port? (current-error-port))
     (not (input-port? (open-output-string)))
     (eq? (r6rs:current-input-port) (current-input-port))
     (eq? (r6rs:current-output-port) (current-output-port))
     (eq? (r6rs:current-error-port) (current-error-port))
     (equal? (with-output-to-string
               (lambda ()
                 (write (list (eq? (r6rs:current-input-port)
                                   (current-input-port))
                              (eq? (r6rs:current-output-port) (current-output-port))
                              (eq? (r6rs:current-error-port) (current-error-port))))))
             "(#t #t #t)")
     (error? (current-input-port (standard-input-port)))
     (error? (current-output-port (standard-output-port)))
     (error? (current-error-port (standard-output-port)))
     (error? (current-input-port (open-output-string)))
     (error? (current-output-port (open-input-string "")))
     (error? (current-error-port (open-input-string "")))
     (error? (console-input-port (standard-input-port)))
     (error? (console-output-port (standard-output-port)))
     (error? (console-error-port (standard-output-port)))
     (error? (console-input-port (open-output-string)))
     (error? (console-output-port (open-input-string "")))
     (error? (console-error-port (open-input-string ""))))

(mat current-transcoder
     (transcoder? (current-transcoder))
     (eqv? (current-transcoder) (native-transcoder))
     (error? (current-transcoder (open-output-string)))
     (parameterize ([current-transcoder (native-transcoder)])
       (eqv? (current-transcoder) (native-transcoder)))
     (parameterize
       ([current-transcoder (make-transcoder (utf-16le-codec))])
       (with-output-to-file "testfile.ss"
         (lambda () (write '\x3bb;12345))
         'replace)
       (file-exists? "testfile.ss"))
     (parameterize
       ([current-transcoder (make-transcoder (utf-16le-codec))])
       (with-input-from-file "testfile.ss"
         (lambda ()
           (and (eqv? (read) '\x3bb;12345)
                (eof-object? (read))))))
     (equal? (call-with-port
               (open-file-input-port "testfile.ss")
               get-bytevector-all)
             #vu8(#xBB #x3 #x31 #x0 #x32 #x0 #x33 #x0 #x34 #x0 #x35 #x0)))

(mat get/put-datum
     (error? (get-datum))
     (error? (get-datum (current-input-port) (current-input-port)))
     (error? (get-datum (open-output-string)))
     (error? (get-datum (open-bytevector-input-port #vu8())))
     (call-with-port (open-string-input-port "hey #;there dude!")
       (lambda (p)
         (and (eq? (get-datum p) 'hey)
              (eqv? (get-char p) #\space)
              (eq? (get-datum p) 'dude!)
              (eof-object? (get-datum p)))))
     (error? (put-datum))
     (error? (put-datum (current-output-port)))
     (error? (put-datum (current-output-port) 'a 'a))
     (error? (put-datum (open-input-string "hello") 'a))
     (error? (put-datum
               (let-values ([(p g) (open-bytevector-output-port)])
                 p)
               'a))
     (equal? (let-values ([(p g) (open-string-output-port)])
               (put-datum p '(this is))
               (put-datum p "cool")
               (put-datum p '(or (maybe . not)))
               (g))
             "(this is)\"cool\"(or (maybe . not))")
     (call-with-port
       (open-string-input-port
         "#3(a b c) #!r6rs #(d e) #!chezscheme #3(f g)")
       (lambda (p)
         (and (equal? (get-datum p) '#(a b c))
              (equal? (get-datum p) '#(d e))
              (equal? (get-datum p) '#(f g g))
              (equal? (get-datum p) #!eof))))
     ; make sure that nel and ls are treated properly
     (call-with-port
       (open-string-input-port
         "#!r6rs \x85; \x2028; #\\x85 #\\x2028 \"\\x85; \\x2028;\"")
       (lambda (p)
         (and (equal? (get-datum p) (integer->char #x85))
              (equal? (get-datum p) (integer->char #x2028))
              (equal? (get-datum p)
                (string (integer->char #x85)
                        #\space
                        (integer->char #x2028))))))
     (equal? (call-with-string-output-port
               (lambda (p)
                 (put-char p #\x85)
                 (put-char p #\space)
                 (put-char p #\x2028)
                 (put-char p #\space)
                 (put-datum p #\x85)
                 (put-char p #\space)
                 (put-datum p #\x2028)
                 (put-char p #\space)
                 (put-datum p "\x85; \x2028;")))
             "\x85; \x2028; #\\x85 #\\x2028 \"\\x85; \\x2028;\"")
     (let ()
       (define (rw? x1)
         (let ([str (let-values ([(p e) (open-string-output-port)])
                      (write x1 p)
                      (e))])
           (let ([x2 (read (open-string-input-port str))])
             (equal? x1 x2))))
       (and (rw? "  \x85;  ")
            (rw? "  \x2028;  ")
            (rw? #\x85)
            (rw? #\x2028))))

(mat utf-16-codec
     (error? (r6rs:utf-16-codec #f))
     (error? (utf-16-codec #f))
     ; test decoding
     (let ()
       (define utf-16->string
         (lambda (eol bv)
           (let ([ip (transcoded-port
                       (let ([n (bytevector-length bv)] [i 0])
                         (make-custom-binary-input-port "foo"
                           (lambda (buf start count)
                             (let ([count (min (+ (random (min count 3)) 1) (fx- n i))])
                               (bytevector-copy! bv i buf start count)
                               (set! i (+ i count))
                               count))
                           (lambda () i)
                           (lambda (p) (set! i p))
                           #f))
                       (make-transcoder
                         (utf-16-codec)
                         eol
                         (error-handling-mode replace)))])
             (call-with-string-output-port
               (lambda (op)
                 (define (deref s)
                   (if (eof-object? s) s (string-ref s 0)))
                 (let again ()
                   (let ([c (if (= (random 5) 3)
                                (deref (get-string-n ip 1))
                                (get-char ip))])
                     (if (eof-object? c)
                         (let ([pos (port-position ip)])
                           (unless (= pos (bytevector-length bv))
                                   (errorf #f "wrong pos ~s at eof" pos)))
                         (begin (put-char op c) (again))))))))))
       (define (big bv)
         (let ([n (bytevector-length bv)])
           (let ([newbv (make-bytevector (+ n 2))])
             (bytevector-u8-set! newbv 0 #xfe)
             (bytevector-u8-set! newbv 1 #xff)
             (do ([i 0 (fx+ i 2)])
                 ((fx>= i (fx- n 1))
                  (unless (fx= i n)
                          (bytevector-u8-set! newbv
                            (fx+ i 2)
                            (bytevector-u8-ref bv i))))
                 (bytevector-u8-set! newbv
                   (fx+ i 2)
                   (bytevector-u8-ref bv i))
                 (bytevector-u8-set! newbv
                   (fx+ i 3)
                   (bytevector-u8-ref bv (fx+ i 1))))
             newbv)))
       (define (little bv)
         (let ([n (bytevector-length bv)])
           (let ([newbv (make-bytevector (+ n 2))])
             (bytevector-u8-set! newbv 0 #xff)
             (bytevector-u8-set! newbv 1 #xfe)
             (do ([i 0 (fx+ i 2)])
                 ((fx>= i (fx- n 1))
                  (unless (fx= i n)
                          (bytevector-u8-set! newbv
                            (fx+ i 2)
                            (bytevector-u8-ref bv i))))
                 (bytevector-u8-set! newbv
                   (fx+ i 2)
                   (bytevector-u8-ref bv (fx+ i 1)))
                 (bytevector-u8-set! newbv
                   (fx+ i 3)
                   (bytevector-u8-ref bv i)))
             newbv)))
       (define (test eol bv s)
         (do ([n 1000 (fx- n 1)])
             ((fx= n 0))
             (let ([seed (random-seed)])
               (unless (and (equal? (utf-16->string eol bv) s)
                            (equal? (utf-16->string eol (big bv)) s)
                            (equal? (utf-16->string eol (little bv)) s))
                       (errorf #f
                               "failed, seed = ~s, bv = ~s, s = ~s"
                               seed
                               bv
                               s)))))
       (test 'lf #vu8(#x00 #x61 #x00 #x0a) "a\n")
       (test 'lf
             #vu8(#x00 #x61 #x00 #x0d #x00 #x0a #x00 #x0d #x00 #x85 #x00
                  #x0d #x00 #x0d #x00 #x0a #x00 #x0d #x20 #x28)
             "a\n\n\n\n\n\n")
       (test 'crlf
             #vu8(#x00 #x61 #x00 #x0d #x00 #x0a #x00 #x0d #x00 #x85 #x00
                  #x0d #x00 #x0d #x00 #x0a #x00 #x0d #x20 #x28)
             "a\n\n\n\n\n\n")
       (test 'none
             #vu8(#x00 #x61 #x00 #x0d #x00 #x0a #x00 #x0d #x00 #x85 #x00
                  #x0d #x00 #x0d #x00 #x0a #x00 #x0d #x20 #x28)
             "a\r\n\r\x85;\r\r\n\r\x2028;")
       (test 'lf
             #vu8(#x00 #x0a #xd8 #x00 #xdc #x00 #xdb #xff #xdf #xff #xdc
                  #x00 #xd8 #x00 #x00 #x00 #x00)
             "\n\x10000;\x10ffff;\xfffd;\xfffd;\xfffd;")
       #t)
     ; test encoding
     (let ()
       (define string->utf-16
         (lambda (eol s)
           (let-values ([(op getbv)
                         (let-values ([(bvop getbv) (open-bytevector-output-port)])
                           (values (transcoded-port
                                     (let ([i 0])
                                       (make-custom-binary-output-port
                                         "foo"
                                         (lambda (buf start count)
                                           (let ([count (random (min (fx+ count 1) 4))])
                                             (put-bytevector bvop buf start count)
                                             (set! i
                                               (+ i count))
                                             count))
                                         (lambda () i)
                                         #f
                                         #f))
                                     (make-transcoder
                                       (utf-16be-codec)
                                       eol
                                       (error-handling-mode replace)))
                                   getbv))])
             (let ([sip (open-string-input-port s)])
               (define (deref s)
                 (if (eof-object? s) s (string-ref s 0)))
               (let again ()
                 (let ([c (get-char sip)])
                   (if (eof-object? c)
                       (let ([pos (port-position op)])
                         (close-port op)
                         (let ([bv (getbv)])
                           (unless (= pos (bytevector-length bv))
                                   (errorf #f "wrong pos ~s at eof" pos))
                           bv))
                       (begin
                         (if (= (random 5) 3)
                             (put-string op (string c))
                             (put-char op c))
                         (again)))))))))
       (define (test eol s bv)
         (do ([n 1000 (fx- n 1)])
             ((fx= n 0))
             (let ([seed (random-seed)])
               (unless (equal? (string->utf-16 eol s) bv)
                       (errorf #f
                               "failed, seed = ~s, s = ~s, bv = ~s"
                               seed
                               s
                               bv)))))
       (test 'lf "a\n" #vu8(#x00 #x61 #x00 #x0a))
       (test 'crlf "a\n" #vu8(#x00 #x61 #x00 #x0d #x00 #x0a))
       (test 'crnel "a\n" #vu8(#x00 #x61 #x00 #x0d #x00 #x85))
       (test 'nel "a\n" #vu8(#x00 #x61 #x00 #x85))
       (test 'ls "a\n" #vu8(#x00 #x61 #x20 #x28))
       (test 'none "a\r\n\r\x85;\r\r\n\r\x2028;"
             #vu8(#x00 #x61 #x00 #x0d #x00 #x0a #x00 #x0d #x00 #x85 #x00
                  #x0d #x00 #x0d #x00 #x0a #x00 #x0d #x20 #x28))
       (test 'lf "a\x10000;\x10ffff;\n"
             #vu8(#x00 #x61 #xd8 #x00 #xdc #x00 #xdb #xff #xdf #xff #x00
                  #x0a))
       #t))

(mat utf-16-BOMs
     (let ()
       (define utf-16-tx
         (make-transcoder (utf-16-codec)
           (eol-style none)
           (error-handling-mode raise)))
       (and (let ()
              (define iop
                (open-file-input/output-port "testfile.ss"
                  (file-options replace)
                  (buffer-mode block)
                  utf-16-tx))
              (define n (port-position iop))
              ; should be 0
              (put-string iop "hello\n")
              ; should write BOM
              (set-port-position! iop n)
              ; should actually position past BOM (position 2)
              (and (eqv? n 0)
                   (eqv? (port-position iop) 2)
                   (equal? (get-string-all iop) "hello\n")
                   (eq? (close-port iop) (void))))
            (let ()
              (define iop
                (open-file-input/output-port "testfile.ss"
                  (file-options no-fail no-truncate)
                  (buffer-mode block)
                  utf-16-tx))
              (define n (port-position iop))
              (and (eqv? n 0)
                   (eqv? (get-char iop) #\h)
                   (eqv? (port-position iop) 4)
                   (equal? (get-string-all iop) "ello\n")
                   (eqv? (port-position iop) 14)
                   (eq? (set-port-position! iop n) (void))
                   (eqv? (port-position iop) 2)
                   (put-string iop "something longer than hello\n")
                   (eq? (set-port-position! iop n) (void))
                   (equal? (get-string-all iop)
                           "something longer than hello\n")
                   (eq? (close-port iop) (void))))))
     (let ()
       ; same as preceding w/slightly different transcoder
       (define utf-16-tx
         (make-transcoder (utf-16-codec)
           (eol-style lf)
           (error-handling-mode replace)))
       (and (let ()
              (define iop
                (open-file-input/output-port "testfile.ss"
                  (file-options replace)
                  (buffer-mode block)
                  utf-16-tx))
              (define n (port-position iop))
              ; should be 0
              (put-string iop "hello\n")
              ; should write BOM
              (set-port-position! iop n)
              ; should actually position past BOM (position 2)
              (and (eqv? n 0)
                   (eqv? (port-position iop) 2)
                   (equal? (get-string-all iop) "hello\n")
                   (eq? (close-port iop) (void))))
            (let ()
              (define iop
                (open-file-input/output-port "testfile.ss"
                  (file-options no-fail no-truncate)
                  (buffer-mode block)
                  utf-16-tx))
              (define n (port-position iop))
              (and (eqv? n 0)
                   (equal? (get-string-all iop) "hello\n")
                   (eq? (set-port-position! iop n) (void))
                   (eqv? (port-position iop) 2)
                   (put-string iop "something longer than hello\n")
                   (eq? (set-port-position! iop n) (void))
                   (equal? (get-string-all iop)
                           "something longer than hello\n")
                   (eq? (close-port iop) (void))))))
     (let ()
       (define utf-16-tx
         (make-transcoder (utf-16-codec)
           (eol-style none)
           (error-handling-mode raise)))
       (define utf-16be-tx
         (make-transcoder (utf-16be-codec)
           (eol-style none)
           (error-handling-mode raise)))
       (and (let ()
              (define iop
                (open-file-input/output-port "testfile.ss"
                  (file-options replace)
                  (buffer-mode block)
                  utf-16-tx))
              (define n (port-position iop))
              ; should be 0
              (put-string iop "hello\n")
              ; should write BOM
              (set-port-position! iop n)
              ; should actually position past BOM (position 2)
              (and (eqv? n 0)
                   (eqv? (port-position iop) 2)
                   (equal? (get-string-all iop) "hello\n")
                   (eq? (close-port iop) (void))))
            (let ()
              (define iop
                (open-file-input/output-port "testfile.ss"
                  (file-options no-fail no-truncate)
                  (buffer-mode block)
                  utf-16-tx))
              ; lookahead-char should position port past the BOM
              (define c (lookahead-char iop))
              (define n (port-position iop))
              ; should be 2
              (and (eqv? c #\h)
                   (eqv? n 2)
                   (equal? (get-string-all iop) "hello\n")
                   (eq? (set-port-position! iop n) (void))
                   (eq? (put-string iop "something longer than hello\n")
                        (void))
                   (eq? (set-port-position! iop n) (void))
                   (equal? (get-string-all iop)
                           "something longer than hello\n")
                   (eq? (close-port iop) (void))))
            (let ()
              (define iop
                (open-file-input/output-port "testfile.ss"
                  (file-options no-fail no-truncate)
                  (buffer-mode block)
                  utf-16be-tx))
              (define n (port-position iop))
              ; should be 0
              (and (eqv? (get-char iop) #\xfeff)
                   (equal? (get-string-all iop)
                           "something longer than hello\n")
                   (eq? (set-port-position! iop n) (void))
                   (eqv? (get-char iop) #\xfeff)
                   (equal? (get-string-all iop)
                           "something longer than hello\n")
                   (eq? (close-port iop) (void))))))
     (let ()
       (define utf-16le-tx
         (make-transcoder (utf-16le-codec)
           (eol-style none)
           (error-handling-mode raise)))
       (and (let ()
              (define iop
                (open-file-input/output-port "testfile.ss"
                  (file-options replace)
                  (buffer-mode block)
                  utf-16le-tx))
              (define n (port-position iop))
              ; should be 0
              (put-string iop "hello\n")
              ; should not write BOM
              (set-port-position! iop n)
              ; should set to 0
              (and (eqv? n 0)
                   (eqv? (port-position iop) 0)
                   (equal? (get-string-all iop) "hello\n")
                   (eq? (close-port iop) (void))))
            (let ()
              (define iop
                (open-file-input/output-port "testfile.ss"
                  (file-options no-fail no-truncate)
                  (buffer-mode block)
                  utf-16le-tx))
              (define n (port-position iop))
              ; should be 0
              (and (eq? n 0)
                   (equal? (get-string-all iop) "hello\n")
                   (eq? (set-port-position! iop n) (void))
                   (eqv? (port-position iop) 0)
                   (eq? (put-string iop "something longer than hello\n")
                        (void))
                   (eq? (set-port-position! iop n) (void))
                   (eqv? (port-position iop) 0)
                   (equal? (get-string-all iop)
                           "something longer than hello\n")
                   (eq? (close-port iop) (void))))))
     (let ()
       (define utf-16be-tx
         (make-transcoder (utf-16be-codec)
           (eol-style none)
           (error-handling-mode raise)))
       (and (let ()
              (define iop
                (open-file-input/output-port "testfile.ss"
                  (file-options replace)
                  (buffer-mode block)
                  utf-16be-tx))
              (define n (port-position iop))
              ; should be 0
              (put-string iop "hello\n")
              ; should not write BOM
              (set-port-position! iop n)
              ; should set to 0
              (and (eqv? n 0)
                   (eqv? (port-position iop) 0)
                   (equal? (get-string-all iop) "hello\n")
                   (eq? (close-port iop) (void))))
            (let ()
              (define iop
                (open-file-input/output-port "testfile.ss"
                  (file-options no-fail no-truncate)
                  (buffer-mode block)
                  utf-16be-tx))
              (define n (port-position iop))
              ; should be 0
              (and (eq? n 0)
                   (equal? (get-string-all iop) "hello\n")
                   (eq? (set-port-position! iop n) (void))
                   (eqv? (port-position iop) 0)
                   (eq? (put-string iop "something longer than hello\n")
                        (void))
                   (eq? (set-port-position! iop n) (void))
                   (eqv? (port-position iop) 0)
                   (equal? (get-string-all iop)
                           "something longer than hello\n")
                   (eq? (close-port iop) (void))))))
     (let ()
       (define utf-16be-tx
         (make-transcoder (utf-16be-codec)
           (eol-style none)
           (error-handling-mode raise)))
       (define utf-16-tx
         (make-transcoder (utf-16-codec)
           (eol-style none)
           (error-handling-mode raise)))
       (and (let ()
              (define iop
                (open-file-input/output-port "testfile.ss"
                  (file-options replace)
                  (buffer-mode block)
                  utf-16be-tx))
              (define n (port-position iop))
              ; should be 0
              (put-string iop "hello\n")
              ; should not write BOM
              (set-port-position! iop n)
              ; should set to 0
              (and (eqv? n 0)
                   (eqv? (port-position iop) 0)
                   (equal? (get-string-all iop) "hello\n")
                   (eq? (close-port iop) (void))))
            (let ()
              (define iop
                (open-file-input/output-port "testfile.ss"
                  (file-options no-fail no-truncate)
                  (buffer-mode block)
                  utf-16-tx))
              (define n (port-position iop))
              ; should be 0
              (and (eq? n 0)
                   (equal? (get-string-all iop) "hello\n")
                   (eq? (set-port-position! iop n) (void))
                   (eqv? (port-position iop) 0)
                   (eq? (put-string iop "something longer than hello\n")
                        (void))
                   (eq? (set-port-position! iop n) (void))
                   (eqv? (port-position iop) 0)
                   (equal? (get-string-all iop)
                           "something longer than hello\n")
                   (eq? (close-port iop) (void))))))
     (let ()
       (define utf-16le-tx
         (make-transcoder (utf-16le-codec)
           (eol-style none)
           (error-handling-mode raise)))
       (define utf-16-tx
         (make-transcoder (utf-16-codec)
           (eol-style none)
           (error-handling-mode raise)))
       (and (let ()
              (define iop
                (open-file-input/output-port "testfile.ss"
                  (file-options replace)
                  (buffer-mode block)
                  utf-16le-tx))
              (define n0 (port-position iop))
              ; should be 0
              (put-char iop #\xfeff)
              ; insert explicit BOM
              (let ()
                (define n (port-position iop))
                ; should be 0
                (put-string iop "hello\n")
                ; should not write BOM
                (set-port-position! iop n)
                ; should set to 0
                (and (eqv? n0 0)
                     (eqv? n 2)
                     (equal? (get-string-all iop) "hello\n")
                     (eq? (close-port iop) (void)))))
            (let ()
              (define iop
                (open-file-input/output-port "testfile.ss"
                  (file-options no-fail no-truncate)
                  (buffer-mode block)
                  utf-16-tx))
              (define n (port-position iop))
              (and (equal? (get-string-all iop) "hello\n")
                   (begin
                     (set-port-position! iop n)
                     (put-string iop "hello again\n")
                     (set-port-position! iop n))
                   (and (equal? (get-string-all iop) "hello again\n")
                        (eq? (close-port iop) (void)))))
            (let ()
              (define iop
                (open-file-input/output-port "testfile.ss"
                  (file-options no-fail no-truncate)
                  (buffer-mode block)
                  utf-16le-tx))
              (define n (port-position iop))
              ; should be 0
              (and (eqv? (get-char iop) #\xfeff)
                   ; BOM should still be there
                   (equal? (get-string-all iop) "hello again\n")
                   (eq? (set-port-position! iop n) (void))
                   (eqv? (port-position iop) 0)
                   (eq? (put-string iop "hello yet again!\n") (void))
                   (eq? (set-port-position! iop n) (void))
                   (eqv? (port-position iop) 0)
                   (equal? (get-string-all iop) "hello yet again!\n")
                   ; BOM is gone now
                   (eq? (close-port iop) (void))))))
     (let ()
       (define utf-16le-tx
         (make-transcoder (utf-16le-codec)
           (eol-style none)
           (error-handling-mode raise)))
       (define faux-utf-16-tx
         (make-transcoder (utf-16-codec 'little)
           (eol-style none)
           (error-handling-mode raise)))
       (and (let ()
              (define iop
                (open-file-input/output-port "testfile.ss"
                  (file-options replace)
                  (buffer-mode block)
                  utf-16le-tx))
              (define n (port-position iop))
              ; should be 0
              (put-string iop "hello\n")
              (set-port-position! iop n)
              (and (eqv? n 0)
                   (eqv? (port-position iop) 0)
                   (equal? (get-string-all iop) "hello\n")
                   (eq? (close-port iop) (void))))
            (let ()
              (define iop
                (open-file-input/output-port "testfile.ss"
                  (file-options no-fail no-truncate)
                  (buffer-mode block)
                  faux-utf-16-tx))
              (define n (port-position iop))
              ; should be 0
              (and (eqv? n 0)
                   (equal? (get-string-all iop) "hello\n")
                   (eq? (set-port-position! iop n) (void))
                   (eqv? (port-position iop) 0)
                   (eq? (put-string iop "hello again\n") (void))
                   (eq? (set-port-position! iop n) (void))
                   (eqv? (port-position iop) 0)
                   (equal? (get-string-all iop) "hello again\n")
                   (eq? (close-port iop) (void))))
            (let ()
              (define iop
                (open-file-input/output-port "testfile.ss"
                  (file-options no-fail no-truncate)
                  (buffer-mode block)
                  utf-16le-tx))
              (define n (port-position iop))
              ; should be 0
              (and (eqv? n 0)
                   (equal? (get-string-all iop) "hello again\n")
                   (eq? (set-port-position! iop n) (void))
                   (eqv? (port-position iop) 0)
                   (eq? (put-string iop "hello yet again!\n") (void))
                   (eq? (set-port-position! iop n) (void))
                   (eqv? (port-position iop) 0)
                   (equal? (get-string-all iop) "hello yet again!\n")
                   (eq? (close-port iop) (void))))))
     (let ()
       (define-syntax and
         (let ()
           (import scheme)
           (syntax-rules ()
             [(_ e ...) (and (let ([x e]) (pretty-print x) x) ...)])))
       (define utf-16-tx
         (make-transcoder (utf-16-codec)
           (eol-style none)
           (error-handling-mode raise)))
       (and (let ()
              (define op
                (open-file-output-port "testfile.ss"
                  (file-options replace)
                  (buffer-mode block)
                  utf-16-tx))
              (define n (port-position op))
              ; should be 0
              (and (eqv? n 0)
                   (eq? (put-string op "hello\n") (void))
                   ; should write BOM
                   (eq? (set-port-position! op n) (void))
                   ; should actually position past BOM (position 2)
                   (eqv? (port-position op) 2)
                   (eq? (put-string op "not hello\n") (void))
                   ; should not write (another) BOM
                   (eq? (close-port op) (void))))
            (let ()
              (define ip
                (open-file-input-port "testfile.ss"
                  (file-options)
                  (buffer-mode block)
                  utf-16-tx))
              (define n (port-position ip))
              ; should be 0
              (define c (lookahead-char ip))
              ; should be #\n
              (and (eqv? n 0)
                   (eqv? c #\n)
                   (eqv? (port-position ip) 2)
                   (equal? (get-string-all ip) "not hello\n")
                   (eq? (set-port-position! ip 2) (void))
                   (equal? (get-string-all ip) "not hello\n")
                   (eq? (close-port ip) (void)))))))

(mat encode/decode-consistency
     ; verify that encoding/decoding is consistent (but not necessarily correct)
     ; crank up loop bounds to stress test
     (let ()
       (define (random-string n)
         (define (random-char) (integer->char (random 256)))
         (let ([s (make-string n)])
           (do ([i 0 (fx+ i 1)])
               ((fx= i n))
               (string-set! s i (random-char)))
           s))
       (define (check who s1 s2)
         (unless (string=? s1 s2)
                 (errorf who "failed for ~a"
                         (parameterize ([print-unicode #f])
                           (format "~s" s1)))))
       (time (let ([latin-1-tx
                     (make-transcoder (latin-1-codec)
                       (eol-style none)
                       (error-handling-mode raise))])
               (do ([n 1000 (fx- n 1)])
                   ((fx= n 0) #t)
                   (let ([s (random-string (random 50))])
                     (check 'latin-1-test4 s
                            (bytevector->string
                              (string->bytevector s latin-1-tx)
                              latin-1-tx)))))))
     (let ()
       (define (random-string n)
         (define (random-char)
           (integer->char
             (let ([k (random (fx- #x110000 (fx- #xe000 #xd800)))])
               (if (fx>= k #xd800)
                   (fx+ k (fx- #xe000 #xd800))
                   k))))
         (let ([s (make-string n)])
           (unless (fx= n 0)
                   ; don't let a BOM sneak in at first character
                   (string-set! s 0
                     (let f ()
                       (let ([c (random-char)])
                         (if (memv c '(#\xfeff #\xfffe))
                             (f)
                             c))))
                   (do ([i 1 (fx+ i 1)])
                       ((fx= i n))
                       (string-set! s i (random-char))))
           s))
       (define (check who s1 s2)
         (unless (string=? s1 s2)
                 (errorf who "failed for ~a"
                         (parameterize ([print-unicode #f])
                           (format "~s" s1)))))
       (time (let ()
               (define utf-8-tx
                 (make-transcoder (utf-8-codec)
                   (eol-style none)
                   (error-handling-mode raise)))
               (define utf-16-tx
                 (make-transcoder (utf-16-codec)
                   (eol-style none)
                   (error-handling-mode raise)))
               (define utf-16le-tx
                 (make-transcoder (utf-16le-codec)
                   (eol-style none)
                   (error-handling-mode raise)))
               (define utf-16be-tx
                 (make-transcoder (utf-16be-codec)
                   (eol-style none)
                   (error-handling-mode raise)))
               (do ([n 1000 (fx- n 1)])
                   ((fx= n 0) #t)
                   (let ([s (random-string (random 50))])
                     (check 'utf-8-test1 s (utf8->string (string->utf8 s)))
                     (check 'utf-8-test2 s
                            (utf8->string (string->bytevector s utf-8-tx)))
                     (check 'utf-8-test3 s
                            (bytevector->string (string->utf8 s) utf-8-tx))
                     (check 'utf-8-test4 s
                            (bytevector->string
                              (string->bytevector s utf-8-tx)
                              utf-8-tx))
                     (check 'utf-16-test1a s
                            (utf16->string (string->utf16 s 'big) 'big))
                     (check 'utf-16-test1b s
                            (utf16->string (string->utf16 s 'big) 'big #t))
                     (check 'utf-16-test2a s
                            (utf16->string
                              (string->bytevector s utf-16-tx)
                              'big))
                     (check 'utf-16-test2b s
                            (utf16->string
                              (string->bytevector s utf-16be-tx)
                              'big
                              #t))
                     (check 'utf-16-test2c s
                            (utf16->string
                              (string->bytevector s utf-16le-tx)
                              'little
                              #t))
                     (check 'utf-16-test3a s
                            (bytevector->string
                              (string->utf16 s 'big)
                              utf-16-tx))
                     (check 'utf-16-test3b s
                            (bytevector->string
                              (string->utf16 s 'big)
                              utf-16be-tx))
                     (check 'utf-16-test3c s
                            (bytevector->string
                              (string->utf16 s 'little)
                              utf-16le-tx))
                     (check 'utf-16-test4a s
                            (bytevector->string
                              (string->bytevector s utf-16-tx)
                              utf-16-tx))
                     (check 'utf-16-test4b s
                            (bytevector->string
                              (string->bytevector s utf-16le-tx)
                              utf-16le-tx))
                     (check 'utf-16-test4c s
                            (bytevector->string
                              (string->bytevector s utf-16be-tx)
                              utf-16be-tx))
                     (check 'utf-16-test5a s
                            (utf16->string (string->utf16 s 'little) 'little))
                     (check 'utf-16-test5b s
                            (utf16->string (string->utf16 s 'little) 'little #t))
                     (let* ([bv (string->bytevector s utf-16be-tx)]
                            [bvn (bytevector-length bv)]
                            [bv^ (make-bytevector (fx+ bvn 2))])
                       ; insert big-endian BOM
                       (bytevector-u8-set! bv^ 0 #xfe)
                       (bytevector-u8-set! bv^ 1 #xff)
                       (bytevector-copy! bv 0 bv^ 2 bvn)
                       (check 'utf-16-test6 s (utf16->string bv^ 'big))
                       (check 'utf-16-test7 s
                              (bytevector->string bv^ utf-16-tx)))
                     (let* ([bv (string->utf16 s 'little)]
                            [bvn (bytevector-length bv)]
                            [bv^ (make-bytevector (fx+ bvn 2))])
                       ; insert little-endian BOM
                       (bytevector-u8-set! bv^ 0 #xff)
                       (bytevector-u8-set! bv^ 1 #xfe)
                       (bytevector-copy! bv 0 bv^ 2 bvn)
                       (check 'utf-16-test8 s (utf16->string bv^ 'little))
                       (check 'utf-16-test9 s
                              (bytevector->string bv^ utf-16-tx)))
                     (check 'utf-32-test1a s
                            (utf32->string (string->utf32 s 'big) 'big))
                     (check 'utf-32-test1a s
                            (utf32->string (string->utf32 s 'big) 'big #t))
                     (check 'utf-32-test2a s
                            (utf32->string (string->utf32 s 'little) 'little))
                     (check 'utf-32-test2b s
                            (utf32->string (string->utf32 s 'little) 'little #f))))))))

(mat string<->bytevector-conversions
     ; adapted with minor modifications from bv2string.sch, which is:
     ;
     ; Copyright 2007 William D Clinger.
     ;
     ; Permission to copy this software, in whole or in part, to use this
     ; software for any lawful purpose, and to redistribute this software
     ; is granted subject to the restriction that all copies made of this
     ; software must include this copyright notice in full.
     ;
     ; I also request that you send me a copy of any improvements that you
     ; make to this software so that they may be incorporated within it to
     ; the benefit of the Scheme community.
     (begin
       (library (bv2string)
         (export main)
         (import (rnrs base)
           (rnrs unicode)
           (rename (rnrs bytevectors)
             (utf8->string rnrs:utf8->string)
             (string->utf8 rnrs:string->utf8))
           (rnrs control)
           (rnrs io simple)
           (rnrs mutable-strings))

         ; Crude test rig, just for benchmarking.

         (define utf8->string)
         (define string->utf8)

         (define (test name actual expected)
           (if (not (equal? actual expected))
               (error 'test name)))

         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
         ;
         ; The R6RS doesn't specify exactly how many replacement
         ; characters get generated by an encoding or decoding error,
         ; so the results of some tests are compared by treating any
         ; sequence of consecutive replacement characters the same as
         ; a single replacement character.
         ;
         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

         (define (string~? s1 s2)
           (define (replacement? c) (char=? c #\xfffd))
           (define (canonicalized s)
             (let loop ((rchars (reverse (string->list s))) (cchars '()))
               (cond
                 ((or (null? rchars) (null? (cdr rchars)))
                  (list->string cchars))
                 ((and (replacement? (car rchars))
                       (replacement? (cadr rchars)))
                  (loop (cdr rchars) cchars))
                 (else
                  (loop (cdr rchars) (cons (car rchars) cchars))))))
           (string=? (canonicalized s1) (canonicalized s2)))

         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
         ;
         ; Basic sanity tests, followed by stress tests on random inputs.
         ;
         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

         (define (string-bytevector-tests
                   *random-stress-tests*
                   *random-stress-test-max-size*)

           (define (test-roundtrip bvec tostring tobvec)
             (let* ((s1 (tostring bvec))
                    (b2 (tobvec s1))
                    (s2 (tostring b2)))
               (test "round trip of string conversion" (string=? s1 s2) #t)))

           ; This random number generator doesn't have to be good.
           ; It just has to be fast.

           (define random
             (letrec ((random14 (lambda (n)
                                  (set! x
                                    (mod (+ (* a x) c) (+ m 1)))
                                  (mod (div x 8) n)))
                      (a 701)
                      (x 1)
                      (c 743483)
                      (m 524287)
                      (loop (lambda (q r n)
                              (if (zero? q)
                                  (mod r n)
                                  (loop (div q 16384)
                                        (+ (* 16384 r) (random14 16384))
                                        n)))))
               (lambda (n)
                 (if (< n 16384)
                     (random14 n)
                     (loop (div n 16384) (random14 16384) n)))))
           ; Returns a random bytevector of length up to n.

           (define (random-bytevector n)
             (let* ((n (random n)) (bv (make-bytevector n)))
               (do ((i 0 (+ i 1)))
                   ((= i n) bv)
                   (bytevector-u8-set! bv i (random 256)))))

           ; Returns a random bytevector of even length up to n.

           (define (random-bytevector2 n)
             (let* ((n (random n))
                    (n (if (odd? n) (+ n 1) n))
                    (bv (make-bytevector n)))
               (do ((i 0 (+ i 1)))
                   ((= i n) bv)
                   (bytevector-u8-set! bv i (random 256)))))

           ; Returns a random bytevector of multiple-of-4 length up to n.

           (define (random-bytevector4 n)
             (let* ((n (random n))
                    (n (* 4 (round (/ n 4))))
                    (bv (make-bytevector n)))
               (do ((i 0 (+ i 1)))
                   ((= i n) bv)
                   (bytevector-u8-set! bv i (random 256)))))

           (test "utf-8, BMP"
                 (bytevector=?
                   (string->utf8 "k\x007f;\x0080;\x07ff;\x0800;\xffff;")
                   '#vu8(#x6b #x7f #b11000010 #b10000000 #b11011111
                         #b10111111 #b11100000 #b10100000 #b10000000
                         #b11101111 #b10111111 #b10111111))
                 #t)

           (test "utf-8, supplemental"
                 (bytevector=? (string->utf8 "\x010000;\x10ffff;")
                   '#vu8(#b11110000 #b10010000 #b10000000 #b10000000
                         #b11110100 #b10001111 #b10111111 #b10111111))
                 #t)

           (test "utf-8, errors 1"
                 (string~? (utf8->string
                             '#vu8(#x61 ; a
                                   #xc0 #x62 ; ?b
                                   #xc1 #x63 ; ?c
                                   #xc2 #x64 ; ?d
                                   #x80 #x65 ; ?e
                                   #xc0 #xc0 #x66 ; ??f
                                   #xe0 #x67 ; ?g
                                   
                                   ))
                           "a\xfffd;b\xfffd;c\xfffd;d\xfffd;e\xfffd;\xfffd;f\xfffd;g")
                 #t)

           (test "utf-8, errors 2"
                 (string~? (utf8->string
                             '#vu8(#xe0 #x80 #x80 #x68 ; ???h
                                   #xe0 #xc0 #x80 #x69 ; ???i
                                   #xf0 #x6a ; ?j
                                   
                                   ))
                           "\xfffd;\xfffd;\xfffd;h\xfffd;\xfffd;\xfffd;i\xfffd;j")
                 #t)

           (test "utf-8, errors 3"
                 (string~? (utf8->string
                             '#vu8(#x61 ; a
                                   #xf0 #x80 #x80 #x80 #x62 ; ????b
                                   #xf0 #x90 #x80 #x80 #x63 ; .c
                                   
                                   ))
                           "a\xfffd;\xfffd;\xfffd;\xfffd;b\x10000;c")
                 #t)

           (test "utf-8, errors 4"
                 (string~? (utf8->string
                             '#vu8(#x61 ; a
                                   #xf0 #xbf #xbf #xbf #x64 ; .d
                                   #xf0 #xbf #xbf #x65 ; ?e
                                   #xf0 #xbf #x66 ; ?f
                                   
                                   ))
                           "a\x3ffff;d\xfffd;e\xfffd;f")
                 #t)

           (test "utf-8, errors 5"
                 (string~? (utf8->string
                             '#vu8(#x61 ; a
                                   #xf4 #x8f #xbf #xbf #x62 ; .b
                                   #xf4 #x90 #x80 #x80 #x63 ; ????c
                                   
                                   ))

                           "a\x10ffff;b\xfffd;\xfffd;\xfffd;\xfffd;c")
                 #t)

           (test "utf-8, errors 6"
                 (string~? (utf8->string
                             '#vu8(#x61 ; a
                                   #xf5 #x80 #x80 #x80 #x64 ; ????d
                                   
                                   ))

                           "a\xfffd;\xfffd;\xfffd;\xfffd;d")
                 #t)

           ; ignores BOM signature
           ; Officially, there is no BOM signature for UTF-8,
           ; so this test is commented out.

           #;
           (test "utf-8, BOM"
                 (string=? (utf8->string
                             '#vu8(#xef #xbb #xbf #x61 #x62 #x63 #x64))
                           "abcd")
                 #t)

           (test-roundtrip
             (random-bytevector 10)
             utf8->string
             string->utf8)

           (do ((i 0 (+ i 1)))
               ((= i *random-stress-tests*))
               (test-roundtrip
                 (random-bytevector *random-stress-test-max-size*)
                 utf8->string
                 string->utf8))

           (test "utf-16, BMP"
                 (bytevector=?
                   (string->utf16 "k\x007f;\x0080;\x07ff;\x0800;\xffff;")
                   '#vu8(#x00 #x6b #x00 #x7f #x00 #x80 #x07 #xff #x08 #x00
                         #xff #xff))
                 #t)

           (test "utf-16le, BMP"
                 (bytevector=?
                   (string->utf16
                     "k\x007f;\x0080;\x07ff;\x0800;\xffff;"
                     'little)
                   '#vu8(#x6b #x00 #x7f #x00 #x80 #x00 #xff #x07 #x00 #x08
                         #xff #xff))
                 #t)

           (test "utf-16, supplemental"
                 (bytevector=? (string->utf16 "\x010000;\xfdcba;\x10ffff;")
                   '#vu8(#xd8 #x00 #xdc #x00 #xdb #xb7 #xdc #xba #xdb #xff
                         #xdf #xff))
                 #t)

           (test "utf-16le, supplemental"
                 (bytevector=?
                   (string->utf16 "\x010000;\xfdcba;\x10ffff;" 'little)
                   '#vu8(#x00 #xd8 #x00 #xdc #xb7 #xdb #xba #xdc #xff #xdb
                         #xff #xdf))
                 #t)

           (test "utf-16be"
                 (bytevector=?
                   (string->utf16 "ab\x010000;\xfdcba;\x10ffff;cd")
                   (string->utf16 "ab\x010000;\xfdcba;\x10ffff;cd" 'big))
                 #t)

           (test "utf-16, errors 1"
                 (string~? "k\x007f;\x0080;\x07ff;\x0800;\xffff;"
                           (utf16->string
                             '#vu8(#x00 #x6b #x00 #x7f #x00 #x80 #x07 #xff
                                   #x08 #x00 #xff #xff)
                             'big))
                 #t)

           (test "utf-16, errors 2"
                 (string~? "k\x007f;\x0080;\x07ff;\x0800;\xffff;"
                   (utf16->string
                     '#vu8(#x00 #x6b #x00 #x7f #x00 #x80 #x07 #xff #x08 #x00
                           #xff #xff)
                     'big
                     #t))
                 #t)

           (test "utf-16, errors 3"
                 (string~? "k\x007f;\x0080;\x07ff;\x0800;\xffff;"
                   (utf16->string
                     '#vu8(#xfe #xff ; big-endian BOM
                           #x00 #x6b #x00 #x7f #x00 #x80 #x07 #xff #x08 #x00
                           #xff #xff)
                     'big))
                 #t)

           (test "utf-16, errors 4"
                 (string~? "k\x007f;\x0080;\x07ff;\x0800;\xffff;"
                   (utf16->string
                     '#vu8(#x6b #x00 #x7f #x00 #x80 #x00 #xff #x07 #x00 #x08
                           #xff #xff)
                     'little
                     #t))
                 #t)

           (test "utf-16, errors 5"
                 (string~? "k\x007f;\x0080;\x07ff;\x0800;\xffff;"
                   (utf16->string
                     '#vu8(#xff #xfe ; little-endian BOM
                           #x6b #x00 #x7f #x00 #x80 #x00 #xff #x07 #x00 #x08
                           #xff #xff)
                     'big))
                 #t)

           (let ((tostring (lambda (bv) (utf16->string bv 'big)))
                 (tostring-big (lambda (bv) (utf16->string bv 'big #t)))
                 (tostring-little
                   (lambda (bv)
                     (utf16->string bv 'little #t)))
                 (tobvec string->utf16)
                 (tobvec-big (lambda (s) (string->utf16 s 'big)))
                 (tobvec-little (lambda (s) (string->utf16 s 'little))))

             (do ((i 0 (+ i 1)))
                 ((= i *random-stress-tests*))
                 (test-roundtrip
                   (random-bytevector2 *random-stress-test-max-size*)
                   tostring
                   tobvec)
                 (test-roundtrip
                   (random-bytevector2 *random-stress-test-max-size*)
                   tostring-big
                   tobvec-big)
                 (test-roundtrip
                   (random-bytevector2 *random-stress-test-max-size*)
                   tostring-little
                   tobvec-little)))

           (test "utf-32"
                 (bytevector=? (string->utf32 "abc")
                   '#vu8(#x00 #x00 #x00 #x61 #x00 #x00 #x00 #x62 #x00 #x00
                         #x00 #x63))
                 #t)

           (test "utf-32be"
                 (bytevector=? (string->utf32 "abc" 'big)
                   '#vu8(#x00 #x00 #x00 #x61 #x00 #x00 #x00 #x62 #x00 #x00
                         #x00 #x63))
                 #t)

           (test "utf-32le"
                 (bytevector=? (string->utf32 "abc" 'little)
                   '#vu8(#x61 #x00 #x00 #x00 #x62 #x00 #x00 #x00 #x63 #x00
                         #x00 #x00))
                 #t)

           (test "utf-32, errors 1"
                 (string~? "a\xfffd;b\xfffd;c\xfffd;d\xfffd;e"
                   (utf32->string
                     '#vu8(#x00 #x00 #x00 #x61 #x00 #x00 #xd9 #x00 #x00 #x00
                           #x00 #x62 #x00 #x00 #xdd #xab #x00 #x00 #x00 #x63
                           #x00 #x11 #x00 #x00 #x00 #x00 #x00 #x64 #x01 #x00
                           #x00 #x65 #x00 #x00 #x00 #x65)
                     'big))
                 #t)

           (test "utf-32, errors 2"
                 (string~? "a\xfffd;b\xfffd;c\xfffd;d\xfffd;e"
                   (utf32->string
                     '#vu8(#x00 #x00 #x00 #x61 #x00 #x00 #xd9 #x00 #x00 #x00
                           #x00 #x62 #x00 #x00 #xdd #xab #x00 #x00 #x00 #x63
                           #x00 #x11 #x00 #x00 #x00 #x00 #x00 #x64 #x01 #x00
                           #x00 #x65 #x00 #x00 #x00 #x65)
                     'big
                     #t))
                 #t)

           (test "utf-32, errors 3"
                 (string~? "a\xfffd;b\xfffd;c\xfffd;d\xfffd;e"
                   (utf32->string
                     '#vu8(#x00 #x00 #xfe #xff ; big-endian BOM
                           #x00 #x00 #x00 #x61 #x00 #x00 #xd9 #x00 #x00 #x00
                           #x00 #x62 #x00 #x00 #xdd #xab #x00 #x00 #x00 #x63
                           #x00 #x11 #x00 #x00 #x00 #x00 #x00 #x64 #x01 #x00
                           #x00 #x65 #x00 #x00 #x00 #x65)
                     'big))
                 #t)

           (test "utf-32, errors 4"
                 (string~? "\xfeff;a\xfffd;b\xfffd;c\xfffd;d\xfffd;e"
                   (utf32->string
                     '#vu8(#x00 #x00 #xfe #xff ; big-endian BOM
                           #x00 #x00 #x00 #x61 #x00 #x00 #xd9 #x00 #x00 #x00
                           #x00 #x62 #x00 #x00 #xdd #xab #x00 #x00 #x00 #x63
                           #x00 #x11 #x00 #x00 #x00 #x00 #x00 #x64 #x01 #x00
                           #x00 #x65 #x00 #x00 #x00 #x65)
                     'big
                     #t))
                 #t)

           (test "utf-32, errors 5"
                 (string~? "a\xfffd;b\xfffd;c\xfffd;d\xfffd;e"
                   (utf32->string
                     '#vu8(#x61 #x00 #x00 #x00 #x00 #xd9 #x00 #x00 #x62 #x00
                           #x00 #x00 #xab #xdd #x00 #x00 #x63 #x00 #x00 #x00
                           #x00 #x00 #x11 #x00 #x64 #x00 #x00 #x00 #x65 #x00
                           #x00 #x01 #x65 #x00 #x00 #x00)
                     'little
                     #t))
                 #t)

           (test "utf-32, errors 6"
                 (string~? "a\xfffd;b\xfffd;c\xfffd;d\xfffd;e"
                   (utf32->string
                     '#vu8(#xff #xfe #x00 #x00 ; little-endian BOM
                           #x61 #x00 #x00 #x00 #x00 #xd9 #x00 #x00 #x62 #x00
                           #x00 #x00 #xab #xdd #x00 #x00 #x63 #x00 #x00 #x00
                           #x00 #x00 #x11 #x00 #x64 #x00 #x00 #x00 #x65 #x00
                           #x00 #x01 #x65 #x00 #x00 #x00)
                     'big))
                 #t)

           (test "utf-32, errors 7"
                 (string~? "\xfeff;a\xfffd;b\xfffd;c\xfffd;d\xfffd;e"
                   (utf32->string
                     '#vu8(#xff #xfe #x00 #x00 ; little-endian BOM
                           #x61 #x00 #x00 #x00 #x00 #xd9 #x00 #x00 #x62 #x00
                           #x00 #x00 #xab #xdd #x00 #x00 #x63 #x00 #x00 #x00
                           #x00 #x00 #x11 #x00 #x64 #x00 #x00 #x00 #x65 #x00
                           #x00 #x01 #x65 #x00 #x00 #x00)
                     'little
                     #t))
                 #t)

           (let ((tostring (lambda (bv) (utf32->string bv 'big)))
                 (tostring-big (lambda (bv) (utf32->string bv 'big #t)))
                 (tostring-little
                   (lambda (bv)
                     (utf32->string bv 'little #t)))
                 (tobvec string->utf32)
                 (tobvec-big (lambda (s) (string->utf32 s 'big)))
                 (tobvec-little (lambda (s) (string->utf32 s 'little))))

             (do ((i 0 (+ i 1)))
                 ((= i *random-stress-tests*))
                 (test-roundtrip
                   (random-bytevector4 *random-stress-test-max-size*)
                   tostring
                   tobvec)
                 (test-roundtrip
                   (random-bytevector4 *random-stress-test-max-size*)
                   tostring-big
                   tobvec-big)
                 (test-roundtrip
                   (random-bytevector4 *random-stress-test-max-size*)
                   tostring-little
                   tobvec-little)))
           )

         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
         ;
         ; Exhaustive tests.
         ;
         ; Tests string <-> bytevector conversion on strings
         ; that contain every Unicode scalar value.
         ;
         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

         (define (exhaustive-string-bytevector-tests)

           ; Tests throughout an inclusive range.

           (define (test-char-range lo hi tostring tobytevector)
             (let* ((n (+ 1 (- hi lo)))
                    (s (make-string n))
                    (replacement-character (integer->char #xfffd)))
               (do ((i lo (+ i 1)))
                   ((> i hi))
                   (let ((c (if (or (<= 0 i #xd7ff) (<= #xe000 i #x10ffff))
                                (integer->char i)
                                replacement-character)))
                     (string-set! s (- i lo) c)))
               (test "test of long string conversion"
                     (string=? (tostring (tobytevector s)) s)
                     #t)))

           (define (test-exhaustively name tostring tobytevector)
             ;(display "Testing ")
             ;(display name)
             ;(display " conversions...")
             ;(newline)
             (test-char-range 0 #xffff tostring tobytevector)
             (test-char-range #x10000 #x1ffff tostring tobytevector)
             (test-char-range #x20000 #x2ffff tostring tobytevector)
             (test-char-range #x30000 #x3ffff tostring tobytevector)
             (test-char-range #x40000 #x4ffff tostring tobytevector)
             (test-char-range #x50000 #x5ffff tostring tobytevector)
             (test-char-range #x60000 #x6ffff tostring tobytevector)
             (test-char-range #x70000 #x7ffff tostring tobytevector)
             (test-char-range #x80000 #x8ffff tostring tobytevector)
             (test-char-range #x90000 #x9ffff tostring tobytevector)
             (test-char-range #xa0000 #xaffff tostring tobytevector)
             (test-char-range #xb0000 #xbffff tostring tobytevector)
             (test-char-range #xc0000 #xcffff tostring tobytevector)
             (test-char-range #xd0000 #xdffff tostring tobytevector)
             (test-char-range #xe0000 #xeffff tostring tobytevector)
             (test-char-range #xf0000 #xfffff tostring tobytevector)
             (test-char-range #x100000 #x10ffff tostring tobytevector))

           ; Feel free to replace this with your favorite timing macro.

           (define (timeit x) x)

           (timeit (test-exhaustively "UTF-8" utf8->string string->utf8))

           ; NOTE:  An unfortunate misunderstanding led to a late deletion
           ; of single-argument utf16->string from the R6RS.  To get the
           ; correct effect of single-argument utf16->string, you have to
           ; use two arguments, as below.
           ;
           ;(timeit (test-exhaustively "UTF-16" utf16->string string->utf16))

           (timeit (test-exhaustively "UTF-16"
                     (lambda (bv) (utf16->string bv 'big))
                     string->utf16))

           ; NOTE:  To get the correct effect of two-argument utf16->string,
           ; you have to use three arguments, as below.

           (timeit (test-exhaustively "UTF-16BE"
                     (lambda (bv)
                       (utf16->string bv 'big #t))
                     (lambda (s) (string->utf16 s 'big))))

           (timeit (test-exhaustively "UTF-16LE"
                     (lambda (bv)
                       (utf16->string bv 'little #t))
                     (lambda (s) (string->utf16 s 'little))))

           ; NOTE:  An unfortunate misunderstanding led to a late deletion
           ; of single-argument utf32->string from the R6RS.  To get the
           ; correct effect of single-argument utf32->string, you have to
           ; use two arguments, as below.
           ;
           ;(timeit (test-exhaustively "UTF-32" utf32->string string->utf32))

           (timeit (test-exhaustively "UTF-32"
                     (lambda (bv) (utf32->string bv 'big))
                     string->utf32))

           ; NOTE:  To get the correct effect of two-argument utf32->string,
           ; you have to use three arguments, as below.

           (timeit (test-exhaustively "UTF-32BE"
                     (lambda (bv)
                       (utf32->string bv 'big #t))
                     (lambda (s) (string->utf32 s 'big))))

           (timeit (test-exhaustively "UTF-32LE"
                     (lambda (bv)
                       (utf32->string bv 'little #t))
                     (lambda (s) (string->utf32 s 'little)))))

         (define (main p1 p2)
           (set! utf8->string p1)
           (set! string->utf8 p2)
           (string-bytevector-tests 2 1000)
           (exhaustive-string-bytevector-tests)))
       #t)
     ; first test w/built-in utf8->string and string->utf8
     (begin
       (let ()
         (import (bv2string))
         (main utf8->string string->utf8))
       #t)
     ; next test w/utf8->string and string->utf8 synthesized from utf-8-codec
     (let ()
       (define (utf8->string bv)
         (get-string-all
           (open-bytevector-input-port bv
             (make-transcoder (utf-8-codec) 'none))))
       (define (string->utf8 s)
         (let-values
           ([(op get)
             (open-bytevector-output-port
               (make-transcoder (utf-8-codec) 'none))])
           (put-string op s)
           (get)))
       (let ()
         (import (bv2string))
         (main utf8->string string->utf8))
       #t))

(mat open-process-ports
     ; see also unix.ms (mat nonblocking ...)
     (begin
       (define ($check-port p xput-port? bt-port?)
         (define-syntax err?
           (syntax-rules ()
             [(_ e1 e2 ...) (guard (c [#t #t]) e1 e2 ... #f)]))
         (unless (and (xput-port? p) (bt-port? p) (file-port? p))
                 (errorf #f "~s is not as it should be" p))
         (let ([fd (port-file-descriptor p)])
           (unless (fixnum? fd)
                   (errorf #f "unexpected file descriptor ~s" fd)))
         (when (or (port-has-port-position? p)
                   (port-has-set-port-position!? p)
                   (port-has-port-length? p)
                   (port-has-set-port-length!? p))
               (errorf #f "unexpected port-has-xxx results for ~s" p))
         (unless (and (err? (port-position p))
                      (err? (set-port-position! p 0))
                      (err? (port-length p))
                      (err? (set-port-length! p 0)))
                 (errorf #f
                         "no error for getting/setting port position/length on ~s"
                         p)))
       (define $emit-dot
         (let ([n 0])
           (lambda ()
             (display ".")
             (set! n (modulo (+ n 1) 72))
             (when (= n 0) (newline))
             (flush-output-port))))
       #t)
     ; test binary ports
     (let-values ([(to-stdin from-stdout from-stderr pid)
                   (open-process-ports (patch-exec-path $cat_flush))])
       (define put-string
         (lambda (bp s)
           (put-bytevector bp (string->utf8 s))))
       (define get-string-some
         (lambda (bp)
           (let ([x (get-bytevector-some bp)])
             (if (eof-object? x) x (utf8->string x)))))
       (define get-string-n
         (lambda (bp n)
           (let ([x (get-bytevector-n bp n)])
             (if (eof-object? x) x (utf8->string x)))))
       (dynamic-wind void
         (lambda ()
           (put-string to-stdin "life in the fast lane\n")
           (flush-output-port to-stdin)
           (let f ()
             ($check-port to-stdin output-port? binary-port?)
             ($check-port from-stdout input-port? binary-port?)
             ($check-port from-stderr input-port? binary-port?)
             (when (input-port-ready? from-stderr)
                   (errorf #f "input ready on from-stderr ~s"
                           (get-string-some from-stderr)))
             (if (input-port-ready? from-stdout)
                 (let ([s (get-string-n from-stdout 10)])
                   (unless (equal? s "life in th")
                           (errorf #f "unexpected from-stdout string ~s" s)))
                 (begin ($emit-dot) (f))))
           (let f ([all ""])
             (unless (equal? all "e fast lane\n")
                     (when (input-port-ready? from-stderr)
                           (errorf #f "input ready on from-stderr ~s"
                                   (get-string-some from-stderr)))
                     (let ([s (get-string-some from-stdout)])
                       ($emit-dot)
                       (f (string-append all s)))))
           (and (not (input-port-ready? from-stderr))
                (not (input-port-ready? from-stdout))
                (begin
                  (close-port to-stdin)
                  (let f ()
                    (unless (and (port-eof? from-stdout)
                                 (port-eof? from-stderr))
                            ($emit-dot)
                            (f)))
                  #t)))
         (lambda ()
           (close-port to-stdin)
           (close-port from-stdout)
           (close-port from-stderr))))
     ; test binary ports w/buffer-mode none
     (let-values ([(to-stdin from-stdout from-stderr pid)
                   (open-process-ports (patch-exec-path $cat_flush)
                     (buffer-mode none))])
       (define put-string
         (lambda (bp s)
           (put-bytevector bp (string->utf8 s))))
       (define get-string-some
         (lambda (bp)
           (let ([x (get-bytevector-some bp)])
             (if (eof-object? x) x (utf8->string x)))))
       (define get-string-n
         (lambda (bp n)
           (let ([x (get-bytevector-n bp n)])
             (if (eof-object? x) x (utf8->string x)))))
       (dynamic-wind void
         (lambda ()
           ($check-port to-stdin output-port? binary-port?)
           ($check-port from-stdout input-port? binary-port?)
           ($check-port from-stderr input-port? binary-port?)
           (put-string to-stdin "life in the fast lane\n")
           (flush-output-port to-stdin)
           (let f ()
             (when (input-port-ready? from-stderr)
                   (errorf #f "input ready on from-stderr ~s"
                           (get-string-some from-stderr)))
             (if (input-port-ready? from-stdout)
                 (let ([s (get-string-n from-stdout 10)])
                   (unless (equal? s "life in th")
                           (errorf #f "unexpected from-stdout string ~s" s)))
                 (begin ($emit-dot) (f))))
           (let f ([all ""])
             (unless (equal? all "e fast lane\n")
                     (when (input-port-ready? from-stderr)
                           (errorf #f "input ready on from-stderr ~s"
                                   (get-string-some from-stderr)))
                     (let ([s (get-string-some from-stdout)])
                       ($emit-dot)
                       (f (string-append all s)))))
           (and (not (input-port-ready? from-stderr))
                (not (input-port-ready? from-stdout))
                (begin
                  (close-port to-stdin)
                  (let f ()
                    (unless (and (port-eof? from-stdout)
                                 (port-eof? from-stderr))
                            ($emit-dot)
                            (f)))
                  #t)))
         (lambda ()
           (close-port to-stdin)
           (close-port from-stdout)
           (close-port from-stderr))))
     ; test textual ports
     (let-values ([(to-stdin from-stdout from-stderr pid)
                   (open-process-ports (patch-exec-path $cat_flush)
                     (buffer-mode block)
                     (native-transcoder))])
       (dynamic-wind void
         (lambda ()
           ($check-port to-stdin output-port? textual-port?)
           ($check-port from-stdout input-port? textual-port?)
           ($check-port from-stderr input-port? textual-port?)
           (put-string to-stdin "life in the fast lane\n")
           (flush-output-port to-stdin)
           (let f ()
             (when (input-port-ready? from-stderr)
                   (errorf #f "input ready on from-stderr ~s"
                           (get-string-some from-stderr)))
             (if (input-port-ready? from-stdout)
                 (let ([s (get-string-n from-stdout 10)])
                   (unless (equal? s "life in th")
                           (errorf #f "unexpected from-stdout string ~s" s)))
                 (begin ($emit-dot) (f))))
           (let f ([all ""])
             (unless (equal? all "e fast lane\n")
                     (when (input-port-ready? from-stderr)
                           (errorf #f "input ready on from-stderr ~s"
                                   (get-string-some from-stderr)))
                     (let ([s (get-string-some from-stdout)])
                       ($emit-dot)
                       (f (string-append all s)))))
           (and (not (input-port-ready? from-stderr))
                (not (input-port-ready? from-stdout))
                (begin
                  (close-port to-stdin)
                  (let f ()
                    (unless (and (port-eof? from-stdout)
                                 (port-eof? from-stderr))
                            ($emit-dot)
                            (f)))
                  #t)))
         (lambda ()
           (close-port to-stdin)
           (close-port from-stdout)
           (close-port from-stderr))))
     ; test textual ports w/buffer-mode none
     (let-values ([(to-stdin from-stdout from-stderr pid)
                   (open-process-ports (patch-exec-path $cat_flush)
                     (buffer-mode none)
                     (native-transcoder))])
       (dynamic-wind void
         (lambda ()
           ($check-port to-stdin output-port? textual-port?)
           ($check-port from-stdout input-port? textual-port?)
           ($check-port from-stderr input-port? textual-port?)
           (put-string to-stdin "life in the fast lane\n")
           (flush-output-port to-stdin)
           (let f ()
             (when (input-port-ready? from-stderr)
                   (errorf #f "input ready on from-stderr ~s"
                           (get-string-some from-stderr)))
             (if (input-port-ready? from-stdout)
                 (let ([s (get-string-n from-stdout 10)])
                   (unless (equal? s "life in th")
                           (errorf #f "unexpected from-stdout string ~s" s)))
                 (begin ($emit-dot) (f))))
           (let f ([all ""])
             (unless (equal? all "e fast lane\n")
                     (when (input-port-ready? from-stderr)
                           (errorf #f "input ready on from-stderr ~s"
                                   (get-string-some from-stderr)))
                     (let ([s (get-string-some from-stdout)])
                       ($emit-dot)
                       (f (string-append all s)))))
           (and (not (input-port-ready? from-stderr))
                (not (input-port-ready? from-stdout))
                (begin
                  (close-port to-stdin)
                  (let f ()
                    (unless (and (port-eof? from-stdout)
                                 (port-eof? from-stderr))
                            ($emit-dot)
                            (f)))
                  #t)))
         (lambda ()
           (close-port to-stdin)
           (close-port from-stdout)
           (close-port from-stderr))))
     ; test textual ports w/buffer-mode line
     (let-values ([(to-stdin from-stdout from-stderr pid)
                   (open-process-ports (patch-exec-path $cat_flush)
                     (buffer-mode line)
                     (native-transcoder))])
       (dynamic-wind void
         (lambda ()
           ($check-port to-stdin output-port? textual-port?)
           ($check-port from-stdout input-port? textual-port?)
           ($check-port from-stderr input-port? textual-port?)
           (put-string to-stdin "life in the fast lane\n")
           (flush-output-port to-stdin)
           (let f ()
             (when (input-port-ready? from-stderr)
                   (errorf #f "input ready on from-stderr ~s"
                           (get-string-some from-stderr)))
             (if (input-port-ready? from-stdout)
                 (let ([s (get-string-n from-stdout 10)])
                   (unless (equal? s "life in th")
                           (errorf #f "unexpected from-stdout string ~s" s)))
                 (begin ($emit-dot) (f))))
           (let f ([all ""])
             (unless (equal? all "e fast lane\n")
                     (when (input-port-ready? from-stderr)
                           (errorf #f "input ready on from-stderr ~s"
                                   (get-string-some from-stderr)))
                     (let ([s (get-string-some from-stdout)])
                       ($emit-dot)
                       (f (string-append all s)))))
           (and (not (input-port-ready? from-stderr))
                (not (input-port-ready? from-stdout))
                (begin
                  (close-port to-stdin)
                  (let f ()
                    (unless (and (port-eof? from-stdout)
                                 (port-eof? from-stderr))
                            ($emit-dot)
                            (f)))
                  #t)))
         (lambda ()
           (close-port to-stdin)
           (close-port from-stdout)
           (close-port from-stderr)))))

(mat to-fold-or-not-to-fold
     (begin
       (define ($readit cs? s)
         (define (string-append* s1 . ls)
           (let f ([s1 s1] [ls ls] [n 0])
             (let ([n1 (string-length s1)])
               (if (null? ls)
                   (let ([s (make-string (fx+ n n1))])
                     (string-copy! s1 0 s n n1)
                     s)
                   (let ([s (f (car ls) (cdr ls) (fx+ n n1 1))])
                     (string-copy! s1 0 s n n1)
                     (string-set! s (fx+ n n1) #\$)
                     s)))))
         (apply string-append*
           (let ([sip (open-input-string s)])
             (parameterize ([case-sensitive cs?])
               (let f ()
                 (let ([x (get-datum sip)])
                   (if (eof-object? x)
                       '()
                       (cons (cond
                               [(gensym? x)
                                (string-append
                                  (symbol->string x)
                                  "%"
                                  (gensym->unique-string x))]
                               [(symbol? x) (symbol->string x)]
                               [(char? x) (string x)]
                               [else
                                (error 'string-append* "unexpected ~s" x)])
                             (f)))))))))
       #t)
     (case-sensitive)
     (equal? ($readit #t "To be or NOT to bE") "To$be$or$NOT$to$bE")
     (equal? ($readit #f "To be or NOT to bE") "to$be$or$not$to$be")
     (equal? ($readit #t "To be #!no-fold-case or NOT #!fold-case to bE")
             "To$be$or$NOT$to$be")
     (equal? ($readit #t "To be #!fold-case or NOT #!no-fold-case to bE")
             "To$be$or$not$to$bE")
     (equal? ($readit #f "To be #!no-fold-case or NOT #!fold-case to bE")
             "to$be$or$NOT$to$be")
     (equal? ($readit #f "To be #!fold-case or NOT #!no-fold-case to bE")
             "to$be$or$not$to$bE")
     ; check delimiting
     (equal? ($readit #f "To be#!fold-caseor NOT#!no-fold-caseto bE")
             "to$be$or$not$to$bE")
     ; verify case folding is not disabled when Unicode hex escape seen
     (equal? ($readit #t "ab\\x43;de") "abCde")
     (equal? ($readit #f "ab\\x43;de") "abcde")
     (equal? ($readit #t "#!fold-case ab\\x43;de") "abcde")
     (equal? ($readit #f "#!fold-case ab\\x43;de") "abcde")
     (equal? ($readit #t "#!no-fold-case ab\\x43;de") "abCde")
     (equal? ($readit #f "#!no-fold-case ab\\x43;de") "abCde")
     ; verify case folding still works when string changes size
     (equal? ($readit #t
                      "Stra\xDF;e #!no-fold-case Stra\xDF;e #!fold-case Stra\xDF;e")
             "Stra\xDF;e$Stra\xDF;e$strasse")
     (equal? ($readit #f
                      "Stra\xDF;e #!no-fold-case Stra\xDF;e #!fold-case Stra\xDF;e")
             "strasse$Stra\xDF;e$strasse")
     (equal? ($readit #t
                      "Stra\xDF;e #!fold-case Stra\xDF;e #!no-fold-case Stra\xDF;e")
             "Stra\xDF;e$strasse$Stra\xDF;e")
     (equal? ($readit #f
                      "Stra\xDF;e #!fold-case Stra\xDF;e #!no-fold-case Stra\xDF;e")
             "strasse$strasse$Stra\xDF;e")
     (equal? ($readit #t "Aa|b C|dE abC|D e|Fg \\#Ab\\ C a\\B\\ cd")
             "Aab CdE$abCD eFg$#Ab C$aB cd")
     ; verify case folding is disabled when vertical bars or backslashes
     ; (other than those for Unicode hex escapes) appear
     (equal? ($readit #f "Aa|b C|dE abC|D e|Fg \\#Ab\\ C a\\B\\ cd")
             "Aab CdE$abCD eFg$#Ab C$aB cd")
     (equal? ($readit #t
                      "#!fold-case Aa|b C|dE abC|D e|Fg \\#Ab\\ C a\\B\\ cd")
             "Aab CdE$abCD eFg$#Ab C$aB cd")
     (equal? ($readit #f
                      "#!fold-case Aa|b C|dE abC|D e|Fg \\#Ab\\ C a\\B\\ cd")
             "Aab CdE$abCD eFg$#Ab C$aB cd")
     (equal? ($readit #t
                      "#!no-fold-case Aa|b C|dE abC|D e|Fg \\#Ab\\ C a\\B\\ cd")
             "Aab CdE$abCD eFg$#Ab C$aB cd")
     (equal? ($readit #f
                      "#!no-fold-case Aa|b C|dE abC|D e|Fg \\#Ab\\ C a\\B\\ cd")
             "Aab CdE$abCD eFg$#Ab C$aB cd")
     ; verify proper case folding for gensyms
     (equal? ($readit #t "#{aBc DeF1}") "aBc%DeF1")
     (equal? ($readit #f "#{aBc DeF2}") "abc%def2")
     (equal? ($readit #t "#!fold-case #{aBc DeF3}") "abc%def3")
     (equal? ($readit #f "#!fold-case #{aBc DeF4}") "abc%def4")
     (equal? ($readit #t "#!no-fold-case #{aBc DeF5}") "aBc%DeF5")
     (equal? ($readit #f "#!no-fold-case #{aBc DeF6}") "aBc%DeF6")
     (equal? ($readit #t "#{aBc De\\F7}") "aBc%DeF7")
     (equal? ($readit #f "#{aBc De\\F8}") "abc%DeF8")
     (equal? ($readit #t "#!fold-case #{aBc De\\F9}") "abc%DeF9")
     (equal? ($readit #f "#!fold-case #{aBc De\\F10}") "abc%DeF10")
     (equal? ($readit #t "#!no-fold-case #{aBc De\\F11}") "aBc%DeF11")
     (equal? ($readit #f "#!no-fold-case #{aBc De\\F12}") "aBc%DeF12")
     (equal? ($readit #t "#{a\\Bc DeF13}") "aBc%DeF13")
     (equal? ($readit #f "#{a\\Bc DeF14}") "aBc%def14")
     (equal? ($readit #t "#!fold-case #{a\\Bc DeF15}") "aBc%def15")
     (equal? ($readit #f "#!fold-case #{a\\Bc DeF16}") "aBc%def16")
     (equal? ($readit #t "#!no-fold-case #{a\\Bc DeF17}") "aBc%DeF17")
     (equal? ($readit #f "#!no-fold-case #{a\\Bc DeF18}") "aBc%DeF18")
     (equal? ($readit #t "#{a\\Bc De\\F19}") "aBc%DeF19")
     (equal? ($readit #f "#{a\\Bc De\\F20}") "aBc%DeF20")
     (equal? ($readit #t "#!fold-case #{a\\Bc De\\F21}") "aBc%DeF21")
     (equal? ($readit #f "#!fold-case #{a\\Bc De\\F22}") "aBc%DeF22")
     (equal? ($readit #t "#!no-fold-case #{a\\Bc De\\F23}") "aBc%DeF23")
     (equal? ($readit #f "#!no-fold-case #{a\\Bc De\\F24}") "aBc%DeF24")
     (equal? ($readit #t "#\\newline") "\n")
     (equal? ($readit #f "#\\newline") "\n")
     (equal? ($readit #f "#!fold-case #\\newline") "\n")
     (equal? ($readit #f "#!fold-case #\\newline") "\n")
     (equal? ($readit #f "#!no-fold-case #\\newline") "\n")
     (equal? ($readit #f "#!no-fold-case #\\newline") "\n")
     (error? ($readit #t "#\\newLine"))
     (equal? ($readit #f "#\\newLine") "\n")
     (equal? ($readit #t "#!fold-case #\\newLine") "\n")
     (equal? ($readit #f "#!fold-case #\\newLine") "\n")
     (error? ($readit #t "#!no-fold-case #\\newLine"))
     (error? ($readit #f "#!no-fold-case #\\newLine")))
;;; format.ms
;;; Copyright 1984-2017 Cisco Systems, Inc.
;;; 
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;; 
;;; http://www.apache.org/licenses/LICENSE-2.0
;;; 
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

; need some for printf and fprintf
; need some when string is not known at compile time
; need some when number of args is not known at compile time, e.g.,
;    (apply format "hi ~s" args)
; construct testing mechanism that gives us all of these from a
; single set of directives
; need some tabulate tests

(mat format-errors
     (error? (format "hi ~s"))
     (error? (format "hi ~s" 'a 'b))
     (error? (format "hi ~"))
     (error? (format "hi ~23"))
     (error? (format "hi ~23@"))
     (error? (format "hi ~@"))
     (error? (format 7 "hi ~@"))
     (error? (format "~@%"))
     (error? (format "~@c%"))
     (error? (format "~c" 3))
     (error? (format "~@~"))
     (error? (format "~@@s"))
     (error? (format "~@3"))
     (error? (format "~q"))
     (error? (format "~,,,-3:d" (expt 2 100)))
     (error? (format "~,,-3,3e" -3.14159))
     (error? (printf 'hello "there"))
     (error? (fprintf 'not-a-port "~a ~s" 17 34))
     (error? (format 'not-a-string-port-or-boolean "~a ~s" 17 34))
     (error? (format "bad~\rdirective")))

(mat format-continuation
     ; like slib tests, but with \r\n for DOS
     (equal? (format "abc~\r\n    123") "abc123")
     (equal? (format "abc~\r\n   ") "abc")
     (equal? (format "abc~:\r\n   def") "abc   def")
     (equal? (format "abc~@\r\n   def") "abc\ndef"))

(mat format-plain
     (equal? (format "") "")
     (equal? (format "a") "a")
     (equal? (format "ab") "ab")
     (equal? (format "ab~%cd") "ab\ncd")
     (equal? (format "ab\ncd") "ab\ncd")
     (equal? (format "a\nb\ncc\nddd\neeee") "a\nb\ncc\nddd\neeee")
     (equal? (format "a~&b~%cc~&ddd~%eeee") "a\nb\ncc\nddd\neeee")
     (equal? (format "a\nb\ncc\nddd\neeee\n") "a\nb\ncc\nddd\neeee\n")
     (equal? (format "a~%b~&cc~%ddd~&eeee\n") "a\nb\ncc\nddd\neeee\n")
     (equal? (format "\na\nb\ncc\nddd\neeee") "\na\nb\ncc\nddd\neeee")
     (equal? (format "~%a~&b~%cc~&ddd~%eeee") "\na\nb\ncc\nddd\neeee")
     (equal? (format "\na\nb\ncc\nddd\neeee\n") "\na\nb\ncc\nddd\neeee\n")
     (equal? (format "~%a~%b~&cc~%ddd~&eeee\n") "\na\nb\ncc\nddd\neeee\n"))

(mat format-object
     (equal? (format "hi ~s" "a") "hi \"a\"")
     (equal? (format "hi ~10s" "a") "hi \"a\"       ")
     (equal? (format "hi ~10@s" "a") "hi        \"a\"")
     (equal? (format "~10,3,2,'$@s" 345) "$$$$$$$$345")
     (equal? (format "~10,3,2,'$@s" 3456) "$$$$$$$$3456")
     (equal? (format "~10,3,2,'$@s" 34567) "$$$$$34567")
     (equal? (format "~10,3,2,'$@s" 345678) "$$$$$345678")
     (equal? (format "~10,3,2,'$@s" 3456789) "$$$$$3456789")
     (equal? (format "~10,3,2,'$@s" 34567890) "$$34567890")
     (equal? (format "~10,3,2,'$@s" 345678901) "$$345678901")
     (equal? (format "~10,3,2,'$@s" 3456789012) "$$3456789012")
     (equal? (format "~7,,4,a~3%~10,3,,'#@s" "hello" 345)
             "hello    \n\n\n#########345")
     (equal? (format "~:s" '#{g0 ymnnefx976kvhp9-a}) "g0")
     (equal? (format "~s" '#{g0 ymnnefx976kvhp9-a})
             "#{g0 ymnnefx976kvhp9-a}")
     (equal? (format "~,,2@s" 345678901) "  345678901")
     (equal? (format "~,,2s" 345678901) "345678901  "))

(mat format-char
     (equal? (format "~c" #\a) "a")
     (equal? (format "~c" #\space) " ")
     (equal? (format "~:c" #\a) "a")
     (equal? (format "~:c" #\space) "<space>")
     (equal? (format "~:c" #\034) "^\\")
     (equal? (format "~:c" #\003) "^C")
     (equal? (format "~@c" #\a) "#\\a")
     (equal? (format "~@c" #\space) "#\\space")
     (equal? (format "~:@c" #\a) "a")
     (equal? (format "~:@c" #\space) "<space>")
     (equal? (format "~:@c" #\034) "^\\")
     (equal? (format "~:@c" #\003) "^C")
     (equal? (format "~@:c" #\a) "a")
     (equal? (format "~@:c" #\space) "<space>")
     (equal? (format "~@:c" #\034) "^\\")
     (equal? (format "~@:c" #\003) "^C"))

(mat format-plural
     (error? (format "abc~:p" 1))
     (error? (format "abc~:p"))
     (error? (format "abc~:@p"))
     (error? (format "abc~:p~s" 2))
     (error? (format "abc~:@p~s" 2))
     (equal? (format "~s abc~:p" 1) "1 abc")
     (equal? (format "~s abc~:p" 2) "2 abcs")
     (equal? (format "~s abc~:p" 1.0) "1.0 abcs")
     (equal? (format "~s abc~:p" 'one) "one abcs")
     (equal? (format "abc~p" 1) "abc")
     (equal? (format "abc~p" 2) "abcs")
     (equal? (format "abc~p" 'kumquat) "abcs")
     (equal? (format "abc~@p" 1) "abcy")
     (equal? (format "abc~@p" 'kumquat) "abcies")
     (equal? (format "~s~@:p" 1) "1y")
     (equal? (format "~s~@:p" 2) "2ies"))

(mat format-convert-case
     (error? (format "~23:(abc)"))
     (error? (format "~,:(abc)"))
     (error? (format "~(abc" #|)|#
       ))
     (error? (format "~:(abc)"))
     (error? (format #|(|# "abc~)"))
     (error? (format "~(~r ~(~a~)~) ~:@(~a)" 1621 "piNK" "bLuE"))
     (equal? (format "~(AbC 123A DEF g~)") "abc 123a def g")
     (equal? (format "~:(AbC 123A DEF g~)") "Abc 123a Def G")
     (equal? (format "~@(AbC 123A DEF g~)") "Abc 123a def g")
     (equal? (format "~:@(AbC 123A DEF g~)") "ABC 123A DEF G")
     (equal? (format "~@:(AbC 123A DEF g~)") "ABC 123A DEF G")
     (equal? (format "~@:(~r ~a~) ~a" 1621 "piNK" "bLuE")
             "SIXTEEN HUNDRED TWENTY-ONE PINK bLuE")
     (equal? (format "~:@(~r ~a~) ~a" 1621 "piNK" "bLuE")
             "SIXTEEN HUNDRED TWENTY-ONE PINK bLuE")
     (equal? (format "~@(~r ~a~) ~a" 1621 "piNK" "bLuE")
             "Sixteen hundred twenty-one pink bLuE")
     (equal? (format "~:(~r ~a~) ~a" 1621 "piNK" "bLuE")
             "Sixteen Hundred Twenty-One Pink bLuE")
     (equal? (format "~(~r ~a~) ~a" 1621 "piNK" "bLuE")
             "sixteen hundred twenty-one pink bLuE")
     (equal? (format "~(~r ~(~a~)~) ~a" 1621 "piNK" "bLuE")
             "sixteen hundred twenty-one pink bLuE")
     (equal? (format "~(~r ~(~a~)~) ~:@(~a~)" 1621 "piNK" "bLuE")
             "sixteen hundred twenty-one pink BLUE")

     ; cltl2 tests
     (equal? (format "~@R ~(~@R~)" 14 14) "XIV xiv")
     (begin
       (define $f
         (lambda (n)
           (format "~@(~R~) error~:P detected." n)))
       (procedure? $f))
     (equal? ($f 0) "Zero errors detected.")
     (equal? ($f 1) "One error detected.")
     (equal? ($f 23) "Twenty-three errors detected."))

(mat format-indirect
     (error? (format "~?" 3))
     (error? (format "~@?" 3))
     (error? (format "~?" "abc"))
     (error? (format "~?" "~a" 4))
     (error? (format "~?" "~a" '()))
     ;  (error? (format "~@?" "abc" '())) ; too many args
     (error? (format "~@?" "~(abc" #|)|#
       ))
     (error? (format "~@?" "~:?"))
     (equal? (format "==> ~? <==" "~a" '(5)) "==> 5 <==")
     (equal? (format "<~@?>" "abc") "<abc>")
     (equal? (format "~:(<~@?>~)" "abc") "<Abc>")
     (equal? (format "<~@?>" "~:@(abc~)") "<ABC>")
     (equal? (format "<~@?>" "~r ~a" 101 "dalmations")
             "<one hundred one dalmations>")
     (equal? (format "<~?~a>" "~r ~a" '(101 "dalmations") "!!!")
             "<one hundred one dalmations!!!>")
     (equal? (format "<~?>" "[~?]" '("(~?)" ("~a" (3)))) "<[(3)]>")
     (equal? (format "<~@?>" "[~@?]" "(~@?)" "~a" 3) "<[(3)]>")
     (error? (format "<~@?>" "[~@?]" "(~@?)" "~a"))
     ;  (error? (format "<~@?>" "[~@?]" "(~@?)" "~a" 3 4)) ; too many args
     ;  (error? (format "<~?>" "[~?]" '("(~?)" ("~a" (3 4))))) ; too many args
     ;  (error? (format "<~?>" "[~?]" '("(~?)" ("~a" (3) 4)))) ; too many args

     ; cltl2 tests
     (equal? (format "~? ~d" "<~a ~d>" '("Foo" 5) 7) "<Foo 5> 7")

     ; cltl2 doesn't want us to complain about too many arguments
     (equal? (format "~? ~d" "<~a ~d>" '("Foo" 5 14) 7) "<Foo 5> 7")

     (equal? (format "~@? ~D" "<~A ~D>" "Foo" 5 7) "<Foo 5> 7")
     (equal? (format "~@? ~D" "<~A ~D>" "Foo" 5 14 7) "<Foo 5> 14")

     (begin
       (define (format-error ctl-index ctl-string string . args)
         (format "~?~%~v@tv~%~3@t\"~a\"~%"
                 string
                 args
                 (+ ctl-index 3)
                 ctl-string))
       (procedure? format-error))
     (equal? (format-error
               16
               "The item is a ~[Foo~;Bar~;Loser~]."
               "ERROR: The argument to the format ~s command must be a number."
               "~[")
             "ERROR: The argument to the format \"~[\" command must be a number.\n                   v\n   \"The item is a ~[Foo~;Bar~;Loser~].\"\n"))

(mat format-conditional/at
     (error? (format "~@[abc~;def~]"))
     (error? (format "~@[abc]"))
     (error? (format #|(|# "~@[abc~)"))
     (equal? (format "<~@[[in ~s]~]>" #f) "<>")
     (equal? (format "<~@[[in ~s]~]>" 'foo) "<[in foo]>")
     ;  (error? (format "<~@[[hey!]~]>" 'foo)) ; too many args
     (equal? (format "<~@[~]> ~s" #t) "<> #t")
     (error? (format "<~@[~]> ~s" #f)))

(mat format-conditional/colon
     (error? (format "~:[abc~:;def~]"))
     (error? (format "~:[abc]"))
     (error? (format #|(|# "~:[abc~)"))
     (equal? (format "<~:[abc~;def~]>" #f) "<abc>")
     (equal? (format "<~:[abc~;def~]>" #t) "<def>")
     (error? (format "<~:[abc~;def~;ghi~]>"))
     (equal? (format "<~:[abc~;~a~]>" #f) "<abc>")
     (equal? (format "<~:[abc~;~a~]>" #t 'yow!) "<yow!>")
     (equal? (format "<~:[abc~;~:*~a~]>" #t) "<#t>")
     (error? (format "<~:[abc~;~a~]>" #t))
     (error? (format "<~:[abc~]>" #f)))

(mat format-conditional
     (error? (format "~[abc~:;def~;ghi~]"))
     (error? (format "~[abc]"))
     (error? (format #|(|# "~[abc~)"))
     (equal? (format "<~[abc~;def~]>" 0) "<abc>")
     (equal? (format "<~[abc~;def~]>" 1) "<def>")
     (equal? (format "<~[abc~;def~]>" -15) "<>")
     (equal? (format "<~[abc~;def~:;ghi~]>" 0) "<abc>")
     (equal? (format "<~[abc~;def~:;ghi~]>" 1) "<def>")
     (equal? (format "<~[abc~;def~:;ghi~]>" 2) "<ghi>")
     (equal? (format "<~[abc~;def~:;ghi~]>" 'huh?) "<ghi>")
     (equal? (format "+++~[~s~;~r ~s~]---" 52) "+++---")
     ;  (error? (format "+++~[~s~;~r ~s~]---" 52 23)) ; too many args
     ;  (error? (format "+++~[~s~;~@r~s~]---" 52 23 '*)) ; too many args
     (equal? (format "+++~[~s~;~r ~s~]---" 0 23) "+++23---")
     (error? (format "+++~[~s~;~r ~s~]---" 0))
     (equal? (format "+++~[~s~;~@r~s~]---" 1 23 '*) "+++XXIII*---")
     (error? (format "+++~[~s~;~@r~s~]---" 1 23))
     (equal? (format "+++~[~]---" 1) "+++---"))

(mat format-tabulate
     (error? (format "~-7t***"))
     (error? (format "~8,'xt"))
     (error? (format "~8,-3t"))
     (error? (format "~8,5,4t"))
     (error? (format "~-7@t***"))
     (error? (format "~8,'x@t"))
     (error? (format "~8,-3@t"))
     (error? (format "~8,5,4@t"))
     (equal? (format "~t***") " ***")
     (equal? (format "x~t***") "x ***")
     (equal? (format "~,3t***") " ***")
     (equal? (format "xxxx~,3t***") "xxxx   ***")
     (equal? (format "xxxx~1,3t***") "xxxx   ***")
     (equal? (format "~0t***") " ***")
     (equal? (format "~1t***") " ***")
     (equal? (format "~2t***") "  ***")
     (equal? (format "~7t***") "       ***")
     (equal? (format "~0,0t***") "***")
     (equal? (format "~1,0t***") " ***")
     (equal? (format "~2,0t***") "  ***")
     (equal? (format "~7,0t***") "       ***")
     (equal? (format "~0,8t***") "        ***")
     (equal? (format "~1,8t***") " ***")
     (equal? (format "~2,8t***") "  ***")
     (equal? (format "~7,8t***") "       ***")
     (equal? (format "~8,8t***") "        ***")
     (equal? (format "~9,8t***") "         ***")
     (equal? (format "x~0t***") "x ***")
     (equal? (format "x~1t***") "x ***")
     (equal? (format "x~2t***") "x ***")
     (equal? (format "x~7t***") "x      ***")
     (equal? (format "x~0,0t***") "x***")
     (equal? (format "x~1,0t***") "x***")
     (equal? (format "x~2,0t***") "x ***")
     (equal? (format "x~7,0t***") "x      ***")
     (equal? (format "x~0,8t***") "x       ***")
     (equal? (format "x~1,8t***") "x        ***")
     (equal? (format "x~2,8t***") "x ***")
     (equal? (format "x~7,8t***") "x      ***")
     (equal? (format "x~8,8t***") "x       ***")
     (equal? (format "x~9,8t***") "x        ***")
     (equal? (format "xxx~7,0@tyyy") "xxx       yyy")
     (equal? (format "xxx~7,1@tyyy") "xxx       yyy")
     (equal? (format "xxx~7,8@tyyy") "xxx             yyy"))

(mat format-justify
     (equal? (format "~<ab~^c~>") "")
     ; not checking to make sure ~^ is at front of segment
     (equal? (format "~<abc~>") "abc")
     (equal? (format "~:@<abc~>") "abc")
     (equal? (format "~,,1,'*:@<abc~>") "*abc*")
     (equal? (format "~10<abc~>") "       abc")
     (equal? (format "~10:<abc~>") "       abc")
     (equal? (format "~10@<abc~>") "abc       ")
     (equal? (format "~10:@<abc~>") "    abc   ")
     (equal? (format "~,8<abc~>") "     abc")
     (equal? (format "~,8<abc~;def~;ghi~>") "abc    def   ghi")
     (equal? (format "~7,8<abc~;def~;ghi~>") "abc   def   ghi")
     (equal? (format "~7,8:<abc~;def~;ghi~>") "  abc  def  ghi")
     (equal? (format "~7,8@<abc~;def~;ghi~>") "abc  def  ghi  ")
     (equal? (format "~7,8:@<abc~;def~;ghi~>") "  abc def  ghi ")
     (equal? (format "~&~7,8:@<abc~;def~;ghi~>~&~&") "  abc def  ghi \n")
     (equal? (format "~7,8,5,'*<abc~;def~;ghi~>")
             "abc*******def*******ghi")
     (equal? (format "~5,8,4,'*:@<abc~;def~;ghi~>")
             "*****abc*****def*****ghi*****")
     (equal? (format "~1,8,4,'*:@<abc~;def~;ghi~>")
             "****abc****def****ghi****")
     (equal? (format "~,,4,'*:@<abc~;def~;ghi~>")
             "****abc****def****ghi****")
     (equal? (format "~7,8,5,'*<~%~,10:;abc~;def~;ghi~>")
             "\nabc*******def*******ghi")
     (equal? (format "~7,8,5,'*<~&~,10:;abc~;def~;ghi~>")
             "abc*******def*******ghi")
     (equal? (format "~7,8,5,'*<~%~,25:;abc~;def~;ghi~>")
             "abc*******def*******ghi")
     (equal? (format "~7,8,5,'*<~%~2,25:;abc~;def~;ghi~>")
             "abc*******def*******ghi")
     (equal? (format "~7,8,5,'*<~%~3,25:;abc~;def~;ghi~>")
             "\nabc*******def*******ghi")
     (equal? (format "~7,8,5,'*<~%~:;abc~;def~;ghi~>")
             "abc*******def*******ghi")
     (equal? (format "~72,,,'-<~%~:;abc~;def~;ghi~>")
             "abc--------------------------------def-------------------------------ghi")
     (equal? (format "~73,,,'-<~%~:;abc~;def~;ghi~>")
             "\nabc--------------------------------def--------------------------------ghi")
     (equal? (format "~73,,,'-:@<~%~:;abc~;def~;ghi~>")
             "\n----------------abc----------------def----------------ghi----------------")
     (equal? (format "~10<~^~a~;~^~a~>" "abc" "def") "abc    def")
     (equal? (format "~10<~^~a~;~^~a~>" "abc") "       abc")
     (equal? (format "~10<~^~a~;~^~a~>") "          ")
     (equal? (format "~10<~^~a~,9:;~a~;~a~>" "\n" "1" "2") "\n1        2")
     (equal? (format "~10<~^~a~,9:;~a~;~a~>") "          ")
     (equal? (format "~10<~^~a~,9:;~a~;~^~a~>" "\n" "1" "2")
             "\n1        2")
     (equal? (format "~10<~^~a~,9:;~a~;~^~a~;~a~>" "\n" "1" "2" "3")
             "\n1    2   3")
     (error? (format "~10<~^~a~,9:;~a~;~^~a~;~a~>" "\n" "1" "2"))
     (equal? (format "~10<~^~a~,9:;~a~;~^~a~;~a~>" "\n" "1")
             "\n         1")
     (error? (format "~10<~^~a~,9:;~a~;~^~a~;~a~>" "\n"))
     (equal? (format "~10<~^~a~,9:;~a~;~^~a~;~a~>") "          ")
     (error? (format "~10<~^~a~,9:;~a~;~a~:^~;~a~>" "\n"))
     (error? (format "~10<~^~a~,9:;~a~;~^~^~a~;~a~>" "\n"))
     (error? (format "~10<~^~a~,9:;~a~;~a~@^~;~a~>" "\n" "1"))
     (error? (format "~10<~(abc~>def~)"))
     (equal? (format "~10<~@:(abc~)~;~@(def~)~>") "ABC    Def")
     (equal? (format "~(~10<~a~;~x~>~)" "PiEs" 221) "pies    dd")
     (equal? (format "~13<~s~;~s~;~s~>" 3.4 4.5 5.6) "3.4  4.5  5.6")
     (equal? (format "~16<~f~;~e~;~g~>" 3.4 4.5 5.6) "3.4  4.5e+0  5.6")

     ; test nested ~<...~>
     (equal? (format "~20<abc~;d~5<e~;f~>g~>") "abc          de   fg")

     ; from cltl2:
     (equal? (format "~10<foo~;bar~>") "foo    bar")
     (equal? (format "~10:<foo~;bar~>") "  foo  bar")
     (equal? (format "~10<foobar~>") "    foobar")
     (equal? (format "~10:<foobar~>") "    foobar")
     (equal? (format "~10:@<foo~;bar~>") "  foo bar ")
     (equal? (format "~10@<foobar~>") "foobar    ")
     (equal? (format "~10:@<foobar~>") "  foobar  ")
     (equal? (format "~%;; ~{~<~%;; ~1:; ~s~>~^,~}.~%" '(a b c))
             "\n;;  a, b, c.\n")
     (equal? (format "~%;; ~{~<~%;; ~1:; ~s~>~^,~}.~%"
               '(list-procedure
                  stack
                  $system-environment
                  $active-threads
                  #{source yqrk281einmw7sg-a}
                  $c-info
                  placeholder
                  make-record-type
                  join-subst
                  trace-let
                  set-top-level-value!
                  integer?
                  error
                  result
                  make-resolved-interface
                  single->double
                  word
                  eleven
                  clear-input-port
                  reverse!
                  eighteen
                  zero
                  write-radix-commas?
                  symbol-value
                  exact->inexact
                  subst!
                  type
                  $apply-procedure
                  loop/p
                  write-radix-sign?))
             "\n;;  list-procedure, stack, $system-environment, $active-threads,\n;;  #{source yqrk281einmw7sg-a}, $c-info, placeholder, make-record-type,\n;;  join-subst, trace-let, set-top-level-value!, integer?, error,\n;;  result, make-resolved-interface, single->double, word, eleven,\n;;  clear-input-port, reverse!, eighteen, zero, write-radix-commas?,\n;;  symbol-value, exact->inexact, subst!, type, $apply-procedure,\n;;  loop/p, write-radix-sign?.\n")
     (equal? (format "~%;; ~{~<~%;; ~1,50:; ~s~>~^,~}.~%"
               '(list-procedure
                  stack
                  $system-environment
                  $active-threads
                  #{source yqrk281einmw7sg-a}
                  $c-info
                  placeholder
                  make-record-type
                  join-subst
                  trace-let
                  set-top-level-value!
                  integer?
                  error
                  result
                  make-resolved-interface
                  single->double
                  word
                  eleven
                  clear-input-port
                  reverse!
                  eighteen
                  zero
                  write-radix-commas?
                  symbol-value
                  exact->inexact
                  subst!
                  type
                  $apply-procedure
                  loop/p
                  write-radix-sign?))
             "\n;;  list-procedure, stack, $system-environment,\n;;  $active-threads, #{source yqrk281einmw7sg-a},\n;;  $c-info, placeholder, make-record-type,\n;;  join-subst, trace-let, set-top-level-value!,\n;;  integer?, error, result,\n;;  make-resolved-interface, single->double, word,\n;;  eleven, clear-input-port, reverse!, eighteen,\n;;  zero, write-radix-commas?, symbol-value,\n;;  exact->inexact, subst!, type,\n;;  $apply-procedure, loop/p, write-radix-sign?.\n")
     (equal? (format "~&;; ~{~<~%~&;; ~1:; ~s~>~^,~}.~&"
               '(list-procedure
                  stack
                  $system-environment
                  $active-threads
                  #{source yqrk281einmw7sg-a}
                  $c-info
                  placeholder
                  make-record-type
                  join-subst
                  trace-let
                  set-top-level-value!
                  integer?
                  error
                  result
                  make-resolved-interface
                  single->double
                  word
                  eleven
                  clear-input-port
                  reverse!
                  eighteen
                  zero
                  write-radix-commas?
                  symbol-value
                  exact->inexact
                  subst!
                  type
                  $apply-procedure
                  loop/p
                  write-radix-sign?))
             ";;  list-procedure, stack, $system-environment, $active-threads,\n;;  #{source yqrk281einmw7sg-a}, $c-info, placeholder, make-record-type,\n;;  join-subst, trace-let, set-top-level-value!, integer?, error,\n;;  result, make-resolved-interface, single->double, word, eleven,\n;;  clear-input-port, reverse!, eighteen, zero, write-radix-commas?,\n;;  symbol-value, exact->inexact, subst!, type, $apply-procedure,\n;;  loop/p, write-radix-sign?.\n")
     (equal? (format "~15<~s~;~^~s~;~^~s~>" 'foo) "            foo")
     (equal? (format "~15<~s~;~^~s~;~^~s~>" 'foo 'bar) "foo         bar")
     (equal? (format "~15<~s~;~^~s~;~^~s~>" 'foo 'bar 'baz)
             "foo   bar   baz"))

(mat format-iterate
     (error? (format "~{abc~:~}"))
     ; ~ directive has no : flag
     (error? (format "~{abc~;~}"))
     ; misplaced directive "~;"

     ; ~{...}
     (error? (format "~{|~s~}"))
     ; too few args
     ;  (error? (format "~{|~s~}" '() "$")) ; too many args
     (equal? (format "~{|~s~}" '()) "")
     (equal? (format "~a~{|~s~}~a" "^" '(a b c) "$") "^|a|b|c$")
     (equal? (format "~a~{|~s~:}~a" "^" '(a b c) "$") "^|a|b|c$")
     (equal? (format "~a~{abc~:}~a" "^" '() "$") "^abc$")
     (equal? (format "~a~2{|~s~:}~a" "^" '(a b c) "$") "^|a|b$")
     (error? (format "~a~2{|~s~:}~a" "^" '() "$"))
     ; too few args
     (equal? (format "+~{<~s~^~s>~}+~{<~s~^~s>~}+" '(a b c d) '(a b c))
             "+<ab><cd>+<ab><c+")
     (equal? (format "+~{<~s~:^~s>~}+~{<~s~^~s>~}+" '(a b c d) '(a b c))
             "+<ab><cd>+<ab><c+")
     (error? (format "+~{<~s~:^~s>~}+~{<~s~:^~s>~}+" '(a b c d) '(a b c)))
     ; too few args
     (equal? (format "~a~{~}~a"
                     "^"
                     "+~{<~s~^~s>~}+"
                     '((a b c d) (a b c) () (a))
                     "$")
             "^+<ab><cd>++<ab><c++++<a+$")
     (error? (format "~a~{~}~a"
                     "^"
                     "+~{<~s~s>~}+"
                     '((a b c d) (a b c) () (a))
                     "$"))
     ; too few args for "+~{<~s~s>~}+"

     ; ~:{...}
     (error? (format "~:{|~s~}"))
     ; too few args
     ;  (error? (format "~:{|~s~}" '() "$")) ; too many args
     (equal? (format "~:{|~s~}" '()) "")
     (equal? (format "~a~:{|~s~}~a" "^" '((a) (b) (c)) "$") "^|a|b|c$")
     (equal? (format "~a~:{|~s~:}~a" "^" '((a) (b) (c)) "$") "^|a|b|c$")
     (equal? (format "~a~:{abc~:}~a" "^" '() "$") "^abc$")
     (equal? (format "~a~2:{|~s~:}~a" "^" '((a) (b) (c)) "$") "^|a|b$")
     (equal? (format "~:{<~s~^~s>~:}" '((a b) (c) (e f))) "<ab><c<ef>")
     (equal? (format "~:{<~s~:^~s>~:}" '((a b) (c d) (e f))) "<ab><cd><e")
     (equal? (format "~a~:{~}~a" "^" "<~s~:^~s>" '() "$") "^$")
     (error? (format "~a~:{~}~a" "^" "<~s~:^~s>" '(a b) "$"))
     ; a is not a pair
     (equal? (format "~a~:{~}~a" "^" "<~s~^~s>" '((a b)) "$") "^<ab>$")
     (equal? (format "~a~:{~}~a" "^" "<~s~:^~s>" '((a b)) "$") "^<a$")
     ;  (error? (format "~a~:{~}~a" "^" "<~s~^~s>" '((a b c)) "$")) ; too many args for "<~s~^~s>"

     (equal? (format "~a~:{~}~a" "^" "<~s~^~s>" '((a b) (c)) "$")
             "^<ab><c$")
     (error? (format "~a~:{~}~a" "^" "<~s~:^~s>" '((a b) (c) (d e)) "$"))
     ; too few args for "<~s~:^~s>" 
     (equal? (format "~a~:{~}~a" "^" "<~s~:^~s>" '((a b) (c d)) "$")
             "^<ab><c$")

     (equal? (format "~:{~}" "~s" '()) "")
     (error? (format "~:{~}" "~s" '(())))
     ; too few args for "~s"
     (error? (format "~:{~}" "~s" '(a b)))
     ; a is not a list
     ;  (error? (format "~:{~}" "~s" '((a b)))) ; too many args for "~s"
     (error? (format "~:{~s~:}" '()))
     ; too few args
     (error? (format "~:{~s~}" '(a b)))
     ; a is not a list
     ;  (error? (format "~:{|~s~}" '((a b)))) ; too many args

     ; ~@{...}
     (equal? (format "~@{|~s~}") "")
     (equal? (format "~@{|~s~}" 'a 'b 'c) "|a|b|c")
     (equal? (format "~@{|~s~:}" '(a) '(b) '(c)) "|(a)|(b)|(c)")
     (equal? (format "~@{abc~:}") "abc")
     (equal? (format "~2@{|~s~:}~s" 'a 'b 'c) "|a|bc")
     (error? (format "~2@{|~s~:}"))
     ; too few args
     (equal? (format "~@{<~s~^~s>~}" 'a 'b 'c 'd) "<ab><cd>")
     (equal? (format "~@{<~s~^~s>~}" 'a 'b 'c 'd 'e) "<ab><cd><e")
     (equal? (format "~@{<~s~:^~s>~}" 'a 'b 'c 'd) "<ab><cd>")
     (error? (format "~@{<~s~:^~s>~}" 'a 'b 'c 'd 'e))
     ; too few args

     ; ~@:{...}
     (equal? (format "~@:{|~s~}") "")
     (equal? (format "~@:{|~s~}" '(a) '(b) '(c)) "|a|b|c")
     (equal? (format "~@:{|~s~:}" '(a) '(b) '(c)) "|a|b|c")
     (equal? (format "~@:{abc~:}") "abc")
     (equal? (format "~2@:{|~s~:}~s" '(a) '(b) '(c)) "|a|b(c)")
     (equal? (format "~@:{<~s~^~s>~:}" '(a b) '(c) '(e f)) "<ab><c<ef>")
     (equal? (format "~@:{<~s~:^~s>~:}" '(a b) '(c d) '(e f)) "<ab><cd><e")
     (equal? (format "~@:{~:}" "<~s~:^~s>" '(a b) '(c d) '(e f))
             "<ab><cd><e")
     (error? (format "~@:{~}" "~s" '()))
     ;  (error? (format "~@:{~}" "~s" '(a b))) ; too many args
     (error? (format "~@:{~s~}" '()))
     ;  (error? (format "~@:{~s~}" '(a b))) ; too many args
     (error? (format "~:@{|~s~}" 'a 'b 'c))
     ; a is not a list

     ; ~{...~} tests from cltl2
     (equal? (format "The winners are:~{ ~S~}." '(fred harry jill))
             "The winners are: fred harry jill.")
     (equal? (format "Pairs:~{ <~S,~S>~}." '(a 1 b 2 c 3))
             "Pairs: <a,1> <b,2> <c,3>.")
     (equal? (format "Pairs:~:{ <~S,~S>~}." '((a 1) (b 2) (c 3)))
             "Pairs: <a,1> <b,2> <c,3>.")
     (equal? (format "Pairs:~@{ <~S,~S>~}." 'a 1 'b 2 'c 3)
             "Pairs: <a,1> <b,2> <c,3>.")
     (equal? (format "Pairs:~:@{ <~S,~S>~}." '(a 1) '(b 2) '(c 3))
             "Pairs: <a,1> <b,2> <c,3>.")

     (equal? (format "~1{~:}" "a ~b c" '(5)) "a 101 c")
     (equal? (format "~1{~:}" "a ~b c" '(5)) (apply format "a ~b c" '(5)))

     ; ~^ tests from cltl2
     (equal? (format "~:{/~s~^ ...~}"
               '((hot dog) (hamburger) (ice cream) (french fries)))
             "/hot .../hamburger/ice .../french ...")
     (equal? (format "~:{/~s~:^ ...~}"
               '((hot dog) (hamburger) (ice cream) (french fries)))
             "/hot .../hamburger .../ice .../french")
     ; this one appears not to be supported by cltl text, but it's one of
     ; the examples
     (equal? (format "~:{/~s~#:^ ...~}"
               '((hot dog) (hamburger) (ice cream) (french fries)))
             "/hot .../hamburger")
     ; was all screwed up in cltl2, and didn't illustrate ~^ within
     ; ~[...~] as advertised:
     ; (begin (define tellstr "~@{~@[~R~]~^ ~A.~}") (string? tellstr))
     ; (equal? (format tellstr 23) "Twenty-three.")
     ; (equal? (format tellstr #f "losers") "losers.")
     ; (equal? (format tellstr 23 "losers") "Twenty-three losers.")
     ; probably meant something more like this:
     (begin
       (define tellstr "~@{~@[~R~^ ~]~A~}.")
       (string? tellstr))
     (equal? (format tellstr 23) "twenty-three.")
     (equal? (format tellstr #f "losers") "losers.")
     (equal? (format tellstr 23 "losers") "twenty-three losers."))

(mat format-goto
     (error? (format "~*"))
     (error? (format "~s ~*" 0))
     (equal? (format "~*~s" 0 1) "1")
     ;  (error? (format "~0*~s" 0 1)) ; too many args
     (error? (format "~2*~s" 0 1))
     (error? (format "~3*~s" 0 1))
     (error? (format "~-3*~s" 0 1))
     ;  (error? (format "~s ~:*" 0)) ; too many args
     (equal? (format "~s~:*~s" 0) "00")
     (error? (format "~s~2:*~s" 0))
     (error? (format "~s~0:*~s" 0))
     (error? (format "~s~:@*~s" 0))
     (error? (format "~s~@:*~s" 0))
     (error? (format "~:*"))
     (error? (format "~:* ~s" 0))
     (equal? (format "~@*") "")
     ;  (error? (format "~s~@*" 0)) ; too many args
     ;  (error? (format "~@*" 0)) ; too many args
     (equal? (format "~s~:*~s~s~s~2:*~s~3*~s~@*~s~s~1@*~s~5@*~s"
                     'a
                     'b
                     'c
                     'd
                     'e
                     'f)
             "aabcbfabbf")
     (equal? (format "~s~?~:*~s~s" '< "~s~s~:*~s~*~s" '(a b c d) '>)
             "<abbd(a b c d)>")
     (equal? (format "~s~@?~:*~s~s" '< "~s~s~:*~s~*~s" 'a 'b 'c 'd '>)
             "<abbdd>"))

(mat format-radix
     (equal? (format "~d" 3) "3")
     (equal? (format "~3d" 1) "  1")
     (equal? (format "~:d" 12345) "12,345")
     (equal? (format "~:@d" 12345) "+12,345")
     (equal? (format "~@:d" 12345) "+12,345")
     (equal? (format "~:d" -12345) "-12,345")
     (equal? (format "~:@d" -12345) "-12,345")
     (equal? (format "~@:d" -12345) "-12,345")
     (equal? (format "~:b" #b10110110101) "10,110,110,101")
     (equal? (format "~20,'q,'%,4:@b" #b10110110101)
             "qqqqqq+101%1011%0101")
     (equal? (format "~,,' ,4b" #xface) "1111101011001110")
     ; cltl2 example: "1111 1010 1100 1110"
     (equal? (format "~,,' ,4:b" #xface) "1111 1010 1100 1110")
     (equal? (format "~19,,' ,4:b" #x1ce) "        1 1100 1110")
     ; cltl2 example: "0000 0001 1100 1110"
     (equal? (format "~x" #x1ce) "1CE")
     (equal? (format "#o~:o" #o1234567076543210) "#o1,234,567,076,543,210")
     (equal? (format "~36r" 35) "Z")
     (equal? (format "~36,10r and ~26r" #36rzeus #26rapollo)
             "      ZEUS and APOLLO")
     (equal? (format "~,10r" -1234567) "  -1234567")
     (equal? (format "~3,20,'*,'|,2:@r" #3r20202020)
             "********+20|20|20|20")
     (equal? (format "~10d" '(a 10 c)) "  (a 10 c)")
     (equal? (format "~10x" '(10 11 12)) "   (A B C)")
     (equal? (format "~36,10,'*r" '(10 20 30)) "***(A K U)"))

(mat format-roman
     (equal? (format "~@r ~@r ~@r" 1999 -1999 4000) "MCMXCIX -1999 4000")
     (equal? (format "~@r ~@r ~@r" 3999 3998 347)
             "MMMCMXCIX MMMCMXCVIII CCCXLVII")
     (equal? (format "~@r" 2599) "MMDXCIX")
     (equal? (format "~@r" 4736) "4736")
     (equal? (format "~@r" 1782) "MDCCLXXXII")
     (equal? (format "~@r" 2251) "MMCCLI")
     (equal? (format "~@r" 1009) "MIX")
     (equal? (format "~@r" 544) "DXLIV")
     (equal? (format "~@r" 7) "VII")
     (equal? (format "~@r" 5) "V"))

(mat format-old-roman
     (equal? (format "~@:r ~@:r ~@:r" 1999 -1999 5000)
             "MDCCCCLXXXXVIIII -1999 5000")
     (equal? (format "~@:r ~@:r ~@:r" 4999 4998 347)
             "MMMMDCCCCLXXXXVIIII MMMMDCCCCLXXXXVIII CCCXXXXVII")
     (equal? (format "~@:r" 2599) "MMDLXXXXVIIII")
     (equal? (format "~@:r" 4736) "MMMMDCCXXXVI")
     (equal? (format "~@:r" 1782) "MDCCLXXXII")
     (equal? (format "~@:r" 2251) "MMCCLI")
     (equal? (format "~@:r" 1009) "MVIIII")
     (equal? (format "~@:r" 544) "DXXXXIIII")
     (equal? (format "~@:r" 7) "VII")
     (equal? (format "~@:r" 5) "V"))

(mat format-cardinal
     (equal? (format "~r" 1000000000) "1,000,000,000")
     (equal? (format "~r" 1000000001) "1,000,000,001")
     (equal? (format "~r" -2) "minus two")
     (equal? (format "~r" -1023) "minus one thousand twenty-three")
     (equal? (format "~r" 999999999)
             "nine hundred ninety-nine million nine hundred ninety-nine thousand nine hundred ninety-nine")
     (equal? (format "~r" -954321098)
             "minus nine hundred fifty-four million three hundred twenty-one thousand ninety-eight")
     (equal? (format "~r" 2599) "two thousand five hundred ninety-nine")
     (equal? (format "~r" 4736) "four thousand seven hundred thirty-six")
     (equal? (format "~r" -4730)
             "minus four thousand seven hundred thirty")
     (equal? (format "~r" -4719)
             "minus four thousand seven hundred nineteen")
     (equal? (format "~r" 1782) "seventeen hundred eighty-two")
     (equal? (format "~r" 2251) "two thousand two hundred fifty-one")
     (equal? (format "~r" 1009) "one thousand nine")
     (equal? (format "~r" 544) "five hundred forty-four")
     (equal? (format "~r ~r ~r ~r ~r ~r ~r ~r ~r ~r" 0 1 2 3 4 5 6 7 8 9)
             "zero one two three four five six seven eight nine")
     (equal? (format "~r ~r ~r ~r ~r ~r ~r ~r ~r ~r"
                     10
                     11
                     12
                     13
                     14
                     15
                     16
                     17
                     18
                     19)
             "ten eleven twelve thirteen fourteen fifteen sixteen seventeen eighteen nineteen"))

(mat format-ordinal
     (equal? (format "~:r" 1000000000) "1,000,000,000th")
     (equal? (format "~:r" -1000000001) "-1,000,000,001st")
     (equal? (format "~:r" -1000000002) "-1,000,000,002nd")
     (equal? (format "~:r" 1000000003) "1,000,000,003rd")
     (equal? (format "~:r" 300000000004) "300,000,000,004th")
     (equal? (format "~:r" 700000000008) "700,000,000,008th")
     (equal? (format "~:r" 800000000010) "800,000,000,010th")
     (equal? (format "~:r" 800000000011) "800,000,000,011th")
     (equal? (format "~:r" 800000000012) "800,000,000,012th")
     (equal? (format "~:r" 800000000013) "800,000,000,013th")
     (equal? (format "~:r" 800000000019) "800,000,000,019th")
     (equal? (format "~:r" 800000000021) "800,000,000,021st")
     (equal? (format "~:r" 800000000073) "800,000,000,073rd")
     (equal? (format "~:r" -2) "minus second")
     (equal? (format "~:r" -1023) "minus one thousand twenty-third")
     (equal? (format "~:r" 999999999)
             "nine hundred ninety-nine million nine hundred ninety-nine thousand nine hundred ninety-ninth")
     (equal? (format "~:r" 999000000) "nine hundred ninety-nine millionth")
     (equal? (format "~:r" -999000000)
             "minus nine hundred ninety-nine millionth")
     (equal? (format "~:r" 912304000)
             "nine hundred twelve million three hundred four thousandth")
     (equal? (format "~:r" 912004000)
             "nine hundred twelve million four thousandth")
     (equal? (format "~:r" -312001900)
             "minus three hundred twelve million nineteen hundredth")
     (equal? (format "~:r" 2599) "two thousand five hundred ninety-ninth")
     (equal? (format "~:r" 4736)
             "four thousand seven hundred thirty-sixth")
     (equal? (format "~:r" -4730)
             "minus four thousand seven hundred thirtieth")
     (equal? (format "~:r" -4716)
             "minus four thousand seven hundred sixteenth")
     (equal? (format "~:r" 1782) "seventeen hundred eighty-second")
     (equal? (format "~:r" 2251) "two thousand two hundred fifty-first")
     (equal? (format "~:r" 1009) "one thousand ninth")
     (equal? (format "~:r" 544) "five hundred forty-fourth")
     (equal? (format "~:r ~:r ~:r ~:r ~:r ~:r ~:r ~:r ~:r ~:r"
                     0
                     1
                     2
                     3
                     4
                     5
                     6
                     7
                     8
                     9)
             "zeroth first second third fourth fifth sixth seventh eighth ninth")
     (equal? (format "~:r ~:r ~:r ~:r ~:r ~:r ~:r ~:r ~:r ~:r"
                     10
                     11
                     12
                     13
                     14
                     15
                     16
                     17
                     18
                     19)
             "tenth eleventh twelfth thirteenth fourteenth fifteenth sixteenth seventeenth eighteenth nineteenth"))

(mat format-fixed1
     (equal? (format "~8,3f" 0.0) "   0.000")
     (equal? (format "~8,3f" -0.0) "  -0.000")
     (equal? (format "~8,3f" 1234567.89) "1234567.890")
     (equal? (format "~8,3f" 123456.789) "123456.789")
     (equal? (format "~8,3f" 1.23456) "   1.235")
     (equal? (format "~8,3f" 1.23456789) "   1.235")
     (equal? (format "~8,3f" 321.23456789) " 321.235")
     (equal? (format "~8,3f" 4321.23456789) "4321.235")
     (equal? (format "~8,3,-2,,'zf" 0.0) "zzz0.000")
     (equal? (format "~8,3,-2,,'zf" -0.0) "zz-0.000")
     (equal? (format "~8,3,-2,,'0f" 4321.23456789) "0043.212")
     (equal? (format "~8,3f" 54321.23456789) "54321.235")
     (equal? (format "~8,3f" -1.23456789) "  -1.235")
     (equal? (format "~8,3@f" 0.0) "  +0.000")
     (equal? (format "~8,3@f" -0.0) "  -0.000")
     (equal? (format "~8,3@f" 1.23456789) "  +1.235")
     (equal? (format "~8,3f" .0023456789) "   0.002")
     (equal? (format "~8,3f" .002) "   0.002")
     (equal? (format "~8,3@f" 123456789) "+123456789.000")
     (equal? (format "~8,3@f" 123456789123456789) "+12345678912345678#.###")
     (equal? (format "~8,3f" 12345678912345678) "12345678912345678.###")
     (equal? (format "~8,3f" 1234567891234567) "1234567891234567.0##")
     (equal? (format "~8,3f" 12345678912345) "12345678912345.000")
     (equal? (format "~8,3f" 1e23) "9999999999999999#######.###")
     (equal? (format "~8,3,23f" 0.0) "   0.000")
     (equal? (format "~8,3,23f" -0.0) "  -0.000")
     (equal? (format "~8,3,23f" 1.0) "10000000000000000#######.###")
     (equal? (format "~8,3f" 1e-23) "   0.000")
     (equal? (format "~8,3,-23f" 0.0) "   0.000")
     (equal? (format "~8,3,-23f" -0.0) "  -0.000")
     (equal? (format "~8,3,-23f" 1.0) "   0.000")
     (equal? (format "~8,3f" 1e-7) "   0.000")
     (equal? (format "~8,3f" 9e-7) "   0.000")
     (equal? (format "~8,3f" 1e-6) "   0.000")
     (equal? (format "~8,3f" 1e-5) "   0.000")
     (equal? (format "~8,3f" 1e-4) "   0.000")
     (equal? (format "~8,3f" 1e-3) "   0.001")
     (equal? (format "~8,3f" 1e-2) "   0.010")
     (equal? (format "~8,3f" 1e-1) "   0.100"))

(mat format-fixed2
     (equal? (format "~10,3,2f" 3.14159) "   314.159")
     (equal? (format "~10,3,-1f" 3.14159) "     0.314")
     (equal? (format "~6,3,-1f" 3.14159) " 0.314")
     (equal? (format "~5,3,-1f" 3.14159) "0.314")
     (equal? (format "~4,3,-1f" 3.14159) ".314")
     (equal? (format "~3,3,-1f" 3.14159) ".314")
     (equal? (format "~10,3,2f" -3.14159) "  -314.159")
     (equal? (format "~10,3,-1f" -3.14159) "    -0.314")
     (equal? (format "~6,3,-1f" -3.14159) "-0.314")
     (equal? (format "~5,3,-1f" -3.14159) "-.314")
     (equal? (format "~3,3,-1f" -3.14159) "-.314")
     (equal? (format "~6,3,-1@f" 3.14159) "+0.314")
     (equal? (format "~5,3,-1@f" 3.14159) "+.314")
     (equal? (format "~,3,-1@f" 3.14159) "+0.314")
     (equal? (format "~,3,-8f" 3.14159) "0.000")
     (equal? (format "~4,3,-8f" 3.14159) ".000"))

(mat format-fixed3
     (equal? (format "~10,,2f" 3.14159) "   314.159")
     (equal? (format "~10,,-1f" 3.14159) "  0.314159")
     (equal? (format "~8,,-1f" 3.14159) "0.314159")
     (equal? (format "~7,,-1f" 3.14159) ".314159")
     (equal? (format "~6,,-1f" 3.14159) ".31416")
     (equal? (format "~5,,-1f" 3.14159) ".3142")
     (equal? (format "~4,,-1f" 3.14159) ".314")
     (equal? (format "~3,,-1f" 3.14159) ".31")
     (equal? (format "~2,,-1f" 3.14159) ".3")
     (equal? (format "~1f" .314159) ".3")
     (equal? (format "~1,,-1f" 3.14159) ".3")
     (equal? (format "~0,,-1f" 3.14159) ".3")

     (equal? (format "~0,,5f" 3.14159) "314159.")

     (equal? (format "~5f" -231.2) "-231.")
     (equal? (format "~5f" 231.2) "231.2")
     (equal? (format "~5f" -23.12) "-23.1")
     (equal? (format "~5f" 23.12) "23.12")
     (equal? (format "~5f" -23.1) "-23.1")
     (equal? (format "~5f" -231) "-231.")
     (equal? (format "~5f" -2.31) "-2.31")
     (equal? (format "~5f" -2310) "-2310.")
     (equal? (format "~5f" 1e23) "9999999999999999#######.")

     (equal? (format "~5,,1f" -231.2) "-2312.")
     (equal? (format "~5,,1f" 231.2) "2312.")
     (equal? (format "~5,,1f" -23.12) "-231.")
     (equal? (format "~5,,1f" 23.12) "231.2")
     (equal? (format "~5,,1f" -23.1) "-231.")
     (equal? (format "~5,,1f" -231) "-2310.")
     (equal? (format "~5,,1f" -2.31) "-23.1")
     (equal? (format "~5,,1f" -2310) "-23100.")
     (equal? (format "~5,,1f" 1e23) "9999999999999999########.")

     (equal? (format "~5,,-1f" -231.2) "-23.1")
     (equal? (format "~5,,-1f" 231.2) "23.12")
     (equal? (format "~5,,-1f" -23.12) "-2.31")
     (equal? (format "~5,,-1f" 23.12) "2.312")
     (equal? (format "~5,,-1f" -23.1) "-2.31")
     (equal? (format "~5,,-1f" -231) "-23.1")
     (equal? (format "~5,,-1f" -2.31) "-.231")
     (equal? (format "~5,,-1f" -2310) "-231.")
     (equal? (format "~5,,-1f" 1e23) "9999999999999999######.")

     (equal? (format "~,,1f" 3.14159) "31.4159")
     (equal? (format "~,,5f" 3.14159) "314159.0")
     (equal? (format "~,,10f" 3.14159) "31415900000.0")
     (equal? (format "~,,-1f" 3.14159) "0.314159")
     (equal? (format "~,,-2f" 3.14159) "0.0314159"))

(mat format-fixed4
     (equal? (format "~8f" 0.0) "     0.0")
     (equal? (format "~8f" -0.0) "    -0.0")
     (equal? (format "~8@f" 0.0) "    +0.0")
     (equal? (format "~8@f" -0.0) "    -0.0")
     (equal? (format "~8f" 1234567.89) "1234568.")
     (equal? (format "~8f" 123456.789) "123456.8")
     (equal? (format "~8f" 1.23456) " 1.23456")
     (equal? (format "~8f" 1.23456789) "1.234568")
     (equal? (format "~8f" 321.23456789) "321.2346")
     (equal? (format "~8f" 4321.23456789) "4321.235")
     (equal? (format "~8f" 54321.23456789) "54321.23")
     (equal? (format "~8f" -1.23456789) "-1.23457")
     (equal? (format "~8@f" 1.23456789) "+1.23457")
     (equal? (format "~8f" .0023456789) ".0023457")
     (equal? (format "~8f" .002) "   0.002")
     (equal? (format "~8@f" 123456789) "+123456789.")
     (equal? (format "~8@f" 123456789123456789) "+12345678912345678#.")
     (equal? (format "~8f" 12345678912345678) "12345678912345678.")
     (equal? (format "~8f" 1234567891234567) "1234567891234567.")
     (equal? (format "~8f" 12345678912345) "12345678912345.")
     (equal? (format "~8f" 1e23) "9999999999999999#######.")
     (equal? (format "~8f" 1e-23) "     0.0")
     (equal? (format "~8f" 1e-8) "     0.0")
     (equal? (format "~8f" 1e-7) ".0000001")
     (equal? (format "~8f" 9e-7) ".0000009")
     (equal? (format "~8f" 1e-6) "0.000001")
     (equal? (format "~7f" 9e-7) ".000001")
     (equal? (format "~7f" 1e-6) ".000001")
     (equal? (format "~6f" 9e-9) "   0.0")
     (equal? (format "~6f" 9e-7) "   0.0")
     (equal? (format "~6f" 1e-6) "   0.0")
     (equal? (format "~6f" 1e-5) ".00001")

     (equal? (format "~6f" 1.0) "   1.0")
     (equal? (format "~6f" 10.0) "  10.0")
     (equal? (format "~6f" 100.0) " 100.0")
     (equal? (format "~6f" 1e3) "1000.0")
     (equal? (format "~6f" 123.0) " 123.0")
     (equal? (format "~6f" 1234.0) "1234.0")
     (equal? (format "~6f" 12345.0) "12345.")
     (equal? (format "~6f" 123456.0) "123456.")
     (equal? (format "~6f" 10000.0) "10000.")
     (equal? (format "~6,,1f" 1e3) "10000.")
     (equal? (format "~5,,1f" 1e3) "10000.")
     (equal? (format "~7f" -1.0) "   -1.0")
     (equal? (format "~7f" -10.0) "  -10.0")
     (equal? (format "~7f" -100.0) " -100.0")
     (equal? (format "~7f" -1e3) "-1000.0")
     (equal? (format "~7f" -123.0) " -123.0")
     (equal? (format "~7f" -1234.0) "-1234.0")
     (equal? (format "~7f" -12345.0) "-12345.")
     (equal? (format "~7f" -123456.0) "-123456.")
     (equal? (format "~7f" -10000.0) "-10000.")
     (equal? (format "~7,,1f" -1e3) "-10000.")
     (equal? (format "~6,,1f" -1e3) "-10000."))

(mat format-fixed5
     (equal? (format "~f" 0.0) "0.0")
     (equal? (format "~f" -0.0) "-0.0")
     (equal? (format "~@f" 0.0) "+0.0")
     (equal? (format "~@f" -0.0) "-0.0")
     (equal? (format "~f" 1234567.89) "1234567.89")
     (equal? (format "~f" 123456.789) "123456.789")
     (equal? (format "~f" 1.23456) "1.23456")
     (equal? (format "~f" 1.23456789) "1.23456789")
     (equal? (format "~f" 321.23456789) "321.23456789")
     (equal? (format "~f" 4321.23456789) "4321.23456789")
     (equal? (format "~f" 54321.23456789) "54321.23456789")
     (equal? (format "~f" -1.23456789) "-1.23456789")
     (equal? (format "~@f" 1.23456789) "+1.23456789")
     (equal? (format "~f" .0023456789) "0.0023456789")
     (equal? (format "~f" .002) "0.002")
     (equal? (format "~@f" 123456789) "+123456789.0")
     (equal? (format "~@f" 123456789123456789) "+12345678912345678#.#")
     (equal? (format "~f" 12345678912345678) "12345678912345678.#")
     (equal? (format "~f" 1234567891234567) "1234567891234567.0")
     (equal? (format "~f" 12345678912345) "12345678912345.0")
     (equal? (format "~f" 1e23) "9999999999999999#######.#")
     (equal? (format "~f" 1e-23) "0.00000000000000000000001")
     (equal? (format "~f" 1e-7) "0.0000001")
     (equal? (format "~f" 9e-7) "0.0000009")
     (equal? (format "~f" 1e-6) "0.000001"))

(mat format-fixed6
     (equal? (format "~2,1@f" 0.003) "+.0")
     (equal? (format "~2@f" 0.003) "+.0")
     (equal? (format "~2@f" 1.34) "+1.")
     (equal? (format "~2,1@f" 1.34) "+1.3")
     (equal? (format "~2,2@f" 1.34) "+1.34")
     (equal? (format "~0f" 1e23) "9999999999999999#######.")
     (equal? (format "~0f" 1e-23) ".0")
     (equal? (format "~0f" -1e-23) "-.0")
     (equal? (format "~0f" 0.0) "0.")
     (equal? (format "~0f" -0.0) "-0."))

(mat format-fixed7
     (equal? (format "~2,1,,'*@f" 0.0) "**")
     (equal? (format "~2,1,,'*@f" -0.0) "**")
     (equal? (format "~2,1,,'*@f" 0.003) "**")
     (equal? (format "~2,,,'*,@f" 0.003) "**")
     (equal? (format "~4,2,,'*@f" 1.34) "****")
     (equal? (format "~2,1,4,'q,'p@f" 0.0) "qq")
     (equal? (format "~2,1,4,'q,'p@f" -0.0) "qq")
     (equal? (format "~2,1,4,'q,'p@f" 1.34) "qq")
     (equal? (format "~10,1,4,'q,'p@f" 0.0) "pppppp+0.0")
     (equal? (format "~10,1,4,'q,'p@f" -0.0) "pppppp-0.0")
     (equal? (format "~10,1,4,'q,'p@f" 1.34) "pp+13400.0")
     (equal? (format "~10,1,-4,'q,'p@f" 1.34) "pppppp+0.0")
     (equal? (format "~10,5,-4,'q,'p@f" 1.34) "pp+0.00013")
     (equal? (format "~10,6,-4,'q,'p@f" 1.34) "p+0.000134")
     (equal? (format "~10,6,-4,'q,'p@f" 0.0) "p+0.000000")
     (equal? (format "~10,6,-4,'q,'p@f" -0.0) "p-0.000000")
     (equal? (format "~2,2,,'q,'p@f" 1.34) "qq")
     (equal? (format "~10,2,,'q,'p@f" 1.34) "ppppp+1.34")
     (equal? (format "~0,,,'*f" 1e23) "")
     (equal? (format "~0,,,'*f" 1e-23) "")
     (equal? (format "~0,,,'*f" -1e-23) ""))

(mat format-fixed8
     (let ()
       ; example adapted from cltl2
       (define (foo x)
         (format "~6,2F|~6,2,1,'*F|~6,2,,'?F|~6F|~,2F|~F" x x x x x x))
       (and (equal? (foo 3.14159)
                    "  3.14| 31.42|  3.14|3.1416|3.14|3.14159")
            (equal? (foo -3.14159) " -3.14|-31.42| -3.14|-3.142|-3.14|-3.14159")
            (equal? (foo 100.0) "100.00|******|100.00| 100.0|100.00|100.0")
            (equal? (foo 1234.0) "1234.00|******|??????|1234.0|1234.00|1234.0")
            (equal? (foo 0.006) "  0.01|  0.06|  0.01| 0.006|0.01|0.006")
            (equal? (foo 0.0) "  0.00|  0.00|  0.00|   0.0|0.00|0.0")
            (equal? (foo -0.0) " -0.00| -0.00| -0.00|  -0.0|-0.00|-0.0"))))

(mat format-exp1
     (equal? (format "~10,5,,2e" 0.0) " 0.0000e+0")
     (equal? (format "~10,5,,2e" -0.0) "-0.0000e+0")
     (equal? (format "~9,5,,2e" 0.0) "0.0000e+0")
     (equal? (format "~9,5,,2e" -0.0) "-.0000e+0")
     (equal? (format "~10,5,,2e" 3.14159) "31.4159e-1")
     (equal? (format "~10,0e" 3.4e-200) "   3.e-200")
     (equal? (format "~10,3,2,0e" 123456789) " 0.123e+09")
     (equal? (format "~9,3,2,0e" 123456789) "0.123e+09")
     (equal? (format "~8,3,2,0e" 0.0) ".000e+00")
     (equal? (format "~8,3,2,0e" -0.0) "-.000e+00")
     (equal? (format "~8,3,2,0e" 123456789) ".123e+09")
     (equal? (format "~7,3,2,0e" 123456789) ".123e+09")
     (equal? (format "~3,3,2,0e" 123456789) ".123e+09"))

(mat format-exp2
     (equal? (format "~10e" 0.0) "    0.0e+0")
     (equal? (format "~10e" -0.0) "   -0.0e+0")
     (equal? (format "~10e" 3.4) "    3.4e+0")
     (equal? (format "~10e" 3.4e10) "   3.4e+10")
     (equal? (format "~10e" 3.4e-10) "   3.4e-10")
     (equal? (format "~10e" 3.4e-200) "  3.4e-200")

     (equal? (format "~10,,,2e" 0.0) "    0.0e+0")
     (equal? (format "~10,,,2e" -0.0) "   -0.0e+0")
     (equal? (format "~10,,,2e" 3.4e-200) " 34.0e-201")
     (equal? (format "~10,,,3e" 3.4e-200) "340.0e-202")
     (equal? (format "~10,,,-2e" 0.0) "    0.0e+0")
     (equal? (format "~10,,,-2e" -0.0) "   -0.0e+0")
     (equal? (format "~10,,,-2e" 3.4e-200) "0.003e-197")

     (equal? (format "~10@e" 3.6e99) "  +3.6e+99")
     (equal? (format "~9@e" 3.6e99) " +3.6e+99")
     (equal? (format "~8@e" 3.6e99) "+3.6e+99")
     (equal? (format "~7@e" 3.6e99) "+4.e+99")
     (equal? (format "~6@e" 3.6e99) "+4.e+99")
     (equal? (format "~5@e" 3.6e99) "+4.e+99")
     (equal? (format "~0@e" 3.6e99) "+4.e+99")

     (equal? (format "~9@e" 0.0) "  +0.0e+0")
     (equal? (format "~7@e" 0.0) "+0.0e+0")
     (equal? (format "~6@e" 0.0) "+0.e+0")
     (equal? (format "~0@e" 0.0) "+0.e+0")
     (equal? (format "~9@e" -0.0) "  -0.0e+0")
     (equal? (format "~7@e" -0.0) "-0.0e+0")
     (equal? (format "~6@e" -0.0) "-0.e+0")
     (equal? (format "~0@e" -0.0) "-0.e+0")

     (equal? (format "~9,,,0@e" 0.0) "  +0.0e+0")
     (equal? (format "~7,,,0@e" 0.0) "+0.0e+0")
     (equal? (format "~6,,,0@e" 0.0) "+.0e+0")
     (equal? (format "~0,,,0@e" 0.0) "+.0e+0")
     (equal? (format "~9,,,0@e" -0.0) "  -0.0e+0")
     (equal? (format "~7,,,0@e" -0.0) "-0.0e+0")
     (equal? (format "~6,,,0@e" -0.0) "-.0e+0")
     (equal? (format "~0,,,0@e" -0.0) "-.0e+0")

     (equal? (format "~10e" 9.999e9) "  9.999e+9")
     (equal? (format "~9e" 9.999e9) " 9.999e+9")
     (equal? (format "~8e" 9.999e9) "9.999e+9")
     (equal? (format "~7e" 9.999e9) "1.0e+10")
     (equal? (format "~6e" 9.999e9) "1.e+10")
     (equal? (format "~5e" 9.999e9) "1.e+10")
     (equal? (format "~0e" 9.999e9) "1.e+10")

     (equal? (format "~10e" 9.999e-10) " 9.999e-10")
     (equal? (format "~9e" 9.999e-10) "9.999e-10")
     (equal? (format "~8e" 9.999e-10) "  1.0e-9")
     (equal? (format "~7e" 9.999e-10) " 1.0e-9")
     (equal? (format "~6e" 9.999e-10) "1.0e-9")
     (equal? (format "~5e" 9.999e-10) "1.e-9")
     (equal? (format "~2e" 9.999e-10) "1.e-9")

     (equal? (format "~10e" 1e23) "   1.0e+23"))

(mat format-exp3
     (equal? (format "~e" 0.0) "0.0e+0")
     (equal? (format "~e" -0.0) "-0.0e+0")
     (equal? (format "~e" 1e23) "1.0e+23")
     (equal? (format "~e" .000345) "3.45e-4")
     (equal? (format "~e" 345) "3.45e+2")
     (equal? (format "~e" 345e20) "3.45e+22")
     (equal? (format "~,,3,e" 0.0) "0.0e+000")
     (equal? (format "~,,3,e" -0.0) "-0.0e+000")
     (equal? (format "~,,3,e" 1e23) "1.0e+023")
     (equal? (format "~,,3,3e" 0.0) "0.0e+000")
     (equal? (format "~,,3,3e" -0.0) "-0.0e+000")
     (equal? (format "~,,3,3e" 1e23) "100.0e+021")
     (equal? (format "~,,,3e" 0.0) "0.0e+0")
     (equal? (format "~,,,3e" -0.0) "-0.0e+0")
     (equal? (format "~,,,3e" 1e23) "100.0e+21")
     (equal? (format "~,,,3e" 3.14159) "314.159e-2")
     (equal? (format "~,,2,3e" 3.14159) "314.159e-02")
     (equal? (format "~,,2,3@e" 3.14159) "+314.159e-02")
     (equal? (format "~,,,-3e" 0.0) "0.0e+0")
     (equal? (format "~,,,-3e" -0.0) "-0.0e+0")
     (equal? (format "~,,,-3e" -3.14159) "-0.000314159e+4")
     (equal? (format "~0e" 0.0) "0.e+0")
     (equal? (format "~0e" -0.0) "-0.e+0")
     (equal? (format "~0,,,0e" 0.0) ".0e+0")
     (equal? (format "~0,,,0e" -0.0) "-.0e+0")
     (equal? (format "~,,1,,'*e" 3e20) "3.0e+20")
     ; can't fill with oc; no w
     (equal? (format "~,2,1,,'*e" 3e20) "3.00e+20")
     ; can't fill with oc; no w
     (equal? (format "~10,2,1,,'*e" 3e20) "**********")
     ; no room for exponent
     (equal? (format "~10,,1,,'*e" 3e20) "**********")
     ; no room for exponent
     (equal? (format "~10,2,,-2,'*e" 3e20) "**********")
     ; d to small for given k
     (equal? (format "~,2,,-2,'*e" 3e20) "0.003e+23")
     ; can't fill with oc; no w
     )

(mat format-exp4
     (let ()
       ; example adapted from cltl2
       (define (foo x)
         (format "~9,2,1,,'*E|~10,3,2,2,'?,,'$E|~9,3,2,-2,'%@E|~9,2E" x x x x))
       (and (equal? (foo 3.14159)
                    "  3.14e+0| 31.42$-01|+.003e+03|  3.14e+0")
            (equal? (foo -3.14159) " -3.14e+0|-31.42$-01|-.003e+03| -3.14e+0")
            (equal? (foo 1100.0) "  1.10e+3| 11.00$+02|+.001e+06|  1.10e+3")
            (equal? (foo 1.1E13) "*********| 11.00$+12|+.001e+16| 1.10e+13")
            (equal? (foo 1.1E120) "*********|??????????|%%%%%%%%%|1.10e+120")
            (equal? (foo 1.1E1200) "   +inf.0|    +inf.0|   +inf.0|   +inf.0")
            ; cltl2 assumes L (128-bit?) floats
            (equal? (foo 0.0) "  0.00e+0|  0.00$+00|+.000e+00|  0.00e+0")
            (equal? (foo -0.0) " -0.00e+0| -0.00$+00|-.000e+00| -0.00e+0")))
     (let ()
       ; like above but without d parameters
       (define (foo x)
         (format "~9,,1,,'*E|~10,,2,2,'?,,'$E|~9,,2,-2,'%@E|~9E" x x x x))
       (and (equal? (foo 3.14159)
                    "3.1416e+0|31.416$-01|+.003e+03|3.1416e+0")
            (equal? (foo -3.14159) "-3.142e+0|-31.42$-01|-.003e+03|-3.142e+0")
            (equal? (foo 1100.0) "   1.1e+3|  11.0$+02|+.001e+06|   1.1e+3")
            (equal? (foo 1.1E13) "*********|  11.0$+12|+.001e+16|  1.1e+13")
            (equal? (foo 1.1E120) "*********|??????????|%%%%%%%%%| 1.1e+120")
            (equal? (foo 1.1E1200) "   +inf.0|    +inf.0|   +inf.0|   +inf.0")
            ; cltl2 assumes L (128-bit?) floats
            (equal? (foo 0.0) "   0.0e+0|   0.0$+00| +0.0e+00|   0.0e+0")
            (equal? (foo -0.0) "  -0.0e+0|  -0.0$+00| -0.0e+00|  -0.0e+0")))
     (equal? ; example adapted from cltl2
       (with-output-to-string
         (lambda ()
           (do ([k -5 (fx+ k 1)])
               ((fx= k 8))
               (printf (format "Scale factor ~2d: |~~13,6,2,~de|~~%" k k)
                       3.14159))))
       (format "Scale factor -5: | 0.000003e+06|~@
             Scale factor -4: | 0.000031e+05|~@
             Scale factor -3: | 0.000314e+04|~@
             Scale factor -2: | 0.003142e+03|~@
             Scale factor -1: | 0.031416e+02|~@
             Scale factor  0: | 0.314159e+01|~@
             Scale factor  1: | 3.141590e+00|~@
             Scale factor  2: | 31.41590e-01|~@
             Scale factor  3: | 314.1590e-02|~@
             Scale factor  4: | 3141.590e-03|~@
             Scale factor  5: | 31415.90e-04|~@
             Scale factor  6: | 314159.0e-05|~@
             Scale factor  7: | 3141590.e-06|\n")))

(mat format-general
     (equal? (format "~g" 0.0) "0.")
     (equal? (format "~g" -0.0) "-0.")
     (equal? (format "~10g" 0.0) "    0.    ")
     (equal? (format "~10g" -0.0) "   -0.    ")
     (let ()
       ; example adapted from cltl2
       (define (foo x)
         (format "~9,2,1,,'*G|~9,3,2,3,'?,,'$G|~9,3,2,0,'%G|~9,2G" x x x x))
       (and (equal? (foo 0.0314159)
                    "  3.14e-2|314.2$-04|0.314e-01|  3.14e-2")
            (equal? (foo 0.314159) "  0.31   |0.314    |0.314    | 0.31    ")
            (equal? (foo 3.14159) "   3.1   | 3.14    | 3.14    |  3.1    ")
            (equal? (foo 31.4159) "   31.   | 31.4    | 31.4    |  31.    ")
            (equal? (foo 314.159) "  3.14e+2| 314.    | 314.    |  3.14e+2")
            (equal? (foo 3141.59) "  3.14e+3|314.2$+01|0.314e+04|  3.14e+3")
            (equal? (foo 3141.59L0) "  3.14e+3|314.2$+01|0.314e+04|  3.14e+3")
            (equal? (foo 3.14E12) "*********|314.0$+10|0.314e+13| 3.14e+12")
            (equal? (foo 3.14L120) "*********|?????????|%%%%%%%%%|3.14e+120")
            (equal? (foo 3.14L1200) "   +inf.0|   +inf.0|   +inf.0|   +inf.0")))
     (equal? (list (format "~,3g" .9999)
                   (format "~,3g" .999)
                   (format "~,3g" 1.0))
             '("1.00" "0.999" "1.00"))
     )

(mat format-dollar
     (equal? (format "~$" 0.0) "0.00")
     (equal? (format "~$" -0.0) "-0.00")
     (equal? (format "~$" 3.4) "3.40")
     (equal? (format "~$" 23.99) "23.99")
     (equal? (format "~$" -12345.67830) "-12345.68")
     (equal? (format "~$" .153) "0.15")
     (equal? (format "~$" -.01) "-0.01")
     (equal? (format "~$" .0159) "0.02")
     (equal? (format "~3$" 0.0) "0.000")
     (equal? (format "~3$" -0.0) "-0.000")
     (equal? (format "~3$" 3.4) "3.400")
     (equal? (format "~3$" 23.99) "23.990")
     (equal? (format "~3$" -12345.67830) "-12345.678")
     (equal? (format "~3$" .153) "0.153")
     (equal? (format "~3$" -.01) "-0.010")
     (equal? (format "~3$" .0159) "0.016")
     (equal? (format "~1,2$" 0.0) "00.0")
     (equal? (format "~1,2$" -0.0) "-00.0")
     (equal? (format "~1,2$" 3.4) "03.4")
     (equal? (format "~1,2$" 23.99) "24.0")
     (equal? (format "~1,2$" 12345.678) "12345.7")
     (equal? (format "~1,2$" .153) "00.2")
     (equal? (format "~1,2$" -.01) "-00.0")
     (equal? (format "~1,2$" .0159) "00.0")
     (equal? (format "~1,2$" .0159) "00.0")
     (equal? (format "~1,2,7$" 0.0) "   00.0")
     (equal? (format "~1,2,7$" -0.0) "  -00.0")
     (equal? (format "~1,2,7$" 3.4) "   03.4")
     (equal? (format "~1,2,7$" 23.99) "   24.0")
     (equal? (format "~1,2,7$" -12345.678) "-12345.7")
     (equal? (format "~1,2,7$" .153) "   00.2")
     (equal? (format "~1,2,7$" -.01) "  -00.0")
     (equal? (format "~1,2,7$" .0159) "   00.0")
     (equal? (format "~1,2,7$" .0159) "   00.0")
     (equal? (format "~1,2,7,'0$" 0.0) "00000.0")
     (equal? (format "~1,2,7,'0$" -0.0) "00-00.0")
     (equal? (format "~1,2,7,'0$" 3.4) "00003.4")
     (equal? (format "~1,2,7,'0$" 23.99) "00024.0")
     (equal? (format "~1,2,7,'0$" -12345.678) "-12345.7")
     (equal? (format "~1,2,7,'0$" .153) "00000.2")
     (equal? (format "~1,2,7,'0$" -.01) "00-00.0")
     (equal? (format "~1,2,7,'0$" .0159) "00000.0")
     (equal? (format "~1,2,7,'0$" .0159) "00000.0")
     (equal? (format "~1,2,7,'0:$" 0.0) "00000.0")
     (equal? (format "~1,2,7,'0:$" -0.0) "-0000.0")
     (equal? (format "~1,2,7,'0:$" 3.4) "00003.4")
     (equal? (format "~1,2,7,'0:$" 23.99) "00024.0")
     (equal? (format "~1,2,7,'0:$" -12345.678) "-12345.7")
     (equal? (format "~1,2,7,'0:$" .153) "00000.2")
     (equal? (format "~1,2,7,'0:$" -.01) "-0000.0")
     (equal? (format "~1,2,7,'0:$" .0159) "00000.0")
     (equal? (format "~1,2,7,'0:$" .0159) "00000.0")
     (equal? (format "~1,2,7,'0@:$" 0.0) "+0000.0")
     (equal? (format "~1,2,7,'0@:$" -0.0) "-0000.0")
     (equal? (format "~1,2,7,'0@:$" 3.4) "+0003.4")
     (equal? (format "~1,2,7,'0@:$" 23.99) "+0024.0")
     (equal? (format "~1,2,7,'0@:$" -12345.678) "-12345.7")
     (equal? (format "~1,2,7,'0@:$" .153) "+0000.2")
     (equal? (format "~1,2,7,'0@:$" -.01) "-0000.0")
     (equal? (format "~1,2,7,'0@:$" .0159) "+0000.0")
     (equal? (format "~1,2,7,'0@:$" .0159) "+0000.0")
     (equal? (format "~1,,7,'*@:$" 0.0) "+***0.0")
     (equal? (format "~1,,7,'*@:$" -0.0) "-***0.0")
     (equal? (format "~1,,7,'*@:$" 3.4) "+***3.4")
     (equal? (format "~,2,7,'*@$" 23.99) "*+23.99")
     (equal? (format "~1,,7,@$" -12345.678) "-12345.7")
     (equal? (format "~1,2,,'*@:$" .153) "+00.2")
     (equal? (format "~,,10,'*$" -.01) "*****-0.01")
     (equal? (format "~1,,,'*@:$" .0159) "+0.0")
     (equal? (format "~,2,7,'*@:$" 0.0) "+*00.00")
     (equal? (format "~,2,7,'*@:$" -0.0) "-*00.00")
     (equal? (format "~,2,7,'*@:$" .0159) "+*00.02")

     ; check to see if exact inputs are accepted
     (equal? (format "~1,2,7,'0@:$" #e23.99) "+0024.0")
     (equal? (format "~$" #e3.4) "3.40")
     (equal? (format "~$" 1/3) "0.33")

     ; check to see if nonreal inputs are rejected
     (error? (format "~$" 'a))
     (error? (format "~$" 1.0+3.0i))
     (error? (format "~$" 1+3i)))

(mat format-cltl2
     ; misc cltl2 tests
     (equal? (format "foo") "foo")
     (begin (define fmt-x 5) #t)
     (equal? (format "The answer is ~D." fmt-x) "The answer is 5.")
     (equal? (format "The answer is ~3D." fmt-x) "The answer is   5.")
     (equal? (format "The answer is ~3,'0D." fmt-x) "The answer is 005.")
     (equal? (format "The answer is ~:D." (expt 47 fmt-x))
             "The answer is 229,345,007.")
     (begin (define fmt-y "elephant") #t)
     (equal? (format "Look at the ~A!" fmt-y) "Look at the elephant!")
     (equal? (format "Type ~:C to ~A." #\004 "delete all your files")
             "Type ^D to delete all your files.")
     (begin (define fmt-n 3) #t)
     (equal? (format "~D item~:P found." fmt-n) "3 items found.")
     (equal? (format "~R dog~:[s are~; is~] here." fmt-n (= fmt-n 1))
             "three dogs are here.")
     (equal? (format "~R dog~:*~[s are~; is~:;s are~] here." fmt-n)
             "three dogs are here.")
     (equal? (format "Here ~[are~;is~:;are~] ~:*~R pupp~:@P." fmt-n)
             "Here are three puppies.")
     (begin (define fmt-n 1) #t)
     (equal? (format "~D item~:P found." fmt-n) "1 item found.")
     (equal? (format "~R dog~:[s are~; is~] here." fmt-n (= fmt-n 1))
             "one dog is here.")
     (equal? (format "~R dog~:*~[s are~; is~:;s are~] here." fmt-n)
             "one dog is here.")
     (equal? (format "Here ~[are~;is~:;are~] ~:*~R pupp~:@P." fmt-n)
             "Here is one puppy.")
     (begin (define fmt-n 0) #t)
     (equal? (format "~D item~:P found." fmt-n) "0 items found.")
     (equal? (format "~R dog~:[s are~; is~] here." fmt-n (= fmt-n 1))
             "zero dogs are here.")
     (equal? (format "~R dog~:*~[s are~; is~:;s are~] here." fmt-n)
             "zero dogs are here.")
     (equal? (format "Here ~[are~;is~:;are~] ~:*~R pupp~:@P." fmt-n)
             "Here are zero puppies."))

; format-slib* tests are adapted from:

;; "formatst.scm" SLIB FORMAT Version 3.0 conformance test
; Written by Dirk Lutzebaeck (lutzeb@cs.tu-berlin.de)
;
; This code is in the public domain.

(mat format-slib1
     (equal? (format "abc") "abc")
     (equal? (format "~a" 10) "10")
     (equal? (format "~a" -1.2) "-1.2")
     (equal? (format "~a" 'a) "a")
     (equal? (format "~a" #t) "#t")
     (equal? (format "~a" #f) "#f")
     (equal? (format "~a" "abc") "abc")
     (equal? (format "~a" '#(1 2 3)) "#(1 2 3)")
     ; ans was "#(1 2 3)"
     (equal? (format "~a" '()) "()")
     (equal? (format "~a" '(a)) "(a)")
     (equal? (format "~a" '(a b)) "(a b)")
     (equal? (format "~a" '(a (b c) d)) "(a (b c) d)")
     (equal? (format "~a" '(a . b)) "(a . b)"))

(mat format-slib2
     (equal? (format "~a ~a" 10 20) "10 20")
     (equal? (format "~a abc ~a def" 10 20) "10 abc 20 def"))

(mat format-slib3
     (equal? (format "~d" 100) "100")
     (equal? (format "~x" 100) "64")
     (equal? (format "~o" 100) "144")
     (equal? (format "~b" 100) "1100100")
     (equal? (format "~@d" 100) "+100")
     (equal? (format "~@d" -100) "-100")
     (equal? (format "~@x" 100) "+64")
     (equal? (format "~@o" 100) "+144")
     (equal? (format "~@b" 100) "+1100100")
     (equal? (format "~10d" 100) "       100")
     (equal? (format "~:d" 123) "123")
     (equal? (format "~:d" 1234) "1,234")
     (equal? (format "~:d" 12345) "12,345")
     (equal? (format "~:d" 123456) "123,456")
     (equal? (format "~:d" 12345678) "12,345,678")
     (equal? (format "~:d" -123) "-123")
     (equal? (format "~:d" -1234) "-1,234")
     (equal? (format "~:d" -12345) "-12,345")
     (equal? (format "~:d" -123456) "-123,456")
     (equal? (format "~:d" -12345678) "-12,345,678")
     (equal? (format "~10:d" 1234) "     1,234")
     (equal? (format "~10:d" -1234) "    -1,234")
     (equal? (format "~10,'*d" 100) "*******100")
     (equal? (format "~10,,'|:d" 12345678) "12|345|678")
     (equal? (format "~10,,,2:d" 12345678) "12,34,56,78")
     (equal? (format "~14,'*,'|,4:@d" 12345678) "****+1234|5678"))

(mat format-slib4
     ; ~r tests
     (equal? (format "~10r" 100) "100")
     (equal? (format "~2r" 100) "1100100")
     (equal? (format "~8r" 100) "144")
     (equal? (format "~16r" 100) "64")
     (equal? (format "~16,10,'*r" 100) "********64")

     (equal? (format "~@r" 4) "IV")
     (equal? (format "~@r" 19) "XIX")
     (equal? (format "~@r" 50) "L")
     (equal? (format "~@r" 100) "C")
     (equal? (format "~@r" 1000) "M")
     (equal? (format "~@r" 99) "XCIX")
     (equal? (format "~@r" 1994) "MCMXCIV")

     ; old roman numeral test
     (equal? (format "~:@r" 4) "IIII")
     (equal? (format "~:@r" 5) "V")
     (equal? (format "~:@r" 10) "X")
     (equal? (format "~:@r" 9) "VIIII")

     ; cardinal/ordinal English number test
     (equal? (format "~r" 4) "four")
     (equal? (format "~r" 10) "ten")
     (equal? (format "~r" 19) "nineteen")
     (equal? (format "~r" 1984) "nineteen hundred eighty-four")
     ; ans was "one thousand, nine hundred eighty-four")
     (equal? (format "~:r" -1984) "minus nineteen hundred eighty-fourth")
     ; ans was "minus one thousand, nine hundred eighty-fourth")
     )

(mat format-slib5
     ; character tests
     (equal? (format "~c" #\a) "a")
     (equal? (format "~@c" #\a) "#\\a")
     (equal? (format "~@c" (integer->char 32)) "#\\space")
     (equal? (format "~@c" (integer->char 0)) "#\\nul")
     ;  (equal? (format "~@c" (integer->char 27)) "#\\esc")
     ;  (equal? (format "~@c" (integer->char 127)) "#\\del")
     ;  (equal? (format "~@c" (integer->char 128)) "#\\200")
     ;  (equal? (format "~@c" (integer->char 255)) "#\\377")
     ;  (equal? (format "~65c") "A")
     ;  (equal? (format "~7@c") "#\\bel")
     (equal? (format "~:c" #\a) "a")
     (equal? (format "~:c" (integer->char 1)) "^A")
     (equal? (format "~:c" (integer->char 27)) "<esc>")
     ;  (equal? (format "~7:c") "^G")
     ;  (equal? (format "~:c" (integer->char 128)) "#\\200")
     ;  (equal? (format "~:c" (integer->char 127)) "#\\177")
     ;  (equal? (format "~:c" (integer->char 255)) "#\\377")
     )

(mat format-slib6
     ; plural test
     (equal? (format "test~p" 1) "test")
     (equal? (format "test~p" 2) "tests")
     (equal? (format "test~p" 0) "tests")
     (equal? (format "tr~@p" 1) "try")
     (equal? (format "tr~@p" 2) "tries")
     (equal? (format "tr~@p" 0) "tries")
     (equal? (format "~a test~:p" 10) "10 tests")
     (equal? (format "~a test~:p" 1) "1 test"))

(mat format-slib-slib7
     ; tilde tests
     (equal? (format "~~~~") "~~")
     (equal? (format "~3~") "~~~"))

(mat format-slib8
     ; whitespace character test
     (equal? (format "~%") "\n")
     (equal? (format "~3%") "\n\n\n")

     (equal? (format "~&") "")
     (equal? (format "abc~&") "abc\n")
     (equal? (format "abc~&def") "abc\ndef")
     (equal? (format "~3&") "\n\n")
     (equal? (format "abc~3&") "abc\n\n\n")
     ; ans was "abc\n\n\n"
     ; not yet  (equal? (format "~_~_~_") "   ")
     ; not yet  (equal? (format "~3_") "   ")
     )

(mat format-slib9
     ; tabulate test
     ; removed leading ~0& from control strings in following
     (equal? (format "~3t") "   ")
     (equal? (format "~10t") "          ")
     ; ans was ""
     (equal? (format "1234567890~,8tABC") "1234567890       ABC")
     (equal? (format "1234567890~0,8tABC") "1234567890      ABC")
     (equal? (format "1234567890~1,8tABC") "1234567890       ABC")
     (equal? (format "1234567890~2,8tABC") "1234567890        ABC")
     ; ans was "1234567890ABC"
     (equal? (format "1234567890~3,8tABC") "1234567890 ABC")
     (equal? (format "1234567890~4,8tABC") "1234567890  ABC")
     (equal? (format "1234567890~5,8tABC") "1234567890   ABC")
     (equal? (format "1234567890~6,8tABC") "1234567890    ABC")
     (equal? (format "1234567890~7,8tABC") "1234567890     ABC")
     (equal? (format "1234567890~8,8tABC") "1234567890      ABC")
     (equal? (format "1234567890~9,8tABC") "1234567890       ABC")
     (equal? (format "1234567890~10,8tABC") "1234567890        ABC")
     ; ans was "1234567890ABC"
     (equal? (format "1234567890~11,8tABC") "1234567890 ABC")
     (equal? (format "12345~,8tABCDE~,8tXYZ") "12345    ABCDE   XYZ")
     (equal? (format "~,8t+++~,8t===") " +++     ===")
     ; ans was "     +++     ==="
     ;  (equal? (format "ABC~,8,'.tDEF") "ABC......DEF")
     (equal? (format "~3,8@tABC") "        ABC")
     (equal? (format "1234~3,8@tABC") "1234    ABC")
     (equal? (format "12~3,8@tABC~3,8@tDEF") "12      ABC     DEF"))

(mat format-slib10
     ; indirection test
     (equal? (format "~a ~? ~a" 10 "~a ~a" '(20 30) 40) "10 20 30 40")
     (equal? (format "~a ~@? ~a" 10 "~a ~a" 20 30 40) "10 20 30 40"))

(mat format-slib11
     (equal? (format "~10a" "abc") "abc       ")
     (equal? (format "~10@a" "abc") "       abc")
     (equal? (format "~10a" "0123456789abc") "0123456789abc")
     (equal? (format "~10@a" "0123456789abc") "0123456789abc"))

(mat format-slib12
     ; pad character test
     (equal? (format "~10,,,'*a" "abc") "abc*******")
     (equal? (format "~10,,,'Xa" "abc") "abcXXXXXXX")
     ; bad test (equal? (format "~10,,,42a" "abc") "abc*******")
     (equal? (format "~10,,,'*@a" "abc") "*******abc")
     (equal? (format "~10,,3,'*a" "abc") "abc*******")
     (equal? (format "~10,,3,'*a" "0123456789abc") "0123456789abc***")
     ; min. padchar length
     (equal? (format "~10,,3,'*@a" "0123456789abc") "***0123456789abc"))

(mat format-slib13
     ; colinc, minpad padding test
     (equal? (format "~10,8,0,'*a" 123) "123********")
     (equal? (format "~10,9,0,'*a" 123) "123*********")
     (equal? (format "~10,10,0,'*a" 123) "123**********")
     (equal? (format "~10,11,0,'*a" 123) "123***********")
     (equal? (format "~8,1,0,'*a" 123) "123*****")
     (equal? (format "~8,2,0,'*a" 123) "123******")
     (equal? (format "~8,3,0,'*a" 123) "123******")
     (equal? (format "~8,4,0,'*a" 123) "123********")
     (equal? (format "~8,5,0,'*a" 123) "123*****")
     (equal? (format "~8,1,3,'*a" 123) "123*****")
     (equal? (format "~8,1,5,'*a" 123) "123*****")
     (equal? (format "~8,1,6,'*a" 123) "123******")
     (equal? (format "~8,1,9,'*a" 123) "123*********"))

(mat format-slib14
     ; slashify test
     (equal? (format "~s" "abc") "\"abc\"")
     (equal? (format "~s" "abc \\ abc") "\"abc \\\\ abc\"")
     (equal? (format "~a" "abc \\ abc") "abc \\ abc")
     (equal? (format "~s" "abc \" abc") "\"abc \\\" abc\"")
     (equal? (format "~a" "abc \" abc") "abc \" abc")
     (equal? (format "~s" #\space) "#\\space")
     (equal? (format "~s" #\newline) "#\\newline")
     (equal? (format "~s" #\tab) "#\\tab")
     ; ans was "#\\ht"
     (equal? (format "~s" #\a) "#\\a")
     (equal? (format "~a" '(a "b" c)) "(a b c)")
     ; ans was "(a \"b\" c)"
     )

(mat format-slib15
     ; continuation line test
     (equal? (format "abc~\n    123") "abc123")
     (equal? (format "abc~\n   ") "abc")
     (equal? (format "abc~:\n   def") "abc   def")
     (equal? (format "abc~@\n   def") "abc\ndef"))

(mat format-slib16
     ; string case conversion
     (equal? (format "~a ~(~a~) ~a" "abc" "HELLO WORLD" "xyz")
             "abc hello world xyz")
     (equal? (format "~a ~:(~a~) ~a" "abc" "HELLO WORLD" "xyz")
             "abc Hello World xyz")
     (equal? (format "~a ~@(~a~) ~a" "abc" "HELLO WORLD" "xyz")
             "abc Hello world xyz")
     (equal? (format "~a ~:@(~a~) ~a" "abc" "hello world" "xyz")
             "abc HELLO WORLD xyz")
     (equal? (format "~:@(~a~)" '(a b c)) "(A B C)")
     (equal? (format "~:@(~x~)" 255) "FF")
     (equal? (format "~:@(~p~)" 2) "S")
     ;  (test `("~:@(~a~)" ,display) (string-upcase (format:iobj->str display)))
     (equal? (format "~:(~a ~a ~a~) ~a" "abc" "xyz" "123" "world")
             "Abc Xyz 123 world"))

(mat format-slib17
     ; variable parameter
     (equal? (format "~va" 10 "abc") "abc       ")
     ; changed 42 to #\* below
     (equal? (format "~v,,,va" 10 #\* "abc") "abc*******"))

(mat format-slib18 ; number of remaining arguments as parameter
     (equal? (format "~#,,,'*@a ~a ~a ~a" 1 1 1 1) "***1 1 1 1"))

(mat format-slib19
     ; argument jumping
     (equal? (format "~a ~* ~a" 10 20 30) "10  30")
     (equal? (format "~a ~2* ~a" 10 20 30 40) "10  40")
     (equal? (format "~a ~:* ~a" 10) "10  10")
     (equal? (format "~a ~a ~2:* ~a ~a" 10 20) "10 20  10 20")
     (equal? (format "~a ~a ~@* ~a ~a" 10 20) "10 20  10 20")
     (equal? (format "~a ~a ~4@* ~a ~a" 10 20 30 40 50 60) "10 20  50 60"))

(mat format-slib20
     ; conditionals
     (equal? (format "~[abc~;xyz~]" 0) "abc")
     (equal? (format "~[abc~;xyz~]" 1) "xyz")
     (equal? (format "~[abc~;xyz~:;456~]" 99) "456")
     (equal? (format "~0[abc~;xyz~:;456~]") "abc")
     (equal? (format "~1[abc~;xyz~:;456~] ~a" 100) "xyz 100")
     (equal? (format "~#[no arg~;~a~;~a and ~a~;~a, ~a and ~a~]") "no arg")
     (equal? (format "~#[no arg~;~a~;~a and ~a~;~a, ~a and ~a~]" 10) "10")
     (equal? (format "~#[no arg~;~a~;~a and ~a~;~a, ~a and ~a~]" 10 20)
             "10 and 20")
     (equal? (format "~#[no arg~;~a~;~a and ~a~;~a, ~a and ~a~]" 10 20 30)
             "10, 20 and 30")
     (equal? (format "~:[hello~;world~] ~a" #t 10) "world 10")
     (equal? (format "~:[hello~;world~] ~a" #f 10) "hello 10")
     (equal? (format "~@[~a tests~]" #f) "")
     (equal? (format "~@[~a tests~]" 10) "10 tests")
     (equal? (format "~@[~a test~:p~] ~a" 10 'done) "10 tests done")
     (equal? (format "~@[~a test~:p~] ~a" 1 'done) "1 test done")
     (equal? (format "~@[~a test~:p~] ~a" 0 'done) "0 tests done")
     (equal? (format "~@[~a test~:p~] ~a" #f 'done) " done")
     (equal? (format "~@[ level = ~d~]~@[ length = ~d~]" #f 5)
             " length = 5")
     (equal? (format "~[abc~;~[4~;5~;6~]~;xyz~]" 0) "abc")
     ; nested conditionals (irrghh)
     (equal? (format "~[abc~;~[4~;5~;6~]~;xyz~]" 2) "xyz")
     (equal? (format "~[abc~;~[4~;5~;6~]~;xyz~]" 1 2) "6")

     ; cltl2 tests
     (begin
       (define foo
         "Items:~#[ none~; ~S~; ~S and ~S~
                 ~:;~@{~#[~; and~] ~S~^,~}~].")
       (string? foo))
     (equal? (format foo) "Items: none.")
     (equal? (format foo 'foo) "Items: foo.")
     (equal? (format foo 'foo 'bar) "Items: foo and bar.")
     (equal? (format foo 'foo 'bar 'baz) "Items: foo, bar, and baz.")
     (equal? (format foo 'foo 'bar 'baz 'quux)
             "Items: foo, bar, baz, and quux."))

(mat format-slib21
     ; iteration
     (equal? (format "~{ ~a ~}" '(a b c)) " a  b  c ")
     (equal? (format "~{ ~a ~}" '()) "")
     (equal? (format "~{ ~a ~5,,,'*a~}" '(a b c d)) " a b**** c d****")
     (equal? (format "~{ ~a,~a ~}" '(a 1 b 2 c 3)) " a,1  b,2  c,3 ")
     (equal? (format "~2{ ~a,~a ~}" '(a 1 b 2 c 3)) " a,1  b,2 ")
     (equal? (format "~3{~a ~} ~a" '(a b c d e) 100) "a b c  100")
     (equal? (format "~0{~a ~} ~a" '(a b c d e) 100) " 100")
     ; replaced (c d e f) with (c d) below
     (equal? (format "~:{ ~a,~a ~}" '((a b) (c d) (g h)))
             " a,b  c,d  g,h ")
     ; replaced (c d e f) with (c d) below
     (equal? (format "~2:{ ~a,~a ~}" '((a b) (c d) (g h))) " a,b  c,d ")
     (equal? (format "~@{ ~a,~a ~}" 'a 1 'b 2 'c 3) " a,1  b,2  c,3 ")
     (equal? (format "~2@{ ~a,~a ~} <~a|~a>" 'a 1 'b 2 'c 3)
             " a,1  b,2  <c|3>")
     (equal? (format "~:@{ ~a,~a ~}" '(a 1) '(b 2) '(c 3))
             " a,1  b,2  c,3 ")
     (equal? (format "~2:@{ ~a,~a ~} ~a" '(a 1) '(b 2) '(c 3))
             " a,1  b,2  (c 3)")
     (equal? (format "~{~}" "<~a,~a>" '(a 1 b 2 c 3)) "<a,1><b,2><c,3>")
     (equal? (format "~{ ~a ~{<~a>~}~} ~a" '(a (1 2) b (3 4)) 10)
             " a <1><2> b <3><4> 10"))

(mat format-slib22
     ; up and out
     (equal? (format "abc ~^ xyz") "abc ")
     (equal? (format "~@(abc ~^ xyz~) ~a" 10) "Abc  xyz 10")
     ; ans was "ABC  xyz 10"
     (equal? (format "done. ~^ ~d warning~:p. ~^ ~d error~:p.") "done. ")
     (equal? (format "done. ~^ ~d warning~:p. ~^ ~d error~:p." 10)
             "done.  10 warnings. ")
     (equal? (format "done. ~^ ~d warning~:p. ~^ ~d error~:p." 10 1)
             "done.  10 warnings.  1 error.")
     (equal? (format "~{ ~a ~^<~a>~} ~a" '(a b c d e f) 10)
             " a <b> c <d> e <f> 10")
     (equal? (format "~{ ~a ~^<~a>~} ~a" '(a b c d e) 10)
             " a <b> c <d> e  10")
     (equal? (format "abc~0^ xyz") "abc")
     (equal? (format "abc~9^ xyz") "abc xyz")
     (equal? (format "abc~7,4^ xyz") "abc xyz")
     (equal? (format "abc~7,7^ xyz") "abc")
     ;  (equal? (format "abc~3,7,9^ xyz") "abc")
     ;  (equal? (format "abc~8,7,9^ xyz") "abc xyz")
     ;  (equal? (format "abc~3,7,5^ xyz") "abc xyz")
     )

(mat format-slib23
     ; complexity tests
     (begin
       (define fmt
         "Items:~#[ none~; ~a~; ~a and ~a~:;~@{~#[~; and~] ~a~^,~}~].")
       (string? fmt))
     (equal? (format fmt) "Items: none.")
     (equal? (format fmt 'foo) "Items: foo.")
     (equal? (format fmt 'foo 'bar) "Items: foo and bar.")
     (equal? (format fmt 'foo 'bar 'baz) "Items: foo, bar, and baz.")
     (equal? (format fmt 'foo 'bar 'baz 'zok)
             "Items: foo, bar, baz, and zok."))

(mat format-slib24
     ; fixed floating points
     (equal? (format "~6,2f" 3.14159) "  3.14")
     (equal? (format "~6,1f" 3.14159) "   3.1")
     (equal? (format "~6,0f" 3.14159) "    3.")
     (equal? (format "~5,1f" 0) "  0.0")
     (equal? (format "~10,7f" 3.14159) " 3.1415900")
     (equal? (format "~10,7f" -3.14159) "-3.1415900")
     (equal? (format "~10,7@f" 3.14159) "+3.1415900")
     (equal? (format "~6,3f" 0.0) " 0.000")
     (equal? (format "~6,4f" 0.007) "0.0070")
     (equal? (format "~6,3f" 0.007) " 0.007")
     (equal? (format "~6,2f" 0.007) "  0.01")
     (equal? (format "~3,2f" 0.007) ".01")
     (equal? (format "~3,2f" -0.007) "-.01")
     (equal? (format "~6,2,,,'*f" 3.14159) "**3.14")
     (equal? (format "~6,3,,'?f" 12345.56789) "??????")
     (equal? (format "~6,3f" 12345.6789) "12345.679")
     (equal? (format "~,3f" 12345.6789) "12345.679")
     (equal? (format "~,3f" 9.9999) "10.000")
     (equal? (format "~6f" 23.4) "  23.4")
     (equal? (format "~6f" 1234.5) "1234.5")
     (equal? (format "~6f" 12345678) "12345678.")
     ; ans was "12345678.0"
     (equal? (format "~6,,,'?f" 12345678) "??????")
     (equal? (format "~6f" 123.56789) "123.57")
     (equal? (format "~6f" 123.0) " 123.0")
     (equal? (format "~6f" -123.0) "-123.0")
     (equal? (format "~6f" 0.0) "   0.0")
     (equal? (format "~3f" 3.141) "3.1")
     (equal? (format "~2f" 3.141) "3.")
     (equal? (format "~1f" 3.141) "3.")
     ; ans was "3.141"
     (equal? (format "~f" 123.56789) "123.56789")
     (equal? (format "~f" -314.0) "-314.0")
     (equal? (format "~f" 1e4) "10000.0")
     (equal? (format "~f" -1.23e10) "-12300000000.0")
     (equal? (format "~f" 1e-4) "0.0001")
     (equal? (format "~f" -1.23e-10) "-0.000000000123")
     (equal? (format "~@f" 314.0) "+314.0")
     (equal? (format "~,,3f" 0.123456) "123.456")
     (equal? (format "~,,-3f" -123.456) "-0.123456")
     (equal? (format "~5,,3f" 0.123456) "123.5"))

(mat format-slib25
     ; exponent floating points
     (equal? (format "~e" 3.14159) "3.14159e+0")
     (equal? (format "~e" 0.00001234) "1.234e-5")
     (equal? (format "~,,,0e" 0.00001234) "0.1234e-4")
     (equal? (format "~,3e" 3.14159) "3.142e+0")
     (equal? (format "~,3@e" 3.14159) "+3.142e+0")
     (equal? (format "~,3@e" 0.0) "+0.000e+0")
     (equal? (format "~,0e" 3.141) "3.e+0")
     (equal? (format "~,3,,0e" 3.14159) "0.314e+1")
     (equal? (format "~,5,3,-2e" 3.14159) "0.00314e+003")
     (equal? (format "~,5,3,-5e" -3.14159) "-0.000003e+006")
     ; ans was "-0.00000e+006"; this is a case where we have to grow d to accommodate given k
     (equal? (format "~,5,2,2e" 3.14159) "31.4159e-01")
     (equal? (format "~,5,2,,,,'ee" 0.0) "0.00000e+00")
     (equal? (format "~12,3e" -3.141) "   -3.141e+0")
     (equal? (format "~12,3,,,,'#e" -3.141) "###-3.141e+0")
     (equal? (format "~10,2e" -1.236e-4) "  -1.24e-4")
     (equal? (format "~5,3e" -3.141) "-3.141e+0")
     (equal? (format "~5,3,,,'*e" -3.141) "*****")
     (equal? (format "~3e" 3.14159) "3.e+0")
     ; ans was "3.14159e+0"
     (equal? (format "~4e" 3.14159) "3.e+0")
     ; ans was "3.14159e+0"
     (equal? (format "~5e" 3.14159) "3.e+0")
     (equal? (format "~5,,,,'*e" 3.14159) "3.e+0")
     (equal? (format "~6e" 3.14159) "3.1e+0")
     (equal? (format "~7e" 3.14159) "3.14e+0")
     (equal? (format "~7e" -3.14159) "-3.1e+0")
     (equal? (format "~8e" 3.14159) "3.142e+0")
     (equal? (format "~9e" 3.14159) "3.1416e+0")
     (equal? (format "~9,,,,,,'ee" 3.14159) "3.1416e+0")
     (equal? (format "~10e" 3.14159) "3.14159e+0")
     (equal? (format "~11e" 3.14159) " 3.14159e+0")
     (equal? (format "~12e" 3.14159) "  3.14159e+0")
     (equal? (format "~13,6,2,-5e" 3.14159) " 0.000003e+06")
     (equal? (format "~13,6,2,-4e" 3.14159) " 0.000031e+05")
     (equal? (format "~13,6,2,-3e" 3.14159) " 0.000314e+04")
     (equal? (format "~13,6,2,-2e" 3.14159) " 0.003142e+03")
     (equal? (format "~13,6,2,-1e" 3.14159) " 0.031416e+02")
     (equal? (format "~13,6,2,0e" 3.14159) " 0.314159e+01")
     (equal? (format "~13,6,2,1e" 3.14159) " 3.141590e+00")
     (equal? (format "~13,6,2,2e" 3.14159) " 31.41590e-01")
     (equal? (format "~13,6,2,3e" 3.14159) " 314.1590e-02")
     (equal? (format "~13,6,2,4e" 3.14159) " 3141.590e-03")
     (equal? (format "~13,6,2,5e" 3.14159) " 31415.90e-04")
     (equal? (format "~13,6,2,6e" 3.14159) " 314159.0e-05")
     (equal? (format "~13,6,2,7e" 3.14159) " 3141590.e-06")
     (equal? (format "~13,6,2,8e" 3.14159) "31415900.e-07")
     (equal? (format "~7,3,,-2e" 0.001) ".001e+0")
     (equal? (format "~8,3,,-2@e" 0.001) "+.001e+0")
     (equal? (format "~8,3,,-2@e" -0.001) "-.001e+0")
     (equal? (format "~8,3,,-2e" 0.001) "0.001e+0")
     (equal? (format "~7,,,-2e" 0.001) ".001e+0")
     ; ans was "0.00e+0"
     (equal? (format "~12,3,1e" 3.14159e12) "   3.142e+12")
     (equal? (format "~12,3,1,,'*e" 3.14159e12) "************")
     (equal? (format "~5,3,1e" 3.14159e12) "3.142e+12"))

(mat format-slib26
     ; general floating point (this test is from Steele's CL book)
     (equal? (format "~9,2,1,,'*g|~9,3,2,3,'?,,'$g|~9,3,2,0,'%g|~9,2g"
                     0.0314159
                     0.0314159
                     0.0314159
                     0.0314159)
             "  3.14e-2|314.2$-04|0.314e-01|  3.14e-2")
     (equal? (format "~9,2,1,,'*g|~9,3,2,3,'?,,'$g|~9,3,2,0,'%g|~9,2g"
                     0.314159
                     0.314159
                     0.314159
                     0.314159)
             "  0.31   |0.314    |0.314    | 0.31    ")
     (equal? (format "~9,2,1,,'*g|~9,3,2,3,'?,,'$g|~9,3,2,0,'%g|~9,2g"
                     3.14159
                     3.14159
                     3.14159
                     3.14159)
             "   3.1   | 3.14    | 3.14    |  3.1    ")
     (equal? (format "~9,2,1,,'*g|~9,3,2,3,'?,,'$g|~9,3,2,0,'%g|~9,2g"
                     31.4159
                     31.4159
                     31.4159
                     31.4159)
             "   31.   | 31.4    | 31.4    |  31.    ")
     (equal? (format "~9,2,1,,'*g|~9,3,2,3,'?,,'$g|~9,3,2,0,'%g|~9,2g"
                     314.159
                     314.159
                     314.159
                     314.159)
             "  3.14e+2| 314.    | 314.    |  3.14e+2")
     (equal? (format "~9,2,1,,'*g|~9,3,2,3,'?,,'$g|~9,3,2,0,'%g|~9,2g"
                     3141.59
                     3141.59
                     3141.59
                     3141.59)
             "  3.14e+3|314.2$+01|0.314e+04|  3.14e+3")
     (equal? (format "~9,2,1,,'*g|~9,3,2,3,'?,,'$g|~9,3,2,0,'%g|~9,2g"
                     3.14e12
                     3.14e12
                     3.14e12
                     3.14e12)
             "*********|314.0$+10|0.314e+13| 3.14e+12")
     (equal? (format "~9,2,1,,'*g|~9,3,2,3,'?,,'$g|~9,3,2,0,'%g|~9,2g"
                     3.14e120
                     3.14e120
                     3.14e120
                     3.14e120)
             "*********|?????????|%%%%%%%%%|3.14e+120")

     ; the fixed-format in the following were followed by the apparently
     ; required backpadding that we omit when w is not supplied
     (equal? (format "~g" 0.0) "0.")
     (equal? (format "~g" 0.1) "0.1")
     (equal? (format "~g" 0.01) "1.0e-2")
     (equal? (format "~g" 123.456) "123.456")
     (equal? (format "~g" 123456.7) "123456.7")
     (equal? (format "~g" 123456.78) "123456.78")
     (equal? (format "~g" 0.9282) "0.9282")
     (equal? (format "~g" 0.09282) "9.282e-2")
     (equal? (format "~g" 1) "1.")
     (equal? (format "~g" 12) "12."))

(mat format-slib27
     ; dollar floating point
     (equal? (format "~$" 1.23) "1.23")
     (equal? (format "~$" 1.2) "1.20")
     (equal? (format "~$" 0.0) "0.00")
     (equal? (format "~$" 9.999) "10.00")
     (equal? (format "~3$" 9.9999) "10.000")
     (equal? (format "~,4$" 3.2) "0003.20")
     (equal? (format "~,4$" 10000.2) "10000.20")
     (equal? (format "~,4,10$" 3.2) "   0003.20")
     (equal? (format "~,4,10@$" 3.2) "  +0003.20")
     (equal? (format "~,4,10:@$" 3.2) "+  0003.20")
     (equal? (format "~,4,10:$" -3.2) "-  0003.20")
     (equal? (format "~,4,10$" -3.2) "  -0003.20")
     (equal? (format "~,,10@$" 3.2) "     +3.20")
     (equal? (format "~,,10:@$" 3.2) "+     3.20")
     (equal? (format "~,,10:@$" -3.2) "-     3.20")
     (equal? (format "~,,10,'_@$" 3.2) "_____+3.20")
     (equal? (format "~,,4$" 1234.4) "1234.40"))
;;; 7.ms
;;; Copyright 1984-2017 Cisco Systems, Inc.
;;; 
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;; 
;;; http://www.apache.org/licenses/LICENSE-2.0
;;; 
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

;;; section 7-1:

(mat load/compile-file
     (error? (load "/file/not/there"))
     (error? (compile-file "/file/not/there"))
     (error? ; abc is not a string
             (load-program 'abc))
     (error? ; xxx is not a procedure
             (load-program "/file/not/there" 'xxx))
     (error? ; 3 is not a string
       (parameterize ([source-directories '("/tmp" ".")]) (load-program 3)))
     (error? ; 3 is not a string
       (parameterize ([source-directories '("/tmp" ".")])
         (load-program 3 values)))
     (not (top-level-bound? 'aaaaa))
     (let ([p (open-output-file "testfile.ss" 'replace)])
       (display "(let ((x 3) (y 4)) (set! aaaaa (+ x y)))" p)
       (close-output-port p)
       (load "testfile.ss")
       (eqv? aaaaa 7))
     (call/cc
       (lambda (k)
         (load "testfile.ss"
               (lambda (x)
                 (unless (equal? (annotation-stripped x)
                                 '(let ((x 3) (y 4))
                                    (set! aaaaa (+ x y))))
                         (k #f))))
         #t))
     (begin
       (printf "***** expect \"compile-file\" message:~%")
       (compile-file "testfile")
       (set! aaaaa 0)
       (load "testfile.so")
       (eqv? aaaaa 7))
     (parameterize ([compile-compressed #f])
       (printf "***** expect \"compile-file\" message:~%")
       (compile-file "testfile")
       (set! aaaaa 0)
       (load "testfile.so")
       (eqv? aaaaa 7))
     (let ((ip (open-input-string
                 "(let ((x -3) (y -4)) (set! aaaaa (+ x y)))"))
           (op (open-file-output-port "testfile.so" (file-options replace))))
       (compile-port ip op)
       (close-input-port ip)
       (close-port op)
       (set! aaaaa 0)
       (load "testfile.so")
       (eqv? aaaaa -7))
     (let ((ip (open-input-string
                 "(let ((x -3) (y -4)) (set! aaaaa (+ x y)))"))
           (op (open-file-output-port "testfile.so"
                 (file-options replace compressed))))
       (compile-port ip op)
       (close-input-port ip)
       (close-port op)
       (set! aaaaa 0)
       (load "testfile.so")
       (eqv? aaaaa -7))
     ; test compiling a file containing most-negative-fixnum
     (let ([p (open-output-file "testfile.ss" 'replace)])
       (printf "***** expect \"compile-file\" message:~%")
       (display `(define $mnfixnum ,(most-negative-fixnum)) p)
       (close-output-port p)
       (compile-file "testfile")
       (load "testfile.so")
       (eqv? $mnfixnum (most-negative-fixnum))))

(mat compile-to-port
     (eqv? (call-with-port
             (open-file-output-port "testfile.so" (file-options replace))
             (lambda (op)
               (compile-to-port
                 '((define ctp1 'hello) (set! ctp1 (cons 'goodbye ctp1)))
                 op)))
           (void))
     (begin (load "testfile.so") #t)
     (equal? ctp1 '(goodbye . hello))
     (begin
       (with-output-to-file "testfile-ctp2a.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-ctp2a)
                (export fact)
                (import (chezscheme))
                (define fact
                  (lambda (x)
                    (if (= x 0) 1 (* x (fact (- x 1)))))))))
         'replace)
       #t)
     (equal? (call-with-port
               (open-file-output-port "testfile.so"
                 (file-options replace compressed))
               (lambda (op)
                 (parameterize ([compile-imported-libraries #t])
                   (compile-to-port
                     '((top-level-program
                         (import (chezscheme) (testfile-ctp2a))
                         (pretty-print (fact 3))))
                     op))))
             '((testfile-ctp2a)))
     (equal? (with-output-to-string (lambda () (load "testfile.so"))) "6\n"))

(mat load-compiled-from-port
     (begin
       (define-values (o get) (open-bytevector-output-port))
       (compile-to-port '((define lcfp1 'worked) 'loaded) o)
       (eq? 'loaded
            (load-compiled-from-port (open-bytevector-input-port (get)))))
     (eq? 'worked lcfp1))

(mat compile-to-file
     (begin
       (delete-file (format "testfile.~s" (machine-type)))
       (compile-to-file
         '((define ctf1 'hello) (set! ctf1 (cons ctf1 'goodbye)))
         "testfile.so")
       #t)
     (begin (load "testfile.so") #t)
     ;; NB: should we protect the following in case we are actually cross compiling?
     (not (file-exists? (format "testfile.~s" (machine-type))))
     (equal? ctf1 '(hello . goodbye))
     (begin
       (with-output-to-file "testfile-ctf2a.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-ctf2a)
                (export fib)
                (import (chezscheme))
                (define fib
                  (lambda (x)
                    (if (< x 2)
                        x
                        (+ (fib (- x 1)) (fib (- x 2)))))))))
         'replace)
       #t)
     (equal? (parameterize ([compile-imported-libraries #t])
               (compile-to-file
                 '((top-level-program
                     (import (chezscheme) (testfile-ctf2a))
                     (pretty-print (fib 11))))
                 "testfile.so"))
             '((testfile-ctf2a)))
     (not (file-exists? (format "testfile-ctf2a.~s" (machine-type))))
     (not (file-exists? (format "testfile.~s" (machine-type))))
     (equal? (with-output-to-string (lambda () (load "testfile.so")))
             "89\n")
     (begin
       (compile-to-file
         '((library (testfile-ctf2a)
             (export fib)
             (import (chezscheme))
             (define fib
               (lambda (x)
                 (if (< x 2)
                     x
                     (+ (fib (- x 1)) (fib (- x 2))))))))
         "testfile.so")
       #t)
     (not (file-exists? (format "testfile.~s" (machine-type)))))

(mat compile-script
     (error? (compile-script "/file/not/there"))
     (begin
       (with-output-to-file "testfile.ss"
         (lambda ()
           (display "#! /usr/bin/scheme --script\n")
           (pretty-print '(define $cs-x 14))
           (pretty-print '(define $cs-y (lambda (q) (+ $cs-x q)))))
         'replace)
       (compile-script "testfile")
       #t)
     (error? $cs-x)
     (error? $cs-y)
     (begin (load "testfile.so") #t)
     (eqv? $cs-x 14)
     (eqv? ($cs-y -17) -3)
     (eqv? (with-input-from-file "testfile.so" read-char) #\#)

     ; test visit/revisit of compiled script
     (begin
       (with-output-to-file "testfile.ss"
         (lambda ()
           (printf "#! /usr/bin/scheme --script\n")
           (pretty-print
             '(eval-when (visit)
                (display "hello from testfile\n")))
           (pretty-print '(display "hello again from testfile\n")))
         'replace)
       (compile-script "testfile")
       #t)
     (equal? (with-output-to-string (lambda () (visit "testfile.so")))
             "hello from testfile\n")
     (equal? (with-output-to-string (lambda () (revisit "testfile.so")))
             "hello again from testfile\n")
     (equal? (with-output-to-string (lambda () (load "testfile.so")))
             "hello from testfile\nhello again from testfile\n"))

(mat load-program/compile-program
     (error? (compile-program "/file/not/there"))
     (error? (load-program "/file/not/there"))
     (error? ; abc is not a string
             (load-program 'abc))
     (error? ; xxx is not a procedure
             (load-program "/file/not/there" 'xxx))
     (error? ; 3 is not a string
       (parameterize ([source-directories '("/tmp" ".")]) (load-program 3)))
     (error? ; 3 is not a string
       (parameterize ([source-directories '("/tmp" ".")])
         (load-program 3 values)))
     (begin
       (with-output-to-file "testfile.ss"
         (lambda ()
           (display "#! /usr/bin/scheme --program\n")
           (pretty-print '(import (rnrs)))
           (pretty-print '(define $cp-x 14))
           (pretty-print '(define $cp-y (lambda (q) (+ $cp-x q))))
           (pretty-print
             '(begin
                (when (file-exists? "testfile-cp.ss")
                      (delete-file "testfile-cp.ss"))
                (with-output-to-file "testfile-cp.ss"
                  (lambda () (write (cons $cp-x ($cp-y 35))))))))
         'replace)
       (compile-program "testfile")
       #t)
     (begin (load-program "testfile.so") #t)
     (error? $cp-x)
     (error? $cp-y)
     (let ([p (with-input-from-file "testfile-cp.ss" read)])
       (eqv? (car p) 14)
       (eqv? (cdr p) 49))
     (eqv? (with-input-from-file "testfile.so" read-char) #\#)

     (begin
       (with-output-to-file "testfile.ss"
         (lambda ()
           (display "#! /usr/bin/scheme --program\n")
           (pretty-print '(import (rnrs)))
           (pretty-print
             '(begin
                (when (file-exists? "testfile-cp.ss")
                      (delete-file "testfile-cp.ss"))
                (with-output-to-file "testfile-cp.ss"
                  (lambda () (write "hello from testfile"))))))
         'replace)
       #t)
     (begin (load-program "testfile.ss") #t)
     (equal? (with-input-from-file "testfile-cp.ss" read)
             "hello from testfile")

     (begin
       (with-output-to-file "testfile.ss"
         (lambda ()
           (display "#! /usr/bin/scheme --program\n")
           (pretty-print '(import (rnrs)))
           (pretty-print '(pretty-print 'hello)))
         'replace)
       #t)
     (error? ; unbound variable pretty-print
             (compile-program "testfile"))
     (error? ; unbound variable pretty-print
             (load-program "testfile.ss"))

     (begin
       (with-output-to-file "testfile.ss"
         (lambda ()
           (display "#! /usr/bin/scheme --program\n")
           (pretty-print '(import (rnrs)))
           (pretty-print '(#%write 'hello)))
         'replace)
       #t)
     (error? ; invalid #% syntax in #!r6rs mode
             (compile-program "testfile"))
     (error? ; invalid #% syntax in #!r6rs mode
             (load-program "testfile.ss")))

(mat maybe-compile
     (error? ; not a procedure
             (compile-program-handler 'ignore))
     (procedure? (compile-program-handler))
     (error? ; not a string
             (maybe-compile-file '(spam)))
     (error? ; not a string
             (maybe-compile-file "spam" 'spam))
     (error? ; not a string
             (maybe-compile-file -2.5 "spam"))
     (error? ; .ss file does not exist
             (maybe-compile-file "probably-does-not-exist.ss"))
     (error? ; .ss file does not exist
       (maybe-compile-file
         "probably-does-not-exist.ss"
         "probably-does-not-exist.so"))
     (begin
       (with-output-to-file "testfile-mc.ss"
         (lambda ()
           (for-each
             pretty-print
             '((import (chezscheme)) (pretty-print 'hello))))
         'replace)
       #t)
     (error? ; cannot create .so file
       (maybe-compile-file "testfile-mc.ss" "/probably/does/not/exist.so"))
     (error? ; not a string
             (maybe-compile-program '(spam)))
     (error? ; not a string
             (maybe-compile-program "spam" 'spam))
     (error? ; not a string
             (maybe-compile-program -2.5 "spam"))
     (error? ; .ss file does not exist
             (maybe-compile-program "probably-does-not-exist.ss"))
     (error? ; .ss file does not exist
       (maybe-compile-program
         "probably-does-not-exist.ss"
         "probably-does-not-exist.so"))
     (begin
       (with-output-to-file "testfile-mc.ss"
         (lambda ()
           (for-each
             pretty-print
             '((import (chezscheme)) (pretty-print 'hello))))
         'replace)
       #t)
     (error? ; cannot create .so file
       (maybe-compile-program
         "testfile-mc.ss"
         "/probably/does/not/exist.so"))
     (error? ; not a string
             (maybe-compile-library '(spam)))
     (error? ; not a string
             (maybe-compile-library "spam" 'spam))
     (error? ; not a string
             (maybe-compile-library -2.5 "spam"))
     (error? ; .ss file does not exist
             (maybe-compile-library "probably-does-not-exist.ss"))
     (error? ; .ss file does not exist
       (maybe-compile-library
         "probably-does-not-exist.ss"
         "probably-does-not-exist.so"))
     (begin
       (with-output-to-file "testfile-mc.ss"
         (lambda ()
           (pretty-print '(library (testfile-mc) (export) (import))))
         'replace)
       #t)
     (error? ; cannot create .so file
       (maybe-compile-library
         "testfile-mc.ss"
         "/probably/does/not/exist.so"))
     (begin
       (with-output-to-file "testfile-mc.ss"
         (lambda ()
           (for-each
             pretty-print
             '((import (chezscheme)) (if))))
         'replace)
       #t)
     (error? ; syntax error
       (maybe-compile-file "testfile-mc.ss" "testfile-mc.so"))
     (not (file-exists? "testfile-mc.so"))
     (error? ; syntax error
       (maybe-compile-program "testfile-mc.ss" "testfile-mc.so"))
     (not (file-exists? "testfile-mc.so"))
     (begin
       (with-output-to-file "testfile-mc.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-mc)
                (export x)
                (import (chezscheme))
                (define))))
         'replace)
       #t)
     (error? ; syntax error
       (maybe-compile-library "testfile-mc.ss" "testfile-mc.so"))
     (not (file-exists? "testfile-mc.so"))
     (begin
       (for-each
         delete-file
         '("testfile-mc-a.so" "testfile-mc-b.so" "testfile-mc-foo.so"))
       (with-output-to-file "testfile-mc-a.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-mc-a)
                (export a)
                (import (chezscheme))
                (define a "a"))))
         'replace)
       (with-output-to-file "testfile-mc-b.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-mc-b)
                (export a b)
                (import (chezscheme) (testfile-mc-a))
                (define b "b"))))
         'replace)
       (with-output-to-file "testfile-mc-c.ss"
         (lambda () (pretty-print '(define c "c")))
         'replace)
       (with-output-to-file "testfile-mc-foo.ss"
         (lambda ()
           (for-each
             pretty-print
             '((import (chezscheme) (testfile-mc-b))
               (include "testfile-mc-c.ss")
               (pretty-print (list a b c)))))
         'replace)
       (separate-compile
         '(lambda (x)
            (parameterize ([compile-imported-libraries #t])
              (maybe-compile-program x)))
         'mc-foo)
       #t)
     (equal? (separate-eval '(load-program "testfile-mc-foo.so"))
             "(\"a\" \"b\" \"c\")\n")
     (equal? (let ([mt* (map file-modification-time
                             (list "testfile-mc-a.so"
                                   "testfile-mc-b.so"
                                   "testfile-mc-foo.so"))])
               (separate-compile
                 '(lambda (x)
                    (parameterize ([compile-imported-libraries #t])
                      (maybe-compile-program x)))
                 'mc-foo)
               (map (lambda (x y)
                      (if (time=? x y)
                          '=
                          (if (time<? x y) '< '>)))
                    (map file-modification-time
                         '("testfile-mc-a.so"
                            "testfile-mc-b.so"
                            "testfile-mc-foo.so"))
                    mt*))
             '(= = =))
     (equal? (let ([mt* (map file-modification-time
                             (list "testfile-mc-a.so"
                                   "testfile-mc-b.so"
                                   "testfile-mc-foo.so"))])
               (separate-compile
                 '(lambda (x)
                    (parameterize ([compile-imported-libraries #t])
                      (maybe-compile-library x)))
                 'mc-b)
               (map (lambda (x y)
                      (if (time=? x y)
                          '=
                          (if (time<? x y) '< '>)))
                    (map file-modification-time
                         (list "testfile-mc-a.so"
                               "testfile-mc-b.so"
                               "testfile-mc-foo.so"))
                    mt*))
             '(= = =))
     (equal? (let ([mt* (map file-modification-time
                             (list "testfile-mc-a.so"
                                   "testfile-mc-b.so"
                                   "testfile-mc-foo.so"))])
               (separate-compile
                 '(lambda (x)
                    (parameterize ([compile-imported-libraries #t])
                      (maybe-compile-library x)))
                 'mc-a)
               (map (lambda (x y)
                      (if (time=? x y)
                          '=
                          (if (time<? x y) '< '>)))
                    (map file-modification-time
                         (list "testfile-mc-a.so"
                               "testfile-mc-b.so"
                               "testfile-mc-foo.so"))
                    mt*))
             '(= = =))
     (touch "testfile-mc-foo.so" "testfile-mc-foo.ss")
     (equal? (let ([mt* (map file-modification-time
                             (list "testfile-mc-a.so"
                                   "testfile-mc-b.so"
                                   "testfile-mc-foo.so"))])
               (separate-compile
                 '(lambda (x)
                    (parameterize ([compile-imported-libraries #t])
                      (maybe-compile-program x)))
                 'mc-foo)
               (map (lambda (x y)
                      (if (time=? x y)
                          '=
                          (if (time<? x y) '< '>)))
                    (map file-modification-time
                         (list "testfile-mc-a.so"
                               "testfile-mc-b.so"
                               "testfile-mc-foo.so"))
                    mt*))
             '(= = >))
     (equal? (separate-eval '(load-program "testfile-mc-foo.so"))
             "(\"a\" \"b\" \"c\")\n")
     (touch "testfile-mc-foo.so" "testfile-mc-c.ss")
     (equal? (let ([mt* (map file-modification-time
                             (list "testfile-mc-a.so"
                                   "testfile-mc-b.so"
                                   "testfile-mc-foo.so"))])
               (separate-compile
                 '(lambda (x)
                    (parameterize ([compile-imported-libraries #t])
                      (maybe-compile-program x)))
                 'mc-foo)
               (map (lambda (x y)
                      (if (time=? x y)
                          '=
                          (if (time<? x y) '< '>)))
                    (map file-modification-time
                         (list "testfile-mc-a.so"
                               "testfile-mc-b.so"
                               "testfile-mc-foo.so"))
                    mt*))
             '(= = >))
     (equal? (separate-eval '(load-program "testfile-mc-foo.so"))
             "(\"a\" \"b\" \"c\")\n")
     (touch "testfile-mc-foo.so" "testfile-mc-b.ss")
     (equal? (let ([mt* (map file-modification-time
                             (list "testfile-mc-a.so"
                                   "testfile-mc-b.so"
                                   "testfile-mc-foo.so"))])
               (separate-compile
                 '(lambda (x)
                    (parameterize ([compile-imported-libraries #t])
                      (maybe-compile-program x)))
                 'mc-foo)
               (map (lambda (x y)
                      (if (time=? x y)
                          '=
                          (if (time<? x y) '< '>)))
                    (map file-modification-time
                         (list "testfile-mc-a.so"
                               "testfile-mc-b.so"
                               "testfile-mc-foo.so"))
                    mt*))
             '(= > >))
     (equal? (separate-eval '(load-program "testfile-mc-foo.so"))
             "(\"a\" \"b\" \"c\")\n")
     (touch "testfile-mc-foo.so" "testfile-mc-a.ss")
     ((lambda (x ls) (and (member x ls) #t))
      (let ([mt* (map file-modification-time
                      (list "testfile-mc-a.so"
                            "testfile-mc-b.so"
                            "testfile-mc-foo.so"))])
        (let ([s (separate-compile
                   '(lambda (x)
                      (parameterize
                        ([compile-program-handler
                           (lambda (ifn ofn)
                             (printf "yippee!\n")
                             (compile-program ifn ofn))]
                         [compile-imported-libraries #t]
                         [compile-file-message #f])
                        (maybe-compile-program x)))
                   'mc-foo)])
          (cons (map (lambda (x y)
                       (if (time=? x y)
                           '=
                           (if (time<? x y) '< '>)))
                     (map file-modification-time
                          (list "testfile-mc-a.so"
                                "testfile-mc-b.so"
                                "testfile-mc-foo.so"))
                     mt*)
                s)))
      '(((> > >) . "yippee!\n((testfile-mc-a) (testfile-mc-b))\n")
        ((> > >) . "yippee!\n((testfile-mc-b) (testfile-mc-a))\n")))
     (equal? (let ([mt* (map file-modification-time
                             (list "testfile-mc-a.so"
                                   "testfile-mc-b.so"
                                   "testfile-mc-foo.so"))])
               (let ([s (separate-compile
                          '(lambda (x)
                             (parameterize
                               ([compile-imported-libraries #t]
                                [compile-file-message #f])
                               (maybe-compile-program x)))
                          'mc-foo)])
                 (cons (map (lambda (x y)
                              (if (time=? x y)
                                  '=
                                  (if (time<? x y) '< '>)))
                            (map file-modification-time
                                 (list "testfile-mc-a.so"
                                       "testfile-mc-b.so"
                                       "testfile-mc-foo.so"))
                            mt*)
                       s)))
             '((= = =) . "#f\n"))
     (equal? (separate-eval '(load-program "testfile-mc-foo.so"))
             "(\"a\" \"b\" \"c\")\n")
     (touch "testfile-mc-foo.so" "testfile-mc-b.ss")
     (equal? (let ([mt* (map file-modification-time
                             (list "testfile-mc-a.so"
                                   "testfile-mc-b.so"
                                   "testfile-mc-foo.so"))])
               (separate-compile
                 '(lambda (x)
                    (parameterize ([compile-imported-libraries #t])
                      (maybe-compile-library x)))
                 'mc-b)
               (map (lambda (x y)
                      (if (time=? x y)
                          '=
                          (if (time<? x y) '< '>)))
                    (map file-modification-time
                         (list "testfile-mc-a.so"
                               "testfile-mc-b.so"
                               "testfile-mc-foo.so"))
                    mt*))
             '(= > =))
     ; NB: create testfile-mc-a.ss newer than testfile-mc-1b.so, since testfile-mc-1b.so might be newer than testfile-mc-foo.so
     (touch "testfile-mc-b.so" "testfile-mc-a.ss")
     (equal? (let ([mt* (map file-modification-time
                             (list "testfile-mc-a.so"
                                   "testfile-mc-b.so"
                                   "testfile-mc-foo.so"))])
               (let ([s (separate-compile
                          '(lambda (x)
                             (parameterize
                               ([compile-imported-libraries #f]
                                [import-notify #t])
                               (maybe-compile-library x)))
                          'mc-b)])
                 (cons (map (lambda (x y)
                              (if (time=? x y)
                                  '=
                                  (if (time<? x y) '< '>)))
                            (map file-modification-time
                                 (list "testfile-mc-a.so"
                                       "testfile-mc-b.so"
                                       "testfile-mc-foo.so"))
                            mt*)
                       s)))
             '((= = =)
               .
               "maybe-compile-library: object file is not older\nmaybe-compile-library: did not find source file \"testfile-mc-a.chezscheme.sls\"\nmaybe-compile-library: found source file \"testfile-mc-a.ss\"\nmaybe-compile-library: found corresponding object file \"testfile-mc-a.so\"\n"))
     (equal? (let ([mt* (map file-modification-time
                             (list "testfile-mc-a.so"
                                   "testfile-mc-b.so"
                                   "testfile-mc-foo.so"))])
               (separate-compile
                 '(lambda (x)
                    (parameterize ([compile-imported-libraries #t])
                      (maybe-compile-library x)))
                 'mc-b)
               (map (lambda (x y)
                      (if (time=? x y)
                          '=
                          (if (time<? x y) '< '>)))
                    (map file-modification-time
                         (list "testfile-mc-a.so"
                               "testfile-mc-b.so"
                               "testfile-mc-foo.so"))
                    mt*))
             '(> > =))
     (equal? (let ([mt* (map file-modification-time
                             (list "testfile-mc-a.so"
                                   "testfile-mc-b.so"
                                   "testfile-mc-foo.so"))])
               (separate-compile
                 '(lambda (x)
                    (parameterize ([compile-imported-libraries #t])
                      (maybe-compile-program x)))
                 'mc-foo)
               (map (lambda (x y)
                      (if (time=? x y)
                          '=
                          (if (time<? x y) '< '>)))
                    (map file-modification-time
                         (list "testfile-mc-a.so"
                               "testfile-mc-b.so"
                               "testfile-mc-foo.so"))
                    mt*))
             '(= = >))
     (equal? (separate-eval '(load-program "testfile-mc-foo.so"))
             "(\"a\" \"b\" \"c\")\n")
     (begin
       (for-each
         delete-file
         '("testfile-mc-a.so"
            "testfile-mc-b.so"
            "testfile-mc-e.so"
            "testfile-mc-f.so"
            "testfile-mc-foo.so"))
       (with-output-to-file "testfile-mc-a.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-mc-a)
                (export a)
                (import (chezscheme))
                (define a "a"))))
         'replace)
       (with-output-to-file "testfile-mc-b.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-mc-b)
                (export a b)
                (import (chezscheme) (testfile-mc-a))
                (define b "b"))))
         'replace)
       (with-output-to-file "testfile-mc-c.ss"
         (lambda () (pretty-print '(define c "c")))
         'replace)
       (with-output-to-file "testfile-mc-d.ss"
         (lambda ()
           (pretty-print
             '(module M
                (d)
                (import (testfile-mc-a) (testfile-mc-b) (chezscheme))
                (define d (vector b a)))))
         'replace)
       (with-output-to-file "testfile-mc-e.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-mc-e)
                (export e-str)
                (import (chezscheme))
                (define e-str "e"))))
         'replace)
       (with-output-to-file "testfile-mc-e-import.ss"
         (lambda () (pretty-print '(import (testfile-mc-e))))
         'replace)
       (with-output-to-file "testfile-mc-f.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-mc-f)
                (export f-str)
                (import (chezscheme))
                (define f-str "f"))))
         'replace)
       (with-output-to-file "testfile-mc-foo.ss"
         (lambda ()
           (for-each
             pretty-print
             '((import (chezscheme) (testfile-mc-b))
               (include "testfile-mc-c.ss")
               (include "testfile-mc-d.ss")
               (import M)
               (meta define build-something-f
                     (lambda (k something)
                       (import (testfile-mc-f))
                       (datum->syntax k
                         (string->symbol
                           (string-append something "-" f-str)))))
               (define-syntax e
                 (lambda (x)
                   (syntax-case x ()
                     [(k)
                      (let ()
                        (include "testfile-mc-e-import.ss")
                        #`'#,(build-something-f #'k e-str))])))
               (pretty-print (list a b c d (e))))))
         'replace)
       (separate-compile
         '(lambda (x)
            (parameterize ([compile-imported-libraries #t])
              (maybe-compile-file x)))
         'mc-foo)
       #t)
     (equal? (separate-eval '(load "testfile-mc-foo.so"))
             "(\"a\" \"b\" \"c\" #(\"b\" \"a\") e-f)\n")
     (equal? (let ([mt* (map file-modification-time
                             '("testfile-mc-a.so"
                                "testfile-mc-b.so"
                                "testfile-mc-e.so"
                                "testfile-mc-f.so"
                                "testfile-mc-foo.so"))])
               (separate-compile
                 '(lambda (x)
                    (parameterize ([compile-imported-libraries #t])
                      (maybe-compile-file x)))
                 'mc-foo)
               (map (lambda (x y)
                      (if (time=? x y)
                          '=
                          (if (time<? x y) '< '>)))
                    (map file-modification-time
                         '("testfile-mc-a.so"
                            "testfile-mc-b.so"
                            "testfile-mc-e.so"
                            "testfile-mc-f.so"
                            "testfile-mc-foo.so"))
                    mt*))
             '(= = = = =))
     (touch "testfile-mc-foo.so" "testfile-mc-foo.ss")
     (equal? (let ([mt* (map file-modification-time
                             '("testfile-mc-a.so"
                                "testfile-mc-b.so"
                                "testfile-mc-e.so"
                                "testfile-mc-f.so"
                                "testfile-mc-foo.so"))])
               (separate-compile
                 '(lambda (x)
                    (parameterize ([compile-imported-libraries #t])
                      (maybe-compile-file x)))
                 'mc-foo)
               (map (lambda (x y)
                      (if (time=? x y)
                          '=
                          (if (time<? x y) '< '>)))
                    (map file-modification-time
                         '("testfile-mc-a.so"
                            "testfile-mc-b.so"
                            "testfile-mc-e.so"
                            "testfile-mc-f.so"
                            "testfile-mc-foo.so"))
                    mt*))
             '(= = = = >))
     (touch "testfile-mc-foo.so" "testfile-mc-a.ss")
     (equal? (let ([mt* (map file-modification-time
                             '("testfile-mc-a.so"
                                "testfile-mc-b.so"
                                "testfile-mc-e.so"
                                "testfile-mc-f.so"
                                "testfile-mc-foo.so"))])
               (separate-compile
                 '(lambda (x)
                    (parameterize ([compile-imported-libraries #f])
                      (maybe-compile-file x)))
                 'mc-foo)
               (map (lambda (x y)
                      (if (time=? x y)
                          '=
                          (if (time<? x y) '< '>)))
                    (map file-modification-time
                         '("testfile-mc-a.so"
                            "testfile-mc-b.so"
                            "testfile-mc-e.so"
                            "testfile-mc-f.so"
                            "testfile-mc-foo.so"))
                    mt*))
             '(= = = = =))
     (equal? (let ([mt* (map file-modification-time
                             '("testfile-mc-a.so"
                                "testfile-mc-b.so"
                                "testfile-mc-e.so"
                                "testfile-mc-f.so"
                                "testfile-mc-foo.so"))])
               (separate-compile
                 '(lambda (x)
                    (parameterize ([compile-imported-libraries #t])
                      (maybe-compile-file x)))
                 'mc-foo)
               (map (lambda (x y)
                      (if (time=? x y)
                          '=
                          (if (time<? x y) '< '>)))
                    (map file-modification-time
                         '("testfile-mc-a.so"
                            "testfile-mc-b.so"
                            "testfile-mc-e.so"
                            "testfile-mc-f.so"
                            "testfile-mc-foo.so"))
                    mt*))
             '(> > = = >))
     (touch "testfile-mc-foo.so" "testfile-mc-c.ss")
     (equal? (let ([mt* (map file-modification-time
                             '("testfile-mc-a.so"
                                "testfile-mc-b.so"
                                "testfile-mc-e.so"
                                "testfile-mc-f.so"
                                "testfile-mc-foo.so"))])
               (separate-compile
                 '(lambda (x)
                    (parameterize ([compile-imported-libraries #f])
                      (maybe-compile-file x)))
                 'mc-foo)
               (map (lambda (x y)
                      (if (time=? x y)
                          '=
                          (if (time<? x y) '< '>)))
                    (map file-modification-time
                         '("testfile-mc-a.so"
                            "testfile-mc-b.so"
                            "testfile-mc-e.so"
                            "testfile-mc-f.so"
                            "testfile-mc-foo.so"))
                    mt*))
             '(= = = = >))
     (touch "testfile-mc-foo.so" "testfile-mc-e.ss")
     (equal? (let ([mt* (map file-modification-time
                             '("testfile-mc-a.so"
                                "testfile-mc-b.so"
                                "testfile-mc-e.so"
                                "testfile-mc-f.so"
                                "testfile-mc-foo.so"))])
               (separate-compile
                 '(lambda (x)
                    (parameterize ([compile-imported-libraries #f])
                      (maybe-compile-file x)))
                 'mc-foo)
               (map (lambda (x y)
                      (if (time=? x y)
                          '=
                          (if (time<? x y) '< '>)))
                    (map file-modification-time
                         '("testfile-mc-a.so"
                            "testfile-mc-b.so"
                            "testfile-mc-e.so"
                            "testfile-mc-f.so"
                            "testfile-mc-foo.so"))
                    mt*))
             '(= = = = =))
     (equal? (let ([mt* (map file-modification-time
                             '("testfile-mc-a.so"
                                "testfile-mc-b.so"
                                "testfile-mc-e.so"
                                "testfile-mc-f.so"
                                "testfile-mc-foo.so"))])
               (separate-compile
                 '(lambda (x)
                    (parameterize ([compile-imported-libraries #t])
                      (maybe-compile-file x)))
                 'mc-foo)
               (map (lambda (x y)
                      (if (time=? x y)
                          '=
                          (if (time<? x y) '< '>)))
                    (map file-modification-time
                         '("testfile-mc-a.so"
                            "testfile-mc-b.so"
                            "testfile-mc-e.so"
                            "testfile-mc-f.so"
                            "testfile-mc-foo.so"))
                    mt*))
             '(= = > = >))
     (touch "testfile-mc-foo.so" "testfile-mc-e-import.ss")
     (equal? (let ([mt* (map file-modification-time
                             '("testfile-mc-a.so"
                                "testfile-mc-b.so"
                                "testfile-mc-e.so"
                                "testfile-mc-f.so"
                                "testfile-mc-foo.so"))])
               (separate-compile
                 '(lambda (x)
                    (parameterize ([compile-imported-libraries #f])
                      (maybe-compile-file x)))
                 'mc-foo)
               (map (lambda (x y)
                      (if (time=? x y)
                          '=
                          (if (time<? x y) '< '>)))
                    (map file-modification-time
                         '("testfile-mc-a.so"
                            "testfile-mc-b.so"
                            "testfile-mc-e.so"
                            "testfile-mc-f.so"
                            "testfile-mc-foo.so"))
                    mt*))
             '(= = = = >))
     (touch "testfile-mc-foo.so" "testfile-mc-f.ss")
     (equal? (let ([mt* (map file-modification-time
                             '("testfile-mc-a.so"
                                "testfile-mc-b.so"
                                "testfile-mc-e.so"
                                "testfile-mc-f.so"
                                "testfile-mc-foo.so"))])
               (separate-compile
                 '(lambda (x)
                    (parameterize ([compile-imported-libraries #f])
                      (maybe-compile-file x)))
                 'mc-foo)
               (map (lambda (x y)
                      (if (time=? x y)
                          '=
                          (if (time<? x y) '< '>)))
                    (map file-modification-time
                         '("testfile-mc-a.so"
                            "testfile-mc-b.so"
                            "testfile-mc-e.so"
                            "testfile-mc-f.so"
                            "testfile-mc-foo.so"))
                    mt*))
             '(= = = = =))
     (equal? (let ([mt* (map file-modification-time
                             '("testfile-mc-a.so"
                                "testfile-mc-b.so"
                                "testfile-mc-e.so"
                                "testfile-mc-f.so"
                                "testfile-mc-foo.so"))])
               (separate-compile
                 '(lambda (x)
                    (parameterize ([compile-imported-libraries #t])
                      (maybe-compile-file x)))
                 'mc-foo)
               (map (lambda (x y)
                      (if (time=? x y)
                          '=
                          (if (time<? x y) '< '>)))
                    (map file-modification-time
                         '("testfile-mc-a.so"
                            "testfile-mc-b.so"
                            "testfile-mc-e.so"
                            "testfile-mc-f.so"
                            "testfile-mc-foo.so"))
                    mt*))
             '(= = = > >))
     (begin
       (rm-rf "testdir")
       (mkdir "testdir")
       (mkfile "testdir/testfile-mc-1a.ss" '(define mcratfink 'abe))
       (mkfile "testdir/testfile-mc-1b.ss"
         '(library (testdir testfile-mc-1b)
            (export mc-1b-x)
            (import (chezscheme))
            (include "testfile-mc-1a.ss")
            (define mc-1b-x (lambda () (list mcratfink)))))
       (mkfile "testdir/testfile-mc-1c.ss"
         '(library (testdir testfile-mc-1c)
                   (export mc-1b-x)
                   (import (testdir testfile-mc-1b))))
       (separate-compile
         '(lambda (x)
            (parameterize ([compile-imported-libraries #t])
              (compile-library x)))
         "testdir/testfile-mc-1c")
       #t)
     (equal? (separate-eval
               '(let ()
                  (import (testdir testfile-mc-1c))
                  (mc-1b-x)))
             "(abe)\n")
     (equal? (let ([mt* (map file-modification-time
                             '("testdir/testfile-mc-1b.so"
                                "testdir/testfile-mc-1c.so"))])
               (separate-compile
                 '(lambda (x)
                    (parameterize ([compile-imported-libraries #t])
                      (maybe-compile-library x)))
                 "testdir/testfile-mc-1c")
               (map (lambda (x y)
                      (if (time=? x y)
                          '=
                          (if (time<? x y) '< '>)))
                    (map file-modification-time
                         '("testdir/testfile-mc-1b.so"
                            "testdir/testfile-mc-1c.so"))
                    mt*))
             '(= =))
     (touch "testdir/testfile-mc-1c.so" "testdir/testfile-mc-1a.ss")
     (equal? (let ([mt* (map file-modification-time
                             '("testdir/testfile-mc-1b.so"
                                "testdir/testfile-mc-1c.so"))])
               (separate-compile
                 '(lambda (x)
                    (parameterize ([compile-imported-libraries #f])
                      (maybe-compile-library x)))
                 "testdir/testfile-mc-1c")
               (map (lambda (x y)
                      (if (time=? x y)
                          '=
                          (if (time<? x y) '< '>)))
                    (map file-modification-time
                         '("testdir/testfile-mc-1b.so"
                            "testdir/testfile-mc-1c.so"))
                    mt*))
             '(= =))
     (equal? (let ([mt* (map file-modification-time
                             '("testdir/testfile-mc-1b.so"
                                "testdir/testfile-mc-1c.so"))])
               (separate-compile
                 '(lambda (x)
                    (parameterize ([compile-imported-libraries #t])
                      (maybe-compile-library x)))
                 "testdir/testfile-mc-1c")
               (map (lambda (x y)
                      (if (time=? x y)
                          '=
                          (if (time<? x y) '< '>)))
                    (map file-modification-time
                         '("testdir/testfile-mc-1b.so"
                            "testdir/testfile-mc-1c.so"))
                    mt*))
             '(> >))
     (touch "testdir/testfile-mc-1c.so" "testdir/testfile-mc-1b.ss")
     (equal? (let ([mt* (map file-modification-time
                             '("testdir/testfile-mc-1b.so"
                                "testdir/testfile-mc-1c.so"))])
               (separate-compile
                 '(lambda (x)
                    (parameterize ([compile-imported-libraries #f])
                      (maybe-compile-library x)))
                 "testdir/testfile-mc-1c")
               (map (lambda (x y)
                      (if (time=? x y)
                          '=
                          (if (time<? x y) '< '>)))
                    (map file-modification-time
                         '("testdir/testfile-mc-1b.so"
                            "testdir/testfile-mc-1c.so"))
                    mt*))
             '(= =))
     (equal? (let ([mt* (map file-modification-time
                             '("testdir/testfile-mc-1b.so"
                                "testdir/testfile-mc-1c.so"))])
               (separate-compile
                 '(lambda (x)
                    (parameterize ([compile-imported-libraries #t])
                      (maybe-compile-library x)))
                 "testdir/testfile-mc-1c")
               (map (lambda (x y)
                      (if (time=? x y)
                          '=
                          (if (time<? x y) '< '>)))
                    (map file-modification-time
                         '("testdir/testfile-mc-1b.so"
                            "testdir/testfile-mc-1c.so"))
                    mt*))
             '(> >))
     (touch "testdir/testfile-mc-1c.so" "testdir/testfile-mc-1c.ss")
     (equal? (let ([mt* (map file-modification-time
                             '("testdir/testfile-mc-1b.so"
                                "testdir/testfile-mc-1c.so"))])
               (separate-compile
                 '(lambda (x)
                    (parameterize ([compile-imported-libraries #t])
                      (maybe-compile-library x)))
                 "testdir/testfile-mc-1c")
               (map (lambda (x y)
                      (if (time=? x y)
                          '=
                          (if (time<? x y) '< '>)))
                    (map file-modification-time
                         '("testdir/testfile-mc-1b.so"
                            "testdir/testfile-mc-1c.so"))
                    mt*))
             '(= >))
     (equal? (let ([mt* (map file-modification-time
                             '("testdir/testfile-mc-1b.so"
                                "testdir/testfile-mc-1c.so"))])
               (separate-compile
                 '(lambda (x)
                    (parameterize ([compile-imported-libraries #f])
                      (maybe-compile-library x)))
                 "testdir/testfile-mc-1c")
               (map (lambda (x y)
                      (if (time=? x y)
                          '=
                          (if (time<? x y) '< '>)))
                    (map file-modification-time
                         '("testdir/testfile-mc-1b.so"
                            "testdir/testfile-mc-1c.so"))
                    mt*))
             '(= =))
     (error? ; can't find testfile-mc-1a.ss
             (separate-compile 'compile-library "testdir/testfile-mc-1b"))
     (begin
       (separate-compile
         '(lambda (x)
            (parameterize
              ([source-directories (cons "testdir" (source-directories))])
              (maybe-compile-library x)))
         "testdir/testfile-mc-1b")
       #t)
     (error? ; can't find testfile-mc-1a.ss
             (separate-compile
               'maybe-compile-library
               "testdir/testfile-mc-1b"))
     ; make sure maybe-compile-file wipes out b.so when it fails to find a.ss
     (or (= (optimize-level) 3)
         (not (file-exists? "testdir/testfile-mc-1b.so")))
     (begin
       (separate-compile
         '(lambda (x)
            (parameterize
              ([source-directories (cons "testdir" (source-directories))])
              (maybe-compile-library x)))
         "testdir/testfile-mc-1b")
       #t)
     (touch "testdir/testfile-mc-1b.so" "testdir/testfile-mc-1a.ss")
     (equal? (let ([mt* (map file-modification-time
                             '("testdir/testfile-mc-1b.so"))])
               (separate-compile
                 '(lambda (x)
                    (parameterize
                      ([source-directories
                         (cons "testdir"
                               (source-directories))])
                      (maybe-compile-library x)))
                 "testdir/testfile-mc-1b")
               (map (lambda (x y)
                      (if (time=? x y)
                          '=
                          (if (time<? x y) '< '>)))
                    (map file-modification-time
                         '("testdir/testfile-mc-1b.so"))
                    mt*))
             '(>))
     (touch "testdir/testfile-mc-1b.so" "testdir/testfile-mc-1b.ss")
     (equal? (let ([mt* (map file-modification-time
                             '("testdir/testfile-mc-1b.so"))])
               (separate-compile
                 '(lambda (x)
                    (parameterize
                      ([source-directories
                         (cons "testdir"
                               (source-directories))])
                      (maybe-compile-library x)))
                 "testdir/testfile-mc-1b")
               (map (lambda (x y)
                      (if (time=? x y)
                          '=
                          (if (time<? x y) '< '>)))
                    (map file-modification-time
                         '("testdir/testfile-mc-1b.so"))
                    mt*))
             '(>))
     (delete-file "testdir/testfile-mc-1a.ss")
     (error? ; maybe-compile-library: can't find testfile-mc-1a.ss
       (separate-compile
         '(lambda (x)
            (parameterize
              ([source-directories (cons "testdir" (source-directories))])
              (maybe-compile-library x)))
         "testdir/testfile-mc-1b"))
     ; make sure maybe-compile-file wipes out b.so when it fails to find a.ss
     (or (= (optimize-level) 3)
         (not (file-exists? "testdir/testfile-mc-1b.so")))
     (begin (rm-rf "testdir") #t)
     ; make sure maybe-compile-file handles incomplete fasl files
     (begin
       (mkfile "testfile-mc-2a.ss"
         '(library (testfile-mc-2a)
            (export q)
            (import (chezscheme))
            (define f (lambda () (printf "running f\n") "x"))
            (define-syntax q
              (begin
                (printf "expanding testfile-mc-2a\n")
                (lambda (x) (printf "expanding q\n") #'(f))))))
       (mkfile "testfile-mc-2.ss"
         '(import (chezscheme) (testfile-mc-2a))
         '(define-syntax qq
            (begin
              (printf "expanding testfile-mc-2\n")
              (lambda (x) (printf "expanding qq\n") #'q)))
         '(printf "qq => ~a\n" qq))
       (delete-file "testfile-mc-2a.so")
       (delete-file "testfile-mc-2.so")
       (display-string
         (separate-compile
           '(lambda (x)
              (parameterize
                ([compile-file-message #f]
                 [compile-imported-libraries #t]
                 [compile-compressed #f])
                (maybe-compile-program x)))
           'mc-2))
       #t)
     (begin
       (let ([p (open-file-input/output-port "testfile-mc-2a.so"
                  (file-options no-create no-fail no-truncate))])
         (set-port-length! p 73)
         (close-port p))
       (display-string
         (separate-compile
           '(lambda (x)
              (parameterize
                ([compile-file-message #f]
                 [compile-imported-libraries #t]
                 [compile-compressed #f]
                 [import-notify #t])
                (maybe-compile-program x)))
           'mc-2))
       #t)
     (begin
       (let ([p (open-file-input/output-port "testfile-mc-2.so"
                  (file-options no-create no-fail no-truncate))])
         (set-port-length! p 87)
         (close-port p))
       (display-string
         (separate-compile
           '(lambda (x)
              (parameterize
                ([compile-file-message #f]
                 [compile-imported-libraries #t]
                 [compile-compressed #f]
                 [import-notify #t])
                (maybe-compile-program x)))
           'mc-2))
       #t)
     ; make sure maybe-compile-file handles missing include files gracefully
     (begin
       (mkfile "testfile-mc-3a.ss" "hello from 3a!")
       (mkfile "testfile-mc-3b.ss"
         '(library (testfile-mc-3b)
            (export q)
            (import (chezscheme))
            (define-syntax q
              (begin
                (printf "expanding testfile-mc-3b\n")
                (lambda (x)
                  (printf "expanding q\n")
                  (include "./testfile-mc-3a.ss"))))))
       (mkfile "testfile-mc-3.ss"
         '(import (chezscheme) (testfile-mc-3b))
         '(define-syntax qq
            (begin
              (printf "expanding testfile-mc-3\n")
              (lambda (x) (printf "expanding qq\n") #'q)))
         '(printf "qq => ~a\n" qq))
       (delete-file "testfile-mc-3b.so")
       (delete-file "testfile-mc-3.so")
       (separate-compile
         '(lambda (x)
            (parameterize
              ([compile-file-message #f] [compile-imported-libraries #t])
              (maybe-compile-program x)))
         'mc-3)
       #t)
     (begin (delete-file "testfile-mc-3a.ss") #t)
     (error? ; separate-compile: no such file or directory: testfile-mc-3a.ss
       (separate-compile
         '(lambda (x)
            (parameterize
              ([compile-file-message #f] [compile-imported-libraries #t])
              (maybe-compile-program x)))
         'mc-3))
     ; make sure maybe-compile-file handles missing include files gracefully
     (begin
       (define-record-type hash-bang-chezscheme)
       (record-writer (type-descriptor hash-bang-chezscheme)
         (lambda (x p wr) (display-string "#!chezscheme")))
       (mkfile "testfile-mc-4a.ss" "hello from 4a!")
       (mkfile "testfile-mc-4b.ss"
         (make-hash-bang-chezscheme)
         '(library (testfile-mc-4b)
            (export b)
            (import (chezscheme))
            (define-syntax q
              (lambda (x)
                (if (file-exists? "testfile-mc-4a.ss")
                    (begin
                      (printf "HEY!\n")
                      (#%$require-include "./testfile-mc-4a.ss")
                      (call-with-input-file "testfile-mc-4a.ss" read))
                    (begin
                      (printf "BARLEY!\n")
                      "testfile-mc-4a is no more"))))
            (define (b) q)))
       (mkfile "testfile-mc-4.ss"
         '(import (chezscheme) (testfile-mc-4b))
         '(printf "q => ~a\n" (b)))
       (delete-file "testfile-mc-4b.so")
       (delete-file "testfile-mc-4.so")
       (separate-compile
         '(lambda (x)
            (parameterize
              ([compile-file-message #f] [compile-imported-libraries #t])
              (maybe-compile-program x)))
         'mc-4)
       #t)
     (equal? (separate-eval '(load-program "testfile-mc-4.so"))
             "q => hello from 4a!\n")
     (begin
       (mkfile "testfile-mc-4a.ss" "goodbye from 4a!")
       (touch "testfile-mc-4.so" "testfile-mc-4a.ss")
       (separate-compile
         '(lambda (x)
            (parameterize
              ([compile-file-message #f]
               [compile-imported-libraries #t]
               [import-notify #t])
              (maybe-compile-program x)))
         'mc-4)
       #t)
     (equal? (separate-eval '(load-program "testfile-mc-4.so"))
             "q => goodbye from 4a!\n")
     (begin (delete-file "testfile-mc-4a.ss") #t)
     (begin
       (separate-compile
         '(lambda (x)
            (parameterize
              ([compile-file-message #f]
               [compile-imported-libraries #t]
               [import-notify #t])
              (maybe-compile-program x)))
         'mc-4)
       #t)
     (equal? (separate-eval '(load-program "testfile-mc-4.so"))
             "q => testfile-mc-4a is no more\n")
     ; make sure maybe-compile-file handles missing include files gracefully
     (begin
       (define-record-type hash-bang-chezscheme)
       (record-writer (type-descriptor hash-bang-chezscheme)
         (lambda (x p wr) (display-string "#!chezscheme")))
       (mkfile "testfile-mc-5a.ss" "hello from 5a!")
       (mkfile "testfile-mc-5b.ss"
         (make-hash-bang-chezscheme)
         '(library (testfile-mc-5b)
            (export q)
            (import (chezscheme))
            (define-syntax q
              (lambda (x)
                (if (file-exists? "testfile-mc-5a.ss")
                    (begin
                      (printf "HEY!\n")
                      (#%$require-include "./testfile-mc-5a.ss")
                      (call-with-input-file "testfile-mc-5a.ss" read))
                    (begin
                      (printf "BARLEY!\n")
                      "testfile-mc-5a is no more"))))))
       (mkfile "testfile-mc-5.ss"
         '(import (chezscheme) (testfile-mc-5b))
         '(define-syntax qq (lambda (x) #'q))
         '(printf "qq => ~a\n" qq))
       (delete-file "testfile-mc-5b.so")
       (delete-file "testfile-mc-5.so")
       (separate-compile
         '(lambda (x)
            (parameterize
              ([compile-file-message #f] [compile-imported-libraries #t])
              (maybe-compile-program x)))
         'mc-5)
       #t)
     (equal? (separate-eval '(load-program "testfile-mc-5.so"))
             "qq => hello from 5a!\n")
     (begin
       (mkfile "testfile-mc-5a.ss" "goodbye from 5a!")
       (touch "testfile-mc-5.so" "testfile-mc-5a.ss")
       (separate-compile
         '(lambda (x)
            (parameterize
              ([compile-file-message #f]
               [compile-imported-libraries #t]
               [import-notify #t])
              (maybe-compile-program x)))
         'mc-5)
       #t)
     (equal? (separate-eval '(load-program "testfile-mc-5.so"))
             "qq => goodbye from 5a!\n")
     (begin (delete-file "testfile-mc-5a.ss") #t)
     (begin
       (separate-compile
         '(lambda (x)
            (parameterize
              ([compile-file-message #f]
               [compile-imported-libraries #t]
               [import-notify #t])
              (maybe-compile-program x)))
         'mc-5)
       #t)
     (equal? (separate-eval '(load-program "testfile-mc-5.so"))
             "qq => testfile-mc-5a is no more\n"))

(mat make-boot-file
     (eq? (begin
            (with-output-to-file "testfile-1.ss"
              (lambda ()
                (pretty-print '(display "hello 1\n")))
              'replace)
            (with-output-to-file "testfile-2.ss"
              (lambda ()
                (pretty-print '(display "hello 2\n")))
              'replace)
            (with-output-to-file "testfile-3.ss"
              (lambda ()
                (pretty-print '(display "hello 3\n")))
              'replace)
            (with-output-to-file "testfile-4.ss"
              (lambda ()
                (pretty-print '(display "hello 4\n")))
              '(replace))
            (with-output-to-file "testfile-5.ss"
              (lambda ()
                (pretty-print '(display "hello 5\n")))
              '(replace))
            (parameterize ([optimize-level 2])
              (compile-script "testfile-1")
              (compile-script "testfile-2")
              (compile-file "testfile-3")
              (compile-file "testfile-4")
              (compile-file "testfile-5")))
          (void))
     (equal? (begin
               (parameterize ([optimize-level 2])
                 (make-boot-file "testfile.boot"
                   '("petite")
                   "testfile-1.so"
                   "testfile-2.ss"
                   "testfile-3.so"
                   "testfile-4.so"
                   "testfile-5.ss"))
               (let-values ([(to-stdin from-stdout from-stderr pid)
                             (open-process-ports
                               (format "~a -b ./testfile.boot -q"
                                       (patch-exec-path *scheme*))
                               (buffer-mode block)
                               (native-transcoder))])
                 (close-output-port to-stdin)
                 (let ([out (get-string-all from-stdout)]
                       [err (get-string-all from-stderr)])
                   (close-input-port from-stdout)
                   (close-input-port from-stderr)
                   (unless (eof-object? err)
                           (error 'bootfile-test1 err))
                   out)))
             "hello 1\nhello 2\nhello 3\nhello 4\nhello 5\n")
     (equal? (begin
               (parameterize ([optimize-level 2])
                 (compile-to-file
                   '((library (A)
                       (export a)
                       (import (scheme))
                       (define a 'aye))
                     (library (B)
                       (export b)
                       (import (A) (scheme))
                       (define b (list a 'captain))))
                   "testfile-libs.so")
                 (make-boot-file "testfile.boot"
                   '("petite")
                   "testfile-libs.so"))
               (let-values ([(to-stdin from-stdout from-stderr pid)
                             (open-process-ports
                               (format "~a -b ./testfile.boot -q"
                                       (patch-exec-path *scheme*))
                               (buffer-mode block)
                               (native-transcoder))])
                 (pretty-print
                   '(let () (import (B)) (printf "~s\n" b))
                   to-stdin)
                 (close-output-port to-stdin)
                 (let ([out (get-string-all from-stdout)]
                       [err (get-string-all from-stderr)])
                   (close-input-port from-stdout)
                   (close-input-port from-stderr)
                   (unless (eof-object? err)
                           (error 'bootfile-test1 err))
                   out)))
             "(aye captain)\n")
     (equal? (begin
               (unless (or (embedded?)
                           (equal? *scheme*
                             (format "../bin/~a/scheme~a"
                                     (machine-type)
                                     (if (windows?)
                                         ".exe"
                                         ""))))
                       (errorf #f
                               "not testing boot file based on ../boot/~a/petite.boot, since *scheme* isn't ../bin/~a/scheme~a"
                               (machine-type)
                               (machine-type)
                               (if (windows?) ".exe" "")))
               (parameterize ([optimize-level 2])
                 (make-boot-file "testfile.boot"
                   '()
                   (format "../boot/~a/petite.boot" (machine-type))
                   "testfile-1.so"
                   "testfile-2.so"
                   "testfile-3.ss"
                   "testfile-4.ss"
                   "testfile-5.so"))
               (let-values ([(to-stdin from-stdout from-stderr pid)
                             (open-process-ports
                               (format "~a -b ./testfile.boot -q"
                                       (patch-exec-path *scheme*))
                               (buffer-mode block)
                               (native-transcoder))])
                 (close-output-port to-stdin)
                 (let ([out (get-string-all from-stdout)]
                       [err (get-string-all from-stderr)])
                   (close-input-port from-stdout)
                   (close-input-port from-stderr)
                   (unless (eof-object? err)
                           (error 'bootfile-test2 err))
                   out)))
             "hello 1\nhello 2\nhello 3\nhello 4\nhello 5\n")
     ; regression test to verify that we can evaluate a foreign-callable form inside the procedure to
     ; which scheme-start is set, which was failing because its relocation information was discarded
     ; by the static-generation collection.
     (equal? (begin
               (unless (or (embedded?)
                           (equal? *scheme*
                             (format "../bin/~a/scheme~a"
                                     (machine-type)
                                     (if (windows?)
                                         ".exe"
                                         ""))))
                       (errorf #f
                               "not testing boot file based on ../boot/~a/petite.boot, since *scheme* isn't ../bin/~a/scheme~a"
                               (machine-type)
                               (machine-type)
                               (if (windows?) ".exe" "")))
               (mkfile "testfile.ss"
                 '(scheme-start
                    (lambda ()
                      (let ([x 0])
                        (printf "~s\n"
                          (foreign-callable (lambda () (set! x (+ x 1)) x)
                            ()
                            void))))))
               (make-boot-file "testfile.boot" '("petite") "testfile.ss")
               (let-values ([(to-stdin from-stdout from-stderr pid)
                             (open-process-ports
                               (format "~a -b ./testfile.boot -q"
                                       (patch-exec-path *scheme*))
                               (buffer-mode block)
                               (native-transcoder))])
                 (close-output-port to-stdin)
                 (let ([out (get-string-all from-stdout)]
                       [err (get-string-all from-stderr)])
                   (close-input-port from-stdout)
                   (close-input-port from-stderr)
                   (unless (eof-object? err)
                           (error 'bootfile-test2 err))
                   out)))
             "#<code>\n"))

(mat hostop
     (begin
       (separate-compile
         `(lambda (x)
            (call-with-port
              (open-file-output-port (format "~a.so" x)
                (file-options compressed replace))
              (lambda (op)
                (call-with-port
                  (open-file-output-port (format "~a.host" x)
                    (file-options compressed replace))
                  (lambda (hostop)
                    (compile-to-port
                      '((library (testfile-hop1)
                          (export a b c)
                          (import (chezscheme))
                          (define-syntax a
                            (identifier-syntax 17))
                          (module b
                            (b1 b2)
                            (define b1 "23.5")
                            (define-syntax b2
                              (identifier-syntax (cons b1 b1))))
                          (define c
                            (lambda (x)
                              (import b)
                              (vector b2 x)))))
                      op
                      #f
                      #f
                      ',(machine-type)
                      hostop))))))
         "testfile-hop1")
       (with-output-to-file "testfile-hop2.ss"
         (lambda ()
           (pretty-print '(eval-when (compile) (load "testfile-hop1.so")))
           (pretty-print '(eval-when (compile) (import (testfile-hop1))))
           (pretty-print '(eval-when (compile) (import b)))
           (pretty-print '(pretty-print (list a b1 b2 (c 55)))))
         'replace)
       (with-output-to-file "testfile-hop3.ss"
         (lambda ()
           (pretty-print
             '(eval-when (compile)
                (load "testfile-hop1.host")))
           (pretty-print '(eval-when (compile) (import (testfile-hop1))))
           (pretty-print '(eval-when (compile) (import b)))
           (pretty-print '(pretty-print (list a b1 b2 (c 55)))))
         'replace)
       (for-each separate-compile '(hop2 hop3))
       #t)
     (equal? (separate-eval '(load "testfile-hop1.so")
               '(import (testfile-hop1))
               'a
               '(import b)
               'b1
               'b2
               '(c 55))
             "17\n\
     \"23.5\"\n\
     (\"23.5\" . \"23.5\")\n\
     #((\"23.5\" . \"23.5\") 55)\n\
     ")
     (equal? (separate-eval '(visit "testfile-hop1.so")
               ; visit now---$invoke-library will revisit later
               '(import (testfile-hop1))
               'a
               '(import b)
               'b1
               'b2
               '(c 55))
             "17\n\
     \"23.5\"\n\
     (\"23.5\" . \"23.5\")\n\
     #((\"23.5\" . \"23.5\") 55)\n\
     ")
     (equal? (separate-eval '(revisit "testfile-hop1.so")
               '(expand 'a)
               '(guard (c [else (display-condition c) (newline)])
                       (eval '(import b)))
               '(expand 'b1)
               '(expand 'b2)
               '(load "testfile-hop2.so"))
             "a\n\
     Exception: unknown module b\n\
     b1\n\
     b2\n\
     (17 \"23.5\" (\"23.5\" . \"23.5\") #((\"23.5\" . \"23.5\") 55))\n\
     ")
     (equal? (separate-eval '(revisit "testfile-hop1.so")
               '(expand 'a)
               '(guard (c [else (display-condition c) (newline)])
                       (eval '(import b)))
               '(expand 'b1)
               '(expand 'b2)
               '(load "testfile-hop3.so"))
             "a\n\
     Exception: unknown module b\n\
     b1\n\
     b2\n\
     (17 \"23.5\" (\"23.5\" . \"23.5\") #((\"23.5\" . \"23.5\") 55))\n\
     ")
     (equal? (separate-eval '(load "testfile-hop1.host")
               '(import (testfile-hop1))
               'a
               '(import b)
               'b1
               'b2
               '(c 55))
             "17\n\
     \"23.5\"\n\
     (\"23.5\" . \"23.5\")\n\
     #((\"23.5\" . \"23.5\") 55)\n\
     ")
     (equal? (separate-eval '(revisit "testfile-hop1.host")
               '(expand 'a)
               '(guard (c [else (display-condition c) (newline)])
                       (eval '(import b)))
               '(expand 'b1)
               '(expand 'b2)
               '(load "testfile-hop2.so"))
             "a\n\
     Exception: unknown module b\n\
     b1\n\
     b2\n\
     (17 \"23.5\" (\"23.5\" . \"23.5\") #((\"23.5\" . \"23.5\") 55))\n\
     ")
     (equal? (separate-eval '(revisit "testfile-hop1.host")
               '(expand 'a)
               '(guard (c [else (display-condition c) (newline)])
                       (eval '(import b)))
               '(expand 'b1)
               '(expand 'b2)
               '(load "testfile-hop3.so"))
             "a\n\
     Exception: unknown module b\n\
     b1\n\
     b2\n\
     (17 \"23.5\" (\"23.5\" . \"23.5\") #((\"23.5\" . \"23.5\") 55))\n\
     ")
     (begin
       (#%$compile-host-library 'moi "testfile-hop1.host")
       (define bv
         (call-with-port
           (open-file-input-port "testfile-hop1.host")
           get-bytevector-all))
       #t)
     (begin
       ; doing it a second time should be a no-op
       (#%$compile-host-library 'moi "testfile-hop1.host")
       (bytevector=?
         (call-with-port
           (open-file-input-port "testfile-hop1.host")
           get-bytevector-all)
         bv))
     (begin (set! bv #f) #t)
     (equal? (separate-eval '(load "testfile-hop1.host")
               '(import (testfile-hop1))
               'a
               '(import b)
               'b1
               'b2
               '(c 55))
             "17\n\
     \"23.5\"\n\
     (\"23.5\" . \"23.5\")\n\
     #((\"23.5\" . \"23.5\") 55)\n\
     ")
     (equal? (separate-eval '(revisit "testfile-hop1.host")
               '(expand 'a)
               '(guard (c [else (display-condition c) (newline)])
                       (eval '(import b)))
               '(expand 'b1)
               '(expand 'b2)
               '(load "testfile-hop2.so"))
             "a\n\
     Exception: unknown module b\n\
     b1\n\
     b2\n\
     (17 \"23.5\" (\"23.5\" . \"23.5\") #((\"23.5\" . \"23.5\") 55))\n\
     ")
     (equal? (separate-eval '(revisit "testfile-hop1.host")
               '(expand 'a)
               '(guard (c [else (display-condition c) (newline)])
                       (eval '(import b)))
               '(expand 'b1)
               '(expand 'b2)
               '(load "testfile-hop3.so"))
             "a\n\
     Exception: unknown module b\n\
     b1\n\
     b2\n\
     (17 \"23.5\" (\"23.5\" . \"23.5\") #((\"23.5\" . \"23.5\") 55))\n\
     ")
     (equal? (separate-eval '(visit "testfile-hop1.so")
               '(delete-file "testfile-hop1.so")
               ; prevent import from revisiting testfile-hop1.so
               '(import (testfile-hop1))
               'a
               '(import b)
               '(guard (c [else (display-condition c) (newline)])
                       (eval 'b1))
               '(guard (c [else (display-condition c) (newline)])
                       (eval 'b2))
               '(guard (c [else (display-condition c) (newline)])
                       (eval 'c)))
             "#t\n\
     17\n\
     Exception: failed for testfile-hop1.so: no such file or directory\n\
     Exception: failed for testfile-hop1.so: no such file or directory\n\
     Exception: failed for testfile-hop1.so: no such file or directory\n\
     "))

(mat eval
     (error? ; 7 is not an environment (should be reported by compile or interpret)
             (eval 3 7))
     (error? ; 7 is not an environment
             (interpret 3 7))
     (error? ; 7 is not an environment
             (compile 3 7))
     (eqv? (eval '(+ 3 4)) 7)
     (eq? (eval '(define foo (lambda (x) x))) (void))
     (eval '(let ([x '(a b c)]) (eq? (foo x) x))))

(mat expand
     ; tested in mats extend-syntax & with in 8.ms
     (error? ; 7 is not an environment (should be reported by sc-expand)
             (expand 3 7))
     (error? ; 7 is not an environment
             (sc-expand 3 7))
     (procedure? expand))

(mat eval-when
     (let ([p (open-output-file "testfile.ss" 'replace)])
       (display "
(eval-when (eval) (set! aaa 'eval))
(eval-when (load) (set! aaa 'load))
(eval-when (compile) (set! aaa 'compile))
"
                p)
       (close-output-port p)
       #t)
     (begin
       (set! aaa #f)
       (load "testfile.ss")
       (eq? aaa 'eval))
     (begin
       (printf "***** expect \"compile-file\" message:~%")
       (set! aaa #f)
       (compile-file "testfile")
       (eq? aaa 'compile))
     (begin
       (set! aaa #f)
       (load "testfile.so")
       (eq? aaa 'load))
     (let ([p (open-output-file "testfile.ss" 'replace)])
       (display "
(eval-when (eval)
   (eval-when (eval) (set! aaa 'eval@eval))
   (eval-when (load) (set! aaa 'load@eval))
   (eval-when (compile) (set! aaa 'compile@eval)))
(eval-when (load)
   (eval-when (eval) (set! bbb 'eval@load))
   (eval-when (load) (set! bbb 'load@load))
   (eval-when (compile) (set! bbb 'compile@load)))
(eval-when (compile)
   (eval-when (eval) (set! ccc 'eval@compile))
   (eval-when (load) (set! ccc 'load@compile))
   (eval-when (compile) (set! ccc 'compile@compile)))
"
                p)
       (close-output-port p)
       #t)
     (begin
       (set! aaa #f)
       (set! bbb #f)
       (set! ccc #f)
       (load "testfile.ss")
       (equal? (list aaa bbb ccc) '(eval@eval #f #f)))
     (begin
       (printf "***** expect \"compile-file\" message:~%")
       (set! aaa #f)
       (set! bbb #f)
       (set! ccc #f)
       (compile-file "testfile")
       (equal? (list aaa bbb ccc) '(#f compile@load eval@compile)))
     (begin
       (set! aaa #f)
       (set! bbb #f)
       (set! ccc #f)
       (load "testfile.so")
       (equal? (list aaa bbb ccc) '(#f load@load #f)))
     (let ([p (open-output-file "testfile.ss" 'replace)])
       (display "
(eval-when (eval) (pretty-print 'evaluating))
(eval-when (compile) (pretty-print 'compiling))
(eval-when (load) (pretty-print 'loading))
(eval-when (visit) (pretty-print 'visiting))
(eval-when (revisit) (pretty-print 'revisiting))
(eval-when (visit revisit) (pretty-print 'visit/revisit))
(eval-when (compile)
  (eval-when (eval)
    (pretty-print 'oops)))
(eval-when (load eval)
  (eval-when (compile)
    (pretty-print 'foo6)))
"
                p)
       (close-output-port p)
       #t)
     (let ()
       (define with-output-to-string
         (lambda (p)
           (parameterize ([current-output-port (open-output-string)])
             (p)
             (get-output-string (current-output-port)))))
       (and (string=? (with-output-to-string
                        (lambda () (compile-file "testfile")))
                      "compiling testfile.ss with output to testfile.so
compiling
oops
foo6
")
            (string=? (with-output-to-string
                        (lambda () (visit "testfile.so")))
                      "visiting
visit/revisit
")
            (string=? (with-output-to-string
                        (lambda () (revisit "testfile.so")))
                      "loading
revisiting
visit/revisit
")
            (string=? (with-output-to-string
                        (lambda () (load "testfile.so")))
                      "loading
visiting
revisiting
visit/revisit
")))
     (let ([p (open-output-file "testfile.ss" 'replace)])
       (display "
(define-syntax $a (identifier-syntax 'b))
(define $foo)
(eval-when (visit) (define visit-x 17))
(eval-when (revisit) (define-syntax revisit-x (identifier-syntax 23)))
"
                p)
       (close-output-port p)
       #t)
     (begin (define-syntax $foo (syntax-rules ())) #t)
     (begin (define-syntax $a (syntax-rules ())) #t)
     (begin (define-syntax visit-x (syntax-rules ())) #t)
     (begin (define-syntax revisit-x (syntax-rules ())) #t)
     (error? $foo)
     (error? $a)
     (error? visit-x)
     (error? revisit-x)
     (begin (compile-file "testfile") #t)
     (eq? $a 'b)
     (error? $foo)
     (error? visit-x)
     (error? revisit-x)
     (begin (define-syntax $foo (syntax-rules ())) #t)
     (begin (define-syntax $a (syntax-rules ())) #t)
     (begin (define-syntax visit-x (syntax-rules ())) #t)
     (begin (define-syntax revisit-x (syntax-rules ())) #t)
     (begin (visit "testfile.so") #t)
     (eq? $a 'b)
     (error? $foo)
     (eq? visit-x 17)
     (error? revisit-x)
     (begin (revisit "testfile.so") #t)
     (eq? $a 'b)
     (eq? $foo (void))
     (eq? visit-x 17)
     (eq? revisit-x 23)
     (begin
       (define get-$foo (lambda () $foo))
       (eq? (get-$foo) (void)))
     (begin (define-syntax $foo (syntax-rules ())) #t)
     (begin (define-syntax $a (syntax-rules ())) #t)
     (begin (define-syntax visit-x (syntax-rules ())) #t)
     (begin (define-syntax revisit-x (syntax-rules ())) #t)
     (begin (revisit "testfile.so") #t)
     (error? $a)
     (error? $foo)
     (eq? (get-$foo) (void))
     (error? visit-x)
     (eq? revisit-x 23)
     (begin (visit "testfile.so") #t)
     (eq? $a 'b)
     (eq? $foo (void))
     (eq? (get-$foo) (void))
     (eq? visit-x 17)
     (eq? revisit-x 23)
     (begin (define-syntax $foo (syntax-rules ())) #t)
     (begin (define-syntax $a (syntax-rules ())) #t)
     (begin (define-syntax visit-x (syntax-rules ())) #t)
     (begin (define-syntax revisit-x (syntax-rules ())) #t)
     (begin (load "testfile.so") #t)
     (eq? $a 'b)
     (eq? $foo (void))
     (eq? (get-$foo) (void))
     (eq? visit-x 17)
     (eq? revisit-x 23)
     (begin (define-syntax $foo (syntax-rules ())) #t)
     (begin (define-syntax $a (syntax-rules ())) #t)
     (begin (define-syntax visit-x (syntax-rules ())) #t)
     (begin (define-syntax revisit-x (syntax-rules ())) #t)
     (begin (load "testfile.ss") #t)
     (eq? $a 'b)
     (eq? $foo (void))
     (error? visit-x)
     (error? revisit-x)
     (eqv? (let ((x 77)) (eval-when (eval) (define x 88)) x) 88)
     (eqv? (let ((x 77))
             (eval-when (compile visit load revisit)
               (define x 88))
             x)
           77)
     (begin
       (define $qlist '())
       (define-syntax $qdef
         (syntax-rules ()
           [(_ x e)
            (begin
              (eval-when (compile)
                (set! $qlist (cons 'x $qlist)))
              (eval-when (load eval) (define x e)))]))
       ($qdef $bar 33)
       (and (null? $qlist) (eqv? $bar 33)))
     (let ([p (open-output-file "testfile.ss" 'replace)])
       (pretty-print '($qdef $baz (lambda () ($qdef x 44) x)) p)
       (close-output-port p)
       #t)
     (begin (compile-file "testfile") #t)
     (equal? $qlist '($baz))
     (begin (load "testfile.so") #t)
     (equal? $qlist '($baz))
     (eq? ($baz) 44)
     ; regression: make sure that visit doesn't evaluate top-level module
     ; inits and definition right-hand-sides
     (let ([p (open-output-file "testfile.ss" 'replace)])
       (display "(eval-when (visit) (printf \"visit A\\n\"))
(eval-when (revisit) (printf \"revisit A\\n\"))
(eval-when (load compile) (printf \"compile load A\\n\"))
(define foo (printf \"evaluating top-level foo rhs\\n\"))
(printf \"evaluating top-level init\\n\") 

(eval-when (visit) (printf \"visit B\\n\"))
(eval-when (revisit) (printf \"revisit B\\n\"))
(eval-when (load compile) (printf \"compile load B\\n\"))
(module ()
  (define foo (printf \"evaluating module foo rhs\\n\"))
  (printf \"evaluating module init\\n\"))
"
                p)
       (close-output-port p)
       #t)
     (let ()
       (define with-output-to-string
         (lambda (p)
           (parameterize ([current-output-port (open-output-string)])
             (p)
             (get-output-string (current-output-port)))))
       (and (string=? (with-output-to-string
                        (lambda () (compile-file "testfile")))
                      "compiling testfile.ss with output to testfile.so
compile load A
compile load B
")
            (string=? (with-output-to-string
                        (lambda () (visit "testfile.so")))
                      "visit A
visit B
")
            (string=? (with-output-to-string
                        (lambda () (revisit "testfile.so")))
                      "revisit A
compile load A
evaluating top-level foo rhs
evaluating top-level init
revisit B
compile load B
evaluating module foo rhs
evaluating module init
"))))

(mat compile-whole-program
     (error? ; no such file or directory nosuchfile.wpo
             (compile-whole-program
               "nosuchfile.wpo"
               "testfile-wpo-ab-all.so"))
     (error? ; incorrect number of arguments 
             (compile-whole-program "testfile-wpo-ab.wpo"))
     (begin
       (with-output-to-file "testfile-wpo-a.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-wpo-a)
                (export make-tree
                        tree
                        tree?
                        tree-left
                        tree-right
                        tree-value)
                (import (chezscheme))

                (define-record-type tree
                  (nongenerative)
                  (fields (mutable left)
                          (mutable value)
                          (mutable right)))
                (record-writer (record-type-descriptor tree)
                  (lambda (r p wr)
                    (display "#[tree " p)
                    (wr (tree-left r) p)
                    (display " " p)
                    (wr (tree-value r) p)
                    (display " " p)
                    (wr (tree-right r) p)
                    (display "]" p))))))
         'replace)
       (with-output-to-file "testfile-wpo-b.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-wpo-b)
                (export make-constant-tree
                        make-tree
                        tree?
                        tree-left
                        tree-right
                        tree-value
                        tree->list)
                (import (rnrs) (testfile-wpo-a))
                (define-syntax make-constant-tree
                  (lambda (x)
                    (define build-tree
                      (lambda (tree-desc)
                        (syntax-case tree-desc ()
                          [(l v r)
                           (make-tree (build-tree #'l)
                             (syntax->datum #'v)
                             (build-tree #'r))]
                          [v (make-tree #f (syntax->datum #'v) #f)])))
                    (syntax-case x ()
                      [(_ tree-desc) #`'#,(build-tree #'tree-desc)])))
                (define tree->list
                  (lambda (t)
                    (let f ([t t] [s '()])
                      (if (not t)
                          s
                          (f (tree-left t)
                             (cons (tree-value t)
                                   (f (tree-right t) s))))))))))
         'replace)
       (with-output-to-file "testfile-wpo-ab.ss"
         (lambda ()
           (pretty-print '(import (chezscheme) (testfile-wpo-b)))
           (pretty-print
             '(define a
                (make-constant-tree ((1 2 4) 5 (8 10 12)))))
           (pretty-print '(printf "constant tree: ~s~%" a))
           (pretty-print
             '(printf "constant tree value: ~s~%" (tree-value a)))
           (pretty-print
             '(printf "constant tree walk: ~s~%" (tree->list a))))
         'replace)
       (separate-compile
         '(lambda (x)
            (parameterize
              ([compile-imported-libraries #t] [generate-wpo-files #t])
              (compile-program x)))
         "testfile-wpo-ab")
       #t)

     (file-exists? "testfile-wpo-a.wpo")
     (file-exists? "testfile-wpo-b.wpo")
     (file-exists? "testfile-wpo-ab.wpo")

     (equal? (separate-eval '(load-program "testfile-wpo-ab.so"))
             "constant tree: #[tree #[tree #[tree #f 1 #f] 2 #[tree #f 4 #f]] 5 #[tree #[tree #f 8 #f] 10 #[tree #f 12 #f]]]\nconstant tree value: 5\nconstant tree walk: (1 2 4 5 8 10 12)\n")

     (equal? (separate-compile
               '(lambda (x)
                  (compile-whole-program (format "~a.wpo" x)
                    (format "~a-all.so" x)))
               "testfile-wpo-ab")
             "()\n")

     (delete-file "testfile-wpo-a.so")
     (delete-file "testfile-wpo-b.so")
     (delete-file "testfile-wpo-ab.so")
     (equal? (separate-eval '(load-program "testfile-wpo-ab-all.so"))
             "constant tree: #[tree #[tree #[tree #f 1 #f] 2 #[tree #f 4 #f]] 5 #[tree #[tree #f 8 #f] 10 #[tree #f 12 #f]]]\nconstant tree value: 5\nconstant tree walk: (1 2 4 5 8 10 12)\n")

     (begin (load-program "testfile-wpo-ab-all.so") #t)

     (not (memq '(testfile-wpo-a) (library-list)))
     (not (memq '(testfile-wpo-b) (library-list)))

     (begin
       (with-output-to-file "testfile-wpo-lib.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-wpo-lib)
                (export f)
                (import (chezscheme))
                (define (f n)
                  (if (zero? n) 1 (* n (f (- n 1))))))))
         'replace)
       (separate-compile
         '(lambda (x)
            (parameterize ([generate-wpo-files #t]) (compile-library x)))
         "testfile-wpo-lib")
       (file-exists? "testfile-wpo-lib.wpo"))

     (begin
       (with-output-to-file "testfile-wpo-prog.ss"
         (lambda ()
           (pretty-print '(import (chezscheme)))
           (pretty-print
             '(pretty-print (let () (import (testfile-wpo-lib)) (f 10))))
           (pretty-print
             '(pretty-print
                ((top-level-value 'f (environment '(testfile-wpo-lib))) 10))))
         'replace)
       (separate-compile
         '(lambda (x)
            (parameterize ([generate-wpo-files #t]) (compile-program x)))
         "testfile-wpo-prog")
       (file-exists? "testfile-wpo-prog.wpo"))

     (equal? (separate-eval '(load-program "testfile-wpo-prog.so"))
             "3628800\n3628800\n")

     (equal? (separate-compile
               '(lambda (x)
                  (compile-whole-program (format "~a.wpo" x)
                    (format "~a-all.so" x)
                    #t))
               "testfile-wpo-prog")
             "()\n")

     (equal? (separate-compile
               '(lambda (x)
                  (compile-whole-program (format "~a.wpo" x)
                    (format "~a-none.so" x)
                    #f))
               "testfile-wpo-prog")
             "()\n")

     (delete-file "testfile-wpo-lib.ss")
     (delete-file "testfile-wpo-lib.so")
     (delete-file "testfile-wpo-lib.wpo")

     (equal? (separate-eval '(load-program "testfile-wpo-prog-all.so"))
             "3628800\n3628800\n")

     (error? (separate-eval '(load-program "testfile-wpo-prog-none.so")))

     (begin
       (with-output-to-file "testfile-wpo-a3.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-wpo-a3)
                (export ! z?)
                (import (rnrs))
                (define (z? n) (= n 0))
                (define (! n)
                  (if (z? n) 1 (* n (! (- n 1))))))))
         'replace)
       (with-output-to-file "testfile-wpo-b3.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-wpo-b3)
                (export fib !)
                (import (rnrs) (testfile-wpo-a3))
                (define (fib n)
                  (cond
                    [(z? n) 1]
                    [(z? (- n 1)) 1]
                    [else (+ (fib (- n 1)) (fib (- n 2)))])))))
         'replace)
       (with-output-to-file "testfile-wpo-c3.ss"
         (lambda ()
           (pretty-print '(import (testfile-wpo-b3) (chezscheme)))
           (pretty-print
             '(pretty-print
                (list (fib 10)
                      (! 10)
                      ((top-level-value 'fib
                         (environment '(testfile-wpo-b3))) 10)
                      ((top-level-value '!
                         (environment '(testfile-wpo-b3))) 10)
                      ((top-level-value 'z?
                         (environment '(testfile-wpo-a3))) 10)))))
         'replace)
       (separate-compile
         '(lambda (x)
            (parameterize
              ([compile-imported-libraries #t] [generate-wpo-files #t])
              (compile-program x)))
         "testfile-wpo-c3")
       #t)

     (equal? (separate-eval '(load-program "testfile-wpo-c3.so"))
             "(89 3628800 89 3628800 #f)\n")

     (equal? (separate-compile
               '(lambda (x)
                  (parameterize ([generate-wpo-files #t])
                    (compile-whole-program (format "~a.wpo" x)
                      (format "~a-all.so" x)
                      #t)))
               "testfile-wpo-c3")
             "()\n")

     (delete-file "testfile-wpo-a3.ss")
     (delete-file "testfile-wpo-a3.so")
     (delete-file "testfile-wpo-a3.wpo")
     (delete-file "testfile-wpo-b3.ss")
     (delete-file "testfile-wpo-b3.so")
     (delete-file "testfile-wpo-b3.wpo")

     (equal? (separate-eval '(load-program "testfile-wpo-c3-all.so"))
             "(89 3628800 89 3628800 #f)\n")

     (begin
       (with-output-to-file "testfile-wpo-a4.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-wpo-a4)
                (export !)
                (import (chezscheme))
                (define (! n)
                  (if (= n 0) 1 (* n (! (- n 1))))))))
         'replace)
       (with-output-to-file "testfile-wpo-b4.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-wpo-b4)
                (export fib)
                (import (chezscheme))
                (define (fib n)
                  (if (or (= n 0) (= n 1))
                      1
                      (+ (fib (- n 1)) (fib (- n 2))))))))
         'replace)
       (with-output-to-file "testfile-wpo-c4.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-wpo-c4)
                (export !fib)
                (import (chezscheme) (testfile-wpo-a4) (testfile-wpo-b4))
                (define (!fib n) (! (fib n))))))
         'replace)
       (with-output-to-file "testfile-wpo-prog4.ss"
         (lambda ()
           (pretty-print '(import (chezscheme) (testfile-wpo-c4)))
           (pretty-print '(pretty-print (!fib 5))))
         'replace)
       (separate-compile
         '(lambda (x)
            (parameterize
              ([compile-imported-libraries #t] [generate-wpo-files #t])
              (compile-program x)))
         "testfile-wpo-prog4")
       #t)

     (delete-file "testfile-wpo-a4.wpo")

     (equal? (separate-compile
               '(lambda (x)
                  (parameterize ([generate-wpo-files #t])
                    (compile-whole-program (format "~a.wpo" x)
                      (format "~a-all.so" x)
                      #t)))
               'wpo-prog4)
             "((testfile-wpo-a4))\n")

     (begin
       (rename-file "testfile-wpo-a4.ss" "testfile-wpo-a4.ss.spam")
       (rename-file "testfile-wpo-b4.ss" "testfile-wpo-b4.ss.spam")
       (rename-file "testfile-wpo-c4.ss" "testfile-wpo-c4.ss.spam")
       (rename-file "testfile-wpo-prog4.ss" "testfile-wpo-prog4.ss.spam")
       #t)

     (delete-file "testfile-wpo-b4.so")
     (delete-file "testfile-wpo-b4.wpo")
     (delete-file "testfile-wpo-c4.so")
     (delete-file "testfile-wpo-c4.wpo")
     (delete-file "testfile-wpo-prog4.so")
     (delete-file "testfile-wpo-prog4.wpo")

     (equal? (separate-eval '(load-program "testfile-wpo-prog4-all.so"))
             "40320\n")

     (delete-file "testfile-wpo-a4.so")

     (error? ; library (testfile-wpo-a4) not found
             (separate-eval '(load-program "testfile-wpo-prog4-all.so")))

     (delete-file "testfile-wpo-prog4-all.so")

     (begin
       (rename-file "testfile-wpo-a4.ss.spam" "testfile-wpo-a4.ss")
       (rename-file "testfile-wpo-b4.ss.spam" "testfile-wpo-b4.ss")
       (rename-file "testfile-wpo-c4.ss.spam" "testfile-wpo-c4.ss")
       (rename-file "testfile-wpo-prog4.ss.spam" "testfile-wpo-prog4.ss")
       #t)

     (begin
       (separate-compile
         '(lambda (x)
            (parameterize
              ([compile-imported-libraries #t] [generate-wpo-files #t])
              (compile-program x)))
         "testfile-wpo-prog4")
       #t)

     (delete-file "testfile-wpo-c4.wpo")

     (equal? (separate-compile
               '(lambda (x)
                  (parameterize ([generate-wpo-files #t])
                    (compile-whole-program (format "~a.wpo" x)
                      (format "~a-all.so" x)
                      #t)))
               'wpo-prog4)
             "((testfile-wpo-c4))\n")

     (delete-file "testfile-wpo-a4.ss")
     (delete-file "testfile-wpo-b4.ss")
     (delete-file "testfile-wpo-c4.ss")
     (delete-file "testfile-wpo-prog4.ss")
     (delete-file "testfile-wpo-a4.so")
     (delete-file "testfile-wpo-a4.wpo")
     (delete-file "testfile-wpo-b4.so")
     (delete-file "testfile-wpo-b4.wpo")
     (delete-file "testfile-wpo-prog4.so")
     (delete-file "testfile-wpo-prog4.wpo")

     (equal? (separate-eval '(load-program "testfile-wpo-prog4-all.so"))
             "40320\n")

     (delete-file "testfile-wpo-c4.so")

     (error? ; library (testfile-wpo-c4) not found
             (separate-eval '(load-program "testfile-wpo-prog4-all.so")))

     (begin
       (with-output-to-file "testfile-wpo-a5.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-wpo-a5)
                (export a)
                (import (chezscheme))
                (define a
                  (lambda (n)
                    (+ ((top-level-value 'c
                          (environment '(testfile-wpo-c5))))
                       n))))))
         'replace)
       (with-output-to-file "testfile-wpo-b5.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-wpo-b5)
                (export b)
                (import (chezscheme) (testfile-wpo-a5))
                (define b (a 10)))))
         'replace)
       (with-output-to-file "testfile-wpo-c5.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-wpo-c5)
                (export c)
                (import (chezscheme) (testfile-wpo-a5) (testfile-wpo-b5))
                (define c (lambda () (+ (a 10) b))))))
         'replace)
       (with-output-to-file "testfile-wpo-prog5.ss"
         (lambda ()
           (pretty-print
             '(import (chezscheme) (testfile-wpo-b5) (testfile-wpo-c5)))
           (pretty-print '(pretty-print (cons (b) c))))
         'replace)
       (separate-compile
         '(lambda (x)
            (parameterize
              ([compile-imported-libraries #t] [generate-wpo-files #t])
              (compile-program x)))
         "testfile-wpo-prog5")
       #t)

     (equal? (separate-compile
               '(lambda (x)
                  (parameterize ([generate-wpo-files #t])
                    (compile-whole-program (format "~a.wpo" x)
                      (format "~a-all.so" x)
                      #t)))
               'wpo-prog5)
             "()\n")

     (error? ; attempt to invoke library (testfile-wpo-c5) while it is still being loaded
             (separate-eval '(load-program "testfile-wpo-prog5-all.so")))

     (begin
       (with-output-to-file "testfile-wpo-a6.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-wpo-a6)
                (export x a)
                (import (rnrs))
                (define x 3)
                (define z 17)
                (define-syntax a (identifier-syntax z))
                (display "invoke a\n"))))
         'replace)
       (with-output-to-file "testfile-wpo-b6.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-wpo-b6)
                (export y)
                (import (rnrs) (testfile-wpo-a6))
                (define counter 9)
                (define (y)
                  (set! counter (+ counter 5))
                  (list x counter a))
                (display "invoke b\n"))))
         'replace)
       (with-output-to-file "testfile-wpo-prog6.ss"
         (lambda ()
           (pretty-print
             '(import (testfile-wpo-b6) (rnrs) (only (chezscheme) printf)))
           (pretty-print '(printf "==== ~s ====" (y)))
           (pretty-print '(printf "==== ~s ====" (y))))
         'replace)
       (separate-compile
         '(lambda (x)
            (parameterize
              ([compile-imported-libraries #t] [generate-wpo-files #t])
              (compile-program x)))
         'wpo-prog6)
       #t)

     (equal? (separate-eval '(load-program "testfile-wpo-prog6.so"))
             "invoke a\ninvoke b\n==== (3 14 17) ======== (3 19 17) ====")

     (equal? (separate-compile
               '(lambda (x)
                  (parameterize ([generate-wpo-files #t])
                    (compile-whole-program (format "~a.wpo" x)
                      (format "~a-all.so" x))))
               'wpo-prog6)
             "()\n")

     (delete-file "testfile-wpo-a6.ss")
     (delete-file "testfile-wpo-a6.so")
     (delete-file "testfile-wpo-a6.wpo")
     (delete-file "testfile-wpo-b6.ss")
     (delete-file "testfile-wpo-b6.so")
     (delete-file "testfile-wpo-b6.wpo")

     (equal? (separate-eval '(load-program "testfile-wpo-prog6-all.so"))
             "invoke a\ninvoke b\n==== (3 14 17) ======== (3 19 17) ====")

     (begin
       (with-output-to-file "testfile-wpo-a7.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-wpo-a7)
                (export x)
                (import (chezscheme))
                (define x (gensym))
                (printf "invoking a\n"))))
         'replace)
       (with-output-to-file "testfile-wpo-b7.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-wpo-b7)
                (export z)
                (import (chezscheme) (testfile-wpo-c7))
                (define z (cons 'b y))
                (printf "invoking b\n"))))
         'replace)
       (with-output-to-file "testfile-wpo-c7.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-wpo-c7)
                (export y)
                (import (chezscheme) (testfile-wpo-a7))
                (define y (cons 'c x))
                (printf "invoking c\n"))))
         'replace)
       (with-output-to-file "testfile-wpo-ab7.ss"
         (lambda ()
           (for-each
             pretty-print
             '((import (chezscheme)
                 (testfile-wpo-c7)
                 (testfile-wpo-a7)
                 (testfile-wpo-b7))
               (pretty-print (eq? (cdr y) x))
               (pretty-print (eq? (cdr z) y))
               (pretty-print (and (eq? (car y) 'c) (eq? (car z) 'b))))))
         'replace)
       (separate-compile
         '(lambda (x)
            (parameterize
              ([compile-imported-libraries #t] [generate-wpo-files #t])
              (compile-program x)))
         'wpo-ab7)
       #t)

     (equal? (separate-eval '(load "testfile-wpo-ab7.so"))
             "invoking a\ninvoking c\ninvoking b\n#t\n#t\n#t\n")

     (delete-file "testfile-wpo-c7.ss")
     (delete-file "testfile-wpo-c7.wpo")

     (equal? (separate-compile
               '(lambda (x)
                  (parameterize ([generate-wpo-files #t])
                    (compile-whole-program (format "~a.wpo" x)
                      (format "~a-all.so" x))))
               'wpo-ab7)
             "((testfile-wpo-c7))\n")

     (equal? (separate-eval '(load "testfile-wpo-ab7-all.so"))
             "invoking a\ninvoking c\ninvoking b\n#t\n#t\n#t\n")

     (begin
       (with-output-to-file "testfile-wpo-extlib.chezscheme.sls"
         (lambda ()
           (pretty-print
             '(library (testfile-wpo-extlib)
                (export magic)
                (import (rnrs))
                (define magic (cons 9 5)))))
         'replace)
       (with-output-to-file "testfile-wpo-ext.ss"
         (lambda ()
           (pretty-print '(import (chezscheme) (testfile-wpo-extlib)))
           (pretty-print '(pretty-print magic)))
         'replace)
       (separate-compile
         '(lambda (x)
            (parameterize
              ([compile-imported-libraries #t] [generate-wpo-files #t])
              (compile-program x)))
         'wpo-ext)
       #t)

     (equal? (separate-compile
               '(lambda (x)
                  (parameterize ([generate-wpo-files #t])
                    (compile-whole-program (format "~a.wpo" x)
                      (format "~a-all.so" x))))
               'wpo-ext)
             "()\n")

     (equal? (separate-eval '(load "testfile-wpo-ext-all.so")) "(9 . 5)\n")

     ; test propagation of #! shell-script line
     (begin
       (define $hash-bang-line
         "#! /usr/bin/scheme --program\n")
       (delete-file "testfile-wpo-c8.so")
       (delete-file "testfile-wpo-c8-all.so")
       (delete-file "testfile-wpo-c8.wpo")
       (with-output-to-file "testfile-wpo-c8.ss"
         (lambda ()
           (display-string $hash-bang-line)
           (for-each
             pretty-print
             '((import (chezscheme)) (printf "hello\n"))))
         'replace)
       (separate-compile
         '(lambda (x)
            (parameterize ([generate-wpo-files #t]) (compile-program x)))
         'wpo-c8)
       (separate-compile
         '(lambda (x)
            (compile-whole-program (format "~a.wpo" x)
              (format "~a-all.so" x)))
         'wpo-c8)
       #t)

     (equal? (separate-eval '(load "testfile-wpo-c8.so")) "hello\n")

     (equal? (separate-eval '(load "testfile-wpo-c8-all.so")) "hello\n")

     (equal? (call-with-port
               (open-file-input-port "testfile-wpo-c8-all.so")
               (lambda (ip)
                 (get-bytevector-n ip (string-length $hash-bang-line))))
             (string->utf8 $hash-bang-line)))

(mat compile-whole-library
     (begin
       (with-output-to-file "testfile-cwl-a1.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-cwl-a1)
                (export x a)
                (import (rnrs))
                (define x 3)
                (define z 17)
                (define-syntax a (identifier-syntax z))
                (display "invoke a\n"))))
         'replace)
       (with-output-to-file "testfile-cwl-b1.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-cwl-b1)
                (export y)
                (import (rnrs) (testfile-cwl-a1))
                (define counter 9)
                (define (y)
                  (set! counter (+ counter 5))
                  (list x counter a))
                (display "invoke b\n"))))
         'replace)
       (separate-compile
         '(lambda (x)
            (parameterize
              ([compile-imported-libraries #t] [generate-wpo-files #t])
              (compile-library x)))
         "testfile-cwl-b1")
       #t)

     (equal? (separate-compile
               '(lambda (x)
                  (parameterize ([generate-wpo-files #t])
                    (compile-whole-library (format "~a.wpo" x)
                      (format "~a.so" x))))
               'cwl-b1)
             "()\n")

     (begin
       (rename-file "testfile-cwl-a1.ss" "testfile-cwl-a1.ss.spam")
       #t)

     (delete-file "testfile-cwl-a1.so")
     (delete-file "testfile-cwl-a1.wpo")

     (equal? (separate-eval
               '(let ()
                  (import (testfile-cwl-b1))
                  (printf ">~s\n" (y))
                  (printf ">~s\n" (y))))
             "invoke a\ninvoke b\n>(3 14 17)\n>(3 19 17)\n")

     (error? ; library (testfile-cwl-a1) not found
             (separate-eval
               '(begin
                  (import (testfile-cwl-a1))
                  (import (testfile-cwl-b1)))))

     (equal? (separate-eval
               '(let ()
                  (import (testfile-cwl-b1))
                  (import (testfile-cwl-a1))
                  (printf ">~s\n" (y))
                  (printf ">~s\n" (list a x))))
             "invoke a\ninvoke b\n>(3 14 17)\n>(17 3)\n")

     (begin
       (rename-file "testfile-cwl-a1.ss.spam" "testfile-cwl-a1.ss")
       (with-output-to-file "testfile-cwl-d1.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-cwl-d1)
                (export z)
                (import (rnrs) (testfile-cwl-a1))
                (define counter 7)
                (define (z)
                  (set! counter (+ counter 5))
                  (list x counter a))
                (display "invoke d\n"))))
         'replace)
       #t)

     (equal? (separate-compile
               '(lambda (x)
                  (parameterize
                    ([compile-imported-libraries #t]
                     [generate-wpo-files #t])
                    (compile-library x)))
               'cwl-d1)
             "compiling testfile-cwl-d1.ss with output to testfile-cwl-d1.so\ncompiling testfile-cwl-a1.ss with output to testfile-cwl-a1.so\n")

     (begin
       (with-output-to-file "testfile-cwl-a2.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-cwl-a2)
                (export f)
                (import (chezscheme))
                (define (f n)
                  (if (zero? n) 1 (* n (f (- n 1))))))))
         'replace)
       (separate-compile
         '(lambda (x)
            (parameterize ([generate-wpo-files #t]) (compile-library x)))
         'cwl-a2)
       (file-exists? "testfile-cwl-a2.wpo"))

     (begin
       (with-output-to-file "testfile-cwl-b2.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-cwl-b2)
                (export main)
                (import (chezscheme))
                (define (main)
                  (import (testfile-cwl-a2))
                  ((top-level-value 'f (environment '(testfile-cwl-a2))) 10)))))
         'replace)
       (separate-compile
         '(lambda (x)
            (parameterize ([generate-wpo-files #t]) (compile-library x)))
         "testfile-cwl-b2")
       (file-exists? "testfile-cwl-b2.wpo"))

     (equal? (separate-eval '(let () (import (testfile-cwl-b2)) (main)))
             "3628800\n")

     (equal? (separate-compile
               '(lambda (x)
                  (compile-whole-library (format "~a.wpo" x)
                    (format "~a.so" x)))
               "testfile-cwl-b2")
             "()\n")

     (delete-file "testfile-cwl-a2.ss")
     (delete-file "testfile-cwl-a2.so")

     (equal? (separate-eval '(let () (import (testfile-cwl-b2)) (main)))
             "3628800\n")

     (begin
       (with-output-to-file "testfile-cwl-c1.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-cwl-c1)
                (export main)
                (import (chezscheme))
                (define (main)
                  (import (testfile-cwl-b1))
                  (printf ">~s\n"
                    ((top-level-value 'y (environment '(testfile-cwl-b1)))))
                  (printf ">~s\n"
                    ((top-level-value 'y (environment '(testfile-cwl-b1)))))))))
         'replace)
       (separate-compile
         '(lambda (x)
            (parameterize ([generate-wpo-files #t]) (compile-library x)))
         "testfile-cwl-c1")
       #t)

     (equal? (separate-eval '(let () (import (testfile-cwl-c1)) (main)))
             "invoke a\ninvoke b\n>(3 14 17)\n>(3 19 17)\n")

     (equal? (separate-compile
               '(lambda (x)
                  (compile-whole-library (format "~a.wpo" x)
                    (format "~a.so" x)))
               "testfile-cwl-c1")
             "()\n")

     (delete-file "testfile-cwl-a1.so")
     (delete-file "testfile-cwl-a1.ss")
     (delete-file "testfile-cwl-b1.so")
     (delete-file "testfile-cwl-b1.ss")

     (equal? (separate-eval '(let () (import (testfile-cwl-c1)) (main)))
             "invoke a\ninvoke b\n>(3 14 17)\n>(3 19 17)\n")

     (begin
       (with-output-to-file "testfile-cwl-a3.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-cwl-a3)
                (export ! z?)
                (import (rnrs))
                (define (z? n) (= n 0))
                (define (! n)
                  (if (z? n) 1 (* n (! (- n 1))))))))
         'replace)
       (with-output-to-file "testfile-cwl-b3.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-cwl-b3)
                (export fib !)
                (import (rnrs) (testfile-cwl-a3))
                (define (fib n)
                  (cond
                    [(z? n) 1]
                    [(z? (- n 1)) 1]
                    [else (+ (fib (- n 1)) (fib (- n 2)))])))))
         'replace)
       (separate-compile
         '(lambda (x)
            (parameterize
              ([compile-imported-libraries #t] [generate-wpo-files #t])
              (compile-library x)))
         "testfile-cwl-b3")
       #t)

     (equal? (separate-eval
               '(let ()
                  (import (testfile-cwl-b3))
                  (import (testfile-cwl-a3))
                  (pretty-print (list (! 10) (fib 10) (z? 10)))))
             "(3628800 89 #f)\n")

     (equal? (separate-compile
               '(lambda (x)
                  (parameterize ([generate-wpo-files #t])
                    (compile-whole-library (format "~a.wpo" x)
                      (format "~a.so" x))))
               "testfile-cwl-b3")
             "()\n")

     (delete-file "testfile-cwl-a3.so")
     (delete-file "testfile-cwl-a3.wpo")

     (equal? (separate-eval
               '(let ()
                  (import (testfile-cwl-b3))
                  (import (testfile-cwl-a3))
                  (pretty-print (list (! 10) (fib 10) (z? 10)))))
             "(3628800 89 #f)\n")

     (begin
       (with-output-to-file "testfile-cwl-x4.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-cwl-x4)
                (export ack)
                (import (rnrs))
                (define (ack m n)
                  (if (= m 0)
                      (+ n 1)
                      (if (= n 0)
                          (ack (- m 1) 1)
                          (ack (- m 1) (ack m (- n 1)))))))))
         'replace)
       (with-output-to-file "testfile-cwl-y4.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-cwl-y4)
                (export fact)
                (import (rnrs))
                (define (fact n)
                  (if (= n 0) 1 (* n (fact (- n 1))))))))
         'replace)
       (with-output-to-file "testfile-cwl-z4.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-cwl-z4)
                (export fib)
                (import (rnrs))
                (define (fib n)
                  (cond
                    [(= n 0) 1]
                    [(= n 1) 1]
                    [else (+ (fib (- n 1)) (fib (- n 2)))])))))
         'replace)
       (with-output-to-file "testfile-cwl-w4.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-cwl-w4)
                (export mult)
                (import (rnrs))
                (define (mult n m)
                  (if (= n 1) m (+ m (mult (- n 1) m)))))))
         'replace)
       (with-output-to-file "testfile-cwl-a4.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-cwl-a4)
                (export a-stuff)
                (import (rnrs)
                  (testfile-cwl-x4)
                  (testfile-cwl-y4)
                  (testfile-cwl-z4)
                  (testfile-cwl-b4)
                  (testfile-cwl-c4))
                (define (a-stuff)
                  (list (ack 3 4) (fib 5) (fact 10))))))
         'replace)
       (with-output-to-file "testfile-cwl-b4.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-cwl-b4)
                (export b-stuff)
                (import (rnrs) (testfile-cwl-x4) (testfile-cwl-w4))
                (define (b-stuff) (mult 3 (ack 3 4))))))
         'replace)
       (with-output-to-file "testfile-cwl-c4.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-cwl-c4)
                (export c-stuff)
                (import (rnrs) (testfile-cwl-y4) (testfile-cwl-w4))
                (define (c-stuff) (mult 5 (fact 10))))))
         'replace)
       #t)

     (begin
       (define (separate-compile-cwl4)
         (separate-compile
           '(lambda (x)
              (parameterize
                ([compile-imported-libraries #t] [generate-wpo-files #t])
                (compile-library x)))
           "testfile-cwl-b4")
         (separate-compile
           '(lambda (x)
              (parameterize
                ([compile-imported-libraries #t] [generate-wpo-files #t])
                (compile-library x)))
           "testfile-cwl-c4")
         (separate-compile
           '(lambda (x)
              (parameterize
                ([compile-imported-libraries #t] [generate-wpo-files #t])
                (compile-library x)))
           "testfile-cwl-a4")
         (andmap (lambda (n)
                   (and (file-exists? (format "testfile-cwl-~s4.wpo" n))
                        (file-exists? (format "testfile-cwl-~s4.so" n))))
                 '(a b c x y z w)))
       #t)

     (begin
       (define (clear-cwl4-output)
         (andmap (lambda (n)
                   (and (delete (format "testfile-cwl-~s4.wpo" n))
                        (delete (format "testfile-cwl-~s4.so" n))))
                 '(a b c x y z w)))
       #t)

     (separate-compile-cwl4)

     (equal? (separate-eval
               '(let ()
                  (import (testfile-cwl-a4))
                  (import (testfile-cwl-b4) (testfile-cwl-c4))
                  (pretty-print (a-stuff))
                  (pretty-print (b-stuff))
                  (pretty-print (c-stuff))))
             "(125 8 3628800)\n375\n18144000\n")

     (equal? (separate-compile
               '(lambda (x)
                  (parameterize ([generate-wpo-files #t])
                    (compile-whole-library (format "~a.wpo" x)
                      (format "~a.so" x))))
               "testfile-cwl-a4")
             "()\n")

     (andmap (lambda (name)
               (andmap (lambda (ext)
                         (delete-file
                           (format "testfile-cwl-~s4.~s" name ext)))
                       '(so ss wpo)))
             '(b c x y z w))

     (equal? (separate-eval
               '(let ()
                  (import (testfile-cwl-a4))
                  (import (testfile-cwl-b4) (testfile-cwl-c4))
                  (pretty-print (a-stuff))
                  (pretty-print (b-stuff))
                  (pretty-print (c-stuff))))
             "(125 8 3628800)\n375\n18144000\n")

     (begin
       (with-output-to-file "testfile-cwl-a5.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-cwl-a5)
                (export fact)
                (import (rnrs))
                (define (fact n)
                  (if (= n 0) 1 (* n (fact (- n 1))))))))
         'replace)
       (with-output-to-file "testfile-cwl-b5.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-cwl-b5)
                (export fib+fact)
                (import (rnrs) (testfile-cwl-a5))
                (define (fib n)
                  (if (or (= n 0) (= n 1))
                      1
                      (+ (fib (- n 1)) (fib (- n 2)))))
                (define (fib+fact n) (+ (fib n) (fact n))))))
         'replace)
       (with-output-to-file "testfile-cwl-c5.ss"
         (lambda ()
           (pretty-print
             `(library (testfile-cwl-c5)
                (export ack+fact)
                (import (rnrs) (testfile-cwl-a5))
                (define (ack m n)
                  (cond
                    [(= m 0) (+ n 1)]
                    [(= n 0) (ack (- m 1) 1)]
                    [else (ack (- m 1) (ack m (- n 1)))]))
                (define (ack+fact m n)
                  (+ (ack m n) (fact m) (fact n))))))
         'replace)
       (separate-compile
         '(lambda (x)
            (parameterize
              ([compile-imported-libraries #t] [generate-wpo-files #t])
              (for-each compile-library x)))
         '(quote ("testfile-cwl-b5" "testfile-cwl-c5")))
       #t)

     (equal? (separate-compile
               '(lambda (x)
                  (parameterize ([generate-wpo-files #t])
                    (compile-whole-library (format "~a.wpo" x)
                      (format "~a.so" x))))
               "testfile-cwl-b5")
             "()\n")

     (delete-file "testfile-cwl-a5.ss")
     (delete-file "testfile-cwl-a5.so")
     (delete-file "testfile-cwl-a5.wpo")

     (equal? (separate-eval
               '(let ()
                  (import (testfile-cwl-b5))
                  (import (testfile-cwl-c5))
                  (list (fib+fact 10) (ack+fact 3 4))))
             "(3628889 155)\n")


     (begin
       (with-output-to-file "testfile-cwl-a5.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-cwl-a5)
                (export fact)
                (import (rnrs))
                (define (fact n)
                  (if (= n 0) 1 (* n (fact (- n 1))))))))
         'replace)

       (separate-compile
         '(lambda (x)
            (parameterize
              ([compile-imported-libraries #t] [generate-wpo-files #t])
              (for-each compile-library x)))
         '(quote ("testfile-cwl-b5" "testfile-cwl-c5")))
       #t)

     (equal? (separate-compile
               '(lambda (x)
                  (parameterize ([generate-wpo-files #t])
                    (compile-whole-library (format "~a.wpo" x)
                      (format "~a.so" x))))
               "testfile-cwl-b5")
             "()\n")

     (error? ; attempting to re-install run-time part of library (testfile-cwl-a5)
             (separate-eval
               '(let ()
                  (import (testfile-cwl-c5))
                  (import (testfile-cwl-b5))
                  (list (fib+fact 10) (ack+fact 3 4)))))

     (error? ; attempting to re-install run-time part of library (testfile-cwl-a5)
             (separate-eval
               '(eval '(list (fib+fact 10) (ack+fact 3 4))
                      (environment '(chezscheme)
                        '(testfile-cwl-c5)
                        '(testfile-cwl-b5)))))

     (equal? (separate-eval
               '(eval '(list (fib+fact 10) (ack+fact 3 4))
                      (environment '(chezscheme)
                        '(testfile-cwl-b5)
                        '(testfile-cwl-c5))))
             "(3628889 155)\n")

     (begin
       (with-output-to-file "testfile-cwl-d5.ss"
         (lambda ()
           (pretty-print
             '(eval '(list (fib+fact 10) (ack+fact 3 4))
                    (environment '(chezscheme)
                      '(testfile-cwl-c5)
                      '(testfile-cwl-b5)))))
         'replace)
       (separate-compile 'cwl-d5)
       #t)

     (error? ; attempting to re-install run-time part of library (testfile-cwl-a5) with uid #{testfile-cwl-a5 ???}
             (separate-eval '(load "testfile-cwl-d5.so")))

     (begin
       (with-output-to-file "testfile-cwl-d5.ss"
         (lambda ()
           (pretty-print
             '(eval '(list (fib+fact 10) (ack+fact 3 4))
                    (environment '(chezscheme)
                      '(testfile-cwl-b5)
                      '(testfile-cwl-c5)))))
         'replace)
       (separate-compile 'cwl-d5)
       #t)

     (equal? (separate-compile
               '(lambda (x)
                  (parameterize ([generate-wpo-files #t])
                    (compile-whole-library (format "~a.wpo" x)
                      (format "~a.so" x))))
               "testfile-cwl-c5")
             "()\n")

     (delete-file "testfile-cwl-a5.ss")
     (delete-file "testfile-cwl-a5.so")
     (delete-file "testfile-cwl-a5.wpo")

     (error? ; attempting to re-install run-time part of library (testfile-cwl-a5) with uid #{testfile-cwl-a5 ???}
             (separate-eval
               '(let ()
                  (import (testfile-cwl-c5))
                  (import (testfile-cwl-b5))
                  (list (fib+fact 10) (ack+fact 3 4)))))

     (error? ; attempting to re-install run-time part of library (testfile-cwl-a5) with uid #{testfile-cwl-a5 ???}
             (separate-eval
               '(let ()
                  (import (testfile-cwl-b5))
                  (import (testfile-cwl-c5))
                  (list (fib+fact 10) (ack+fact 3 4)))))

     (begin
       (with-output-to-file "testfile-cwl-a6.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-cwl-a6)
                (export !)
                (import (chezscheme))
                (define (! n)
                  (if (= n 0) 1 (* n (! (- n 1))))))))
         'replace)
       (with-output-to-file "testfile-cwl-b6.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-cwl-b6)
                (export fib)
                (import (chezscheme))
                (define (fib n)
                  (if (or (= n 0) (= n 1))
                      1
                      (+ (fib (- n 1)) (fib (- n 2))))))))
         'replace)
       (with-output-to-file "testfile-cwl-c6.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-cwl-c6)
                (export !fib)
                (import (chezscheme) (testfile-cwl-a6) (testfile-cwl-b6))
                (define (!fib n) (! (fib n))))))
         'replace)
       (with-output-to-file "testfile-cwl-d6.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-cwl-d6)
                (export runit)
                (import (chezscheme) (testfile-cwl-c6))
                (define (runit) (pretty-print (!fib 5)))
                (display "invoking d6\n"))))
         'replace)
       (separate-compile
         '(lambda (x)
            (parameterize
              ([compile-imported-libraries #t] [generate-wpo-files #t])
              (compile-library x)))
         "testfile-cwl-d6")
       #t)

     (delete-file "testfile-cwl-a6.wpo")

     (equal? (separate-compile
               '(lambda (x)
                  (parameterize ([generate-wpo-files #t])
                    (compile-whole-library (format "~a.wpo" x)
                      (format "~a.so" x))))
               'cwl-d6)
             "((testfile-cwl-a6))\n")

     (begin
       (rename-file "testfile-cwl-a6.ss" "testfile-cwl-a6.ss.spam")
       (rename-file "testfile-cwl-b6.ss" "testfile-cwl-b6.ss.spam")
       (rename-file "testfile-cwl-c6.ss" "testfile-cwl-c6.ss.spam")
       (rename-file "testfile-cwl-d6.ss" "testfile-cwl-d6.ss.spam")
       #t)

     (delete-file "testfile-cwl-b6.so")
     (delete-file "testfile-cwl-b6.wpo")
     (delete-file "testfile-cwl-c6.so")
     (delete-file "testfile-cwl-c6.wpo")
     (delete-file "testfile-cwl-d6.wpo")

     (equal? (separate-eval '(begin (import (testfile-cwl-d6)) (runit)))
             "invoking d6\n40320\n")

     (delete-file "testfile-cwl-a6.so")

     (error? ; cannot find a6
       (separate-eval '(begin (import (testfile-cwl-d6)) (runit))))

     (delete-file "testfile-cwl-d6.so")

     (begin
       (rename-file "testfile-cwl-a6.ss.spam" "testfile-cwl-a6.ss")
       (rename-file "testfile-cwl-b6.ss.spam" "testfile-cwl-b6.ss")
       (rename-file "testfile-cwl-c6.ss.spam" "testfile-cwl-c6.ss")
       (rename-file "testfile-cwl-d6.ss.spam" "testfile-cwl-d6.ss")
       #t)

     (begin
       (separate-compile
         '(lambda (x)
            (parameterize
              ([compile-imported-libraries #t] [generate-wpo-files #t])
              (compile-library x)))
         "testfile-cwl-d6")
       #t)

     (delete-file "testfile-cwl-c6.wpo")

     (equal? (separate-compile
               '(lambda (x)
                  (parameterize ([generate-wpo-files #t])
                    (compile-whole-library (format "~a.wpo" x)
                      (format "~a.so" x))))
               'cwl-d6)
             "((testfile-cwl-c6))\n")

     (delete-file "testfile-cwl-a6.so")
     (delete-file "testfile-cwl-a6.wpo")
     (delete-file "testfile-cwl-b6.so")
     (delete-file "testfile-cwl-b6.wpo")
     (delete-file "testfile-cwl-d6.wpo")
     (delete-file "testfile-cwl-a6.ss")
     (delete-file "testfile-cwl-b6.ss")
     (delete-file "testfile-cwl-c6.ss")
     (delete-file "testfile-cwl-d6.ss")

     (equal? (separate-eval '(begin (import (testfile-cwl-d6)) (runit)))
             "invoking d6\n40320\n")

     (delete-file "testfile-cwl-c6.so")

     (error? ; cannot find c6
       (separate-eval '(begin (import (testfile-cwl-d6)) (runit))))

     (begin
       (with-output-to-file "testfile-cwl-a7.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-cwl-a7)
                (export x)
                (import (chezscheme))
                (define $x (make-parameter 1))
                (define-syntax x (identifier-syntax ($x)))
                (printf "invoking a\n"))))
         'replace)
       (with-output-to-file "testfile-cwl-b7.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-cwl-b7)
                (export z)
                (import (chezscheme) (testfile-cwl-c7))
                (define $z (make-parameter (+ y 1)))
                (define-syntax z (identifier-syntax ($z)))
                (printf "invoking b\n"))))
         'replace)
       (with-output-to-file "testfile-cwl-c7.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-cwl-c7)
                (export y)
                (import (chezscheme) (testfile-cwl-a7))
                (define $y (make-parameter (+ x 1)))
                (define-syntax y (identifier-syntax ($y)))
                (printf "invoking c\n"))))
         'replace)
       (separate-compile
         '(lambda (x)
            (parameterize
              ([compile-imported-libraries #t] [generate-wpo-files #t])
              (compile-library x)))
         'cwl-b7)
       #t)

     (delete-file "testfile-cwl-c7.wpo")
     (delete-file "testfile-cwl-c7.ss")

     (equal? (separate-compile
               '(lambda (x)
                  (parameterize ([generate-wpo-files #t])
                    (compile-whole-library
                      (format "~a.wpo" x)
                      "testfile-cwl-ab7.so")))
               'cwl-b7)
             "((testfile-cwl-c7))\n")

     (equal? (separate-eval '(load "testfile-cwl-ab7.so")
               '(import (testfile-cwl-a7))
               '(write x)
               '(newline)
               '(import (testfile-cwl-b7))
               '(write z)
               '(newline)
               '(import (testfile-cwl-c7))
               '(write y)
               '(newline))
             "invoking a\n1\ninvoking c\ninvoking b\n3\n2\n")

     (equal? (separate-eval '(load "testfile-cwl-ab7.so")
               '(import (testfile-cwl-a7))
               '(write x)
               '(newline)
               '(import (testfile-cwl-c7))
               '(write y)
               '(newline)
               '(import (testfile-cwl-b7))
               '(write z)
               '(newline))
             "invoking a\n1\ninvoking c\n2\ninvoking b\n3\n")

     (equal? (separate-eval '(load "testfile-cwl-ab7.so")
               '(import (testfile-cwl-a7))
               '(write x)
               '(newline)
               '(import (testfile-cwl-c7))
               '(write y)
               '(newline))
             "invoking a\n1\ninvoking c\n2\n")
     (equal? (separate-eval '(load "testfile-cwl-ab7.so")
               '(import (testfile-cwl-b7))
               '(write z)
               '(newline)
               '(import (testfile-cwl-c7))
               '(write y)
               '(newline))
             "invoking a\ninvoking c\ninvoking b\n3\n2\n")
     (equal? (separate-eval '(load "testfile-cwl-ab7.so")
               '(import (testfile-cwl-a7))
               '(import (testfile-cwl-c7))
               '(write y)
               '(newline))
             "invoking a\ninvoking c\n2\n")
     (equal? (separate-eval '(load "testfile-cwl-ab7.so")
               '(import (testfile-cwl-b7))
               '(import (testfile-cwl-c7))
               '(write y)
               '(newline))
             "invoking a\ninvoking c\n2\n")
     (equal? (separate-eval '(load "testfile-cwl-ab7.so")
               '(import (testfile-cwl-a7) (testfile-cwl-c7))
               '(write y)
               '(newline))
             "invoking a\ninvoking c\n2\n")
     (equal? (separate-eval '(load "testfile-cwl-ab7.so")
               '(import (testfile-cwl-c7) (testfile-cwl-b7))
               '(write y)
               '(newline))
             "invoking a\ninvoking c\n2\n")
     (equal? (separate-eval '(load "testfile-cwl-ab7.so")
               '(import (testfile-cwl-c7))
               '(write y)
               '(newline))
             "invoking a\ninvoking c\n2\n")

     (begin
       (with-output-to-file "testfile-cwl-a8.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-cwl-a8)
                (export x)
                (import (chezscheme))
                (define x (gensym))
                (printf "invoking a\n"))))
         'replace)
       (with-output-to-file "testfile-cwl-b8.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-cwl-b8)
                (export z)
                (import (chezscheme) (testfile-cwl-c8))
                (define z (cons 'b y))
                (printf "invoking b\n"))))
         'replace)
       (with-output-to-file "testfile-cwl-c8.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-cwl-c8)
                (export y)
                (import (chezscheme) (testfile-cwl-a8))
                (define y (cons 'c x))
                (printf "invoking c\n"))))
         'replace)
       (with-output-to-file "testfile-cwl-d8.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-cwl-d8)
                (export runit)
                (import (chezscheme)
                  (testfile-cwl-c8)
                  (testfile-cwl-a8)
                  (testfile-cwl-b8))
                (define (runit yes?)
                  (pretty-print (eq? (cdr y) x))
                  (pretty-print (eq? (cdr z) y))
                  (pretty-print (and (eq? (car y) 'c) (eq? (car z) 'b)))
                  (when yes?
                        (eq? (eval 'x (environment '(testfile-cwl-a8))) x))))))
         'replace)
       (separate-compile
         '(lambda (x)
            (parameterize
              ([compile-imported-libraries #t] [generate-wpo-files #t])
              (compile-library x)))
         'cwl-d8)
       #t)

     (equal? (separate-eval '(begin (import (testfile-cwl-d8)) (runit #f)))
             "invoking a\ninvoking c\ninvoking b\n#t\n#t\n#t\n")

     (equal? (separate-eval '(begin (import (testfile-cwl-d8)) (runit #t)))
             "invoking a\ninvoking c\ninvoking b\n#t\n#t\n#t\n#t\n")

     (delete-file "testfile-cwl-c8.ss")
     (delete-file "testfile-cwl-c8.wpo")

     (equal? (separate-compile
               '(lambda (x)
                  (parameterize ([generate-wpo-files #t])
                    (compile-whole-library (format "~a.wpo" x)
                      (format "~a.so" x))))
               'cwl-d8)
             "((testfile-cwl-c8))\n")

     (equal? (separate-eval '(begin (import (testfile-cwl-d8)) (runit #f)))
             "invoking a\ninvoking c\ninvoking b\n#t\n#t\n#t\n")

     (equal? (separate-eval '(begin (import (testfile-cwl-d8)) (runit #t)))
             "invoking a\ninvoking c\ninvoking b\n#t\n#t\n#t\n#t\n")

     (begin
       (with-output-to-file "testfile-cwl-a9.ss"
         (lambda ()
           (pretty-print
             '(eval-when (visit)
                (library (testfile-cwl-a9)
                  (export x)
                  (import (chezscheme))
                  (define x 5)))))
         'replace)
       (separate-compile
         '(lambda (x)
            (parameterize
              ([compile-imported-libraries #t] [generate-wpo-files #t])
              (compile-library x)))
         'cwl-a9)
       #t)

     (error? ; found visit-only run-time library (testfile-cwl-a9)
       (separate-compile
         '(lambda (x)
            (parameterize ([generate-wpo-files #t])
              (compile-whole-library (format "~a.wpo" x)
                (format "~a.so" x))))
         'cwl-a9))

     (begin
       (with-output-to-file "testfile-cwl-a10.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-cwl-a10)
                (export f x)
                (import (chezscheme) (testfile-cwl-b10))
                (define f (lambda (x) (* x 17)))
                (define x 5))))
         'replace)
       (with-output-to-file "testfile-cwl-b10.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-cwl-b10)
                (export g y)
                (import (chezscheme))
                (define g (lambda (x) (+ x 23)))
                (define y 37))))
         'replace)
       (separate-compile
         '(lambda (x)
            (parameterize
              ([compile-imported-libraries #t] [generate-wpo-files #t])
              (compile-library x)))
         'cwl-a10)
       (separate-compile
         '(lambda (x)
            (parameterize ([generate-wpo-files #t])
              (compile-whole-library (format "~a.wpo" x)
                (format "~a.so" x))))
         'cwl-a10)
       #t)

     (delete-file "testfile-cwl-a10.ss")
     (delete-file "testfile-cwl-a10.wpo")
     (delete-file "testfile-cwl-b10.ss")
     (delete-file "testfile-cwl-b10.so")
     (delete-file "testfile-cwl-b10.wpo")

     (test-cp0-expansion
       `(let ()
          (import (testfile-cwl-a10) (testfile-cwl-b10))
          (+ (f (g y)) x))
       `(begin
          (#3%$invoke-library '(testfile-cwl-b10) '() ',gensym?)
          (#3%$invoke-library '(testfile-cwl-a10) '() ',gensym?)
          1025))

     (begin
       (with-output-to-file "testfile-cwl-a11.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-cwl-a11)
                (export f x)
                (import (chezscheme) (testfile-cwl-b11))
                (define f (lambda (x) (* x 17)))
                (define x 5))))
         'replace)
       (with-output-to-file "testfile-cwl-b11.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-cwl-b11)
                (export g y)
                (import (chezscheme))
                (define g (lambda (x) (+ x 23)))
                (define y 37))))
         'replace)
       (separate-compile
         '(lambda (x)
            (parameterize
              ([compile-imported-libraries #t] [generate-wpo-files #t])
              (compile-library x)))
         'cwl-a11)
       (separate-compile
         '(lambda (x)
            (parameterize
              ([generate-wpo-files #t] [run-cp0 (lambda (cp0 x) x)])
              (compile-whole-library (format "~a.wpo" x)
                (format "~a.so" x))))
         'cwl-a11)
       #t)

     (delete-file "testfile-cwl-a11.ss")
     (delete-file "testfile-cwl-a11.wpo")
     (delete-file "testfile-cwl-b11.ss")
     (delete-file "testfile-cwl-b11.so")
     (delete-file "testfile-cwl-b11.wpo")

     (test-cp0-expansion
       `(let ()
          (import (testfile-cwl-a11) (testfile-cwl-b11))
          (+ (f (g y)) x))
       `(begin
          (#3%$invoke-library '(testfile-cwl-b11) '() ',gensym?)
          (#3%$invoke-library '(testfile-cwl-a11) '() ',gensym?)
          ,(lambda (x) (not (eqv? x 1025)))))

     (begin
       (delete-file "testfile-cwl-a12.so")
       (delete-file "testfile-cwl-a12.wpo")
       (delete-file "testfile-cwl-b12.so")
       (delete-file "testfile-cwl-b12.wpo")
       (with-output-to-file "testfile-cwl-a12.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-cwl-a12)
                (export f)
                (import (chezscheme))
                (define f (lambda (x) (* x 17))))))
         'replace)
       (with-output-to-file "testfile-cwl-b12.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-cwl-b12)
                (export g f)
                (import (chezscheme) (testfile-cwl-a12))
                (define g (lambda (x) (+ x 23))))))
         'replace)
       (separate-compile
         '(lambda (x)
            (parameterize
              ([compile-imported-libraries #t] [generate-wpo-files #t])
              (compile-library x)))
         'cwl-b12)
       (separate-compile
         '(lambda (x)
            (parameterize ([generate-wpo-files #t])
              (compile-whole-library (format "~a.wpo" x)
                (format "~a.so" x))))
         'cwl-b12)
       #t)
     (equal? (separate-eval
               '(let ()
                  (import (testfile-cwl-b12))
                  (list (f 3) (g 5))))
             "(51 28)\n")

     (begin
       (delete-file "testfile-cwl-a13.so")
       (delete-file "testfile-cwl-a13.wpo")
       (delete-file "testfile-cwl-b13.so")
       (delete-file "testfile-cwl-b13.wpo")
       (delete-file "testfile-cwl-c13.so")
       (delete-file "testfile-cwl-c13.wpo")
       (with-output-to-file "testfile-cwl-a13.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-cwl-a13)
                (export a)
                (import (chezscheme))
                (define-syntax a (identifier-syntax f))
                (define f (lambda (x) (* x 17))))))
         'replace)
       (with-output-to-file "testfile-cwl-b13.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-cwl-b13)
                (export g a)
                (import (chezscheme) (testfile-cwl-a13))
                (define g (lambda (x) (a x))))))
         'replace)
       (with-output-to-file "testfile-cwl-c13.ss"
         (lambda ()
           (for-each
             pretty-print
             '((import (chezscheme) (testfile-cwl-b13))
               (pretty-print
                 (list (g 3)
                       (a 5)
                       (eval '(a 7) (environment '(testfile-cwl-a13))))))))
         'replace)
       (separate-compile
         '(lambda (x)
            (parameterize ([generate-wpo-files #t]) (compile-library x)))
         'cwl-a13)
       (separate-compile
         '(lambda (x)
            (parameterize ([generate-wpo-files #f]) (compile-library x)))
         'cwl-b13)
       (separate-compile
         '(lambda (x)
            (parameterize ([generate-wpo-files #t]) (compile-program x)))
         'cwl-c13)
       (separate-compile
         '(lambda (x)
            (compile-whole-program (format "~a.wpo" x) (format "~a.so" x)))
         'cwl-c13)
       #t)
     (equal? (separate-eval '(load-program "testfile-cwl-c13.so"))
             "(51 85 119)\n")

     (begin
       (with-output-to-file "testfile-wpo-extlib-1.chezscheme.sls"
         (lambda ()
           (pretty-print
             '(library (testfile-wpo-extlib-1)
                (export magic)
                (import (rnrs))
                (define magic (cons 9 5)))))
         'replace)
       (with-output-to-file "testfile-wpo-extlib-2.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-wpo-extlib-2)
                (export p)
                (import (chezscheme) (testfile-wpo-extlib))
                (define p (lambda () (pretty-print magic))))))
         'replace)
       (separate-compile
         '(lambda (x)
            (parameterize
              ([compile-imported-libraries #t] [generate-wpo-files #t])
              (compile-library x)))
         'wpo-extlib-2)
       #t)

     (equal? (separate-compile
               '(lambda (x)
                  (parameterize ([generate-wpo-files #t])
                    (compile-whole-library (format "~a.wpo" x)
                      (format "~a-all.so" x))))
               'wpo-extlib-2)
             "()\n")

     (equal? (separate-eval '(let () (import (testfile-wpo-extlib-2)) (p)))
             "(9 . 5)\n")

     ;; regression tests from @owaddell generated to fix problems he encountered
     ;; with compile-whole-library from a test generator.
     (begin
       (with-output-to-file "testfile-wpo-coconut.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-wpo-coconut)
                (export coconut apple->coconut)
                (import (scheme))
                (define $init (list '_))
                (define apple->coconut
                  (cons 'apple->coconut $init))
                (define coconut
                  (list 'coconut apple->coconut $init)))))
         'replace)
       (with-output-to-file "testfile-wpo-banana.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-wpo-banana)
                (export banana apple->banana)
                (import (scheme))
                (define $init (list '_))
                (define apple->banana
                  (cons 'apple->banana $init))
                (define banana
                  (list 'banana apple->banana $init)))))
         'replace)
       (with-output-to-file "testfile-wpo-apple.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-wpo-apple)
                (export apple)
                (import (scheme)
                  (testfile-wpo-banana)
                  (testfile-wpo-coconut))
                (define $init
                  (list '_
                        (cons 'apple->banana apple->banana)
                        (cons 'apple->coconut apple->coconut)))
                (define apple (list 'apple $init)))))
         'replace)
       (with-output-to-file "testfile-wpo-main.ss"
         (lambda ()
           (pretty-print
             '(import (scheme)
                (testfile-wpo-banana)
                (testfile-wpo-coconut)
                (testfile-wpo-apple)))
           (pretty-print '(pretty-print banana))
           (pretty-print '(pretty-print coconut))
           (pretty-print '(pretty-print apple)))
         'replace)
       (separate-compile
         '(lambda (x)
            (parameterize
              ([compile-imported-libraries #t] [generate-wpo-files #t])
              (compile-program x)))
         'wpo-main)
       #t)

     (equal? (separate-compile
               '(lambda (x)
                  (parameterize ([generate-wpo-files #f])
                    (compile-whole-library (format "~a.wpo" x)
                      (format "~a.so" x))))
               'wpo-coconut)
             "()\n")

     (begin (delete-file "testfile-wpo-coconut.wpo") #t)
     (equal? (separate-compile
               '(lambda (x)
                  (parameterize ([generate-wpo-files #f])
                    (compile-whole-library (format "~a.wpo" x)
                      (format "~a.so" x))))
               'wpo-apple)
             "((testfile-wpo-coconut))\n")

     (begin
       (delete-file "testfile-wpo-banana.wpo")
       (delete-file "testfile-wpo-apple.wpo")
       (delete-file "testfile-wpo-banana.so")
       #t)

     (equal? (separate-compile
               '(lambda (x)
                  (parameterize
                    ([library-search-handler
                       (let ([lsh (library-search-handler)])
                         (lambda (who name dirs exts)
                           (lsh who
                                (if (equal? name '(testfile-wpo-banana))
                                    '(testfile-wpo-apple)
                                    name)
                                dirs
                                exts)))])
                    (compile-whole-program (format "~a.wpo" x)
                      (format "~a.so" x))))
               'wpo-main)
             "((testfile-wpo-apple)\n  (testfile-wpo-banana)\n  (testfile-wpo-coconut))\n")

     (equal? (separate-eval
               '(parameterize
                  ([library-search-handler
                     (let ([lsh (library-search-handler)])
                       (lambda (who name dirs exts)
                         (lsh who
                              (if (equal? name '(testfile-wpo-banana))
                                  '(testfile-wpo-apple)
                                  name)
                              dirs
                              exts)))])
                  (load-program "testfile-wpo-main.so")))
             (string-append
               "(banana (apple->banana _) (_))\n"
               "(coconut (apple->coconut _) (_))\n"
               "(apple\n  (_ (apple->banana apple->banana _)\n     (apple->coconut apple->coconut _)))\n"))

     (begin
       ;; clean-up to make sure previous builds don't get in the way.
       (delete-file "testfile-wpo-coconut.ss")
       (delete-file "testfile-wpo-coconut.so")
       (delete-file "testfile-wpo-coconut.wpo")

       (delete-file "testfile-wpo-banana.ss")
       (delete-file "testfile-wpo-banana.so")
       (delete-file "testfile-wpo-banana.wpo")

       (delete-file "testfile-wpo-apple.ss")
       (delete-file "testfile-wpo-apple.so")
       (delete-file "testfile-wpo-apple.wpo")

       (delete-file "testfile-wpo-main.ss")
       (delete-file "testfile-wpo-main.so")
       (delete-file "testfile-wpo-main.wpo")

       #t)

     (begin
       (with-output-to-file "testfile-wpo-coconut.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-wpo-coconut)
                (export coconut banana->coconut apple->coconut)
                (import (scheme))
                (define $init (list '_))
                (define banana->coconut
                  (cons 'banana->coconut $init))
                (define apple->coconut
                  (cons 'apple->coconut $init))
                (define coconut
                  (list 'coconut banana->coconut apple->coconut $init)))))
         'replace)
       (with-output-to-file "testfile-wpo-date.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-wpo-date)
                (export date apple->date)
                (import (scheme))
                (define $init (list '_))
                (define apple->date
                  (cons 'apple->date $init))
                (define date (list 'date apple->date $init)))))
         'replace)
       (with-output-to-file "testfile-wpo-apple.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-wpo-apple)
                (export apple)
                (import (scheme)
                  (testfile-wpo-date)
                  (testfile-wpo-coconut))
                (define $init
                  (list '_
                        (cons 'apple->date apple->date)
                        (cons 'apple->coconut apple->coconut)))
                (define apple (list 'apple $init)))))
         'replace)
       (with-output-to-file "testfile-wpo-banana.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-wpo-banana)
                (export banana)
                (import (scheme) (testfile-wpo-coconut))
                (define $init
                  (list '_ (cons 'banana->coconut banana->coconut)))
                (define banana (list 'banana $init)))))
         'replace)
       (with-output-to-file "testfile-wpo-main.ss"
         (lambda ()
           (pretty-print
             '(import (scheme)
                (testfile-wpo-date)
                (testfile-wpo-banana)
                (testfile-wpo-coconut)
                (testfile-wpo-apple)))
           (pretty-print '(pretty-print date))
           (pretty-print '(pretty-print banana))
           (pretty-print '(pretty-print coconut))
           (pretty-print '(pretty-print apple)))
         'replace)
       (separate-compile
         '(lambda (x)
            (parameterize
              ([compile-imported-libraries #t] [generate-wpo-files #t])
              (compile-program x)))
         'wpo-main)
       #t)

     (equal? (separate-compile
               '(lambda (x)
                  (parameterize ([generate-wpo-files #f])
                    (compile-whole-library (format "~a.wpo" x)
                      (format "~a.so" x))))
               'wpo-coconut)
             "()\n")

     (begin (delete-file "testfile-wpo-coconut.wpo") #t)
     (equal? (separate-compile
               '(lambda (x)
                  (parameterize ([generate-wpo-files #f])
                    (compile-whole-library (format "~a.wpo" x)
                      (format "~a.so" x))))
               'wpo-apple)
             "((testfile-wpo-coconut))\n")

     (begin
       (delete-file "testfile-wpo-date.wpo")
       (delete-file "testfile-wpo-apple.wpo")
       (delete-file "testfile-wpo-date.so")
       #t)

     (equal? (separate-compile
               '(lambda (x)
                  (parameterize
                    ([library-search-handler
                       (let ([lsh (library-search-handler)])
                         (lambda (who name dirs exts)
                           (lsh who
                                (if (equal? name '(testfile-wpo-date))
                                    '(testfile-wpo-apple)
                                    name)
                                dirs
                                exts)))])
                    (compile-whole-program (format "~a.wpo" x)
                      (format "~a.so" x))))
               'wpo-main)
             "((testfile-wpo-apple)\n  (testfile-wpo-date)\n  (testfile-wpo-coconut))\n")

     (equal? (separate-eval
               '(parameterize
                  ([library-search-handler
                     (let ([lsh (library-search-handler)])
                       (lambda (who name dirs exts)
                         (lsh who
                              (if (equal? name '(testfile-wpo-date))
                                  '(testfile-wpo-apple)
                                  name)
                              dirs
                              exts)))])
                  (load-program "testfile-wpo-main.so")))
             (string-append
               "(date (apple->date _) (_))\n"
               "(banana (_ (banana->coconut banana->coconut _)))\n"
               "(coconut (banana->coconut _) (apple->coconut _) (_))\n"
               "(apple\n"
               "  (_ (apple->date apple->date _)\n"
               "     (apple->coconut apple->coconut _)))\n"))

     (begin
       ;; clean-up to make sure previous builds don't get in the way.
       (delete-file "testfile-wpo-coconut.ss")
       (delete-file "testfile-wpo-coconut.so")
       (delete-file "testfile-wpo-coconut.wpo")

       (delete-file "testfile-wpo-date.ss")
       (delete-file "testfile-wpo-date.so")
       (delete-file "testfile-wpo-date.wpo")

       (delete-file "testfile-wpo-banana.ss")
       (delete-file "testfile-wpo-banana.so")
       (delete-file "testfile-wpo-banana.wpo")

       (delete-file "testfile-wpo-apple.ss")
       (delete-file "testfile-wpo-apple.so")
       (delete-file "testfile-wpo-apple.wpo")

       (delete-file "testfile-wpo-main.ss")
       (delete-file "testfile-wpo-main.so")
       (delete-file "testfile-wpo-main.wpo")

       #t)

     (begin
       (with-output-to-file "testfile-wpo-date.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-wpo-date)
                (export date apple->date)
                (import (scheme))
                (define $init (list '_))
                (define apple->date
                  (cons 'apple->date $init))
                (define date (list 'date apple->date $init)))))
         'replace)
       (with-output-to-file "testfile-wpo-eel.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-wpo-eel)
                (export eel coconut->eel apple->eel)
                (import (scheme))
                (define $init (list '_))
                (define coconut->eel
                  (cons 'coconut->eel $init))
                (define apple->eel (cons 'apple->eel $init))
                (define eel
                  (list 'eel coconut->eel apple->eel $init)))))
         'replace)
       (with-output-to-file "testfile-wpo-coconut.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-wpo-coconut)
                (export coconut banana->coconut apple->coconut)
                (import (scheme) (testfile-wpo-eel))
                (define $init
                  (list '_ (cons 'coconut->eel coconut->eel)))
                (define banana->coconut
                  (cons 'banana->coconut $init))
                (define apple->coconut
                  (cons 'apple->coconut $init))
                (define coconut
                  (list 'coconut banana->coconut apple->coconut $init)))))
         'replace)
       (with-output-to-file "testfile-wpo-apple.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-wpo-apple)
                (export apple)
                (import (scheme)
                  (testfile-wpo-date)
                  (testfile-wpo-coconut)
                  (testfile-wpo-eel))
                (define $init
                  (list '_
                        (cons 'apple->date apple->date)
                        (cons 'apple->coconut apple->coconut)
                        (cons 'apple->eel apple->eel)))
                (define apple (list 'apple $init)))))
         'replace)
       (with-output-to-file "testfile-wpo-banana.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-wpo-banana)
                (export banana)
                (import (scheme) (testfile-wpo-coconut))
                (define $init
                  (list '_ (cons 'banana->coconut banana->coconut)))
                (define banana (list 'banana $init)))))
         'replace)
       (with-output-to-file "testfile-wpo-main.ss"
         (lambda ()
           (pretty-print
             '(import (scheme)
                (testfile-wpo-date)
                (testfile-wpo-banana)
                (testfile-wpo-coconut)
                (testfile-wpo-apple)
                (testfile-wpo-eel)))
           (pretty-print '(pretty-print date))
           (pretty-print '(pretty-print banana))
           (pretty-print '(pretty-print coconut))
           (pretty-print '(pretty-print apple))
           (pretty-print '(pretty-print eel)))
         'replace)
       (separate-compile
         '(lambda (x)
            (parameterize
              ([compile-imported-libraries #t] [generate-wpo-files #t])
              (compile-program x)))
         'wpo-main)
       #t)

     (equal? (separate-compile
               '(lambda (x)
                  (parameterize ([generate-wpo-files #f])
                    (compile-whole-library (format "~a.wpo" x)
                      (format "~a.so" x))))
               'wpo-coconut)
             "()\n")

     (begin
       (delete-file "testfile-wpo-eel.wpo")
       (delete-file "testfile-wpo-coconut.wpo")
       (delete-file "testfile-wpo-eel.so")
       #t)
     (equal? (separate-compile
               '(lambda (x)
                  (parameterize
                    ([generate-wpo-files #f]
                     [library-search-handler
                       (let ([lsh (library-search-handler)])
                         (lambda (who name dirs exts)
                           (lsh who
                                (if (equal? name '(testfile-wpo-eel))
                                    '(testfile-wpo-coconut)
                                    name)
                                dirs
                                exts)))])
                    (compile-whole-library (format "~a.wpo" x)
                      (format "~a.so" x))))
               'wpo-apple)
             "((testfile-wpo-coconut) (testfile-wpo-eel))\n")

     (begin
       (delete-file "testfile-wpo-date.wpo")
       (delete-file "testfile-wpo-apple.wpo")
       (delete-file "testfile-wpo-date.so")
       #t)

     (equal? (separate-compile
               '(lambda (x)
                  (parameterize
                    ([library-search-handler
                       (let ([lsh (library-search-handler)])
                         (lambda (who name dirs exts)
                           (lsh who
                                (cond
                                  [(equal? name '(testfile-wpo-date))
                                   '(testfile-wpo-apple)]
                                  [(equal? name '(testfile-wpo-eel))
                                   '(testfile-wpo-coconut)]
                                  [else name])
                                dirs
                                exts)))])
                    (compile-whole-program (format "~a.wpo" x)
                      (format "~a.so" x))))
               'wpo-main)
             "((testfile-wpo-apple)\n  (testfile-wpo-date)\n  (testfile-wpo-coconut)\n  (testfile-wpo-eel))\n")

     (equal? (separate-eval
               '(parameterize
                  ([library-search-handler
                     (let ([lsh (library-search-handler)])
                       (lambda (who name dirs exts)
                         (lsh who
                              (cond
                                [(equal? name '(testfile-wpo-date))
                                 '(testfile-wpo-apple)]
                                [(equal? name '(testfile-wpo-eel))
                                 '(testfile-wpo-coconut)]
                                [else name])
                              dirs
                              exts)))])
                  (load-program "testfile-wpo-main.so")))
             (string-append
               "(date (apple->date _) (_))\n"
               "(banana\n"
               "  (_ (banana->coconut\n"
               "       banana->coconut\n"
               "       _\n"
               "       (coconut->eel coconut->eel _))))\n"
               "(coconut\n"
               "  (banana->coconut _ (coconut->eel coconut->eel _))\n"
               "  (apple->coconut _ (coconut->eel coconut->eel _))\n"
               "  (_ (coconut->eel coconut->eel _)))\n"
               "(apple\n"
               "  (_ (apple->date apple->date _)\n"
               "     (apple->coconut\n"
               "       apple->coconut\n"
               "       _\n"
               "       (coconut->eel coconut->eel _))\n"
               "     (apple->eel apple->eel _)))\n"
               "(eel (coconut->eel _) (apple->eel _) (_))\n"))

     (begin
       ;; clean-up to make sure previous builds don't get in the way.
       (delete-file "testfile-wpo-coconut.ss")
       (delete-file "testfile-wpo-coconut.so")
       (delete-file "testfile-wpo-coconut.wpo")

       (delete-file "testfile-wpo-eel.ss")
       (delete-file "testfile-wpo-eel.so")
       (delete-file "testfile-wpo-eel.wpo")

       (delete-file "testfile-wpo-date.ss")
       (delete-file "testfile-wpo-date.so")
       (delete-file "testfile-wpo-date.wpo")

       (delete-file "testfile-wpo-banana.ss")
       (delete-file "testfile-wpo-banana.so")
       (delete-file "testfile-wpo-banana.wpo")

       (delete-file "testfile-wpo-apple.ss")
       (delete-file "testfile-wpo-apple.so")
       (delete-file "testfile-wpo-apple.wpo")

       (delete-file "testfile-wpo-main.ss")
       (delete-file "testfile-wpo-main.so")
       (delete-file "testfile-wpo-main.wpo")

       #t)

     (begin
       (with-output-to-file "testfile-deja-vu-one.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-deja-vu-one)
                       (export a)
                       (import (scheme))
                       (define a 3))))
         'replace)
       (with-output-to-file "testfile-deja-vu-two.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-deja-vu-two)
                (export b)
                (import (scheme) (testfile-deja-vu-one))
                (define b (list 'b a)))))
         'replace)
       (with-output-to-file "testfile-deja-vu-dup.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-deja-vu-dup)
                (export d)
                (import (scheme) (testfile-deja-vu-one))
                (define d (list a 'd)))))
         'replace)
       (with-output-to-file "testfile-deja-vu-main.ss"
         (lambda ()
           (for-each
             pretty-print
             '((import (scheme)
                 (testfile-deja-vu-one)
                 (testfile-deja-vu-two)
                 (testfile-deja-vu-dup))
               (pretty-print (list a b d)))))
         'replace)
       (separate-eval
         '(parameterize ([generate-wpo-files #t])
            (compile-library "testfile-deja-vu-one")
            (compile-library "testfile-deja-vu-two")
            (compile-library "testfile-deja-vu-dup")
            (compile-program "testfile-deja-vu-main")
            (compile-whole-library
              "testfile-deja-vu-one.wpo"
              "testfile-deja-vu-one.done")
            (compile-whole-library
              "testfile-deja-vu-two.wpo"
              "testfile-deja-vu-two.done")
            (compile-whole-library
              "testfile-deja-vu-dup.wpo"
              "testfile-deja-vu-dup.done")))
       #t)

     (error? (separate-eval
               '(compile-whole-program
                  "testfile-deja-vu-main.wpo"
                  "testfile-deja-vu-main.done")))

     (begin
       (do ([stem '("one" "two" "dup" "main") (cdr stem)])
           ((null? stem))
           (do ([ext '("ss" "so" "wpo" "done") (cdr ext)])
               ((null? ext))
               (delete-file
                 (format "testfile-deja-vu-~a.~a" (car stem) (car ext)))))
       #t)
     )

(mat maybe-compile-whole
     (begin
       (delete-file "testfile-mcw-a1.so")
       (delete-file "testfile-mcw-a1.wpo")
       (delete-file "testfile-mcw-b1.so")
       (delete-file "testfile-mcw-b1.wpo")
       (delete-file "testfile-mcw-c1.so")
       (delete-file "testfile-mcw-c1.wpo")
       (with-output-to-file "testfile-mcw-ha1.ss"
         (lambda ()
           (pretty-print '(define minor-msg-number 97)))
         'replace)
       (with-output-to-file "testfile-mcw-hb1.ss"
         (lambda ()
           (pretty-print '(define major-msg-number 113)))
         'replace)
       (with-output-to-file "testfile-mcw-a1.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-mcw-a1)
                (export a)
                (import (chezscheme))
                (define a "hello from a"))))
         'replace)
       (with-output-to-file "testfile-mcw-b1.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-mcw-b1)
                (export b)
                (import (chezscheme) (testfile-mcw-a1))
                (include "testfile-mcw-ha1.ss")
                (define b
                  (lambda ()
                    (format "~a and b [~s]" a minor-msg-number))))))
         'replace)
       (with-output-to-file "testfile-mcw-c1.ss"
         (lambda ()
           (for-each
             pretty-print
             '((import (chezscheme) (testfile-mcw-b1))
               (include "testfile-mcw-hb1.ss")
               (printf "~a and c [~s]\n" (b) major-msg-number))))
         'replace)
       (separate-compile
         '(lambda (x)
            (parameterize
              ([compile-imported-libraries #t] [generate-wpo-files #t])
              (compile-program x)))
         'mcw-c1)
       #t)

     (equal? (separate-eval '(load-program "testfile-mcw-c1.so"))
             "hello from a and b [97] and c [113]\n")

     (begin
       (with-output-to-file "testfile-mcw-a1.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-mcw-a1)
                (export a)
                (import (chezscheme))
                (define a "greetings from a"))))
         'replace)
       (touch "testfile-mcw-a1.so" "testfile-mcw-a1.ss")
       (separate-compile
         '(lambda (x)
            (parameterize
              ([compile-imported-libraries #t] [generate-wpo-files #t])
              (maybe-compile-program x)))
         'mcw-c1)
       #t)

     (equal? (separate-eval '(load-program "testfile-mcw-c1.so"))
             "greetings from a and b [97] and c [113]\n")

     (begin
       (separate-compile
         '(lambda (x)
            (compile-whole-program (format "~a.wpo" x) (format "~a.so" x))
            #f)
         'mcw-c1)
       #t)

     (equal? (separate-eval '(load-program "testfile-mcw-c1.so"))
             "greetings from a and b [97] and c [113]\n")

     (begin
       (with-output-to-file "testfile-mcw-a1.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-mcw-a1)
                (export a)
                (import (chezscheme))
                (define a "salutations from a"))))
         'replace)
       (touch "testfile-mcw-a1.so" "testfile-mcw-a1.ss")
       (separate-compile
         '(lambda (x)
            (parameterize
              ([compile-imported-libraries #t] [generate-wpo-files #t])
              (parameterize
                ([compile-program-handler
                   (lambda (ifn ofn)
                     (compile-program ifn ofn)
                     (compile-whole-program
                       (format "~a.wpo" (path-root ofn))
                       ofn
                       #t))])
                (maybe-compile-program x))))
         'mcw-c1)
       #t)

     (equal? (separate-eval '(load-program "testfile-mcw-c1.so"))
             "salutations from a and b [97] and c [113]\n")

     (begin
       (with-output-to-file "testfile-mcw-a1.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-mcw-a1)
                (export a)
                (import (chezscheme))
                (define a "goodbye from a"))))
         'replace)
       (touch "testfile-mcw-a1.so" "testfile-mcw-a1.ss")
       (separate-compile
         '(lambda (x)
            (parameterize
              ([compile-imported-libraries #t] [generate-wpo-files #t])
              (parameterize
                ([compile-program-handler
                   (lambda (ifn ofn)
                     (compile-program ifn ofn)
                     (compile-whole-program
                       (format "~a.wpo" (path-root ofn))
                       ofn
                       #t))])
                (maybe-compile-program x))))
         'mcw-c1)
       #t)

     (equal? (separate-eval '(load-program "testfile-mcw-c1.so"))
             "goodbye from a and b [97] and c [113]\n")

     (begin
       (with-output-to-file "testfile-mcw-hb1.ss"
         (lambda ()
           (pretty-print '(define major-msg-number 773)))
         'replace)
       (touch "testfile-mcw-c1.so" "testfile-mcw-hb1.ss")
       (separate-compile
         '(lambda (x)
            (parameterize
              ([compile-imported-libraries #t] [generate-wpo-files #t])
              (parameterize
                ([compile-program-handler
                   (lambda (ifn ofn)
                     (compile-program ifn ofn)
                     (compile-whole-program
                       (format "~a.wpo" (path-root ofn))
                       ofn
                       #t))])
                (maybe-compile-program x))))
         'mcw-c1)
       #t)

     (equal? (separate-eval '(load-program "testfile-mcw-c1.so"))
             "goodbye from a and b [97] and c [773]\n")

     (begin
       (with-output-to-file "testfile-mcw-a1.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-mcw-a1)
                (export a)
                (import (chezscheme))
                (define a "hello again from a"))))
         'replace)
       (touch "testfile-mcw-a1.so" "testfile-mcw-a1.ss")
       (separate-compile
         '(lambda (x)
            (parameterize
              ([compile-imported-libraries #t] [generate-wpo-files #t])
              (parameterize
                ([compile-library-handler
                   (lambda (ifn ofn)
                     (compile-library ifn ofn)
                     (compile-whole-library
                       (format "~a.wpo" (path-root ofn))
                       ofn))])
                (maybe-compile-library x))))
         'mcw-b1)
       #t)

     (equal? (separate-eval
               '(let ()
                  (import (testfile-mcw-b1))
                  (printf "~a\n" (b))))
             "hello again from a and b [97]\n")

     (begin
       (with-output-to-file "testfile-mcw-ha1.ss"
         (lambda ()
           (pretty-print '(define minor-msg-number -53)))
         'replace)
       (touch "testfile-mcw-a1.so" "testfile-mcw-a1.ss")
       (separate-compile
         '(lambda (x)
            (parameterize
              ([compile-imported-libraries #t] [generate-wpo-files #t])
              (parameterize
                ([compile-library-handler
                   (lambda (ifn ofn)
                     (compile-library ifn ofn)
                     (compile-whole-library
                       (format "~a.wpo" (path-root ofn))
                       ofn))])
                (maybe-compile-library x))))
         'mcw-b1)
       #t)

     (equal? (separate-eval
               '(let ()
                  (import (testfile-mcw-b1))
                  (printf "~a\n" (b))))
             "hello again from a and b [-53]\n"))

(mat library-manager
     (begin
       (with-output-to-file "testfile-lm-a.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-lm-a)
                (export ct-a rt-a)
                (import (scheme))
                (meta define ct-a (begin (display "ct-a rhs\n") 123))
                (define rt-a
                  (begin (display "rt-a rhs\n") 456)))))
         'replace)
       (with-output-to-file "testfile-lm-b.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-lm-b)
                (export b)
                (import (scheme) (testfile-lm-a))
                (define-syntax (use-ct-val x)
                  (if (odd? ct-a) #'"odd" #'"even"))
                (define b use-ct-val))))
         'replace)
       (with-output-to-file "testfile-lm-c.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-lm-c)
                (export c)
                (import (scheme) (testfile-lm-a))
                (define use-rt-val rt-a)
                (define c use-rt-val))))
         'replace)
       (with-output-to-file "testfile-lm-combined.ss"
         (lambda ()
           (pretty-print
             '(begin
                (include "testfile-lm-a.ss")
                (include "testfile-lm-b.ss")
                (include "testfile-lm-c.ss"))))
         'replace)
       (with-output-to-file "testfile-lm-use-b.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-lm-use-b)
                (export x)
                (import (scheme) (testfile-lm-b))
                (meta define x b))))
         'replace)
       (with-output-to-file "testfile-lm-use-c.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-lm-use-c)
                (export x)
                (import (scheme) (testfile-lm-c))
                (define-syntax (x x) c))))
         'replace)
       #t)
     (equal? (separate-eval '(import-notify #t)
               '(compile-library "testfile-lm-a"))
             (string-append
               "compiling testfile-lm-a.ss with output to testfile-lm-a.so\n"
               "ct-a rhs\n"))
     (equal? (separate-eval '(import-notify #t)
               '(library-extensions '((".ss" . ".so")))
               '(compile-library "testfile-lm-b")
               '(printf "b = ~s\n" (let () (import (testfile-lm-b)) b)))
             (string-append
               "compiling testfile-lm-b.ss with output to testfile-lm-b.so\n"
               "import: found source file \"testfile-lm-a.ss\"\n"
               "import: found corresponding object file \"testfile-lm-a.so\"\n"
               "import: object file is not older\n"
               "import: loading object file \"testfile-lm-a.so\"\n"
               "ct-a rhs\n"
               "b = \"odd\"\n"))
     (equal? (separate-eval '(import-notify #t)
               '(library-extensions '((".ss" . ".so")))
               '(compile-library "testfile-lm-c")
               '(printf "c = ~s\n" (let () (import (testfile-lm-c)) c)))
             (string-append
               "compiling testfile-lm-c.ss with output to testfile-lm-c.so\n"
               "import: found source file \"testfile-lm-a.ss\"\n"
               "import: found corresponding object file \"testfile-lm-a.so\"\n"
               "import: object file is not older\n"
               "import: loading object file \"testfile-lm-a.so\"\n"
               "rt-a rhs\n"
               "c = 456\n"))
     (equal? ;; library manager revisits object file containing a single library
       ;; to resolve dependencies after earlier visit
       (separate-eval '(import-notify #t)
         '(library-extensions '((".ss" . ".so")))
         '(visit "testfile-lm-a.so")
         '(let () (import (testfile-lm-c)) c))
       (string-append
         "import: found source file \"testfile-lm-c.ss\"\n"
         "import: found corresponding object file \"testfile-lm-c.so\"\n"
         "import: object file is not older\n"
         "import: loading object file \"testfile-lm-c.so\"\n"
         "import: attempting to 'revisit' previously 'visited' \"testfile-lm-a.so\" for library (testfile-lm-a) run-time info\n"
         "rt-a rhs\n"
         "456\n"))
     (equal? ;; library manager visits object file containing a single library
       ;; to resolve dependencies after earlier revisit
       (separate-eval '(import-notify #t)
         '(library-extensions '((".ss" . ".so")))
         '(revisit "testfile-lm-a.so")
         '(let () (import (testfile-lm-b)) b))
       (string-append
         "import: found source file \"testfile-lm-b.ss\"\n"
         "import: found corresponding object file \"testfile-lm-b.so\"\n"
         "import: object file is not older\n"
         "import: loading object file \"testfile-lm-b.so\"\n"
         "import: attempting to 'visit' previously 'revisited' \"testfile-lm-a.so\" for library (testfile-lm-a) compile-time info\n"
         "\"odd\"\n"))
     (equal? (separate-eval '(import-notify #t)
               '(library-extensions '((".ss" . ".so")))
               '(compile-file "testfile-lm-combined"))
             (string-append
               "compiling testfile-lm-combined.ss with output to testfile-lm-combined.so\n"
               "ct-a rhs\n"))
     (equal? ;; library manager revisits object file containing related libraries
       ;; to resolve dependencies after earlier visit
       (separate-eval '(import-notify #t)
         '(visit "testfile-lm-combined.so")
         '(let ()
            (import (testfile-lm-a))
            (define-syntax (foo x) ct-a)
            (printf "foo = ~s\n" foo))
         '(let () (import (testfile-lm-c)) c))
       (string-append
         "ct-a rhs\n"
         "foo = 123\n"
         "import: attempting to 'revisit' previously 'visited' \"testfile-lm-combined.so\" for library (testfile-lm-c) run-time info\n"
         "rt-a rhs\n"
         "456\n"))
     (equal? ;; library manager visits object file containing related libraries
       ;; to resolve dependencies after earlier revisit
       (separate-eval '(import-notify #t)
         '(revisit "testfile-lm-combined.so")
         '(let ()
            (import (testfile-lm-a))
            (define foo rt-a)
            (printf "foo = ~s\n" foo))
         '(let () (import (testfile-lm-b)) b))
       (string-append
         "import: attempting to 'visit' previously 'revisited' \"testfile-lm-combined.so\" for library (testfile-lm-a) compile-time info\n"
         "rt-a rhs\n"
         "foo = 456\n"
         "\"odd\"\n"))
     (equal? ;; library manager does not revisit due to earlier load
       (separate-eval '(import-notify #t)
         '(load "testfile-lm-combined.so")
         '(let ()
            (import (testfile-lm-a))
            (define-syntax (foo x) ct-a)
            (printf "foo = ~s\n" foo))
         '(let () (import (testfile-lm-c)) c))
       (string-append "ct-a rhs\n" "foo = 123\n" "rt-a rhs\n" "456\n"))
     (equal? ;; library manager does not revisit due to earlier load
       (separate-eval '(import-notify #t)
         '(load "testfile-lm-combined.so")
         '(let ()
            (import (testfile-lm-a))
            (define foo rt-a)
            (printf "foo = ~s\n" foo))
         '(let () (import (testfile-lm-b)) b))
       (string-append "rt-a rhs\n" "foo = 456\n" "\"odd\"\n")))

;;; section 7.2:

(mat top-level-value-functions
     (error? (top-level-bound? "hello"))
     (error? (top-level-bound?))
     (error? (top-level-bound? 45 'hello))
     (error? (top-level-bound? 'hello 'hello))
     (error? (top-level-bound? (scheme-environment) (scheme-environment)))
     (error? (top-level-mutable? "hello"))
     (error? (top-level-mutable?))
     (error? (top-level-mutable? 45 'hello))
     (error? (top-level-mutable? 'hello 'hello))
     (error? (top-level-mutable? (scheme-environment) (scheme-environment)))
     (error? (top-level-value "hello"))
     (error? (top-level-value))
     (error? (top-level-value 'hello 'hello))
     (error? (top-level-value (scheme-environment) (scheme-environment)))
     (error? (set-top-level-value! "hello" "hello"))
     (error? (set-top-level-value!))
     (error? (set-top-level-value! 15))
     (error? (set-top-level-value! 'hello 'hello 'hello))
     (error? (set-top-level-value! (scheme-environment)
               (scheme-environment)
               (scheme-environment)))
     (error? (define-top-level-value "hello" "hello"))
     (error? (define-top-level-value))
     (error? (define-top-level-value 15))
     (error? (define-top-level-value 'hello 'hello 'hello))
     (error? (define-top-level-value (scheme-environment)
               (scheme-environment)
               (scheme-environment)))

     (top-level-bound? 'cons (scheme-environment))
     (not (top-level-mutable? 'cons (scheme-environment)))
     (eq? (top-level-bound? 'probably-not-bound (scheme-environment)) #f)
     (equal? (top-level-value 'top-level-value) top-level-value)
     (equal? (parameterize
               ([interaction-environment
                  (copy-environment (scheme-environment) #t)])
               (eval '(define cons *))
               (eval '(list (cons 3 4)
                            (fluid-let ([cons list])
                              (list (cons 1 2)
                                    ((top-level-value 'cons) 1 2)
                                    ((top-level-value 'cons (scheme-environment)) 1 2)
                                    (top-level-mutable? 'cons)
                                    (top-level-mutable? 'cons (scheme-environment))
                                    (top-level-mutable? 'car)
                                    (top-level-mutable? 'car (scheme-environment)))))))
             '(12 ((1 2) (1 2) (1 . 2) #t #f #f #f)))
     (let ([abcde 4])
       (and (not (top-level-bound? 'abcde))
            (begin
              (define-top-level-value 'abcde 3)
              (eqv? (top-level-value 'abcde) 3))
            (top-level-bound? 'abcde)
            (begin
              (set-top-level-value! 'abcde 9)
              (eqv? (top-level-value 'abcde) 9))
            (eqv? abcde 4)))
     (eqv? abcde 9)
     (let ([x (gensym)])
       (and (not (top-level-bound? x))
            (begin
              (define-top-level-value x 'hi)
              (eq? (top-level-value x) 'hi))
            (top-level-bound? x)
            (begin
              (set-top-level-value! x 'there)
              (eq? (top-level-value x) 'there))
            (eq? (eval x) 'there)))
     (error? (top-level-value 'i-am-not-bound-i-hope))
     (error? (top-level-value 'let))
     (equal? (parameterize
               ([interaction-environment
                  (copy-environment (scheme-environment) #t)])
               (eval '(define cons (let () (import scheme) cons)))
               (eval '(fluid-let ([cons 'notcons])
                        (list (top-level-value 'cons)
                              (parameterize ([optimize-level 0]) (eval 'cons))
                              (parameterize
                                ([interaction-environment (scheme-environment)])
                                ((top-level-value 'cons) 3 4))))))
             '(notcons notcons (3 . 4)))
     (error? (set-top-level-value! 'let 45))
     (error? (parameterize ([interaction-environment (scheme-environment)])
               (eval '(define let 45) (scheme-environment))))
     (error? (parameterize ([interaction-environment (scheme-environment)])
               (eval '(set! let 45) (scheme-environment))))
     (error? (parameterize ([interaction-environment (scheme-environment)])
               (define-top-level-value 'let 45)))
     (error? (parameterize ([interaction-environment (scheme-environment)])
               (set-top-level-value! 'let 45)))
     (error? (define-top-level-value 'let 45 (scheme-environment)))
     (error? (set-top-level-value! 'let 45 (scheme-environment)))
     (error? (parameterize ([interaction-environment (scheme-environment)])
               (eval '(define cons 45) (scheme-environment))))
     (error? (parameterize ([interaction-environment (scheme-environment)])
               (eval '(set! cons 45) (scheme-environment))))
     (error? (parameterize ([interaction-environment (scheme-environment)])
               (define-top-level-value 'cons 45)))
     (error? (parameterize ([interaction-environment (scheme-environment)])
               (set-top-level-value! 'cons 45)))
     (error? (define-top-level-value 'cons 45 (scheme-environment)))
     (error? (set-top-level-value! 'cons 45 (scheme-environment)))
     (error? (parameterize ([interaction-environment (scheme-environment)])
               (eval '(define foo 45) (scheme-environment))))
     (error? (parameterize ([interaction-environment (scheme-environment)])
               (eval '(set! foo 45) (scheme-environment))))
     (error? (parameterize ([interaction-environment (scheme-environment)])
               (define-top-level-value 'foo 45)))
     (error? (parameterize ([interaction-environment (scheme-environment)])
               (set-top-level-value! 'foo 45)))
     (error? (define-top-level-value 'foo 45 (scheme-environment)))
     (error? (set-top-level-value! 'foo 45 (scheme-environment)))
     (begin
       (define-syntax $let (identifier-syntax let))
       (equal? ($let ((x 3) (y 4)) (cons x y)) '(3 . 4)))
     (eqv? (define-top-level-value '$let 76) (void))
     (eqv? (top-level-value '$let) 76)
     (eqv? $let 76)

     ; make sure implicit treatment of top-level identifiers as variables
     ; works when assignment occurs in loaded object file
     (equal? (begin
               (with-output-to-file "testfile.ss"
                 (lambda ()
                   (pretty-print '(set! $fribblefratz 17)))
                 'replace)
               (compile-file "testfile")
               (load "testfile.so")
               (list (top-level-bound? '$fribblefratz)
                     (top-level-value '$fribblefratz)))
             '(#t 17))
     (eqv? $fribblefratz 17)
     (equal? (begin
               (with-output-to-file "testfile.ss"
                 (lambda ()
                   (pretty-print '(set! $notfribblefratz -17)))
                 'replace)
               ; compile in a separate Scheme process
               (if (windows?)
                   (system (format "echo (compile-file \"testfile\") | ~a"
                                   (patch-exec-path *scheme*)))
                   (system (format "echo '(compile-file \"testfile\")' | ~a"
                                   *scheme*)))
               (load "testfile.so")
               (list (top-level-bound? '$notfribblefratz)
                     (top-level-value '$notfribblefratz)))
             '(#t -17))
     (eqv? $notfribblefratz -17))

;;; section 7.3:

(mat new-cafe
     (procedure? new-cafe)
     (equal? (guard (c [else #f])
               (let ([ip (open-string-input-port "(+ 3 4)")])
                 (let-values ([(op get) (open-string-output-port)])
                   (parameterize
                     ([console-input-port ip]
                      [console-output-port op]
                      [console-error-port op]
                      [#%$cafe 0]
                      [waiter-prompt-string "Huh?"])
                     (new-cafe))
                   (get))))
             "Huh? 7\nHuh? \n")
     (equal? (guard (c [else #f])
               (let ([ip (open-string-input-port "(if)")])
                 (let-values ([(op get) (open-string-output-port)])
                   (parameterize
                     ([console-input-port ip]
                      [console-output-port op]
                      [console-error-port op]
                      [#%$cafe 0]
                      [waiter-prompt-string "Huh?"])
                     (new-cafe))
                   (get))))
             "Huh? \nException: invalid syntax (if)\nHuh? \n")
     (equal? (separate-eval
               `(let ([ip (open-string-input-port
                            "
                    (base-exception-handler
                      (lambda (c)
                        (fprintf (console-output-port) \"~%>>> \")
                        (display-condition c (console-output-port))
                        (fprintf (console-output-port) \" <<<~%\")
                        (reset)))
                    (if)")])
                  (let-values ([(op get) (open-string-output-port)])
                    (parameterize
                      ([console-input-port ip]
                       [console-output-port op]
                       [console-error-port op]
                       [#%$cafe 0]
                       [waiter-prompt-string "Huh?"])
                      (new-cafe))
                    (get))))
             "\"Huh? Huh? \\n>>> Exception: invalid syntax (if) <<<\\nHuh? \\n\"\n"))

(mat reset
     (procedure? (reset-handler))
     (eqv? (call/cc
             (lambda (k)
               (parameterize ([reset-handler (lambda () (k 17))]) (reset))))
           17)
     (error? ; unexpected return from handler
       (guard (c [else (raise-continuable c)])
              (parameterize ([reset-handler values]) (reset)))))

(mat exit
     (procedure? (exit-handler))
     (eqv? (call/cc
             (lambda (k)
               (parameterize ([exit-handler (lambda () (k 17))]) (exit))))
           17)
     (eqv? (call/cc
             (lambda (k)
               (parameterize ([exit-handler (lambda (q) (k 17))])
                 (exit -1))))
           17)
     (error? ; unexpected return from handler
             (parameterize ([exit-handler values]) (exit)))
     (error? ; unexpected return from handler
             (parameterize ([exit-handler values]) (exit 5)))
     (begin
       (define (exit-code expr)
         (if (windows?)
             (system (format "echo ~s | ~a -q" expr
                             (patch-exec-path *scheme*)))
             (system (format "echo '~s' | ~a -q" expr *scheme*))))
       #t)
     (eqv? (exit-code '(exit)) 0)
     (eqv? (exit-code '(exit 15)) 15)
     (eqv? (exit-code '(exit 0)) 0)
     (eqv? (exit-code '(exit 24 7)) 24)
     (eqv? (exit-code '(exit 0 1 2)) 0)
     (eqv? (exit-code '(exit 3.14)) 1)
     (eqv? (exit-code '(exit 9.8 3.14)) 1)
     (begin
       (with-output-to-file "testfile-exit.ss"
         (lambda ()
           (for-each
             pretty-print
             '((import (scheme))
               (apply exit (map string->number (command-line-arguments))))))
         'replace)
       #t)
     (eqv? (system (format "~a --script testfile-exit.ss"
                           (patch-exec-path *scheme*)))
           0)
     (eqv? (system (format "~a --script testfile-exit.ss 5"
                           (patch-exec-path *scheme*)))
           5)
     (eqv? (system (format "~a --script testfile-exit.ss 0 1 2"
                           (patch-exec-path *scheme*)))
           0)
     (eqv? (system (format "~a --script testfile-exit.ss 3 4 5"
                           (patch-exec-path *scheme*)))
           3)
     (eqv? (system (format "~a --program testfile-exit.ss"
                           (patch-exec-path *scheme*)))
           0)
     (eqv? (system (format "~a --program testfile-exit.ss 2"
                           (patch-exec-path *scheme*)))
           2)
     (eqv? (system (format "~a --program testfile-exit.ss 0 1 2"
                           (patch-exec-path *scheme*)))
           0)
     (eqv? (system (format "~a --program testfile-exit.ss 6 7 8"
                           (patch-exec-path *scheme*)))
           6))

(mat abort
     (procedure? (abort-handler))
     (eqv? (call/cc
             (lambda (k)
               (parameterize ([abort-handler (lambda () (k 17))]) (abort))))
           17)
     (error? ; unexpected return from handler
             (parameterize ([abort-handler values]) (abort))))

(mat command-line
     (equal? (command-line) '(""))
     (equal? (r6rs:command-line) (command-line))
     (parameterize ([command-line '("cp" "x" "y")])
       (and (equal? (command-line) '("cp" "x" "y"))
            (equal? (r6rs:command-line) '("cp" "x" "y")))))

(mat command-line-arguments
     (null? (command-line-arguments))
     (parameterize ([command-line-arguments '("x" "y")])
       (equal? (command-line-arguments) '("x" "y"))))

;;; section 7.4:

(mat transcript-on/transcript-off ; check output
     (begin
       (delete-file "testscript")
       (printf "***** expect transcript output:~%")
       (parameterize
         ([console-input-port (open-input-string "(transcript-off)\n")])
         (transcript-on "testscript")
         (let repl ()
           (display "OK, " (console-output-port))
           (let ([x (read (console-input-port))])
             (unless (eof-object? x)
                     (let ([x (eval x)])
                       (pretty-print x (console-output-port)))
                     (repl)))))
       (not (eof-object? (with-input-from-file "testscript" read-char)))))

;;; section 7.5:

(mat collect
     (error? ; invalid generation
             (collect-maximum-generation -1))
     (error? ; invalid generation
             (collect-maximum-generation 10000))
     (error? ; invalid generation
             (collect-maximum-generation 'static))
     (error? ; invalid generation
             (release-minimum-generation -1))
     (error? ; invalid generation
       (release-minimum-generation (+ (collect-maximum-generation) 1)))
     (error? ; invalid generation
             (release-minimum-generation 'static))
     (let ([g (+ (collect-maximum-generation) 1)])
       (guard (c [(and (message-condition? c)
                       (equal? (condition-message c)
                               "invalid generation ~s")
                       (irritants-condition? c)
                       (equal? (condition-irritants c) (list g)))])
              (collect g)
              #f))
     (let ([g (+ (collect-maximum-generation) 1)])
       (guard (c [(and (message-condition? c)
                       (equal? (condition-message c)
                               "invalid target generation ~s for generation ~s")
                       (irritants-condition? c)
                       (equal? (condition-irritants c) (list g 0)))])
              (collect 0 g)
              #f))
     (error? (collect 0 -1))
     (error? (collect -1 0))
     (error? (collect 1 0))
     (error? (collect 'static))
     (with-interrupts-disabled (collect (collect-maximum-generation))
       (let ([b1 (bytes-allocated)])
         (let loop ([n 1000] [x '()])
           (or (= n 0) (loop (- n 1) (cons x x))))
         (let ([b2 (bytes-allocated)])
           (collect (collect-maximum-generation))
           (let ([b3 (bytes-allocated)])
             (and (> b2 b1) (< b3 b2)))))))

(mat object-counts
     ; basic structural checks
     (let ([hc (object-counts)])
       (begin
         (assert (list? hc))
         (for-each (lambda (a) (assert (pair? a))) hc)
         (for-each
           (lambda (a)
             (assert (or (symbol? (car a))
                         (record-type-descriptor? (car a)))))
           hc)
         (for-each (lambda (a) (assert (list? (cdr a)))) hc)
         (for-each
           (lambda (a)
             (for-each
               (lambda (a)
                 (and (or (and (fixnum? (car a))
                               (<= 0 (car a) (collect-maximum-generation)))
                          (eq? (car a) 'static))
                      (and (fixnum? (cadr a))
                           (>= (cadr a) 0))
                      (and (fixnum? (cddr a))
                           (>= (cddr a) (cadr a)))))
               (cdr a)))
           hc)
         (assert (assq 'pair hc))
         (assert (assq 'procedure hc))
         (assert (assq 'symbol hc))
         (assert (assp record-type-descriptor? hc))
         #t))
     ; a few idiot checks including verification of proper behavior when changing collect-maximum-generation
     (parameterize ([enable-object-counts #t])
       (pair? (with-interrupts-disabled
                (let ([cmg (collect-maximum-generation)])
                  (collect-maximum-generation 4)
                  (collect 4 4)
                  (let ()
                    (define (locate type gen ls)
                      (cond
                        [(assq type ls)
                         =>
                         (lambda (a)
                           (cond
                             [(assv gen (cdr a)) => cadr]
                             [else #f]))]
                        [else #f]))
                    (define-record-type flub (fields x))
                    (define q0 (make-flub 0))
                    (define b0 (box 0))
                    (collect 0 0)
                    (let ([hc (object-counts)])
                      (assert (locate 'box 0 hc))
                      (assert (locate (record-type-descriptor flub) 0 hc))
                      (collect-maximum-generation 7)
                      (let ([hc (object-counts)])
                        (assert (locate 'box 0 hc))
                        (assert (locate (record-type-descriptor flub) 0 hc))
                        (collect 7 7)
                        (let ()
                          (define q1 (make-flub q0))
                          (define b1 (box b0))
                          (collect 6 6)
                          (let ()
                            (define q2 (make-flub q1))
                            (define b2 (box b1))
                            (collect 5 5)
                            (let ([hc (object-counts)])
                              (assert (locate 'box 5 hc))
                              (assert (locate 'box 6 hc))
                              (assert (locate 'box 7 hc))
                              (assert (locate (record-type-descriptor flub) 5 hc))
                              (assert (locate (record-type-descriptor flub) 6 hc))
                              (assert (locate (record-type-descriptor flub) 7 hc))
                              (collect-maximum-generation 5)
                              (let ([hc (object-counts)])
                                (assert (locate 'box 5 hc))
                                (assert (not (locate 'box 6 hc)))
                                (assert (not (locate 'box 7 hc)))
                                (assert (locate (record-type-descriptor flub) 5 hc))
                                (assert (not (locate (record-type-descriptor flub) 6 hc)))
                                (assert (not (locate (record-type-descriptor flub) 7 hc)))
                                (collect 5 5)
                                (let ([hc (object-counts)])
                                  (assert (locate 'box 5 hc))
                                  (assert (not (locate 'box 6 hc)))
                                  (assert (not (locate 'box 7 hc)))
                                  (assert (locate (record-type-descriptor flub) 5 hc))
                                  (assert (not (locate (record-type-descriptor flub) 6 hc)))
                                  (assert (not (locate (record-type-descriptor flub) 7 hc)))
                                  (collect-maximum-generation cmg)
                                  (collect cmg cmg)
                                  (cons q2 b2)))))))))))))
     ; make sure we can handle turning enable-object-counts on and off
     (equal? (parameterize ([collect-request-handler void])
               (define-record-type frob (fields x))
               (define x (list (make-frob 3)))
               (parameterize ([enable-object-counts #t]) (collect 0 0))
               (parameterize ([enable-object-counts #f]) (collect 0 1))
               (do ([n 100000 (fx- n 1)]) ((fx= n 0)) (set! x (cons n x)))
               (parameterize ([enable-object-counts #t]) (collect 1 1))
               (cons (length x)
                     (cadr (assq 1
                                 (cdr (assq (record-type-descriptor frob)
                                            (object-counts)))))))
             `(100001 . 1))
     (let ([a (assq 'reloc-table (object-counts))])
       (or (not a) (not (assq 'static (cdr a))))))

(mat collect-rendezvous
     (begin
       (define (check-working-gc collect)
         (with-interrupts-disabled
           (let ([p (weak-cons (gensym) #f)])
             (collect)
             (eq? (car p) #!bwp))))
       (and (check-working-gc collect)
            (check-working-gc collect-rendezvous)))
     (or (not (threaded?))
         (let ([m (make-mutex)] [c (make-condition)] [done? #f])
           (fork-thread
             (lambda ()
               (let loop ()
                 (mutex-acquire m)
                 (cond
                   [done? (condition-signal c) (mutex-release m)]
                   [else (mutex-release m) (loop)]))))
           (and (check-working-gc collect-rendezvous)
                ;; End thread:
                (begin
                  (mutex-acquire m)
                  (set! done? #t)
                  (condition-wait c m)
                  (mutex-release m)
                  ;; Make sure the thread is really done
                  (let loop ()
                    (unless (= 1 (#%$top-level-value '$active-threads))
                            (loop)))
                  ;; Plain `collect` should work again:
                  (check-working-gc collect))))))

;;; section 7.6:

(mat time
     (begin
       (printf "***** expect time output (nonzero allocation):~%")
       (time (let loop ([n 1000] [x '()])
               (or (= n 0) (loop (- n 1) (cons x x))))))
     (begin
       (printf "***** expect time output (nonzero cpu & real time):~%")
       (time (letrec ([tak (lambda (x y z)
                             (if (>= y x)
                                 z
                                 (tak (tak (1- x) y z)
                                      (tak (1- y) z x)
                                      (tak (1- z) x y))))])
               (tak 18 12 6)))
       #t)
     (begin
       (printf "***** expect time output (>= 2 collections):~%")
       (time (begin (collect) (collect)))
       #t))

(mat sstats
     (begin
       (define exact-integer?
         (lambda (x) (and (exact? x) (integer? x))))
       (define exact-nonnegative-integer?
         (lambda (x)
           (and (exact-integer? x) (nonnegative? x))))
       (define sstats-time?
         (lambda (t type)
           (and (time? t) (eq? (time-type t) type))))
       #t)
     (error? ; invalid cpu time
       (make-sstats 0
         (make-time 'time-monotonic 0 0)
         0
         0
         (make-time 'time-collector-cpu 0 0)
         (make-time 'time-collector-real 0 0)
         0))
     (error? ; invalid real time
       (make-sstats
         (make-time 'time-duration 0 0)
         0
         0
         0
         (make-time 'time-collector-cpu 0 0)
         (make-time 'time-collector-real 0 0)
         0))
     (error? ; invalid bytes
       (make-sstats (make-time 'time-duration 0 0)
         (make-time 'time-monotonic 0 0)
         0.0
         0
         (make-time 'time-collector-cpu 0 0)
         (make-time 'time-collector-real 0 0)
         0))
     (error? ; invalid gc-count
       (make-sstats (make-time 'time-duration 0 0)
         (make-time 'time-monotonic 0 0)
         0
         "oops"
         (make-time 'time-collector-cpu 0 0)
         (make-time 'time-collector-real 0 0)
         0))
     (error? ; invalid gc-cpu
       (make-sstats (make-time 'time-duration 0 0)
         (make-time 'time-monotonic 0 0)
         0
         0
         0
         (make-time 'time-collector-real 0 0)
         0))
     (error? ; invalid gc-real
       (make-sstats (make-time 'time-duration 0 0)
         (make-time 'time-monotonic 0 0)
         0
         0
         (make-time 'time-collector-cpu 0 0)
         0
         0))
     (error? ; invalid gc-bytes
       (make-sstats (make-time 'time-duration 0 0)
         (make-time 'time-monotonic 0 0)
         0
         0
         (make-time 'time-collector-cpu 0 0)
         (make-time 'time-collector-real 0 0)
         0.0))
     (begin
       (define sstats
         (make-sstats (make-time 'time-process 0 0)
           (make-time 'time-monotonic 0 0)
           0
           0
           (make-time 'time-collector-cpu 0 0)
           (make-time 'time-collector-real 0 0)
           0))
       #t)
     (sstats? sstats)
     (error? ; not an sstats record
             (sstats-cpu 'it))
     (error? ; not an sstats record
             (sstats-real 'is))
     (error? ; not an sstats record
             (sstats-bytes 'fun))
     (error? ; not an sstats record
             (sstats-gc-count 'to))
     (error? ; not an sstats record
             (sstats-gc-cpu 'write))
     (error? ; not an sstats record
             (sstats-gc-real 'mats))
     (error? ; not an sstats record
             (sstats-gc-bytes '(not really)))
     (sstats-time? (sstats-cpu sstats) 'time-process)
     (sstats-time? (sstats-real sstats) 'time-monotonic)
     (eqv? (sstats-bytes sstats) 0)
     (eqv? (sstats-gc-count sstats) 0)
     (sstats-time? (sstats-gc-cpu sstats) 'time-collector-cpu)
     (sstats-time? (sstats-gc-real sstats) 'time-collector-real)
     (eqv? (sstats-gc-bytes sstats) 0)

     (error? ; not an sstats record
             (set-sstats-cpu! 'it (make-time 'time-duration 1 0)))
     (error? ; not an sstats record
       (set-sstats-real! 'is (make-time 'time-duration 1 0)))
     (error? ; not an sstats record
             (set-sstats-bytes! 'fun 11))
     (error? ; not an sstats record
             (set-sstats-gc-count! 'to 13))
     (error? ; not an sstats record
       (set-sstats-gc-cpu! 'write (make-time 'time-duration 1 0)))
     (error? ; not an sstats record
       (set-sstats-gc-real! 'mats (make-time 'time-duration 1 0)))
     (error? ; not an sstats record
             (set-sstats-gc-bytes! '(not really) 17))
     (error? ; 12 is not a time
             (set-sstats-cpu! sstats 12))
     (error? ; 12 is not a time
             (set-sstats-real! sstats 12))
     (error? ; 12 is not a time
             (set-sstats-gc-cpu! sstats 12))
     (error? ; 12 is not a time
             (set-sstats-gc-real! sstats 12))
     (error? ; #[time whatsit] is not a time
             (set-sstats-gc-real! sstats (make-assertion-violation)))
     (begin
       (set-sstats-cpu! sstats (make-time 'time-utc 12 3))
       (set-sstats-cpu! sstats (make-time 'time-monotonic 12 3))
       (set-sstats-cpu! sstats (make-time 'time-duration 12 3))
       (set-sstats-cpu! sstats (make-time 'time-thread 12 3))
       (set-sstats-cpu! sstats (make-time 'time-collector-cpu 12 3))
       (set-sstats-cpu! sstats (make-time 'time-collector-real 12 3))
       (set-sstats-real! sstats (make-time 'time-utc 12 3))
       (set-sstats-real! sstats (make-time 'time-duration 12 3))
       (set-sstats-real! sstats (make-time 'time-process 12 3))
       (set-sstats-real! sstats (make-time 'time-thread 12 3))
       (set-sstats-real! sstats (make-time 'time-collector-cpu 12 3))
       (set-sstats-real! sstats (make-time 'time-collector-real 12 3))
       (set-sstats-gc-cpu! sstats (make-time 'time-utc 12 3))
       (set-sstats-gc-cpu! sstats (make-time 'time-monotonic 12 3))
       (set-sstats-gc-cpu! sstats (make-time 'time-duration 12 3))
       (set-sstats-gc-cpu! sstats (make-time 'time-process 12 3))
       (set-sstats-gc-cpu! sstats (make-time 'time-thread 12 3))
       (set-sstats-gc-cpu! sstats (make-time 'time-collector-real 12 3))
       (set-sstats-gc-real! sstats (make-time 'time-utc 12 3))
       (set-sstats-gc-real! sstats (make-time 'time-monotonic 12 3))
       (set-sstats-gc-real! sstats (make-time 'time-duration 12 3))
       (set-sstats-gc-real! sstats (make-time 'time-process 12 3))
       (set-sstats-gc-real! sstats (make-time 'time-thread 12 3))
       (set-sstats-gc-real! sstats (make-time 'time-collector-cpu 12 3))
       #t)
     (eq? (set-sstats-cpu! sstats (make-time 'time-process 12 3)) (void))
     (eq? (set-sstats-real! sstats (make-time 'time-monotonic 12 3))
          (void))
     (eq? (set-sstats-gc-cpu! sstats (make-time 'time-collector-cpu 12 3))
          (void))
     (eq? (set-sstats-gc-real! sstats
            (make-time 'time-collector-real 12 3))
          (void))

     (error? (set-sstats-bytes! sstats 12.3))
     (error? (set-sstats-bytes! sstats 12.0))
     (error? (set-sstats-gc-count! sstats 3+4i))
     (error? (set-sstats-gc-count! sstats #f))
     (error? (set-sstats-gc-bytes! sstats 8/3))
     (error? (set-sstats-gc-bytes! sstats 'twelve))
     (eq? (set-sstats-bytes! sstats 12) (void))
     (eq? (set-sstats-gc-count! sstats 3) (void))
     (eq? (set-sstats-gc-bytes! sstats 8) (void))

     (begin
       (define sstats-diff
         (sstats-difference
           (make-sstats (make-time 'time-process 83 5)
             (make-time 'time-monotonic 12 1)
             5
             23
             (make-time 'time-collector-cpu (expt 2 8) 0)
             (make-time 'time-collector-real 735 1000007)
             29)
           (make-sstats (make-time 'time-process 3 0)
             (make-time 'time-monotonic 10333221 2)
             20
             3
             (make-time 'time-collector-cpu 0 0)
             (make-time 'time-collector-real 0 0)
             4)))
       #t)
     (sstats? sstats-diff)
     (sstats-time? (sstats-cpu sstats-diff) 'time-duration)
     (time=? (sstats-cpu sstats-diff) (make-time 'time-duration 80 5))
     (sstats-time? (sstats-real sstats-diff) 'time-duration)
     (time=? (sstats-real sstats-diff)
             (make-time 'time-duration 989666791 -2))
     (eqv? (sstats-bytes sstats-diff) -15)
     (eqv? (sstats-gc-count sstats-diff) 20)
     (sstats-time? (sstats-gc-cpu sstats-diff) 'time-duration)
     (time=? (sstats-gc-cpu sstats-diff)
             (make-time 'time-duration (expt 2 8) 0))
     (sstats-time? (sstats-gc-real sstats-diff) 'time-duration)
     (time=? (sstats-gc-real sstats-diff)
             (make-time 'time-duration 735 1000007))
     (eqv? (sstats-gc-bytes sstats-diff) 25)

     (let ([sstats (statistics)])
       (and (sstats? sstats)
            (sstats-time? (sstats-cpu sstats) 'time-thread)
            (sstats-time? (sstats-real sstats) 'time-monotonic)
            (exact-nonnegative-integer? (sstats-bytes sstats))
            (exact-nonnegative-integer? (sstats-gc-count sstats))
            (sstats-time? (sstats-gc-cpu sstats) 'time-collector-cpu)
            (sstats-time? (sstats-gc-real sstats) 'time-collector-real)
            (exact-nonnegative-integer? (sstats-gc-bytes sstats))))

     (let ([sstats (sstats-difference (statistics) (statistics))])
       (and (sstats? sstats)
            (sstats-time? (sstats-cpu sstats) 'time-duration)
            (sstats-time? (sstats-real sstats) 'time-duration)
            (exact-integer? (sstats-bytes sstats))
            (exact-integer? (sstats-gc-count sstats))
            (sstats-time? (sstats-gc-cpu sstats) 'time-duration)
            (sstats-time? (sstats-gc-real sstats) 'time-duration)
            (exact-integer? (sstats-gc-bytes sstats)))))

(mat display-statistics ; check output
     (let ([s (with-output-to-string display-statistics)])
       (and (string? s) (> (string-length s) 50))))

(mat cpu-time (> (cpu-time) 0) (let ([x (cpu-time)]) (<= x (cpu-time))))

(mat real-time
     (> (real-time) 0)
     (let ([x (real-time)]) (<= x (real-time))))

(mat bytes-allocated
     (error? (bytes-allocated 'yuk))
     (error? (bytes-allocated -1))
     (error? (bytes-allocated (+ (collect-maximum-generation) 1)))
     (error? (bytes-allocated (+ (most-positive-fixnum) 1)))
     (error? (bytes-allocated #f))
     (error? (bytes-allocated (+ (collect-maximum-generation) 1) 'new))
     (error? (bytes-allocated (+ (collect-maximum-generation) 1) #f))
     (error? (bytes-allocated 0 'gnu))
     (error? (bytes-allocated #f 'gnu))
     (error? (bytes-allocated 'static 'gnu))
     (> (bytes-allocated) 0)
     (andmap (lambda (g) (>= (bytes-allocated g) 0))
             (iota (+ (collect-maximum-generation) 1)))
     (>= (bytes-allocated 'static) 0)
     (let ([x (bytes-allocated)]) (<= x (bytes-allocated)))
     (>= (initial-bytes-allocated) 0)
     (>= (collections) 0)
     (>= (bytes-deallocated) 0)
     (let ([b (bytes-deallocated)] [c (collections)])
       (let ([x (make-list 10 'a)])
         (pretty-print x)
         (collect)
         (and (> (collections) c) (> (bytes-deallocated) b))))
     (>= (bytes-allocated #f #f) 0)
     (andmap (lambda (space) (>= (bytes-allocated #f space) 0))
             (#%$spaces))
     (let ()
       (define fudge 2000)
       (define ~= (lambda (x y) (<= (abs (- x y)) fudge)))
       (define all-gen
         (append (iota (+ (collect-maximum-generation) 1)) '(static)))
       (for-each
         (lambda (space)
           (critical-section
             (let ([n1 (bytes-allocated #f space)]
                   [n2 (fold-left
                         (lambda (bytes gen)
                           (+ bytes (bytes-allocated gen space)))
                         0
                         all-gen)])
               (unless (~= n1 n2)
                       (errorf #f
                               "discrepancy for space ~s: ~d vs ~d"
                               space
                               n1
                               n2)))))
         (#%$spaces))
       (for-each
         (lambda (gen)
           (critical-section
             (let ([n1 (bytes-allocated gen #f)]
                   [n2 (fold-left
                         (lambda (bytes space)
                           (+ bytes (bytes-allocated gen space)))
                         0
                         (#%$spaces))])
               (unless (~= n1 n2)
                       (errorf #f
                               "discrepancy for generation ~s: ~d vs ~d"
                               gen
                               n1
                               n2)))))
         all-gen)
       (critical-section
         (let ([n1 (bytes-allocated #f #f)]
               [n2 (fold-left
                     (lambda (bytes gen)
                       (fold-left
                         (lambda (bytes space)
                           (+ bytes (bytes-allocated gen space)))
                         bytes
                         (#%$spaces)))
                     0
                     all-gen)])
           (unless (~= n1 n2)
                   (errorf #f
                           "discrepancy in bytes-allocated: ~d vs ~d"
                           n1
                           n2))))
       #t))

(mat memory-bytes
     (critical-section
       (let ([x (maximum-memory-bytes)])
         (<= (current-memory-bytes) x)))
     (critical-section
       (let ([x (maximum-memory-bytes)])
         (reset-maximum-memory-bytes!)
         (let ([y (maximum-memory-bytes)]) (<= y x)))))

(mat date-and-time
     (let ([s (date-and-time)])
       (printf "***** check date-and-time: ~s~%" s)
       (string? s)))

;;; section 7-7:

(mat trace-lambda ; check output
     (letrec ([fact (trace-lambda fact
                      (x)
                      (if (= x 0) 1 (* x (fact (- x 1)))))])
       (printf "***** expect trace of (fact 3):~%")
       (eqv? (fact 3) 6)))

(mat trace-let ; check output
     (begin
       (printf "***** expect trace of (fib 3):~%")
       (eqv? (trace-let fib
               ([x 3])
               (if (< x 2)
                   1
                   (+ (fib (- x 1)) (fib (- x 2)))))
             3)))

(mat trace/untrace
     (begin
       (set! lslen
         (lambda (ls)
           (if (null? ls) 0 (+ (lslen (cdr ls)) 1))))
       (and (equal? (trace lslen) '(lslen))
            (equal? (trace) '(lslen))
            (begin
              (printf "***** expect trace of (lslen '(a b c)):~%")
              (eqv? (lslen '(a b c)) 3))
            (equal? (untrace lslen) '(lslen))
            (equal? (trace) '())
            (equal? (trace lslen) '(lslen))
            (equal? (trace lslen) '(lslen))
            (begin
              (set! lslen (lambda (x) x))
              (printf "***** do *not* expect output:~%")
              (eqv? (lslen 'a) 'a))
            (equal? (trace lslen) '(lslen))
            (begin
              (printf "***** expect trace of (lslen 'a):~%")
              (eqv? (lslen 'a) 'a))
            (equal? (untrace) '(lslen))
            (equal? (trace) '())
            (begin
              (printf "***** do *not* expect output:~%")
              (eqv? (lslen 'a) 'a)))))

;;; section 7-8:

(mat error
     (error? (errorf 'a "hit me!"))
     (error? (let f ([n 10])
               (if (= n 0)
                   (errorf 'f "n is ~s" n)
                   (f (- n 1))))))

(mat keyboard-interrupt-handler ; must be tested by hand
     (procedure? (keyboard-interrupt-handler)))

(mat collect-request-handler
     (procedure? (collect-request-handler))
     (call/cc
       (lambda (k)
         (parameterize
           ([collect-request-handler (lambda () (collect) (k #t))])
           (let f ([x '()]) (f (list-copy (cons 'a x))))))))

(mat timer-interrupt-handler ; tested in mat set-timer below
     (procedure? (timer-interrupt-handler)))


;;; section 7-9:

(mat set-timer
     (let ([count1 0])
       (timer-interrupt-handler (lambda () (set! count1 (+ count1 1))))
       (set-timer (+ 10 (random 10)))
       (let loop2 ([count2 1])
         (cond
           [(= count2 100)]
           [(= count1 count2)
            (set-timer (+ 10 (random 10)))
            (loop2 (+ count2 1))]
           [else (loop2 count2)]))))

(mat disable-interrupts-enable-interrupts
     (and (= (disable-interrupts) 1)
          (= (disable-interrupts) 2)
          (= (enable-interrupts) 1)
          (= (enable-interrupts) 0))
     (call/cc
       (lambda (k)
         (timer-interrupt-handler (lambda () (k #t)))
         (disable-interrupts)
         (parameterize ([timer-interrupt-handler (lambda () (k #f))])
           (set-timer 1)
           (let loop ([n 1000]) (or (= n 0) (loop (- n 1)))))
         (enable-interrupts)
         (let loop ([n 1000]) (or (= n 0) (loop (- n 1))))
         #f)))

(mat with-interrupts-disabled
     (call/cc
       (lambda (k)
         (timer-interrupt-handler (lambda () (k #t)))
         (with-interrupts-disabled
           (parameterize ([timer-interrupt-handler (lambda () (k #f))])
             (set-timer 1)
             (let loop ([n 1000])
               (or (= n 0) (loop (- n 1))))))
         (let loop ([n 1000]) (or (= n 0) (loop (- n 1))))
         #f))
     ; test old name
     (call/cc
       (lambda (k)
         (timer-interrupt-handler (lambda () (k #t)))
         (critical-section
           (parameterize ([timer-interrupt-handler (lambda () (k #f))])
             (set-timer 1)
             (let loop ([n 1000])
               (or (= n 0) (loop (- n 1))))))
         (let loop ([n 1000]) (or (= n 0) (loop (- n 1))))
         #f)))
;;; record.ms
;;; Copyright 1984-2017 Cisco Systems, Inc.
;;; 
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;; 
;;; http://www.apache.org/licenses/LICENSE-2.0
;;; 
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

(define $mpf32
  (min (most-positive-fixnum) (- (ash 1 29) 1)))
(define $mnf32 (max (most-negative-fixnum) (- (ash 1 29))))

(define $mpf64
  (min (most-positive-fixnum) (- (ash 1 60) 1)))
(define $mnf64 (max (most-negative-fixnum) (- (ash 1 60))))

(mat record1
     (begin
       (define-record fudge ((immutable double-float a)))
       (andmap procedure? (list make-fudge fudge? fudge-a)))
     (error? (make-fudge 3))
     (error? (fudge-a 3)))

(mat record2
     (begin
       (define fudge
         (make-record-type "fudge" '((immutable double-float a))))
       (record-type-descriptor? fudge))
     (begin
       (define make-fudge (record-constructor fudge))
       (procedure? make-fudge))
     (error? (make-fudge 3))
     (error? ((csv7:record-field-accessor fudge 'a) 3))
     (error? (make-record-type "fudge" '((immutable double-float a) . b)))
     (error? (make-record-type "fudge"
               (let ([x (list '(immutable a) '(immutable b) '(immutable c))])
                 (set-cdr! (cddr x) (cdr x))
                 x))))

(mat type-descriptor
     (let ()
       (define-record foo ())
       (record-type-descriptor? (type-descriptor foo)))
     (error? (type-descriptor 3))
     (error? (type-descriptor car)))

(mat record3
     (begin
       (define-record fudge ((immutable a)))
       (andmap procedure? (list make-fudge fudge? fudge-a)))
     (begin (define x (make-fudge 3)) (fudge? x))
     (eqv? (fudge-a x) 3)
     (error? (set-fudge-a! x x))
     (eqv? (fudge-a x) 3)
     (let ()
       (define-record fudge ((immutable a)))
       (and (andmap procedure? (list make-fudge fudge? fudge-a))
            (let ((x (make-fudge 3)))
              (and (fudge? x)
                   (eqv? (fudge-a x) 3)
                   (eqv? (fudge-a x) 3))))))

(mat record4
     (begin
       (define-record fudge ((a)))
       (andmap procedure? (list make-fudge fudge? fudge-a set-fudge-a!)))
     (begin (define x (make-fudge 3)) (fudge? x))
     (eqv? (fudge-a x) 3)
     (error? (set-fudge-a! 3 x))
     (begin (set-fudge-a! x x) (eqv? (fudge-a x) x))
     #;
     (equal? (format "~s" x) "#0=#[fudge #0#]")
     (begin
       (define-record fudge ((mutable a)))
       (andmap procedure? (list make-fudge fudge? fudge-a set-fudge-a!)))
     (begin (define x (make-fudge 3)) (fudge? x))
     (eqv? (fudge-a x) 3)
     (begin (set-fudge-a! x x) (eqv? (fudge-a x) x))
     #;
     (equal? (format "~s" x) "#0=#[fudge #0#]"))

(mat record5
     (begin
       (define-record fudge ((mutable a) (mutable double-float b)))
       (andmap procedure?
         (list make-fudge fudge? fudge-a set-fudge-a! fudge-b set-fudge-b!)))
     (begin (define x (make-fudge 'a 3.4)) (fudge? x))
     (eqv? (begin (set-fudge-b! x 4.4) (fudge-b x)) 4.4)
     #;
     (equal? (format "~s" x) "#[fudge a 4.4]")
     (begin
       (collect (collect-maximum-generation))
       (set-fudge-a! x (cons 3 4))
       (let ((p (weak-cons (fudge-a x) #f)))
         (collect)
         (and (eq? (car p) (fudge-a x))
              (begin
                (collect)
                (eq? (car p) (fudge-a x))
                (equal? (car p) '(3 . 4))))))
     (error? (set-fudge-b! x 4))
     (begin
       (define-record fudge ((a) (double-float b)))
       (andmap procedure?
         (list make-fudge fudge? fudge-a set-fudge-a! fudge-b set-fudge-b!)))
     (begin (define x (make-fudge 'a 3.4)) (fudge? x))
     (eqv? (begin (set-fudge-b! x 4.4) (fudge-b x)) 4.4)
     #;
     (equal? (format "~s" x) "#[fudge a 4.4]")
     (begin
       (collect (collect-maximum-generation))
       (set-fudge-a! x (cons 3 4))
       (let ((p (weak-cons (fudge-a x) #f)))
         (collect)
         (and (eq? (car p) (fudge-a x))
              (begin
                (collect)
                (eq? (car p) (fudge-a x))
                (equal? (car p) '(3 . 4))))))
     (error? (set-fudge-b! x 4)))

(mat record6
     (begin
       (define-record bar
         ((immutable a) (immutable integer-32 b))
         (((immutable c) (+ a b)) ((immutable double-float d) (+ a b c))))
       (andmap procedure? (list make-bar bar? bar-a bar-b bar-c bar-d)))
     (begin
       (define x (make-bar 9.0 23))
       (and (bar? x)
            #;
            (equal? (format "~s" x) "#[bar 9.0 23 32.0 64.0]")))
     (eqv? (bar-d x) 64.0)
     (eqv? (bar-b x) 23)
     (let ((y (make-bar 9.0 $mpf32)))
       (eqv? (bar-b y) $mpf32))
     (let ((y (make-bar 9.0 (+ $mpf32 1))))
       (eqv? (bar-b y) (+ $mpf32 1)))
     (let ((y (make-bar 9.0 $mnf32)))
       (eqv? (bar-b y) $mnf32))
     (let ((y (make-bar 9.0 (- $mnf32 1))))
       (eqv? (bar-b y) (- $mnf32 1)))
     (let ((y (make-bar 9.0 #x7fffffff)))
       (eqv? (bar-b y) #x7fffffff))
     (let ((y (make-bar 9.0 #x-80000000)))
       (eqv? (bar-b y) #x-80000000))
     (error? (make-bar 9.0 #x100000000))
     (error? (make-bar 9.0 #x-80000001))
     (error? (make-bar 9.0 23.0))
     ; now that we allow 2^(b-1)..2^b-1
     (let ((y (make-bar 9.0 #x80000000)))
       (eqv? (bar-b y) #x-80000000))
     (let ((y (make-bar 9.0 #xffffffff)))
       (eqv? (bar-b y) #x-1))

     ; make sure we can use modifiers and types as field names
     (equal? (let ()
               (define-record foo
                 ((mutable mutable)
                  (immutable int)
                  (immutable integer-32)
                  integer-8))
               (let ([x (make-foo 3 4 5 6)])
                 (set-foo-mutable! x 75)
                 (list ($record->vector x)
                       (foo-mutable x)
                       (foo-int x)
                       (foo-integer-32 x)
                       (foo-integer-8 x))))
             '(#(foo 75 4 5 6) 75 4 5 6))
     (equal? (let ()
               (define foo
                 (make-record-type "hello"
                   '((mutable mutable)
                     (immutable int)
                     (immutable integer-32)
                     integer-8)))
               (let ([x ((record-constructor foo) 3 4 5 6)])
                 ((csv7:record-field-mutator foo 'mutable) x 75)
                 (list ($record->vector x)
                       ((csv7:record-field-accessor foo 'mutable) x)
                       ((csv7:record-field-accessor foo 'int) x)
                       ((csv7:record-field-accessor foo 'integer-32) x)
                       ((csv7:record-field-accessor foo 'integer-8) x))))
             '(#(hello 75 4 5 6) 75 4 5 6)))

(mat record7
     (begin
       (define-record bar
         ((immutable a) (immutable unsigned-32 b))
         ((c (+ a b)) ((double-float d) (+ a b c))))
       (andmap procedure? (list make-bar bar? bar-a bar-b bar-c bar-d)))
     (begin
       (define x (make-bar 9.0 23))
       (and (bar? x)
            #;
            (equal? (format "~s" x) "#[bar 9.0 23 32.0 64.0]")))
     (eqv? (bar-d x) 64.0)
     (eqv? (bar-b x) 23)
     (let ((y (make-bar 9.0 $mpf32)))
       (eqv? (bar-b y) $mpf32))
     (let ((y (make-bar 9.0 (+ $mpf32 1))))
       (eqv? (bar-b y) (+ $mpf32 1)))
     (let ((y (make-bar 9.0 #x7fffffff)))
       (eqv? (bar-b y) #x7fffffff))
     (let ((y (make-bar 9.0 #x80000000)))
       (eqv? (bar-b y) #x80000000))
     (let ((y (make-bar 9.0 #xffffffff)))
       (eqv? (bar-b y) #xffffffff))
     (error? (make-bar 9.0 #x100000000))
     (error? (make-bar 9.0 #x-ffffffff))
     (error? (make-bar 9.0 23.0))
     ; now that we allow 2^(b-1)..2^b-1
     (let ([y (make-bar 9.0 $mnf32)])
       (eqv? (bar-b y) (+ #x100000000 $mnf32)))
     (let ([y (make-bar 9.0 (- $mnf32 1))])
       (eqv? (bar-b y) (+ #x100000000 (- $mnf32 1))))
     (let ([y (make-bar 9.0 -1)])
       (eqv? (bar-b y) #xffffffff))
     (let ([y (make-bar 9.0 #x-80000000)])
       (eqv? (bar-b y) #x80000000)))

(mat record8
     (let ()
       (define small
         (make-record-type "small"
           (append '((immutable double-float x))
                   (map (lambda (x) (gensym)) (make-list 3))
                   '((mutable y)))))
       (let ()
         (define make-small (record-constructor small))
         (define small-x
           (csv7:record-field-accessor small 'x))
         (define small-y
           (csv7:record-field-accessor small 'y))
         (define set-small-y!
           (csv7:record-field-mutator small 'y))
         (record-reader 'small small)
         (let ((x (apply make-small (cons 3.4 (make-list 4 'odyssey)))))
           (and (eqv? (string-length (format "~s" x)) 44)
                (begin
                  (collect (collect-maximum-generation))
                  (set-small-y! x (cons 3 4))
                  (let ((p (weak-cons (small-y x) #f)))
                    (collect)
                    (and (eq? (car p) (small-y x))
                         (begin
                           (collect)
                           (eq? (car p) (small-y x))))))))))
     (let ()
       (define huge
         (make-record-type "huge"
           (append '((immutable double-float x))
                   (map (lambda (x) (gensym))
                        (make-list 2000))
                   '(y))))
       (let ()
         (define make-huge (record-constructor huge))
         (define huge-x
           (csv7:record-field-accessor huge 'x))
         (define huge-y
           (csv7:record-field-accessor huge 'y))
         (define set-huge-y!
           (csv7:record-field-mutator huge 'y))
         (record-reader 'huge huge)
         (let ((x (apply make-huge (cons 3.4 (make-list 2001 'odyssey)))))
           (and (eqv? (string-length (format "~s" x)) 16019)
                (begin
                  (collect (collect-maximum-generation))
                  (set-huge-y! x (cons 3 4))
                  (let ((p (weak-cons (huge-y x) #f)))
                    (collect)
                    (and (eq? (car p) (huge-y x))
                         (begin
                           (collect)
                           (eq? (car p) (huge-y x)))))))))))

(mat record9
     (record-type-descriptor? (make-record-type "fudge" '()))
     (begin
       (define fudge
         (make-record-type "fudge" '((mutable a))))
       (define make-fudge (record-constructor fudge))
       (define fudge? (record-predicate fudge))
       (define fudge.a
         (csv7:record-field-accessor fudge 'a))
       (define x (make-fudge 3))
       (and (record-type-descriptor? fudge) (fudge? x)))
     (eqv? (fudge.a x) 3)
     (begin
       (define set-fudge.a!
         (csv7:record-field-mutator fudge 'a))
       (set-fudge.a! x x)
       (eqv? (fudge.a x) x))
     (begin (record-reader 'fudge fudge) #t)
     (begin
       (define y (read (open-input-string "#[fudge 77]")))
       (and (fudge? y) (eqv? (fudge.a y) 77)))
     (eq? (record-reader 'fudge) fudge)
     (eq? (record-reader fudge) 'fudge)
     (begin (record-reader 'fudge #f) #t)
     ; pass name
     (not (record-reader fudge))
     (not (record-reader 'fudge))
     (begin (record-reader 'fudge fudge) #t)
     (eq? (record-reader 'fudge) fudge)
     (eq? (record-reader fudge) 'fudge)
     (error? (record-reader #f))
     (error? (record-reader #f 'fudge))
     (error? (record-reader fudge 'fudge))
     (error? (record-reader #f #f))
     (error? (record-reader 'fudge 'candy))
     (error? (record-reader fudge fudge))
     (begin (record-reader fudge #f) #t)
     ; pass rtd
     (not (record-reader fudge))
     (not (record-reader 'fudge))
     (begin
       (define fudge (make-record-type "fudge" '((a))))
       (define make-fudge (record-constructor fudge))
       (define fudge? (record-predicate fudge))
       (define fudge.a
         (csv7:record-field-accessor fudge 'a))
       (define x (make-fudge 3))
       (and (record-type-descriptor? fudge) (fudge? x)))
     (eqv? (fudge.a x) 3)
     (begin
       (define set-fudge.a!
         (csv7:record-field-mutator fudge 'a))
       (set-fudge.a! x x)
       (eqv? (fudge.a x) x))
     (begin (record-reader 'fudge fudge) #t)
     (begin
       (define y (read (open-input-string "#[fudge 77]")))
       (and (fudge? y) (eqv? (fudge.a y) 77))))

(mat record10
     (begin
       (define bar
         (make-record-type "bar"
           '((immutable a) (mutable b) (immutable c))))
       (define make-bar (record-constructor bar))
       (define bar? (record-predicate bar))
       (define bar.a (csv7:record-field-accessor bar 'a))
       (define bar.b (csv7:record-field-accessor bar 'b))
       (define bar.c (csv7:record-field-accessor bar 'c))
       (define x (make-bar 3 4 5))
       (bar? x))
     (eqv? (bar.b x) 4)
     (begin
       (define set-bar.b!
         (csv7:record-field-mutator bar 'b))
       (procedure? set-bar.b!))
     (error? (define set-bar.a! (csv7:record-field-mutator bar 'a)))
     (error? (define set-bar.c! (csv7:record-field-mutator bar 'c)))
     (begin (record-reader 'bar bar) #t)
     (let ((x (read (open-input-string "#1=#[bar a #1# c]"))))
       (and (bar? x) (eq? (bar.b x) x)))
     (let ((x (read (open-input-string "#[bar #1=a b #1#]"))))
       (and (bar? x)
            (eq? (bar.a x) 'a)
            (eq? (bar.a x) (bar.c x))
            (eq? (bar.b x) 'b)))
     (error? (read (open-input-string "#1=#[bar a b #1#]")))
     (error? (read (open-input-string "#1=#[bar #1# b c]")))
     (bar? (read (open-input-string "#[bar #1# b #1=a]")))
     (equal? (with-output-to-string
               (lambda ()
                 (let ([pred (begin
                               (display "one\n")
                               (record-predicate
                                 (begin
                                   (display "two\n")
                                   (make-record-type '#{foo bje68fdhbe06wod3-a} '(x)))))])
                   (printf "~s\n" (pred 17))
                   (printf "~s\n"
                     (pred ((record-constructor
                              (make-record-type '#{foo bje68fdhbe06wod3-a} '(x))) 55))))))
             "one\ntwo\n#f\n#t\n"))

#;
(mat record11
     (let ()
       (define froz
         (rec froz
              (make-record-type "froz"
                '((immutable a) (immutable b))
                (lambda (x p wr)
                  (define froz.a
                    (csv7:record-field-accessor froz 'a))
                  (wr `(* hi john ,(froz.a x) *) p)))))
       (equal? (format "~s" ((record-constructor froz) 1 2))
               "(* hi john 1 *)")))

(mat record12
     (begin
       (define-record $tree
         ((immutable left) (immutable node) (immutable right)))
       (record-type-descriptor? (type-descriptor $tree)))
     ($tree? (make-$tree 3 4 5))
     (let ((tr (make-$tree 'a 'b 'c)))
       (and (eq? ($tree-left tr) 'a)
            (eq? ($tree-node tr) 'b)
            (eq? ($tree-right tr) 'c)))
     (begin
       (define-record $tree ((left) (node) (right)))
       (record-type-descriptor? (type-descriptor $tree)))
     ($tree? (make-$tree 3 4 5))
     (let ((tr (make-$tree 'a 'b 'c)))
       (and (eq? ($tree-left tr) 'a)
            (eq? ($tree-node tr) 'b)
            (eq? ($tree-right tr) 'c)))
     (begin
       (define-record $tree (left node right))
       (record-type-descriptor? (type-descriptor $tree)))
     ($tree? (make-$tree 3 4 5))
     (let ((tr (make-$tree 'a 'b 'c)))
       (and (eq? ($tree-left tr) 'a)
            (eq? ($tree-node tr) 'b)
            (eq? ($tree-right tr) 'c)))
     (begin
       (define-record $tree ((left) (immutable node) (right)))
       (record-type-descriptor? (type-descriptor $tree)))
     ($tree? (make-$tree 3 4 5))
     (let ((tr (make-$tree 'a 'b 'c)))
       (and (eq? ($tree-left tr) 'a)
            (eq? ($tree-node tr) 'b)
            (eq? ($tree-right tr) 'c)))
     (begin
       (define-record pare
         ((mutable kar) kdr)
         (((scheme-object original-kar) kar) ((mutable original-kdr) kdr)))
       (record-type-descriptor? (type-descriptor pare)))
     (andmap procedure?
       (list make-pare
             pare?
             pare-kar
             pare-kdr
             pare-original-kar
             pare-original-kdr
             set-pare-kar!
             set-pare-kdr!
             set-pare-original-kar!
             set-pare-original-kdr!))
     (pare? (make-pare 3 4))
     (eq? (pare-kar (make-pare 'a 'b)) 'a)
     (eq? (pare-kdr (make-pare 'a 'b)) 'b)
     (eq? (pare-original-kar (make-pare 'a 'b)) 'a)
     (eq? (pare-original-kdr (make-pare 'a 'b)) 'b)
     (let ((p (make-pare 'a 'b)))
       (set-pare-kar! p 'c)
       (set-pare-kdr! p 'd)
       (and (eq? (pare-kar p) 'c)
            (eq? (pare-kdr p) 'd)
            (eq? (pare-original-kar p) 'a)
            (eq? (pare-original-kdr p) 'b))))

(mat record13
     (begin
       (define-record stretch-string
         ((integer-32 length) (fill))
         ([(string) (make-string length fill)]))
       (define stretch-string-ref
         (lambda (s i)
           (let ([n (stretch-string-length s)])
             (when (>= i n)
                   (stretch-stretch-string! s (+ i 1) n))
             (string-ref (stretch-string-string s) i))))
       (define stretch-string-set!
         (lambda (s i c)
           (let ([n (stretch-string-length s)])
             (when (>= i n)
                   (stretch-stretch-string! s (+ i 1) n))
             (string-set! (stretch-string-string s) i c))))
       (define stretch-string-fill!
         (lambda (s c)
           (string-fill! (stretch-string-string s) c)
           (set-stretch-string-fill! s c)))
       (define stretch-stretch-string!
         (lambda (s i n)
           (set-stretch-string-length! s i)
           (let ([str (stretch-string-string s)]
                 [fill (stretch-string-fill s)])
             (let ([xtra (make-string (- i n) fill)])
               (set-stretch-string-string! s (string-append str xtra))))))
       (define ss (make-stretch-string 2 #\X))
       (stretch-string? ss))
     (equal? (stretch-string-string ss) "XX")
     (eqv? (stretch-string-ref ss 3) #\X)
     (eqv? (stretch-string-length ss) 4)
     (equal? (stretch-string-string ss) "XXXX")
     (begin
       (stretch-string-fill! ss #\@)
       (equal? (stretch-string-string ss) "@@@@"))
     (eqv? (stretch-string-ref ss 5) #\@)
     (equal? (stretch-string-string ss) "@@@@@@")
     (begin
       (stretch-string-set! ss 7 #\=)
       (eqv? (stretch-string-length ss) 8))
     (equal? (stretch-string-string ss) "@@@@@@@="))

(mat record14
     (begin
       (define-record froz
         ((immutable a) (immutable b))
         (((immutable c) (+ a b)))
         (#; (print-method
               (lambda (x p wr)
                 (wr `(* hi john ,(froz-c x) *) p)))))
       (froz? (make-froz 17 23)))
     #;
     (equal? (format "~s" (make-froz 17 23)) "(* hi john 40 *)")
     (eqv? (froz-a (make-froz 17 23)) 17)
     (let ()
       (define-record pair
         ((mutable car) (immutable cdr))
         ()
         (#; (print-method
               (lambda (x p wr)
                 (display "(" p)
                 ; )
                 (wr (car x) p)
                 (display " . " p)
                 (wr (cdr x) p)
                 ; (
                 (display ")" p)))
             (constructor cons)
             (prefix "")))
       (and (pair? (cons 3 4))
            (not (pair? '(3 . 4)))
            (eq? (car (cons 3 4)) 3)
            (eq? (cdr (cons 3 4)) 4)
            #;
            (equal? (format "~s" (cons 3 (cons 4 '()))) "(3 . (4 . ()))")
            #;
            (let ((x (cons 3 4)))
              (set-car! x x)
              (equal? (format "~s" x) "#0=(#0# . 4)")))))

(mat record15
     (equal? (let ()
               (define-record foo ((mutable a)))
               (let ((x (make-foo '*)))
                 (record-reader 'foo (record-rtd x))
                 (set-foo-a! x x)
                 (parameterize ((print-graph #t))
                   (let ((p (open-output-string)))
                     (pretty-print x p)
                     (get-output-string p)))))
             (format "#0=#[foo #0#]~%"))
     (equal? (let ((* "*"))
               (define-record foo (a))
               (let ((x (make-foo *)) (y (make-foo *)))
                 (record-reader 'foo (record-rtd x))
                 (parameterize ((print-graph #t)) (format "~s" (list x y)))))
             "(#[foo #0=\"*\"] #[foo #0#])"))

(mat record16
     (begin
       (define-record bazar
         ((immutable a) (mutable b) (immutable c))
         ()
         ((prefix "bazar.") #; (reader-name "bazar")))
       (define x (make-bazar 3 4 5))
       (bazar? x))
     (eqv? (bazar.b x) 4)
     (procedure? set-bazar.b!)
     (eqv? (record-reader 'bazar (record-rtd x)) (void))
     (let ((x (read (open-input-string "#1=#[bazar a #1# c]"))))
       (and (bazar? x) (eq? (bazar.b x) x)))
     (let ((x (read (open-input-string "#[bazar #1=a b #1#]"))))
       (and (bazar? x)
            (eq? (bazar.a x) 'a)
            (eq? (bazar.a x) (bazar.c x))
            (eq? (bazar.b x) 'b)))
     (error? (read (open-input-string "#1=#[bazar a b #1#]")))
     (error? (read (open-input-string "#1=#[bazar #1# b c]")))
     (bazar? (read (open-input-string "#[bazar #1# b #1=a]"))))

(mat record17
     (let ()
       (define-record f ((integer-8 x) (integer-8 y) (integer-32 z)))
       (let ()
         (define r (make-f 1 2 3))
         (and (f? r)
              (equal? '(3 2 1) (list (f-z r) (f-y r) (f-x r))))))
     (let ()
       (define-record f ((integer-8 x) (integer-8 y) (integer-32 z)))
       (let ()
         (define r (make-f 1 2 3))
         (set-f-x! r 72)
         (set-f-y! r 73)
         (set-f-z! r 74)
         (and (f? r)
              (equal? '(74 73 72) (list (f-z r) (f-y r) (f-x r))))))
     (let ()
       (define-record f ((integer-8 x) (integer-8 y) (integer-32 z)))
       (let ()
         (define r (make-f 1 2 3))
         (set-f-x! r -72)
         (set-f-y! r -73)
         (set-f-z! r -74)
         (and (f? r)
              (equal? '(-74 -73 -72) (list (f-z r) (f-y r) (f-x r))))))
     (begin
       (define-record $froz
         ((unsigned-8 x) (double-float y) (single-float z) (unsigned-16 w)))
       (procedure? make-$froz))
     (error? (make-$froz 256 2.5 3.5 0))
     (let ([y (make-$froz -1 2.5 3.5 0)])
       (eqv? ($froz-x y) (+ #x100 -1)))
     (error? (make-$froz -129 2.5 3.5 0))
     (error? (make-$froz 0 2.5 3.5 #x10000))
     (let ([y (make-$froz 0 2.5 3.5 -1)])
       (eqv? ($froz-w y) (+ #x10000 -1)))
     (error? (make-$froz 0 2.5 3.5 #x-8001))
     (error? (make-$froz 0 2 3.5 0))
     (error? (make-$froz 0 2.5 3 0))
     (begin
       (define $rfroz (make-$froz 1 2.5 3.5 4))
       ($froz? $rfroz))
     (eqv? ($froz-x $rfroz) 1)
     (eqv? ($froz-y $rfroz) 2.5)
     (eqv? ($froz-z $rfroz) 3.5)
     (eqv? ($froz-w $rfroz) 4)
     (eqv? (set-$froz-x! $rfroz 2) (void))
     (eqv? (set-$froz-y! $rfroz 2.75) (void))
     (eqv? (set-$froz-z! $rfroz 3.75) (void))
     (eqv? (set-$froz-w! $rfroz 5) (void))
     (eqv? ($froz-x $rfroz) 2)
     (eqv? ($froz-y $rfroz) 2.75)
     (eqv? ($froz-z $rfroz) 3.75)
     (eqv? ($froz-w $rfroz) 5)
     (eqv? (set-$froz-z! $rfroz #b11e111111111) (void))
     (eqv? ($froz-z $rfroz) +inf.0)
     (eqv? (set-$froz-z! $rfroz #b11e-111111111) (void))
     (eqv? ($froz-z $rfroz) 0.0)
     (begin
       (set-$froz-x! $rfroz -1)
       (eqv? ($froz-x $rfroz) (+ #x100 -1)))
     (error? (set-$froz-x! $rfroz 256))
     (error? (set-$froz-x! $rfroz #x-81))
     (error? (set-$froz-y! $rfroz 2))
     (error? (set-$froz-z! $rfroz 2))
     (error? (set-$froz-w! $rfroz #x-8001))
     (begin
       (set-$froz-w! $rfroz -1)
       (eqv? ($froz-w $rfroz) (+ #x10000 -1)))
     (error? (set-$froz-w! $rfroz #x10000))
     (begin
       (define-record $froz ((integer-8 x) (integer-16 w)))
       (procedure? make-$froz))
     (error? (make-$froz 256 0))
     (let ([y (make-$froz #x80 #x8000)])
       (and (eqv? ($froz-x y) #x-80)
            (eqv? ($froz-w y) #x-8000)))
     (error? (make-$froz -129 0))
     (error? (make-$froz 0 #x10000))
     (error? (make-$froz 0 #x-8001))
     (begin
       (define $rfroz (make-$froz 1 4))
       ($froz? $rfroz))
     (eqv? ($froz-x $rfroz) 1)
     (eqv? ($froz-w $rfroz) 4)
     (eqv? (set-$froz-x! $rfroz 2) (void))
     (eqv? (set-$froz-w! $rfroz 5) (void))
     (eqv? ($froz-x $rfroz) 2)
     (eqv? ($froz-w $rfroz) 5)
     (begin
       (set-$froz-x! $rfroz #xff)
       (set-$froz-w! $rfroz #xffff)
       (eqv? ($froz-x $rfroz) -1)
       (eqv? ($froz-w $rfroz) -1))
     (error? (set-$froz-x! $rfroz 256))
     (error? (set-$froz-x! $rfroz -129))
     (error? (set-$froz-w! $rfroz #x10000))
     (error? (set-$froz-w! $rfroz #x-8001)))

(mat record18
     (let* ([size 200]
            [ls (map (lambda (x)
                       (let ([name (gensym)])
                         (case (random 6)
                           [(0) `(immutable ,name)]
                           [(1) `(mutable ,name)]
                           [(2) `(integer-32 ,name)]
                           [(3) `(double-float ,name)]
                           [(4) `(single-float ,name)]
                           [(5) `(immutable unsigned-16 ,name)])))
                     (make-list size))])
       (define another
         (lambda (type)
           (case type
             [(scheme-object) (substring "xxlovelyxx" 2 8)]
             [(integer-32)
              (case (random 10)
                [(0) 0]
                [(1) 1]
                [(2) -1]
                [(3) $mpf32]
                [(4) $mnf32]
                [(5) (+ $mpf32 1)]
                [(6) (- $mnf32 1)]
                [(7) #x7fffffff]
                [(8) #x-80000000]
                [(9) (- (random #x100000000) #x80000000)])]
             [(unsigned-16)
              (case (random 6)
                [(0) 0]
                [(1) 1]
                [(2) #x7fff]
                [(3) #x8000]
                [(4) #xffff]
                [(5) (random #x10000)])]
             [(double-float)
              (if (zero? (random 1))
                  (random 1e15)
                  (- (random 1e15)))]
             [(single-float) (inexact (random #e1e7))]
             [else (errorf #f "unexpected type ~s" type)])))
       (let ([rtd (make-record-type "big" ls)])
         (let ([accessors
                 (map (lambda (x) (csv7:record-field-accessor rtd x))
                      (csv7:record-type-field-names rtd))]
               [mutators (map (lambda (x)
                                (and (csv7:record-field-mutable? rtd x)
                                     (csv7:record-field-mutator rtd x)))
                              (csv7:record-type-field-names rtd))]
               [vals (map another
                          (map cadr
                               (csv7:record-type-field-decls rtd)))])
           (let ([inst (apply (record-constructor rtd) vals)])
             (let f ((n 2000) (vals vals))
               (unless (= n 0)
                       (if (= (modulo n 20) 0) (collect))
                       (f (- n 1)
                          (map (lambda (acc mut! val type)
                                 (let ([ival (acc inst)])
                                   (unless (and (eqv? ival val)
                                                (or (not (string? ival))
                                                    (string=? ival "lovely")))
                                           (errorf #f
                                                   "unexpected value ~s; should have been ~s"
                                                   ival
                                                   val)))
                                 (if (and mut! (= (random 10) 3))
                                     (let ([nval (another type)])
                                       (mut! inst nval)
                                       nval)
                                     val))
                               accessors
                               mutators
                               vals
                               (map cadr
                                    (csv7:record-type-field-decls rtd)))))))))
       #t))

(mat foreign-data
     (begin
       (module ($fd-unaligned-integers $fd-unaligned-floats)
         (define-syntax define-constant
           (syntax-rules (machine-type)
             [(_ machine-type y) (begin)]
             [(_ x y) (define x y)]))
         (define-syntax features
           (syntax-rules () [(_ x ...) (begin)]))
         (define-syntax constant (syntax-rules () [(_ x) x]))
         (define-syntax constant-case
           (syntax-rules (else)
             [(_ const [(k ...) e1 e2 ...] ... [else ee1 ee2 ...])
              (meta-cond
                [(memv (constant const) '(k ...)) e1 e2 ...]
                ...
                [else ee1 ee2 ...])]
             [(_ const [(k ...) e1 e2 ...] ...)
              (meta-cond
                [(memv (constant const) '(k ...)) e1 e2 ...]
                ...
                [else
                 (syntax-error const
                   (format "unhandled value ~s" (constant const)))])]))
         (include "../s/machine.def")
         ; all this work for two constants:
         (define $fd-unaligned-integers
           (constant unaligned-integers))
         (define $fd-unaligned-floats
           (constant unaligned-floats)))
       (define ($fd-make-min bytes)
         (- (ash (expt 256 bytes) -1)))
       (define ($fd-make-max bytes) (- (expt 256 bytes) 1))
       (define $fd-addr-min
         ($fd-make-min (foreign-sizeof 'void*)))
       (define $fd-addr-max
         ($fd-make-max (foreign-sizeof 'void*)))
       (define $fd-int-min
         ($fd-make-min (foreign-sizeof 'int)))
       (define $fd-int-max
         ($fd-make-max (foreign-sizeof 'int)))
       (define $fd-short-min
         ($fd-make-min (foreign-sizeof 'short)))
       (define $fd-short-max
         ($fd-make-max (foreign-sizeof 'short)))
       (define $fd-long-min
         ($fd-make-min (foreign-sizeof 'long)))
       (define $fd-long-max
         ($fd-make-max (foreign-sizeof 'long)))
       (define $fd-long-long-min
         ($fd-make-min (foreign-sizeof 'long-long)))
       (define $fd-long-long-max
         ($fd-make-max (foreign-sizeof 'long-long)))
       (define $fd-char-max ($fd-make-max 1))
       (define $fd-wchar-max
         (min ($fd-make-max (foreign-sizeof 'wchar)) #x10ffff))
       (define $fd-i8-min ($fd-make-min 1))
       (define $fd-i8-max ($fd-make-max 1))
       (define $fd-i16-min ($fd-make-min 2))
       (define $fd-i16-max ($fd-make-max 2))
       (define $fd-i32-min ($fd-make-min 4))
       (define $fd-i32-max ($fd-make-max 4))
       (define $fd-i64-min ($fd-make-min 8))
       (define $fd-i64-max ($fd-make-max 8))
       #t)
     ; foreign-alloc
     (error? ; not a positive fixnum
             (foreign-alloc 0))
     (error? ; not a positive fixnum
             (foreign-alloc (+ (most-positive-fixnum) 1)))
     (error? ; not a positive fixnum
             (foreign-alloc -5))
     (error? ; not a positive fixnum
             (foreign-alloc 17.0))
     ; foreign-free
     (error? ; invalid address
             (foreign-free 17.0))
     (error? ; invalid address
             (foreign-free (- $fd-addr-min 1)))
     (error? ; invalid address
             (foreign-free (+ $fd-addr-max 1)))
     (equal? (let ([x (foreign-alloc 16)])
               (list (<= 0 x $fd-addr-max) (foreign-free x)))
             (list #t (void)))
     ; foreign-ref
     (begin
       (define $max-uptr+1
         (cond
           [(fx= (fixnum-width) 30) #x100000000]
           [(fx= (fixnum-width) 61) #x10000000000000000]
           [else
            ($oops '$raw-fd-a "unexpected fixnum-width ~s" (fixnum-width))]))
       #t)
     (error? ; invalid address
             (foreign-ref 'integer-32 $max-uptr+1 0))
     (error? ; invalid address
       (foreign-ref 'integer-32 (- $max-uptr+1) 100))
     (error? ; invalid offset
       (foreign-ref 'integer-32 0 (+ (most-positive-fixnum) 1)))
     (error? ; invalid addr + offset
             (foreign-ref 'integer-32 (- $max-uptr+1 4) 4))
     (error? ; invalid addr + offset for 4-byte type
             (foreign-ref 'integer-32 (- $max-uptr+1 8) 6))
     (error? ; invalid address
             (foreign-set! 'integer-32 $max-uptr+1 0 7))
     (error? ; invalid address
       (foreign-set! 'integer-32 (- $max-uptr+1) 100 7))
     (error? ; invalid offset
       (foreign-set! 'integer-32 0 (+ (most-positive-fixnum) 1) 7))
     (error? ; invalid addr + offset
             (foreign-set! 'integer-32 (- $max-uptr+1 4) 4 7))
     (error? ; invalid addr + offset for 4-byte type
             (foreign-set! 'integer-32 (- $max-uptr+1 8) 6 7))
     (meta-cond
       [(fx= (fixnum-width) 30)
        (define $real-fd-a (foreign-alloc (+ 40 7)))
        (define $fd-a (logand (+ $real-fd-a 7) -8))
        (define $raw-fd-a
          (ash (if (>= $fd-a (expt 2 31)) (- $fd-a (expt 2 32)) $fd-a) -2))
        (and (<= 0 $fd-a $fd-addr-max) (fixnum? $raw-fd-a))]
       [(fx= (fixnum-width) 61)
        (define $real-fd-a (foreign-alloc (+ 40 7)))
        (define $fd-a (logand (+ $real-fd-a 7) -8))
        (define $raw-fd-a
          (ash (if (>= $fd-a (expt 2 63)) (- $fd-a (expt 2 64)) $fd-a) -3))
        (and (<= 0 $fd-a $fd-addr-max) (fixnum? $raw-fd-a))]
       [else
        ($oops '$raw-fd-a "unexpected fixnum-width ~s" (fixnum-width))])
     (error? ; invalid type
             (foreign-ref 'aint $fd-a 0))
     (error? ; invalid type
             (foreign-ref 'ptr $fd-a 0))
     (error? ; invalid type
             (foreign-ref 'scheme-object $fd-a 0))
     (begin
       (define $fd-f (lambda () (foreign-ref 'ptr $fd-a 0)))
       (procedure? $fd-f))
     (error? ; invalid type
             ($fd-f))
     (begin
       (define $fd-f (lambda (x) (foreign-ref x $fd-a 0)))
       (procedure? $fd-f))
     (error? ; invalid type
             ($fd-f 'ptr))
     (error? ; invalid address
             (foreign-ref 'int 7.5 0))
     (error? ; invalid address
             (foreign-ref 'int (- $fd-addr-min 1) 0))
     (error? ; invalid address
             (foreign-ref 'int (+ $fd-addr-max 1) 0))
     (error? ; not a fixnum
             (foreign-ref 'int $fd-a 0.0))
     (error? ; not a fixnum
       (foreign-ref 'int $fd-a (+ (most-positive-fixnum) 1)))
     (error? ; not a fixnum
       (foreign-ref 'int $fd-a (- (most-negative-fixnum) 1)))
     ; foreign-set!
     (error? ; invalid type
             (foreign-set! 'aint $fd-a 0 17))
     (error? ; invalid type
             (foreign-set! 'ptr $fd-a 0 17))
     (error? ; invalid type
       (foreign-set! 'scheme-object $fd-a 0 17))
     (begin
       (define $fd-f
         (lambda () (foreign-set! 'ptr $fd-a 0 17)))
       (procedure? $fd-f))
     (error? ; invalid type
             ($fd-f))
     (begin
       (define $fd-f
         (lambda (x) (foreign-set! x $fd-a 0 17)))
       (procedure? $fd-f))
     (error? ; invalid type
             ($fd-f 'ptr))
     (error? ; invalid address
             (foreign-set! 'int 7.5 0 17))
     (error? ; invalid address
       (foreign-set! 'int (- $fd-addr-min 1) 0 17))
     (error? ; invalid address
       (foreign-set! 'int (+ $fd-addr-max 1) 0 17))
     (error? ; not a fixnum
             (foreign-set! 'int $fd-a 0.0 17))
     (error? ; not a fixnum
       (foreign-set! 'int $fd-a (+ (most-positive-fixnum) 1) 17))
     (error? ; not a fixnum
       (foreign-set! 'int $fd-a (- (most-negative-fixnum) 1) 17))
     ; integer-8/unsigned-8
     (error? ; invalid value for type
             (foreign-set! 'integer-8 $fd-a 0 17.0))
     (error? ; invalid value for type
             (foreign-set! 'integer-8 $fd-a 0 (- $fd-i8-min 1)))
     (error? ; invalid value for type
             (foreign-set! 'integer-8 $fd-a 0 (+ $fd-i8-max 1)))
     (error? ; invalid value for type
             (foreign-set! 'unsigned-8 $fd-a 0 17.0))
     (error? ; invalid value for type
             (foreign-set! 'unsigned-8 $fd-a 0 (- $fd-i8-min 1)))
     (error? ; invalid value for type
             (foreign-set! 'unsigned-8 $fd-a 0 (+ $fd-i8-max 1)))
     (equal? (begin
               (foreign-set! 'integer-8 $fd-a 3 255)
               (list (foreign-ref 'integer-8 $fd-a 3)
                     (foreign-ref 'unsigned-8 $fd-a 3)))
             '(-1 255))
     (equal? (begin
               (foreign-set! 'unsigned-8 $fd-a 5 -5)
               (list (foreign-ref 'integer-8 $fd-a 5)
                     (foreign-ref 'unsigned-8 $fd-a 5)))
             '(-5 251))
     (equal? (begin
               (foreign-set! 'integer-8 $fd-a 0 #x-80)
               (foreign-set! 'integer-8 $fd-a 1 0)
               (foreign-set! 'integer-8 $fd-a 2 #x7f)
               (foreign-set! 'integer-8 $fd-a 3 #x80)
               (foreign-set! 'integer-8 $fd-a 4 #xff)
               (list (foreign-ref 'integer-8 $fd-a 0)
                     (foreign-ref 'integer-8 $fd-a 1)
                     (foreign-ref 'integer-8 $fd-a 2)
                     (foreign-ref 'integer-8 $fd-a 3)
                     (foreign-ref 'integer-8 $fd-a 4)
                     (foreign-ref 'unsigned-8 $fd-a 0)
                     (foreign-ref 'unsigned-8 $fd-a 1)
                     (foreign-ref 'unsigned-8 $fd-a 2)
                     (foreign-ref 'unsigned-8 $fd-a 3)
                     (foreign-ref 'unsigned-8 $fd-a 4)))
             `(#x-80 0 #x7f #x-80 -1 #x80 0 #x7f #x80 #xff))
     (equal? (begin
               (foreign-set! 'unsigned-8 $fd-a 0 #x-80)
               (foreign-set! 'unsigned-8 $fd-a 1 0)
               (foreign-set! 'unsigned-8 $fd-a 2 #x7f)
               (foreign-set! 'unsigned-8 $fd-a 3 #x80)
               (foreign-set! 'unsigned-8 $fd-a 4 #xff)
               (list (foreign-ref 'integer-8 $fd-a 0)
                     (foreign-ref 'integer-8 $fd-a 1)
                     (foreign-ref 'integer-8 $fd-a 2)
                     (foreign-ref 'integer-8 $fd-a 3)
                     (foreign-ref 'integer-8 $fd-a 4)
                     (foreign-ref 'unsigned-8 $fd-a 0)
                     (foreign-ref 'unsigned-8 $fd-a 1)
                     (foreign-ref 'unsigned-8 $fd-a 2)
                     (foreign-ref 'unsigned-8 $fd-a 3)
                     (foreign-ref 'unsigned-8 $fd-a 4)))
             `(#x-80 0 #x7f #x-80 -1 #x80 0 #x7f #x80 #xff))
     ; integer-16/unsigned-16
     (error? ; invalid value for type
             (foreign-set! 'integer-16 $fd-a 0 17.0))
     (error? ; invalid value for type
             (foreign-set! 'integer-16 $fd-a 0 (- $fd-i16-min 1)))
     (error? ; invalid value for type
             (foreign-set! 'integer-16 $fd-a 0 (+ $fd-i16-max 1)))
     (error? ; invalid value for type
             (foreign-set! 'unsigned-16 $fd-a 0 17.0))
     (error? ; invalid value for type
             (foreign-set! 'unsigned-16 $fd-a 0 (- $fd-i16-min 1)))
     (error? ; invalid value for type
             (foreign-set! 'unsigned-16 $fd-a 0 (+ $fd-i16-max 1)))
     (equal? (begin
               (foreign-set! 'integer-16 $fd-a 2 #xabcd)
               (list (foreign-ref 'integer-16 $fd-a 2)
                     (foreign-ref 'unsigned-16 $fd-a 2)))
             `(,(- #xabcd #x10000) #xabcd))
     (equal? (begin
               (foreign-set! 'unsigned-16 $fd-a 2 -5321)
               (list (foreign-ref 'integer-16 $fd-a 2)
                     (foreign-ref 'unsigned-16 $fd-a 2)))
             `(-5321 ,(+ -5321 #x10000)))
     (equal? (begin
               (foreign-set! 'integer-16 $fd-a 0 #x-8000)
               (foreign-set! 'integer-16 $fd-a 2 0)
               (foreign-set! 'integer-16 $fd-a 4 #x7fff)
               (foreign-set! 'integer-16 $fd-a 6 #x8000)
               (foreign-set! 'integer-16 $fd-a 8 #xffff)
               (list (foreign-ref 'integer-16 $fd-a 0)
                     (foreign-ref 'integer-16 $fd-a 2)
                     (foreign-ref 'integer-16 $fd-a 4)
                     (foreign-ref 'integer-16 $fd-a 6)
                     (foreign-ref 'integer-16 $fd-a 8)
                     (foreign-ref 'unsigned-16 $fd-a 0)
                     (foreign-ref 'unsigned-16 $fd-a 2)
                     (foreign-ref 'unsigned-16 $fd-a 4)
                     (foreign-ref 'unsigned-16 $fd-a 6)
                     (foreign-ref 'unsigned-16 $fd-a 8)))
             `(#x-8000 0 #x7fff #x-8000 -1 #x8000 0 #x7fff #x8000 #xffff))
     (equal? (begin
               (foreign-set! 'unsigned-16 $fd-a 0 #x-8000)
               (foreign-set! 'unsigned-16 $fd-a 2 0)
               (foreign-set! 'unsigned-16 $fd-a 4 #x7fff)
               (foreign-set! 'unsigned-16 $fd-a 6 #x8000)
               (foreign-set! 'unsigned-16 $fd-a 8 #xffff)
               (list (foreign-ref 'integer-16 $fd-a 0)
                     (foreign-ref 'integer-16 $fd-a 2)
                     (foreign-ref 'integer-16 $fd-a 4)
                     (foreign-ref 'integer-16 $fd-a 6)
                     (foreign-ref 'integer-16 $fd-a 8)
                     (foreign-ref 'unsigned-16 $fd-a 0)
                     (foreign-ref 'unsigned-16 $fd-a 2)
                     (foreign-ref 'unsigned-16 $fd-a 4)
                     (foreign-ref 'unsigned-16 $fd-a 6)
                     (foreign-ref 'unsigned-16 $fd-a 8)))
             `(#x-8000 0 #x7fff #x-8000 -1 #x8000 0 #x7fff #x8000 #xffff))
     ; integer-32/unsigned-32
     (error? ; invalid value for type
             (foreign-set! 'integer-32 $fd-a 0 17.0))
     (error? ; invalid value for type
             (foreign-set! 'integer-32 $fd-a 0 (- $fd-i32-min 1)))
     (error? ; invalid value for type
             (foreign-set! 'integer-32 $fd-a 0 (+ $fd-i32-max 1)))
     (error? ; invalid value for type
             (foreign-set! 'unsigned-32 $fd-a 0 17.0))
     (error? ; invalid value for type
             (foreign-set! 'unsigned-32 $fd-a 0 (- $fd-i32-min 1)))
     (error? ; invalid value for type
             (foreign-set! 'unsigned-32 $fd-a 0 (+ $fd-i32-max 1)))
     (equal? (begin
               (foreign-set! 'integer-32 $fd-a 0 #x-80000000)
               (foreign-set! 'integer-32 $fd-a 4 0)
               (foreign-set! 'integer-32 $fd-a 8 #x7fffffff)
               (foreign-set! 'integer-32 $fd-a 12 #x80000000)
               (foreign-set! 'integer-32 $fd-a 16 #xffffffff)
               (list (foreign-ref 'integer-32 $fd-a 0)
                     (foreign-ref 'integer-32 $fd-a 4)
                     (foreign-ref 'integer-32 $fd-a 8)
                     (foreign-ref 'integer-32 $fd-a 12)
                     (foreign-ref 'integer-32 $fd-a 16)
                     (foreign-ref 'unsigned-32 $fd-a 0)
                     (foreign-ref 'unsigned-32 $fd-a 4)
                     (foreign-ref 'unsigned-32 $fd-a 8)
                     (foreign-ref 'unsigned-32 $fd-a 12)
                     (foreign-ref 'unsigned-32 $fd-a 16)))
             `(#x-80000000
                0
                #x7fffffff
                #x-80000000
                -1
                #x80000000
                0
                #x7fffffff
                #x80000000
                #xffffffff))
     (equal? (begin
               (foreign-set! 'unsigned-32 $fd-a 0 #x-80000000)
               (foreign-set! 'unsigned-32 $fd-a 4 0)
               (foreign-set! 'unsigned-32 $fd-a 8 #x7fffffff)
               (foreign-set! 'unsigned-32 $fd-a 12 #x80000000)
               (foreign-set! 'unsigned-32 $fd-a 16 #xffffffff)
               (list (foreign-ref 'integer-32 $fd-a 0)
                     (foreign-ref 'integer-32 $fd-a 4)
                     (foreign-ref 'integer-32 $fd-a 8)
                     (foreign-ref 'integer-32 $fd-a 12)
                     (foreign-ref 'integer-32 $fd-a 16)
                     (foreign-ref 'unsigned-32 $fd-a 0)
                     (foreign-ref 'unsigned-32 $fd-a 4)
                     (foreign-ref 'unsigned-32 $fd-a 8)
                     (foreign-ref 'unsigned-32 $fd-a 12)
                     (foreign-ref 'unsigned-32 $fd-a 16)))
             `(#x-80000000
                0
                #x7fffffff
                #x-80000000
                -1
                #x80000000
                0
                #x7fffffff
                #x80000000
                #xffffffff))
     (equal? (begin
               (foreign-set! 'integer-32 $fd-a 12 #xabcd1234)
               (list (foreign-ref 'integer-32 $fd-a 12)
                     (foreign-ref 'unsigned-32 $fd-a 12)))
             `(,(- #xabcd1234 #x100000000) #xabcd1234))
     (equal? (begin
               (foreign-set! 'unsigned-32 $fd-a 12 #x-765321ab)
               (list (foreign-ref 'integer-32 $fd-a 12)
                     (foreign-ref 'unsigned-32 $fd-a 12)))
             `(#x-765321ab ,(+ #x-765321ab #x100000000)))
     ; integer-64/unsigned-64
     (error? ; invalid value for type
             (foreign-set! 'integer-64 $fd-a 0 17.0))
     (error? ; invalid value for type
             (foreign-set! 'integer-64 $fd-a 0 (- $fd-i64-min 1)))
     (error? ; invalid value for type
             (foreign-set! 'integer-64 $fd-a 0 (+ $fd-i64-max 1)))
     (error? ; invalid value for type
             (foreign-set! 'unsigned-64 $fd-a 0 17.0))
     (error? ; invalid value for type
             (foreign-set! 'unsigned-64 $fd-a 0 (- $fd-i64-min 1)))
     (error? ; invalid value for type
             (foreign-set! 'unsigned-64 $fd-a 0 (+ $fd-i64-max 1)))
     (equal? (begin
               (foreign-set! 'integer-64 $fd-a 16 #xabcd1234ffee8765)
               (list (foreign-ref 'integer-64 $fd-a 16)
                     (foreign-ref 'unsigned-64 $fd-a 16)
                     (if (eq? (native-endianness) 'little)
                         (logor (foreign-ref 'unsigned-32 $fd-a 16) (ash (foreign-ref 'integer-32 $fd-a 20) 32))
                         (logor (foreign-ref 'unsigned-32 $fd-a 20) (ash (foreign-ref 'integer-32 $fd-a 16) 32)))
                     (if (eq? (native-endianness) 'little)
                         (logor (foreign-ref 'unsigned-32 $fd-a 16) (ash (foreign-ref 'unsigned-32 $fd-a 20) 32))
                         (logor (foreign-ref 'unsigned-32 $fd-a 20) (ash (foreign-ref 'unsigned-32 $fd-a 16) 32)))))
             `(,(- #xabcd1234ffee8765 #x10000000000000000)
               #xabcd1234ffee8765
               ,(- #xabcd1234ffee8765 #x10000000000000000)
               #xabcd1234ffee8765))
     (equal? (begin
               (foreign-set! 'unsigned-64 $fd-a 16 #x-765321ab4c8e9de1)
               (list (foreign-ref 'integer-64 $fd-a 16)
                     (foreign-ref 'unsigned-64 $fd-a 16)
                     (if (eq? (native-endianness) 'little)
                         (logor (foreign-ref 'unsigned-32 $fd-a 16) (ash (foreign-ref 'integer-32 $fd-a 20) 32))
                         (logor (foreign-ref 'unsigned-32 $fd-a 20) (ash (foreign-ref 'integer-32 $fd-a 16) 32)))
                     (if (eq? (native-endianness) 'little)
                         (logor (foreign-ref 'unsigned-32 $fd-a 16) (ash (foreign-ref 'unsigned-32 $fd-a 20) 32))
                         (logor (foreign-ref 'unsigned-32 $fd-a 20) (ash (foreign-ref 'unsigned-32 $fd-a 16) 32)))))
             `(#x-765321ab4c8e9de1
                ,(+ #x-765321ab4c8e9de1 #x10000000000000000)
                #x-765321ab4c8e9de1
                ,(+ #x-765321ab4c8e9de1 #x10000000000000000)))
     (equal? (begin
               (foreign-set! 'integer-64 $fd-a 0 #x-8000000000000000)
               (foreign-set! 'integer-64 $fd-a 8 0)
               (foreign-set! 'integer-64 $fd-a 16 #x7fffffffffffffff)
               (foreign-set! 'integer-64 $fd-a 24 #x8000000000000000)
               (foreign-set! 'integer-64 $fd-a 32 #xffffffffffffffff)
               (list (foreign-ref 'integer-64 $fd-a 0)
                     (foreign-ref 'integer-64 $fd-a 8)
                     (foreign-ref 'integer-64 $fd-a 16)
                     (foreign-ref 'integer-64 $fd-a 24)
                     (foreign-ref 'integer-64 $fd-a 32)
                     (foreign-ref 'unsigned-64 $fd-a 0)
                     (foreign-ref 'unsigned-64 $fd-a 8)
                     (foreign-ref 'unsigned-64 $fd-a 16)
                     (foreign-ref 'unsigned-64 $fd-a 24)
                     (foreign-ref 'unsigned-64 $fd-a 32)))
             `(#x-8000000000000000
                0
                #x7fffffffffffffff
                #x-8000000000000000
                -1
                #x8000000000000000
                0
                #x7fffffffffffffff
                #x8000000000000000
                #xffffffffffffffff))
     (equal? (begin
               (foreign-set! 'unsigned-64 $fd-a 0 #x-8000000000000000)
               (foreign-set! 'unsigned-64 $fd-a 8 0)
               (foreign-set! 'unsigned-64 $fd-a 16 #x7fffffffffffffff)
               (foreign-set! 'unsigned-64 $fd-a 24 #x8000000000000000)
               (foreign-set! 'unsigned-64 $fd-a 32 #xffffffffffffffff)
               (list (foreign-ref 'integer-64 $fd-a 0)
                     (foreign-ref 'integer-64 $fd-a 8)
                     (foreign-ref 'integer-64 $fd-a 16)
                     (foreign-ref 'integer-64 $fd-a 24)
                     (foreign-ref 'integer-64 $fd-a 32)
                     (foreign-ref 'unsigned-64 $fd-a 0)
                     (foreign-ref 'unsigned-64 $fd-a 8)
                     (foreign-ref 'unsigned-64 $fd-a 16)
                     (foreign-ref 'unsigned-64 $fd-a 24)
                     (foreign-ref 'unsigned-64 $fd-a 32)))
             `(#x-8000000000000000
                0
                #x7fffffffffffffff
                #x-8000000000000000
                -1
                #x8000000000000000
                0
                #x7fffffffffffffff
                #x8000000000000000
                #xffffffffffffffff))
     ; iptr/uptr
     (error? ; invalid value for type
             (foreign-set! 'iptr $fd-a 0 17.0))
     (error? ; invalid value for type
             (foreign-set! 'iptr $fd-a 0 (- $fd-addr-min 1)))
     (error? ; invalid value for type
             (foreign-set! 'iptr $fd-a 0 (+ $fd-addr-max 1)))
     (error? ; invalid value for type
             (foreign-set! 'uptr $fd-a 0 17.0))
     (error? ; invalid value for type
             (foreign-set! 'uptr $fd-a 0 (- $fd-addr-min 1)))
     (error? ; invalid value for type
             (foreign-set! 'uptr $fd-a 0 (+ $fd-addr-max 1)))
     (case $fd-addr-max
       [(#xffffffff)
        (and (equal? (begin
                       (foreign-set! 'iptr $fd-a 12 #xabcd1234)
                       (list (foreign-ref 'iptr $fd-a 12)
                             (foreign-ref 'uptr $fd-a 12)
                             (foreign-ref 'integer-32 $fd-a 12)
                             (foreign-ref 'unsigned-32 $fd-a 12)))
                     `(,(- #xabcd1234 #x100000000)
                       #xabcd1234
                       ,(- #xabcd1234 #x100000000)
                       #xabcd1234))
             (equal? (begin
                       (foreign-set! 'uptr $fd-a 12 #x-765321ab)
                       (list (foreign-ref 'iptr $fd-a 12)
                             (foreign-ref 'uptr $fd-a 12)
                             (foreign-ref 'integer-32 $fd-a 12)
                             (foreign-ref 'unsigned-32 $fd-a 12)))
                     `(#x-765321ab
                        ,(+ #x-765321ab #x100000000)
                        #x-765321ab
                        ,(+ #x-765321ab #x100000000))))]
       [(#xffffffffffffffff)
        (and (equal? (begin
                       (foreign-set! 'iptr $fd-a 16 #xabcd1234ffee8765)
                       (list (foreign-ref 'iptr $fd-a 16)
                             (foreign-ref 'uptr $fd-a 16)
                             (if (eq? (native-endianness) 'little)
                                 (logor (foreign-ref 'unsigned-32 $fd-a 16) (ash (foreign-ref 'integer-32 $fd-a 20) 32))
                                 (logor (foreign-ref 'unsigned-32 $fd-a 20) (ash (foreign-ref 'integer-32 $fd-a 16) 32)))
                             (if (eq? (native-endianness) 'little)
                                 (logor (foreign-ref 'unsigned-32 $fd-a 16) (ash (foreign-ref 'unsigned-32 $fd-a 20) 32))
                                 (logor (foreign-ref 'unsigned-32 $fd-a 20) (ash (foreign-ref 'unsigned-32 $fd-a 16) 32)))))
                     `(,(- #xabcd1234ffee8765 #x10000000000000000)
                       #xabcd1234ffee8765
                       ,(- #xabcd1234ffee8765 #x10000000000000000)
                       #xabcd1234ffee8765))
             (equal? (begin
                       (foreign-set! 'uptr $fd-a 16 #x-765321ab4c8e9de1)
                       (list (foreign-ref 'iptr $fd-a 16)
                             (foreign-ref 'uptr $fd-a 16)
                             (if (eq? (native-endianness) 'little)
                                 (logor (foreign-ref 'unsigned-32 $fd-a 16) (ash (foreign-ref 'integer-32 $fd-a 20) 32))
                                 (logor (foreign-ref 'unsigned-32 $fd-a 20) (ash (foreign-ref 'integer-32 $fd-a 16) 32)))
                             (if (eq? (native-endianness) 'little)
                                 (logor (foreign-ref 'unsigned-32 $fd-a 16) (ash (foreign-ref 'unsigned-32 $fd-a 20) 32))
                                 (logor (foreign-ref 'unsigned-32 $fd-a 20) (ash (foreign-ref 'unsigned-32 $fd-a 16) 32)))))
                     `(#x-765321ab4c8e9de1
                        ,(+ #x-765321ab4c8e9de1 #x10000000000000000)
                        #x-765321ab4c8e9de1
                        ,(+ #x-765321ab4c8e9de1 #x10000000000000000)))
             (equal? (begin
                       (foreign-set! 'void* $fd-a 16 #x-765321ab4c8e9de1)
                       (list (foreign-ref 'iptr $fd-a 16)
                             (foreign-ref 'void* $fd-a 16)
                             (if (eq? (native-endianness) 'little)
                                 (logor (foreign-ref 'unsigned-32 $fd-a 16) (ash (foreign-ref 'integer-32 $fd-a 20) 32))
                                 (logor (foreign-ref 'unsigned-32 $fd-a 20) (ash (foreign-ref 'integer-32 $fd-a 16) 32)))
                             (if (eq? (native-endianness) 'little)
                                 (logor (foreign-ref 'unsigned-32 $fd-a 16) (ash (foreign-ref 'unsigned-32 $fd-a 20) 32))
                                 (logor (foreign-ref 'unsigned-32 $fd-a 20) (ash (foreign-ref 'unsigned-32 $fd-a 16) 32)))))
                     `(#x-765321ab4c8e9de1
                        ,(+ #x-765321ab4c8e9de1 #x10000000000000000)
                        #x-765321ab4c8e9de1
                        ,(+ #x-765321ab4c8e9de1 #x10000000000000000))))]
       [else
        (error 'foreign-data-mat "unexpected $fd-addr-max ~s" $fd-addr-max)])
     ; int/unsigned
     (error? ; invalid value for type
             (foreign-set! 'int $fd-a 0 17.0))
     (error? ; invalid value for type
             (foreign-set! 'int $fd-a 0 (- $fd-int-min 1)))
     (error? ; invalid value for type
             (foreign-set! 'int $fd-a 0 (+ $fd-int-max 1)))
     (error? ; invalid value for type
             (foreign-set! 'unsigned $fd-a 0 17.0))
     (error? ; invalid value for type
             (foreign-set! 'unsigned $fd-a 0 (- $fd-int-min 1)))
     (error? ; invalid value for type
             (foreign-set! 'unsigned $fd-a 0 (+ $fd-int-max 1)))
     (case $fd-int-max
       [(#xffffffff)
        (and (equal? (begin
                       (foreign-set! 'int $fd-a 0 #x-80000000)
                       (foreign-set! 'int $fd-a 4 0)
                       (foreign-set! 'int $fd-a 8 #x7fffffff)
                       (foreign-set! 'int $fd-a 12 #x80000000)
                       (foreign-set! 'int $fd-a 16 #xffffffff)
                       (list (foreign-ref 'int $fd-a 0)
                             (foreign-ref 'int $fd-a 4)
                             (foreign-ref 'int $fd-a 8)
                             (foreign-ref 'int $fd-a 12)
                             (foreign-ref 'int $fd-a 16)
                             (foreign-ref 'unsigned $fd-a 0)
                             (foreign-ref 'unsigned $fd-a 4)
                             (foreign-ref 'unsigned $fd-a 8)
                             (foreign-ref 'unsigned $fd-a 12)
                             (foreign-ref 'unsigned $fd-a 16)))
                     `(#x-80000000
                        0
                        #x7fffffff
                        #x-80000000
                        -1
                        #x80000000
                        0
                        #x7fffffff
                        #x80000000
                        #xffffffff))
             (equal? (begin
                       (foreign-set! 'unsigned $fd-a 0 #x-80000000)
                       (foreign-set! 'unsigned $fd-a 4 0)
                       (foreign-set! 'unsigned $fd-a 8 #x7fffffff)
                       (foreign-set! 'unsigned $fd-a 12 #x80000000)
                       (foreign-set! 'unsigned $fd-a 16 #xffffffff)
                       (list (foreign-ref 'int $fd-a 0)
                             (foreign-ref 'int $fd-a 4)
                             (foreign-ref 'int $fd-a 8)
                             (foreign-ref 'int $fd-a 12)
                             (foreign-ref 'int $fd-a 16)
                             (foreign-ref 'unsigned $fd-a 0)
                             (foreign-ref 'unsigned $fd-a 4)
                             (foreign-ref 'unsigned $fd-a 8)
                             (foreign-ref 'unsigned $fd-a 12)
                             (foreign-ref 'unsigned $fd-a 16)))
                     `(#x-80000000
                        0
                        #x7fffffff
                        #x-80000000
                        -1
                        #x80000000
                        0
                        #x7fffffff
                        #x80000000
                        #xffffffff))
             (equal? (begin
                       (foreign-set! 'unsigned-int $fd-a 0 #x-80000000)
                       (foreign-set! 'unsigned-int $fd-a 4 0)
                       (foreign-set! 'unsigned-int $fd-a 8 #x7fffffff)
                       (foreign-set! 'unsigned-int $fd-a 12 #x80000000)
                       (foreign-set! 'unsigned-int $fd-a 16 #xffffffff)
                       (list (foreign-ref 'int $fd-a 0)
                             (foreign-ref 'int $fd-a 4)
                             (foreign-ref 'int $fd-a 8)
                             (foreign-ref 'int $fd-a 12)
                             (foreign-ref 'int $fd-a 16)
                             (foreign-ref 'unsigned-int $fd-a 0)
                             (foreign-ref 'unsigned-int $fd-a 4)
                             (foreign-ref 'unsigned-int $fd-a 8)
                             (foreign-ref 'unsigned-int $fd-a 12)
                             (foreign-ref 'unsigned-int $fd-a 16)))
                     `(#x-80000000
                        0
                        #x7fffffff
                        #x-80000000
                        -1
                        #x80000000
                        0
                        #x7fffffff
                        #x80000000
                        #xffffffff))
             (equal? (begin
                       (foreign-set! 'int $fd-a 12 #xabcd1234)
                       (list (foreign-ref 'int $fd-a 12)
                             (foreign-ref 'unsigned $fd-a 12)
                             (foreign-ref 'integer-32 $fd-a 12)
                             (foreign-ref 'unsigned-32 $fd-a 12)))
                     `(,(- #xabcd1234 #x100000000)
                       #xabcd1234
                       ,(- #xabcd1234 #x100000000)
                       #xabcd1234))
             (equal? (begin
                       (foreign-set! 'unsigned $fd-a 12 #x-765321ab)
                       (list (foreign-ref 'int $fd-a 12)
                             (foreign-ref 'unsigned $fd-a 12)
                             (foreign-ref 'integer-32 $fd-a 12)
                             (foreign-ref 'unsigned-32 $fd-a 12)))
                     `(#x-765321ab
                        ,(+ #x-765321ab #x100000000)
                        #x-765321ab
                        ,(+ #x-765321ab #x100000000))))]
       [else
        (error 'foreign-data-mat "unexpected $fd-int-max ~s" $fd-int-max)])
     ; short/unsigned-short
     (error? ; invalid value for type
             (foreign-set! 'short $fd-a 0 17.0))
     (error? ; invalid value for type
             (foreign-set! 'short $fd-a 0 (- $fd-short-min 1)))
     (error? ; invalid value for type
             (foreign-set! 'short $fd-a 0 (+ $fd-short-max 1)))
     (error? ; invalid value for type
             (foreign-set! 'unsigned-short $fd-a 0 17.0))
     (error? ; invalid value for type
       (foreign-set! 'unsigned-short $fd-a 0 (- $fd-short-min 1)))
     (error? ; invalid value for type
       (foreign-set! 'unsigned-short $fd-a 0 (+ $fd-short-max 1)))
     (case $fd-short-max
       [(#xffff)
        (and (equal? (begin
                       (foreign-set! 'short $fd-a 0 #x-8000)
                       (foreign-set! 'short $fd-a 2 0)
                       (foreign-set! 'short $fd-a 4 #x7fff)
                       (foreign-set! 'short $fd-a 6 #x8000)
                       (foreign-set! 'short $fd-a 8 #xffff)
                       (list (foreign-ref 'short $fd-a 0)
                             (foreign-ref 'short $fd-a 2)
                             (foreign-ref 'short $fd-a 4)
                             (foreign-ref 'short $fd-a 6)
                             (foreign-ref 'short $fd-a 8)
                             (foreign-ref 'unsigned-short $fd-a 0)
                             (foreign-ref 'unsigned-short $fd-a 2)
                             (foreign-ref 'unsigned-short $fd-a 4)
                             (foreign-ref 'unsigned-short $fd-a 6)
                             (foreign-ref 'unsigned-short $fd-a 8)))
                     `(#x-8000 0
                               #x7fff
                               #x-8000
                               -1
                               #x8000
                               0
                               #x7fff
                               #x8000
                               #xffff))
             (equal? (begin
                       (foreign-set! 'unsigned-short $fd-a 0 #x-8000)
                       (foreign-set! 'unsigned-short $fd-a 2 0)
                       (foreign-set! 'unsigned-short $fd-a 4 #x7fff)
                       (foreign-set! 'unsigned-short $fd-a 6 #x8000)
                       (foreign-set! 'unsigned-short $fd-a 8 #xffff)
                       (list (foreign-ref 'short $fd-a 0)
                             (foreign-ref 'short $fd-a 2)
                             (foreign-ref 'short $fd-a 4)
                             (foreign-ref 'short $fd-a 6)
                             (foreign-ref 'short $fd-a 8)
                             (foreign-ref 'unsigned-short $fd-a 0)
                             (foreign-ref 'unsigned-short $fd-a 2)
                             (foreign-ref 'unsigned-short $fd-a 4)
                             (foreign-ref 'unsigned-short $fd-a 6)
                             (foreign-ref 'unsigned-short $fd-a 8)))
                     `(#x-8000 0
                               #x7fff
                               #x-8000
                               -1
                               #x8000
                               0
                               #x7fff
                               #x8000
                               #xffff))
             (equal? (begin
                       (foreign-set! 'short $fd-a 2 #xabcd)
                       (list (foreign-ref 'short $fd-a 2)
                             (foreign-ref 'unsigned-short $fd-a 2)
                             (foreign-ref 'integer-16 $fd-a 2)
                             (foreign-ref 'unsigned-16 $fd-a 2)))
                     `(,(- #xabcd #x10000)
                       #xabcd
                       ,(- #xabcd #x10000)
                       #xabcd))
             (equal? (begin
                       (foreign-set! 'unsigned-short $fd-a 2 -5321)
                       (list (foreign-ref 'short $fd-a 2)
                             (foreign-ref 'unsigned-short $fd-a 2)
                             (foreign-ref 'integer-16 $fd-a 2)
                             (foreign-ref 'unsigned-16 $fd-a 2)))
                     `(-5321 ,(+ -5321 #x10000) -5321 ,(+ -5321 #x10000))))]
       [else
        (error 'foreign-data-mat
               "unexpected $fd-short-max ~s"
               $fd-short-max)])
     ; long/unsigned-long
     (error? ; invalid value for type
             (foreign-set! 'long $fd-a 0 17.0))
     (error? ; invalid value for type
             (foreign-set! 'long $fd-a 0 (- $fd-long-min 1)))
     (error? ; invalid value for type
             (foreign-set! 'long $fd-a 0 (+ $fd-long-max 1)))
     (error? ; invalid value for type
             (foreign-set! 'unsigned-long $fd-a 0 17.0))
     (error? ; invalid value for type
             (foreign-set! 'unsigned-long $fd-a 0 (- $fd-long-min 1)))
     (error? ; invalid value for type
             (foreign-set! 'unsigned-long $fd-a 0 (+ $fd-long-max 1)))
     (case $fd-long-max
       [(#xffffffff)
        (and (equal? (begin
                       (foreign-set! 'long $fd-a 0 #x-80000000)
                       (foreign-set! 'long $fd-a 4 0)
                       (foreign-set! 'long $fd-a 8 #x7fffffff)
                       (foreign-set! 'long $fd-a 12 #x80000000)
                       (foreign-set! 'long $fd-a 16 #xffffffff)
                       (list (foreign-ref 'long $fd-a 0)
                             (foreign-ref 'long $fd-a 4)
                             (foreign-ref 'long $fd-a 8)
                             (foreign-ref 'long $fd-a 12)
                             (foreign-ref 'long $fd-a 16)
                             (foreign-ref 'unsigned-long $fd-a 0)
                             (foreign-ref 'unsigned-long $fd-a 4)
                             (foreign-ref 'unsigned-long $fd-a 8)
                             (foreign-ref 'unsigned-long $fd-a 12)
                             (foreign-ref 'unsigned-long $fd-a 16)))
                     `(#x-80000000
                        0
                        #x7fffffff
                        #x-80000000
                        -1
                        #x80000000
                        0
                        #x7fffffff
                        #x80000000
                        #xffffffff))
             (equal? (begin
                       (foreign-set! 'unsigned-long $fd-a 0 #x-80000000)
                       (foreign-set! 'unsigned-long $fd-a 4 0)
                       (foreign-set! 'unsigned-long $fd-a 8 #x7fffffff)
                       (foreign-set! 'unsigned-long $fd-a 12 #x80000000)
                       (foreign-set! 'unsigned-long $fd-a 16 #xffffffff)
                       (list (foreign-ref 'long $fd-a 0)
                             (foreign-ref 'long $fd-a 4)
                             (foreign-ref 'long $fd-a 8)
                             (foreign-ref 'long $fd-a 12)
                             (foreign-ref 'long $fd-a 16)
                             (foreign-ref 'unsigned-long $fd-a 0)
                             (foreign-ref 'unsigned-long $fd-a 4)
                             (foreign-ref 'unsigned-long $fd-a 8)
                             (foreign-ref 'unsigned-long $fd-a 12)
                             (foreign-ref 'unsigned-long $fd-a 16)))
                     `(#x-80000000
                        0
                        #x7fffffff
                        #x-80000000
                        -1
                        #x80000000
                        0
                        #x7fffffff
                        #x80000000
                        #xffffffff))
             (equal? (begin
                       (foreign-set! 'long $fd-a 12 #xabcd1234)
                       (list (foreign-ref 'long $fd-a 12)
                             (foreign-ref 'unsigned-long $fd-a 12)
                             (foreign-ref 'integer-32 $fd-a 12)
                             (foreign-ref 'unsigned-32 $fd-a 12)))
                     `(,(- #xabcd1234 #x100000000)
                       #xabcd1234
                       ,(- #xabcd1234 #x100000000)
                       #xabcd1234))
             (equal? (begin
                       (foreign-set! 'unsigned-long $fd-a 12 #x-765321ab)
                       (list (foreign-ref 'long $fd-a 12)
                             (foreign-ref 'unsigned-long $fd-a 12)
                             (foreign-ref 'integer-32 $fd-a 12)
                             (foreign-ref 'unsigned-32 $fd-a 12)))
                     `(#x-765321ab
                        ,(+ #x-765321ab #x100000000)
                        #x-765321ab
                        ,(+ #x-765321ab #x100000000))))]
       [(#xffffffffffffffff)
        (and (equal? (begin
                       (foreign-set! 'long $fd-a 0 #x-8000000000000000)
                       (foreign-set! 'long $fd-a 8 0)
                       (foreign-set! 'long $fd-a 16 #x7fffffffffffffff)
                       (foreign-set! 'long $fd-a 24 #x8000000000000000)
                       (foreign-set! 'long $fd-a 32 #xffffffffffffffff)
                       (list (foreign-ref 'long $fd-a 0)
                             (foreign-ref 'long $fd-a 8)
                             (foreign-ref 'long $fd-a 16)
                             (foreign-ref 'long $fd-a 24)
                             (foreign-ref 'long $fd-a 32)
                             (foreign-ref 'unsigned-long $fd-a 0)
                             (foreign-ref 'unsigned-long $fd-a 8)
                             (foreign-ref 'unsigned-long $fd-a 16)
                             (foreign-ref 'unsigned-long $fd-a 24)
                             (foreign-ref 'unsigned-long $fd-a 32)))
                     `(#x-8000000000000000
                        0
                        #x7fffffffffffffff
                        #x-8000000000000000
                        -1
                        #x8000000000000000
                        0
                        #x7fffffffffffffff
                        #x8000000000000000
                        #xffffffffffffffff))
             (equal? (begin
                       (foreign-set!
                         'unsigned-long
                         $fd-a
                         0
                         #x-8000000000000000)
                       (foreign-set! 'unsigned-long $fd-a 8 0)
                       (foreign-set!
                         'unsigned-long
                         $fd-a
                         16
                         #x7fffffffffffffff)
                       (foreign-set!
                         'unsigned-long
                         $fd-a
                         24
                         #x8000000000000000)
                       (foreign-set!
                         'unsigned-long
                         $fd-a
                         32
                         #xffffffffffffffff)
                       (list (foreign-ref 'long $fd-a 0)
                             (foreign-ref 'long $fd-a 8)
                             (foreign-ref 'long $fd-a 16)
                             (foreign-ref 'long $fd-a 24)
                             (foreign-ref 'long $fd-a 32)
                             (foreign-ref 'unsigned-long $fd-a 0)
                             (foreign-ref 'unsigned-long $fd-a 8)
                             (foreign-ref 'unsigned-long $fd-a 16)
                             (foreign-ref 'unsigned-long $fd-a 24)
                             (foreign-ref 'unsigned-long $fd-a 32)))
                     `(#x-8000000000000000
                        0
                        #x7fffffffffffffff
                        #x-8000000000000000
                        -1
                        #x8000000000000000
                        0
                        #x7fffffffffffffff
                        #x8000000000000000
                        #xffffffffffffffff))
             (equal? (begin
                       (foreign-set! 'long $fd-a 16 #xabcd1234ffee8765)
                       (list (foreign-ref 'long $fd-a 16)
                             (foreign-ref 'unsigned-long $fd-a 16)
                             (if (eq? (native-endianness) 'little)
                                 (logor (foreign-ref 'unsigned-32 $fd-a 16) (ash (foreign-ref 'integer-32 $fd-a 20) 32))
                                 (logor (foreign-ref 'unsigned-32 $fd-a 20) (ash (foreign-ref 'integer-32 $fd-a 16) 32)))
                             (if (eq? (native-endianness) 'little)
                                 (logor (foreign-ref 'unsigned-32 $fd-a 16) (ash (foreign-ref 'unsigned-32 $fd-a 20) 32))
                                 (logor (foreign-ref 'unsigned-32 $fd-a 20) (ash (foreign-ref 'unsigned-32 $fd-a 16) 32)))))
                     `(,(- #xabcd1234ffee8765 #x10000000000000000)
                       #xabcd1234ffee8765
                       ,(- #xabcd1234ffee8765 #x10000000000000000)
                       #xabcd1234ffee8765))
             (equal? (begin
                       (foreign-set!
                         'unsigned-long
                         $fd-a
                         16
                         #x-765321ab4c8e9de1)
                       (list (foreign-ref 'long $fd-a 16)
                             (foreign-ref 'unsigned-long $fd-a 16)
                             (if (eq? (native-endianness) 'little)
                                 (logor (foreign-ref 'unsigned-32 $fd-a 16) (ash (foreign-ref 'integer-32 $fd-a 20) 32))
                                 (logor (foreign-ref 'unsigned-32 $fd-a 20) (ash (foreign-ref 'integer-32 $fd-a 16) 32)))
                             (if (eq? (native-endianness) 'little)
                                 (logor (foreign-ref 'unsigned-32 $fd-a 16) (ash (foreign-ref 'unsigned-32 $fd-a 20) 32))
                                 (logor (foreign-ref 'unsigned-32 $fd-a 20) (ash (foreign-ref 'unsigned-32 $fd-a 16) 32)))))
                     `(#x-765321ab4c8e9de1
                        ,(+ #x-765321ab4c8e9de1 #x10000000000000000)
                        #x-765321ab4c8e9de1
                        ,(+ #x-765321ab4c8e9de1 #x10000000000000000))))]
       [else
        (error 'foreign-data-mat "unexpected $fd-long-max ~s" $fd-long-max)])
     ; long-long/unsigned-long-long
     (error? ; invalid value for type
             (foreign-set! 'long-long $fd-a 0 17.0))
     (error? ; invalid value for type
       (foreign-set! 'long-long $fd-a 0 (- $fd-long-long-min 1)))
     (error? ; invalid value for type
       (foreign-set! 'long-long $fd-a 0 (+ $fd-long-long-max 1)))
     (error? ; invalid value for type
             (foreign-set! 'unsigned-long-long $fd-a 0 17.0))
     (error? ; invalid value for type
       (foreign-set! 'unsigned-long-long $fd-a 0 (- $fd-long-long-min 1)))
     (error? ; invalid value for type
       (foreign-set! 'unsigned-long-long $fd-a 0 (+ $fd-long-long-max 1)))
     (case $fd-long-long-max
       [(#xffffffffffffffff)
        (and (equal? (begin
                       (foreign-set!
                         'long-long
                         $fd-a
                         0
                         #x-8000000000000000)
                       (foreign-set! 'long-long $fd-a 8 0)
                       (foreign-set!
                         'long-long
                         $fd-a
                         16
                         #x7fffffffffffffff)
                       (foreign-set!
                         'long-long
                         $fd-a
                         24
                         #x8000000000000000)
                       (foreign-set!
                         'long-long
                         $fd-a
                         32
                         #xffffffffffffffff)
                       (list (foreign-ref 'long-long $fd-a 0)
                             (foreign-ref 'long-long $fd-a 8)
                             (foreign-ref 'long-long $fd-a 16)
                             (foreign-ref 'long-long $fd-a 24)
                             (foreign-ref 'long-long $fd-a 32)
                             (foreign-ref 'unsigned-long-long $fd-a 0)
                             (foreign-ref 'unsigned-long-long $fd-a 8)
                             (foreign-ref 'unsigned-long-long $fd-a 16)
                             (foreign-ref 'unsigned-long-long $fd-a 24)
                             (foreign-ref 'unsigned-long-long $fd-a 32)))
                     `(#x-8000000000000000
                        0
                        #x7fffffffffffffff
                        #x-8000000000000000
                        -1
                        #x8000000000000000
                        0
                        #x7fffffffffffffff
                        #x8000000000000000
                        #xffffffffffffffff))
             (equal? (begin
                       (foreign-set!
                         'unsigned-long-long
                         $fd-a
                         0
                         #x-8000000000000000)
                       (foreign-set! 'unsigned-long-long $fd-a 8 0)
                       (foreign-set!
                         'unsigned-long-long
                         $fd-a
                         16
                         #x7fffffffffffffff)
                       (foreign-set!
                         'unsigned-long-long
                         $fd-a
                         24
                         #x8000000000000000)
                       (foreign-set!
                         'unsigned-long-long
                         $fd-a
                         32
                         #xffffffffffffffff)
                       (list (foreign-ref 'long-long $fd-a 0)
                             (foreign-ref 'long-long $fd-a 8)
                             (foreign-ref 'long-long $fd-a 16)
                             (foreign-ref 'long-long $fd-a 24)
                             (foreign-ref 'long-long $fd-a 32)
                             (foreign-ref 'unsigned-long-long $fd-a 0)
                             (foreign-ref 'unsigned-long-long $fd-a 8)
                             (foreign-ref 'unsigned-long-long $fd-a 16)
                             (foreign-ref 'unsigned-long-long $fd-a 24)
                             (foreign-ref 'unsigned-long-long $fd-a 32)))
                     `(#x-8000000000000000
                        0
                        #x7fffffffffffffff
                        #x-8000000000000000
                        -1
                        #x8000000000000000
                        0
                        #x7fffffffffffffff
                        #x8000000000000000
                        #xffffffffffffffff))
             (equal? (begin
                       (foreign-set!
                         'long-long
                         $fd-a
                         16
                         #xabcd1234ffee8765)
                       (list (foreign-ref 'long-long $fd-a 16)
                             (foreign-ref 'unsigned-long-long $fd-a 16)
                             (if (eq? (native-endianness) 'little)
                                 (logor (foreign-ref 'unsigned-32 $fd-a 16) (ash (foreign-ref 'integer-32 $fd-a 20) 32))
                                 (logor (foreign-ref 'unsigned-32 $fd-a 20) (ash (foreign-ref 'integer-32 $fd-a 16) 32)))
                             (if (eq? (native-endianness) 'little)
                                 (logor (foreign-ref 'unsigned-32 $fd-a 16) (ash (foreign-ref 'unsigned-32 $fd-a 20) 32))
                                 (logor (foreign-ref 'unsigned-32 $fd-a 20) (ash (foreign-ref 'unsigned-32 $fd-a 16) 32)))))
                     `(,(- #xabcd1234ffee8765 #x10000000000000000)
                       #xabcd1234ffee8765
                       ,(- #xabcd1234ffee8765 #x10000000000000000)
                       #xabcd1234ffee8765))
             (equal? (begin
                       (foreign-set!
                         'unsigned-long-long
                         $fd-a
                         16
                         #x-765321ab4c8e9de1)
                       (list (foreign-ref 'long-long $fd-a 16)
                             (foreign-ref 'unsigned-long-long $fd-a 16)
                             (if (eq? (native-endianness) 'little)
                                 (logor (foreign-ref 'unsigned-32 $fd-a 16) (ash (foreign-ref 'integer-32 $fd-a 20) 32))
                                 (logor (foreign-ref 'unsigned-32 $fd-a 20) (ash (foreign-ref 'integer-32 $fd-a 16) 32)))
                             (if (eq? (native-endianness) 'little)
                                 (logor (foreign-ref 'unsigned-32 $fd-a 16) (ash (foreign-ref 'unsigned-32 $fd-a 20) 32))
                                 (logor (foreign-ref 'unsigned-32 $fd-a 20) (ash (foreign-ref 'unsigned-32 $fd-a 16) 32)))))
                     `(#x-765321ab4c8e9de1
                        ,(+ #x-765321ab4c8e9de1 #x10000000000000000)
                        #x-765321ab4c8e9de1
                        ,(+ #x-765321ab4c8e9de1 #x10000000000000000))))]
       [else
        (error 'foreign-data-mat
               "unexpected $fd-long-long-max ~s"
               $fd-long-long-max)])
     ; char
     (error? ; invalid value for type
             (foreign-set! 'char $fd-a 0 17))
     (error? ; invalid value for type
       (foreign-set! 'char $fd-a 0 (integer->char (+ $fd-char-max 1))))
     (case $fd-char-max
       [(#xff)
        (and (equal? (begin
                       (foreign-set! 'char $fd-a 2 #\xed)
                       (list (foreign-ref 'char $fd-a 2)
                             (foreign-ref 'unsigned-8 $fd-a 2)))
                     `(#\xed #xed))
             (equal? (begin
                       (foreign-set! 'char $fd-a 3 (integer->char 0))
                       (list (foreign-ref 'char $fd-a 3)
                             (foreign-ref 'unsigned-8 $fd-a 3)))
                     `(#\nul 0))
             (equal? (begin
                       (foreign-set!
                         'char
                         $fd-a
                         3
                         (integer->char $fd-char-max))
                       (list (foreign-ref 'char $fd-a 3)
                             (foreign-ref 'unsigned-8 $fd-a 3)))
                     `(,(integer->char $fd-char-max) ,$fd-char-max)))]
       [else
        (error 'foreign-data-mat "unexpected $fd-char-max ~s" $fd-char-max)])
     ; wchar
     (error? ; invalid value for type
             (foreign-set! 'wchar $fd-a 0 17))
     (or (= $fd-wchar-max #x10ffff)
         (guard (c [#t])
           (foreign-set!
             'wchar
             $fd-a
             0
             (integer->char (+ $fd-wchar-max 1)))
           #f))
     (case $fd-wchar-max
       [(#xffff)
        (and (equal? (begin
                       (foreign-set! 'wchar $fd-a 2 #\xedac)
                       (list (foreign-ref 'wchar $fd-a 2)
                             (foreign-ref 'unsigned-16 $fd-a 2)))
                     `(#\xedac #xedac))
             (equal? (begin
                       (foreign-set! 'wchar $fd-a 2 (integer->char 0))
                       (list (foreign-ref 'wchar $fd-a 2)
                             (foreign-ref 'unsigned-16 $fd-a 2)))
                     `(#\nul 0))
             (equal? (begin
                       (foreign-set!
                         'wchar
                         $fd-a
                         2
                         (integer->char $fd-wchar-max))
                       (list (foreign-ref 'wchar $fd-a 2)
                             (foreign-ref 'unsigned-16 $fd-a 2)))
                     `(,(integer->char $fd-wchar-max) ,$fd-wchar-max)))]
       [(#x10ffff)
        (and (equal? (begin
                       (foreign-set! 'wchar $fd-a 4 #\x10edac)
                       (list (foreign-ref 'wchar $fd-a 4)
                             (foreign-ref 'unsigned-32 $fd-a 4)))
                     `(#\x10edac #x10edac))
             (equal? (begin
                       (foreign-set! 'wchar $fd-a 4 (integer->char 0))
                       (list (foreign-ref 'wchar $fd-a 4)
                             (foreign-ref 'unsigned-32 $fd-a 4)))
                     `(#\nul 0))
             (equal? (begin
                       (foreign-set!
                         'wchar
                         $fd-a
                         4
                         (integer->char $fd-wchar-max))
                       (list (foreign-ref 'wchar $fd-a 4)
                             (foreign-ref 'unsigned-32 $fd-a 4)))
                     `(,(integer->char $fd-wchar-max) ,$fd-wchar-max)))]
       [else
        (error 'foreign-data-mat
               "unexpected $fd-wchar-max ~s"
               $fd-wchar-max)])
     ; boolean
     (equal? (begin
               (foreign-set! 'boolean $fd-a 0 #t)
               (foreign-set! 'boolean $fd-a 8 #f)
               (foreign-set! 'boolean $fd-a 16 0)
               (foreign-set! 'int $fd-a 24 64)
               (list (foreign-ref 'boolean $fd-a 0)
                     (foreign-ref 'boolean $fd-a 8)
                     (foreign-ref 'boolean $fd-a 16)
                     (foreign-ref 'boolean $fd-a 24)
                     (foreign-ref 'int $fd-a 0)
                     (foreign-ref 'int $fd-a 8)
                     (foreign-ref 'int $fd-a 16)
                     (foreign-ref 'int $fd-a 24)))
             '(#t #f #t #t 1 0 1 64))
     ; fixnum
     (error? ; invalid value for type
             (foreign-set! 'fixnum $fd-a 0 2/3))
     (error? ; invalid value for type
             (foreign-set! 'fixnum $fd-a 0 (+ (greatest-fixnum) 1)))
     (error? ; invalid value for type
             (foreign-set! 'fixnum $fd-a 0 (- (least-fixnum) 1)))
     (equal? (begin
               (foreign-set! 'fixnum $fd-a 0 (greatest-fixnum))
               (foreign-set! 'fixnum $fd-a 8 (least-fixnum))
               (foreign-set! 'fixnum $fd-a 16 0)
               (foreign-set!
                 'fixnum
                 $fd-a
                 24
                 (quotient (greatest-fixnum) 2))
               (list (foreign-ref 'fixnum $fd-a 0)
                     (foreign-ref 'fixnum $fd-a 8)
                     (foreign-ref 'fixnum $fd-a 16)
                     (foreign-ref 'fixnum $fd-a 24)))
             `(,(greatest-fixnum)
               ,(least-fixnum)
               0
               ,(quotient (greatest-fixnum) 2)))
     ; float / single-float
     (error? ; invalid value for type
             (foreign-set! 'float $fd-a 0 17))
     (error? ; invalid value for type
             (foreign-set! 'single-float $fd-a 0 17))
     (equal? (begin
               (foreign-set! 'float $fd-a 12 7.5)
               (list (foreign-ref 'float $fd-a 12)
                     (foreign-ref 'single-float $fd-a 12)))
             '(7.5 7.5))
     (equal? (begin
               (foreign-set! 'single-float $fd-a 12 7.5)
               (list (foreign-ref 'float $fd-a 12)
                     (foreign-ref 'single-float $fd-a 12)))
             '(7.5 7.5))
     ; double / double-float
     (error? ; invalid value for type
             (foreign-set! 'double $fd-a 0 17))
     (error? ; invalid value for type
             (foreign-set! 'double-float $fd-a 0 17))
     (equal? (begin
               (foreign-set! 'double $fd-a 8 -5.4)
               (list (foreign-ref 'double $fd-a 8)
                     (foreign-ref 'double-float $fd-a 8)))
             '(-5.4 -5.4))
     (equal? (begin
               (foreign-set! 'double-float $fd-a 8 -5.4)
               (list (foreign-ref 'double $fd-a 8)
                     (foreign-ref 'double-float $fd-a 8)))
             '(-5.4 -5.4))
     ; spot check unaligned ref/set
     (or (not $fd-unaligned-integers)
         (equal? (begin
                   (foreign-set! 'unsigned-32 $fd-a 13 #x-765321ab)
                   (list (foreign-ref 'integer-32 $fd-a 13)
                         (foreign-ref 'unsigned-32 $fd-a 13)))
                 `(#x-765321ab ,(+ #x-765321ab #x100000000))))
     (or (not $fd-unaligned-integers)
         (equal? (begin
                   (foreign-set! 'integer-64 $fd-a 17 #xabcd1234ffee8765)
                   (list (foreign-ref 'integer-64 $fd-a 17)
                         (foreign-ref 'unsigned-64 $fd-a 17)
                         (if (eq? (native-endianness) 'little)
                             (logor (foreign-ref 'unsigned-32 $fd-a 17) (ash (foreign-ref 'integer-32 $fd-a 21) 32))
                             (logor (foreign-ref 'unsigned-32 $fd-a 21) (ash (foreign-ref 'integer-32 $fd-a 17) 32)))
                         (if (eq? (native-endianness) 'little)
                             (logor (foreign-ref 'unsigned-32 $fd-a 17) (ash (foreign-ref 'unsigned-32 $fd-a 21) 32))
                             (logor (foreign-ref 'unsigned-32 $fd-a 21) (ash (foreign-ref 'unsigned-32 $fd-a 17) 32)))))
                 `(,(- #xabcd1234ffee8765 #x10000000000000000)
                   #xabcd1234ffee8765
                   ,(- #xabcd1234ffee8765 #x10000000000000000)
                   #xabcd1234ffee8765)))
     (or (not $fd-unaligned-integers)
         (case $fd-short-max
           [(#xffff)
            (and (equal? (begin
                           (foreign-set! 'short $fd-a 3 #xabcd)
                           (list (foreign-ref 'short $fd-a 3)
                                 (foreign-ref 'unsigned-short $fd-a 3)
                                 (foreign-ref 'integer-16 $fd-a 3)
                                 (foreign-ref 'unsigned-16 $fd-a 3)))
                         `(,(- #xabcd #x10000)
                           #xabcd
                           ,(- #xabcd #x10000)
                           #xabcd))
                 (equal? (begin
                           (foreign-set! 'unsigned-short $fd-a 3 -5321)
                           (list (foreign-ref 'short $fd-a 3)
                                 (foreign-ref 'unsigned-short $fd-a 3)
                                 (foreign-ref 'integer-16 $fd-a 3)
                                 (foreign-ref 'unsigned-16 $fd-a 3)))
                         `(-5321 ,(+ -5321 #x10000)
                                 -5321
                                 ,(+ -5321 #x10000))))]
           [else
            (error 'foreign-data-mat
                   "unexpected $fd-short-max ~s"
                   $fd-short-max)]))
     (or (not $fd-unaligned-floats)
         (equal? (begin
                   (foreign-set! 'float $fd-a 6 7.5)
                   (list (foreign-ref 'float $fd-a 6)
                         (foreign-ref 'single-float $fd-a 6)))
                 '(7.5 7.5)))
     (or (not $fd-unaligned-floats)
         (equal? (begin
                   (foreign-set! 'double-float $fd-a 5 -5.4)
                   (list (foreign-ref 'double $fd-a 5)
                         (foreign-ref 'double-float $fd-a 5)))
                 '(-5.4 -5.4)))
     ; $object-ref
     (equal? (begin
               (foreign-set! 'integer-8 $fd-a 3 255)
               (list (#%$object-ref 'integer-8 $raw-fd-a 3)
                     (#%$object-ref 'unsigned-8 $raw-fd-a 3)))
             '(-1 255))
     (equal? (begin
               (foreign-set! 'unsigned-8 $fd-a 5 -5)
               (list (#%$object-ref 'integer-8 $raw-fd-a 5)
                     (#%$object-ref 'unsigned-8 $raw-fd-a 5)))
             '(-5 251))
     (equal? (begin
               (foreign-set! 'integer-8 $fd-a 0 #x-80)
               (foreign-set! 'integer-8 $fd-a 1 0)
               (foreign-set! 'integer-8 $fd-a 2 #x7f)
               (foreign-set! 'integer-8 $fd-a 3 #x80)
               (foreign-set! 'integer-8 $fd-a 4 #xff)
               (list (#%$object-ref 'integer-8 $raw-fd-a 0)
                     (#%$object-ref 'integer-8 $raw-fd-a 1)
                     (#%$object-ref 'integer-8 $raw-fd-a 2)
                     (#%$object-ref 'integer-8 $raw-fd-a 3)
                     (#%$object-ref 'integer-8 $raw-fd-a 4)
                     (#%$object-ref 'unsigned-8 $raw-fd-a 0)
                     (#%$object-ref 'unsigned-8 $raw-fd-a 1)
                     (#%$object-ref 'unsigned-8 $raw-fd-a 2)
                     (#%$object-ref 'unsigned-8 $raw-fd-a 3)
                     (#%$object-ref 'unsigned-8 $raw-fd-a 4)))
             `(#x-80 0 #x7f #x-80 -1 #x80 0 #x7f #x80 #xff))
     (equal? (begin
               (foreign-set! 'unsigned-8 $fd-a 0 #x-80)
               (foreign-set! 'unsigned-8 $fd-a 1 0)
               (foreign-set! 'unsigned-8 $fd-a 2 #x7f)
               (foreign-set! 'unsigned-8 $fd-a 3 #x80)
               (foreign-set! 'unsigned-8 $fd-a 4 #xff)
               (list (#%$object-ref 'integer-8 $raw-fd-a 0)
                     (#%$object-ref 'integer-8 $raw-fd-a 1)
                     (#%$object-ref 'integer-8 $raw-fd-a 2)
                     (#%$object-ref 'integer-8 $raw-fd-a 3)
                     (#%$object-ref 'integer-8 $raw-fd-a 4)
                     (#%$object-ref 'unsigned-8 $raw-fd-a 0)
                     (#%$object-ref 'unsigned-8 $raw-fd-a 1)
                     (#%$object-ref 'unsigned-8 $raw-fd-a 2)
                     (#%$object-ref 'unsigned-8 $raw-fd-a 3)
                     (#%$object-ref 'unsigned-8 $raw-fd-a 4)))
             `(#x-80 0 #x7f #x-80 -1 #x80 0 #x7f #x80 #xff))
     ; integer-16/unsigned-16
     (equal? (begin
               (foreign-set! 'integer-16 $fd-a 2 #xabcd)
               (list (#%$object-ref 'integer-16 $raw-fd-a 2)
                     (#%$object-ref 'unsigned-16 $raw-fd-a 2)))
             `(,(- #xabcd #x10000) #xabcd))
     (equal? (begin
               (foreign-set! 'unsigned-16 $fd-a 2 -5321)
               (list (#%$object-ref 'integer-16 $raw-fd-a 2)
                     (#%$object-ref 'unsigned-16 $raw-fd-a 2)))
             `(-5321 ,(+ -5321 #x10000)))
     (equal? (begin
               (foreign-set! 'integer-16 $fd-a 0 #x-8000)
               (foreign-set! 'integer-16 $fd-a 2 0)
               (foreign-set! 'integer-16 $fd-a 4 #x7fff)
               (foreign-set! 'integer-16 $fd-a 6 #x8000)
               (foreign-set! 'integer-16 $fd-a 8 #xffff)
               (list (#%$object-ref 'integer-16 $raw-fd-a 0)
                     (#%$object-ref 'integer-16 $raw-fd-a 2)
                     (#%$object-ref 'integer-16 $raw-fd-a 4)
                     (#%$object-ref 'integer-16 $raw-fd-a 6)
                     (#%$object-ref 'integer-16 $raw-fd-a 8)
                     (#%$object-ref 'unsigned-16 $raw-fd-a 0)
                     (#%$object-ref 'unsigned-16 $raw-fd-a 2)
                     (#%$object-ref 'unsigned-16 $raw-fd-a 4)
                     (#%$object-ref 'unsigned-16 $raw-fd-a 6)
                     (#%$object-ref 'unsigned-16 $raw-fd-a 8)))
             `(#x-8000 0 #x7fff #x-8000 -1 #x8000 0 #x7fff #x8000 #xffff))
     (equal? (begin
               (foreign-set! 'unsigned-16 $fd-a 0 #x-8000)
               (foreign-set! 'unsigned-16 $fd-a 2 0)
               (foreign-set! 'unsigned-16 $fd-a 4 #x7fff)
               (foreign-set! 'unsigned-16 $fd-a 6 #x8000)
               (foreign-set! 'unsigned-16 $fd-a 8 #xffff)
               (list (#%$object-ref 'integer-16 $raw-fd-a 0)
                     (#%$object-ref 'integer-16 $raw-fd-a 2)
                     (#%$object-ref 'integer-16 $raw-fd-a 4)
                     (#%$object-ref 'integer-16 $raw-fd-a 6)
                     (#%$object-ref 'integer-16 $raw-fd-a 8)
                     (#%$object-ref 'unsigned-16 $raw-fd-a 0)
                     (#%$object-ref 'unsigned-16 $raw-fd-a 2)
                     (#%$object-ref 'unsigned-16 $raw-fd-a 4)
                     (#%$object-ref 'unsigned-16 $raw-fd-a 6)
                     (#%$object-ref 'unsigned-16 $raw-fd-a 8)))
             `(#x-8000 0 #x7fff #x-8000 -1 #x8000 0 #x7fff #x8000 #xffff))
     ; integer-32/unsigned-32
     (equal? (begin
               (foreign-set! 'integer-32 $fd-a 0 #x-80000000)
               (foreign-set! 'integer-32 $fd-a 4 0)
               (foreign-set! 'integer-32 $fd-a 8 #x7fffffff)
               (foreign-set! 'integer-32 $fd-a 12 #x80000000)
               (foreign-set! 'integer-32 $fd-a 16 #xffffffff)
               (list (#%$object-ref 'integer-32 $raw-fd-a 0)
                     (#%$object-ref 'integer-32 $raw-fd-a 4)
                     (#%$object-ref 'integer-32 $raw-fd-a 8)
                     (#%$object-ref 'integer-32 $raw-fd-a 12)
                     (#%$object-ref 'integer-32 $raw-fd-a 16)
                     (#%$object-ref 'unsigned-32 $raw-fd-a 0)
                     (#%$object-ref 'unsigned-32 $raw-fd-a 4)
                     (#%$object-ref 'unsigned-32 $raw-fd-a 8)
                     (#%$object-ref 'unsigned-32 $raw-fd-a 12)
                     (#%$object-ref 'unsigned-32 $raw-fd-a 16)))
             `(#x-80000000
                0
                #x7fffffff
                #x-80000000
                -1
                #x80000000
                0
                #x7fffffff
                #x80000000
                #xffffffff))
     (equal? (begin
               (foreign-set! 'unsigned-32 $fd-a 0 #x-80000000)
               (foreign-set! 'unsigned-32 $fd-a 4 0)
               (foreign-set! 'unsigned-32 $fd-a 8 #x7fffffff)
               (foreign-set! 'unsigned-32 $fd-a 12 #x80000000)
               (foreign-set! 'unsigned-32 $fd-a 16 #xffffffff)
               (list (#%$object-ref 'integer-32 $raw-fd-a 0)
                     (#%$object-ref 'integer-32 $raw-fd-a 4)
                     (#%$object-ref 'integer-32 $raw-fd-a 8)
                     (#%$object-ref 'integer-32 $raw-fd-a 12)
                     (#%$object-ref 'integer-32 $raw-fd-a 16)
                     (#%$object-ref 'unsigned-32 $raw-fd-a 0)
                     (#%$object-ref 'unsigned-32 $raw-fd-a 4)
                     (#%$object-ref 'unsigned-32 $raw-fd-a 8)
                     (#%$object-ref 'unsigned-32 $raw-fd-a 12)
                     (#%$object-ref 'unsigned-32 $raw-fd-a 16)))
             `(#x-80000000
                0
                #x7fffffff
                #x-80000000
                -1
                #x80000000
                0
                #x7fffffff
                #x80000000
                #xffffffff))
     (equal? (begin
               (foreign-set! 'integer-32 $fd-a 12 #xabcd1234)
               (list (#%$object-ref 'integer-32 $raw-fd-a 12)
                     (#%$object-ref 'unsigned-32 $raw-fd-a 12)))
             `(,(- #xabcd1234 #x100000000) #xabcd1234))
     (equal? (begin
               (foreign-set! 'unsigned-32 $fd-a 12 #x-765321ab)
               (list (#%$object-ref 'integer-32 $raw-fd-a 12)
                     (#%$object-ref 'unsigned-32 $raw-fd-a 12)))
             `(#x-765321ab ,(+ #x-765321ab #x100000000)))
     ; integer-64/unsigned-64
     (equal? (begin
               (foreign-set! 'integer-64 $fd-a 16 #xabcd1234ffee8765)
               (list (#%$object-ref 'integer-64 $raw-fd-a 16)
                     (#%$object-ref 'unsigned-64 $raw-fd-a 16)
                     (if (eq? (native-endianness) 'little)
                         (logor (#%$object-ref 'unsigned-32 $raw-fd-a 16) (ash (#%$object-ref 'integer-32 $raw-fd-a 20) 32))
                         (logor (#%$object-ref 'unsigned-32 $raw-fd-a 20) (ash (#%$object-ref 'integer-32 $raw-fd-a 16) 32)))
                     (if (eq? (native-endianness) 'little)
                         (logor (#%$object-ref 'unsigned-32 $raw-fd-a 16) (ash (#%$object-ref 'unsigned-32 $raw-fd-a 20) 32))
                         (logor (#%$object-ref 'unsigned-32 $raw-fd-a 20) (ash (#%$object-ref 'unsigned-32 $raw-fd-a 16) 32)))))
             `(,(- #xabcd1234ffee8765 #x10000000000000000)
               #xabcd1234ffee8765
               ,(- #xabcd1234ffee8765 #x10000000000000000)
               #xabcd1234ffee8765))
     (equal? (begin
               (foreign-set! 'unsigned-64 $fd-a 16 #x-765321ab4c8e9de1)
               (list (#%$object-ref 'integer-64 $raw-fd-a 16)
                     (#%$object-ref 'unsigned-64 $raw-fd-a 16)
                     (if (eq? (native-endianness) 'little)
                         (logor (#%$object-ref 'unsigned-32 $raw-fd-a 16) (ash (#%$object-ref 'integer-32 $raw-fd-a 20) 32))
                         (logor (#%$object-ref 'unsigned-32 $raw-fd-a 20) (ash (#%$object-ref 'integer-32 $raw-fd-a 16) 32)))
                     (if (eq? (native-endianness) 'little)
                         (logor (#%$object-ref 'unsigned-32 $raw-fd-a 16) (ash (#%$object-ref 'unsigned-32 $raw-fd-a 20) 32))
                         (logor (#%$object-ref 'unsigned-32 $raw-fd-a 20) (ash (#%$object-ref 'unsigned-32 $raw-fd-a 16) 32)))))
             `(#x-765321ab4c8e9de1
                ,(+ #x-765321ab4c8e9de1 #x10000000000000000)
                #x-765321ab4c8e9de1
                ,(+ #x-765321ab4c8e9de1 #x10000000000000000)))
     (equal? (begin
               (foreign-set! 'integer-64 $fd-a 0 #x-8000000000000000)
               (foreign-set! 'integer-64 $fd-a 8 0)
               (foreign-set! 'integer-64 $fd-a 16 #x7fffffffffffffff)
               (foreign-set! 'integer-64 $fd-a 24 #x8000000000000000)
               (foreign-set! 'integer-64 $fd-a 32 #xffffffffffffffff)
               (list (#%$object-ref 'integer-64 $raw-fd-a 0)
                     (#%$object-ref 'integer-64 $raw-fd-a 8)
                     (#%$object-ref 'integer-64 $raw-fd-a 16)
                     (#%$object-ref 'integer-64 $raw-fd-a 24)
                     (#%$object-ref 'integer-64 $raw-fd-a 32)
                     (#%$object-ref 'unsigned-64 $raw-fd-a 0)
                     (#%$object-ref 'unsigned-64 $raw-fd-a 8)
                     (#%$object-ref 'unsigned-64 $raw-fd-a 16)
                     (#%$object-ref 'unsigned-64 $raw-fd-a 24)
                     (#%$object-ref 'unsigned-64 $raw-fd-a 32)))
             `(#x-8000000000000000
                0
                #x7fffffffffffffff
                #x-8000000000000000
                -1
                #x8000000000000000
                0
                #x7fffffffffffffff
                #x8000000000000000
                #xffffffffffffffff))
     (equal? (begin
               (foreign-set! 'unsigned-64 $fd-a 0 #x-8000000000000000)
               (foreign-set! 'unsigned-64 $fd-a 8 0)
               (foreign-set! 'unsigned-64 $fd-a 16 #x7fffffffffffffff)
               (foreign-set! 'unsigned-64 $fd-a 24 #x8000000000000000)
               (foreign-set! 'unsigned-64 $fd-a 32 #xffffffffffffffff)
               (list (#%$object-ref 'integer-64 $raw-fd-a 0)
                     (#%$object-ref 'integer-64 $raw-fd-a 8)
                     (#%$object-ref 'integer-64 $raw-fd-a 16)
                     (#%$object-ref 'integer-64 $raw-fd-a 24)
                     (#%$object-ref 'integer-64 $raw-fd-a 32)
                     (#%$object-ref 'unsigned-64 $raw-fd-a 0)
                     (#%$object-ref 'unsigned-64 $raw-fd-a 8)
                     (#%$object-ref 'unsigned-64 $raw-fd-a 16)
                     (#%$object-ref 'unsigned-64 $raw-fd-a 24)
                     (#%$object-ref 'unsigned-64 $raw-fd-a 32)))
             `(#x-8000000000000000
                0
                #x7fffffffffffffff
                #x-8000000000000000
                -1
                #x8000000000000000
                0
                #x7fffffffffffffff
                #x8000000000000000
                #xffffffffffffffff))
     ; fixnum
     (equal? (begin
               (foreign-set! 'fixnum $fd-a 0 (greatest-fixnum))
               (foreign-set! 'fixnum $fd-a 8 (least-fixnum))
               (foreign-set! 'fixnum $fd-a 16 0)
               (foreign-set!
                 'fixnum
                 $fd-a
                 24
                 (quotient (greatest-fixnum) 2))
               (list (#%$object-ref 'fixnum $raw-fd-a 0)
                     (#%$object-ref 'fixnum $raw-fd-a 8)
                     (#%$object-ref 'fixnum $raw-fd-a 16)
                     (#%$object-ref 'fixnum $raw-fd-a 24)))
             `(,(greatest-fixnum)
               ,(least-fixnum)
               0
               ,(quotient (greatest-fixnum) 2)))
     ; single-float
     (equal? (begin
               (foreign-set! 'single-float $fd-a 12 7.5)
               (#%$object-ref 'single-float $raw-fd-a 12))
             7.5)
     ; double-float
     (equal? (begin
               (foreign-set! 'double-float $fd-a 8 -5.4)
               (#%$object-ref 'double-float $raw-fd-a 8))
             -5.4)
     ; spot check unaligned ref/set
     (or (not $fd-unaligned-integers)
         (equal? (begin
                   (foreign-set! 'unsigned-32 $fd-a 13 #x-765321ab)
                   (list (#%$object-ref 'integer-32 $raw-fd-a 13)
                         (#%$object-ref 'unsigned-32 $raw-fd-a 13)))
                 `(#x-765321ab ,(+ #x-765321ab #x100000000))))
     (or (not $fd-unaligned-integers)
         (equal? (begin
                   (foreign-set! 'integer-64 $fd-a 17 #xabcd1234ffee8765)
                   (list (#%$object-ref 'integer-64 $raw-fd-a 17)
                         (#%$object-ref 'unsigned-64 $raw-fd-a 17)
                         (if (eq? (native-endianness) 'little)
                             (logor (#%$object-ref 'unsigned-32 $raw-fd-a 17) (ash (#%$object-ref 'integer-32 $raw-fd-a 21) 32))
                             (logor (#%$object-ref 'unsigned-32 $raw-fd-a 21) (ash (#%$object-ref 'integer-32 $raw-fd-a 17) 32)))
                         (if (eq? (native-endianness) 'little)
                             (logor (#%$object-ref 'unsigned-32 $raw-fd-a 17) (ash (#%$object-ref 'unsigned-32 $raw-fd-a 21) 32))
                             (logor (#%$object-ref 'unsigned-32 $raw-fd-a 21) (ash (#%$object-ref 'unsigned-32 $raw-fd-a 17) 32)))))
                 `(,(- #xabcd1234ffee8765 #x10000000000000000)
                   #xabcd1234ffee8765
                   ,(- #xabcd1234ffee8765 #x10000000000000000)
                   #xabcd1234ffee8765)))
     (or (not $fd-unaligned-integers)
         (case $fd-short-max
           [(#xffff)
            (and (equal? (begin
                           (foreign-set! 'short $fd-a 3 #xabcd)
                           (list (#%$object-ref 'short $raw-fd-a 3)
                                 (#%$object-ref 'unsigned-short $raw-fd-a 3)
                                 (#%$object-ref 'integer-16 $raw-fd-a 3)
                                 (#%$object-ref 'unsigned-16 $raw-fd-a 3)))
                         `(,(- #xabcd #x10000)
                           #xabcd
                           ,(- #xabcd #x10000)
                           #xabcd))
                 (equal? (begin
                           (foreign-set! 'unsigned-short $fd-a 3 -5321)
                           (list (#%$object-ref 'short $raw-fd-a 3)
                                 (#%$object-ref 'unsigned-short $raw-fd-a 3)
                                 (#%$object-ref 'integer-16 $raw-fd-a 3)
                                 (#%$object-ref 'unsigned-16 $raw-fd-a 3)))
                         `(-5321 ,(+ -5321 #x10000)
                                 -5321
                                 ,(+ -5321 #x10000))))]
           [else
            (error 'foreign-data-mat
                   "unexpected $fd-short-max ~s"
                   $fd-short-max)]))
     (or (not $fd-unaligned-floats)
         (equal? (begin
                   (foreign-set! 'single-float $fd-a 6 7.5)
                   (#%$object-ref 'single-float $raw-fd-a 6))
                 7.5))
     (or (not $fd-unaligned-floats)
         (equal? (begin
                   (foreign-set! 'double-float $fd-a 5 -5.4)
                   (#%$object-ref 'double-float $raw-fd-a 5))
                 -5.4))

     ; $object-set!
     (equal? (begin
               (#%$object-set! 'integer-8 $raw-fd-a 3 255)
               (list (foreign-ref 'integer-8 $fd-a 3)
                     (foreign-ref 'unsigned-8 $fd-a 3)))
             '(-1 255))
     (equal? (begin
               (#%$object-set! 'unsigned-8 $raw-fd-a 5 -5)
               (list (foreign-ref 'integer-8 $fd-a 5)
                     (foreign-ref 'unsigned-8 $fd-a 5)))
             '(-5 251))
     (equal? (begin
               (#%$object-set! 'integer-8 $raw-fd-a 0 #x-80)
               (#%$object-set! 'integer-8 $raw-fd-a 1 0)
               (#%$object-set! 'integer-8 $raw-fd-a 2 #x7f)
               (#%$object-set! 'integer-8 $raw-fd-a 3 #x80)
               (#%$object-set! 'integer-8 $raw-fd-a 4 #xff)
               (list (foreign-ref 'integer-8 $fd-a 0)
                     (foreign-ref 'integer-8 $fd-a 1)
                     (foreign-ref 'integer-8 $fd-a 2)
                     (foreign-ref 'integer-8 $fd-a 3)
                     (foreign-ref 'integer-8 $fd-a 4)
                     (foreign-ref 'unsigned-8 $fd-a 0)
                     (foreign-ref 'unsigned-8 $fd-a 1)
                     (foreign-ref 'unsigned-8 $fd-a 2)
                     (foreign-ref 'unsigned-8 $fd-a 3)
                     (foreign-ref 'unsigned-8 $fd-a 4)))
             `(#x-80 0 #x7f #x-80 -1 #x80 0 #x7f #x80 #xff))
     (equal? (begin
               (#%$object-set! 'unsigned-8 $raw-fd-a 0 #x-80)
               (#%$object-set! 'unsigned-8 $raw-fd-a 1 0)
               (#%$object-set! 'unsigned-8 $raw-fd-a 2 #x7f)
               (#%$object-set! 'unsigned-8 $raw-fd-a 3 #x80)
               (#%$object-set! 'unsigned-8 $raw-fd-a 4 #xff)
               (list (foreign-ref 'integer-8 $fd-a 0)
                     (foreign-ref 'integer-8 $fd-a 1)
                     (foreign-ref 'integer-8 $fd-a 2)
                     (foreign-ref 'integer-8 $fd-a 3)
                     (foreign-ref 'integer-8 $fd-a 4)
                     (foreign-ref 'unsigned-8 $fd-a 0)
                     (foreign-ref 'unsigned-8 $fd-a 1)
                     (foreign-ref 'unsigned-8 $fd-a 2)
                     (foreign-ref 'unsigned-8 $fd-a 3)
                     (foreign-ref 'unsigned-8 $fd-a 4)))
             `(#x-80 0 #x7f #x-80 -1 #x80 0 #x7f #x80 #xff))
     ; integer-16/unsigned-16
     (equal? (begin
               (#%$object-set! 'integer-16 $raw-fd-a 2 #xabcd)
               (list (foreign-ref 'integer-16 $fd-a 2)
                     (foreign-ref 'unsigned-16 $fd-a 2)))
             `(,(- #xabcd #x10000) #xabcd))
     (equal? (begin
               (#%$object-set! 'unsigned-16 $raw-fd-a 2 -5321)
               (list (foreign-ref 'integer-16 $fd-a 2)
                     (foreign-ref 'unsigned-16 $fd-a 2)))
             `(-5321 ,(+ -5321 #x10000)))
     (equal? (begin
               (#%$object-set! 'integer-16 $raw-fd-a 0 #x-8000)
               (#%$object-set! 'integer-16 $raw-fd-a 2 0)
               (#%$object-set! 'integer-16 $raw-fd-a 4 #x7fff)
               (#%$object-set! 'integer-16 $raw-fd-a 6 #x8000)
               (#%$object-set! 'integer-16 $raw-fd-a 8 #xffff)
               (list (foreign-ref 'integer-16 $fd-a 0)
                     (foreign-ref 'integer-16 $fd-a 2)
                     (foreign-ref 'integer-16 $fd-a 4)
                     (foreign-ref 'integer-16 $fd-a 6)
                     (foreign-ref 'integer-16 $fd-a 8)
                     (foreign-ref 'unsigned-16 $fd-a 0)
                     (foreign-ref 'unsigned-16 $fd-a 2)
                     (foreign-ref 'unsigned-16 $fd-a 4)
                     (foreign-ref 'unsigned-16 $fd-a 6)
                     (foreign-ref 'unsigned-16 $fd-a 8)))
             `(#x-8000 0 #x7fff #x-8000 -1 #x8000 0 #x7fff #x8000 #xffff))
     (equal? (begin
               (#%$object-set! 'unsigned-16 $raw-fd-a 0 #x-8000)
               (#%$object-set! 'unsigned-16 $raw-fd-a 2 0)
               (#%$object-set! 'unsigned-16 $raw-fd-a 4 #x7fff)
               (#%$object-set! 'unsigned-16 $raw-fd-a 6 #x8000)
               (#%$object-set! 'unsigned-16 $raw-fd-a 8 #xffff)
               (list (foreign-ref 'integer-16 $fd-a 0)
                     (foreign-ref 'integer-16 $fd-a 2)
                     (foreign-ref 'integer-16 $fd-a 4)
                     (foreign-ref 'integer-16 $fd-a 6)
                     (foreign-ref 'integer-16 $fd-a 8)
                     (foreign-ref 'unsigned-16 $fd-a 0)
                     (foreign-ref 'unsigned-16 $fd-a 2)
                     (foreign-ref 'unsigned-16 $fd-a 4)
                     (foreign-ref 'unsigned-16 $fd-a 6)
                     (foreign-ref 'unsigned-16 $fd-a 8)))
             `(#x-8000 0 #x7fff #x-8000 -1 #x8000 0 #x7fff #x8000 #xffff))
     ; integer-32/unsigned-32
     (equal? (begin
               (#%$object-set! 'integer-32 $raw-fd-a 0 #x-80000000)
               (#%$object-set! 'integer-32 $raw-fd-a 4 0)
               (#%$object-set! 'integer-32 $raw-fd-a 8 #x7fffffff)
               (#%$object-set! 'integer-32 $raw-fd-a 12 #x80000000)
               (#%$object-set! 'integer-32 $raw-fd-a 16 #xffffffff)
               (list (foreign-ref 'integer-32 $fd-a 0)
                     (foreign-ref 'integer-32 $fd-a 4)
                     (foreign-ref 'integer-32 $fd-a 8)
                     (foreign-ref 'integer-32 $fd-a 12)
                     (foreign-ref 'integer-32 $fd-a 16)
                     (foreign-ref 'unsigned-32 $fd-a 0)
                     (foreign-ref 'unsigned-32 $fd-a 4)
                     (foreign-ref 'unsigned-32 $fd-a 8)
                     (foreign-ref 'unsigned-32 $fd-a 12)
                     (foreign-ref 'unsigned-32 $fd-a 16)))
             `(#x-80000000
                0
                #x7fffffff
                #x-80000000
                -1
                #x80000000
                0
                #x7fffffff
                #x80000000
                #xffffffff))
     (equal? (begin
               (#%$object-set! 'unsigned-32 $raw-fd-a 0 #x-80000000)
               (#%$object-set! 'unsigned-32 $raw-fd-a 4 0)
               (#%$object-set! 'unsigned-32 $raw-fd-a 8 #x7fffffff)
               (#%$object-set! 'unsigned-32 $raw-fd-a 12 #x80000000)
               (#%$object-set! 'unsigned-32 $raw-fd-a 16 #xffffffff)
               (list (foreign-ref 'integer-32 $fd-a 0)
                     (foreign-ref 'integer-32 $fd-a 4)
                     (foreign-ref 'integer-32 $fd-a 8)
                     (foreign-ref 'integer-32 $fd-a 12)
                     (foreign-ref 'integer-32 $fd-a 16)
                     (foreign-ref 'unsigned-32 $fd-a 0)
                     (foreign-ref 'unsigned-32 $fd-a 4)
                     (foreign-ref 'unsigned-32 $fd-a 8)
                     (foreign-ref 'unsigned-32 $fd-a 12)
                     (foreign-ref 'unsigned-32 $fd-a 16)))
             `(#x-80000000
                0
                #x7fffffff
                #x-80000000
                -1
                #x80000000
                0
                #x7fffffff
                #x80000000
                #xffffffff))
     (equal? (begin
               (#%$object-set! 'integer-32 $raw-fd-a 12 #xabcd1234)
               (list (foreign-ref 'integer-32 $fd-a 12)
                     (foreign-ref 'unsigned-32 $fd-a 12)))
             `(,(- #xabcd1234 #x100000000) #xabcd1234))
     (equal? (begin
               (#%$object-set! 'unsigned-32 $raw-fd-a 12 #x-765321ab)
               (list (foreign-ref 'integer-32 $fd-a 12)
                     (foreign-ref 'unsigned-32 $fd-a 12)))
             `(#x-765321ab ,(+ #x-765321ab #x100000000)))
     ; integer-64/unsigned-64
     (equal? (begin
               (#%$object-set! 'integer-64 $raw-fd-a 16 #xabcd1234ffee8765)
               (list (foreign-ref 'integer-64 $fd-a 16)
                     (foreign-ref 'unsigned-64 $fd-a 16)
                     (if (eq? (native-endianness) 'little)
                         (logor (foreign-ref 'unsigned-32 $fd-a 16) (ash (foreign-ref 'integer-32 $fd-a 20) 32))
                         (logor (foreign-ref 'unsigned-32 $fd-a 20) (ash (foreign-ref 'integer-32 $fd-a 16) 32)))
                     (if (eq? (native-endianness) 'little)
                         (logor (foreign-ref 'unsigned-32 $fd-a 16) (ash (foreign-ref 'unsigned-32 $fd-a 20) 32))
                         (logor (foreign-ref 'unsigned-32 $fd-a 20) (ash (foreign-ref 'unsigned-32 $fd-a 16) 32)))))
             `(,(- #xabcd1234ffee8765 #x10000000000000000)
               #xabcd1234ffee8765
               ,(- #xabcd1234ffee8765 #x10000000000000000)
               #xabcd1234ffee8765))
     (equal? (begin
               (#%$object-set!
                 'unsigned-64
                 $raw-fd-a
                 16
                 #x-765321ab4c8e9de1)
               (list (foreign-ref 'integer-64 $fd-a 16)
                     (foreign-ref 'unsigned-64 $fd-a 16)
                     (if (eq? (native-endianness) 'little)
                         (logor (foreign-ref 'unsigned-32 $fd-a 16) (ash (foreign-ref 'integer-32 $fd-a 20) 32))
                         (logor (foreign-ref 'unsigned-32 $fd-a 20) (ash (foreign-ref 'integer-32 $fd-a 16) 32)))
                     (if (eq? (native-endianness) 'little)
                         (logor (foreign-ref 'unsigned-32 $fd-a 16) (ash (foreign-ref 'unsigned-32 $fd-a 20) 32))
                         (logor (foreign-ref 'unsigned-32 $fd-a 20) (ash (foreign-ref 'unsigned-32 $fd-a 16) 32)))))
             `(#x-765321ab4c8e9de1
                ,(+ #x-765321ab4c8e9de1 #x10000000000000000)
                #x-765321ab4c8e9de1
                ,(+ #x-765321ab4c8e9de1 #x10000000000000000)))
     (equal? (begin
               (#%$object-set! 'integer-64 $raw-fd-a 0 #x-8000000000000000)
               (#%$object-set! 'integer-64 $raw-fd-a 8 0)
               (#%$object-set! 'integer-64 $raw-fd-a 16 #x7fffffffffffffff)
               (#%$object-set! 'integer-64 $raw-fd-a 24 #x8000000000000000)
               (#%$object-set! 'integer-64 $raw-fd-a 32 #xffffffffffffffff)
               (list (foreign-ref 'integer-64 $fd-a 0)
                     (foreign-ref 'integer-64 $fd-a 8)
                     (foreign-ref 'integer-64 $fd-a 16)
                     (foreign-ref 'integer-64 $fd-a 24)
                     (foreign-ref 'integer-64 $fd-a 32)
                     (foreign-ref 'unsigned-64 $fd-a 0)
                     (foreign-ref 'unsigned-64 $fd-a 8)
                     (foreign-ref 'unsigned-64 $fd-a 16)
                     (foreign-ref 'unsigned-64 $fd-a 24)
                     (foreign-ref 'unsigned-64 $fd-a 32)))
             `(#x-8000000000000000
                0
                #x7fffffffffffffff
                #x-8000000000000000
                -1
                #x8000000000000000
                0
                #x7fffffffffffffff
                #x8000000000000000
                #xffffffffffffffff))
     (equal? (begin
               (#%$object-set!
                 'unsigned-64
                 $raw-fd-a
                 0
                 #x-8000000000000000)
               (#%$object-set! 'unsigned-64 $raw-fd-a 8 0)
               (#%$object-set!
                 'unsigned-64
                 $raw-fd-a
                 16
                 #x7fffffffffffffff)
               (#%$object-set!
                 'unsigned-64
                 $raw-fd-a
                 24
                 #x8000000000000000)
               (#%$object-set!
                 'unsigned-64
                 $raw-fd-a
                 32
                 #xffffffffffffffff)
               (list (foreign-ref 'integer-64 $fd-a 0)
                     (foreign-ref 'integer-64 $fd-a 8)
                     (foreign-ref 'integer-64 $fd-a 16)
                     (foreign-ref 'integer-64 $fd-a 24)
                     (foreign-ref 'integer-64 $fd-a 32)
                     (foreign-ref 'unsigned-64 $fd-a 0)
                     (foreign-ref 'unsigned-64 $fd-a 8)
                     (foreign-ref 'unsigned-64 $fd-a 16)
                     (foreign-ref 'unsigned-64 $fd-a 24)
                     (foreign-ref 'unsigned-64 $fd-a 32)))
             `(#x-8000000000000000
                0
                #x7fffffffffffffff
                #x-8000000000000000
                -1
                #x8000000000000000
                0
                #x7fffffffffffffff
                #x8000000000000000
                #xffffffffffffffff))
     ; fixnum
     (equal? (begin
               (#%$object-set! 'fixnum $raw-fd-a 0 (greatest-fixnum))
               (#%$object-set! 'fixnum $raw-fd-a 8 (least-fixnum))
               (#%$object-set! 'fixnum $raw-fd-a 16 0)
               (#%$object-set!
                 'fixnum
                 $raw-fd-a
                 24
                 (quotient (greatest-fixnum) 2))
               (list (foreign-ref 'fixnum $fd-a 0)
                     (foreign-ref 'fixnum $fd-a 8)
                     (foreign-ref 'fixnum $fd-a 16)
                     (foreign-ref 'fixnum $fd-a 24)))
             `(,(greatest-fixnum)
               ,(least-fixnum)
               0
               ,(quotient (greatest-fixnum) 2)))
     ; single-float
     (equal? (begin
               (#%$object-set! 'single-float $raw-fd-a 12 7.5)
               (foreign-ref 'single-float $fd-a 12))
             7.5)
     ; double-float
     (equal? (begin
               (#%$object-set! 'double-float $raw-fd-a 8 -5.4)
               (foreign-ref 'double-float $fd-a 8))
             -5.4)
     ; spot check unaligned ref/set
     (or (not $fd-unaligned-integers)
         (equal? (begin
                   (#%$object-set! 'unsigned-32 $raw-fd-a 13 #x-765321ab)
                   (list (foreign-ref 'integer-32 $fd-a 13)
                         (foreign-ref 'unsigned-32 $fd-a 13)))
                 `(#x-765321ab ,(+ #x-765321ab #x100000000))))
     (or (not $fd-unaligned-integers)
         (equal? (begin
                   (#%$object-set!
                     'integer-64
                     $raw-fd-a
                     17
                     #xabcd1234ffee8765)
                   (list (foreign-ref 'integer-64 $fd-a 17)
                         (foreign-ref 'unsigned-64 $fd-a 17)
                         (if (eq? (native-endianness) 'little)
                             (logor (foreign-ref 'unsigned-32 $fd-a 17) (ash (foreign-ref 'integer-32 $fd-a 21) 32))
                             (logor (foreign-ref 'unsigned-32 $fd-a 21) (ash (foreign-ref 'integer-32 $fd-a 17) 32)))
                         (if (eq? (native-endianness) 'little)
                             (logor (foreign-ref 'unsigned-32 $fd-a 17) (ash (foreign-ref 'unsigned-32 $fd-a 21) 32))
                             (logor (foreign-ref 'unsigned-32 $fd-a 21) (ash (foreign-ref 'unsigned-32 $fd-a 17) 32)))))
                 `(,(- #xabcd1234ffee8765 #x10000000000000000)
                   #xabcd1234ffee8765
                   ,(- #xabcd1234ffee8765 #x10000000000000000)
                   #xabcd1234ffee8765)))
     (or (not $fd-unaligned-integers)
         (case $fd-short-max
           [(#xffff)
            (and (equal? (begin
                           (#%$object-set! 'short $raw-fd-a 3 #xabcd)
                           (list (foreign-ref 'short $fd-a 3)
                                 (foreign-ref 'unsigned-short $fd-a 3)
                                 (foreign-ref 'integer-16 $fd-a 3)
                                 (foreign-ref 'unsigned-16 $fd-a 3)))
                         `(,(- #xabcd #x10000)
                           #xabcd
                           ,(- #xabcd #x10000)
                           #xabcd))
                 (equal? (begin
                           (#%$object-set! 'unsigned-short $raw-fd-a 3 -5321)
                           (list (foreign-ref 'short $fd-a 3)
                                 (foreign-ref 'unsigned-short $fd-a 3)
                                 (foreign-ref 'integer-16 $fd-a 3)
                                 (foreign-ref 'unsigned-16 $fd-a 3)))
                         `(-5321 ,(+ -5321 #x10000)
                                 -5321
                                 ,(+ -5321 #x10000))))]
           [else
            (error 'foreign-data-mat
                   "unexpected $fd-short-max ~s"
                   $fd-short-max)]))
     (or (not $fd-unaligned-floats)
         (equal? (begin
                   (#%$object-set! 'single-float $raw-fd-a 6 7.5)
                   (foreign-ref 'single-float $fd-a 6))
                 7.5))
     (or (not $fd-unaligned-floats)
         (equal? (begin
                   (#%$object-set! 'double-float $raw-fd-a 5 -5.4)
                   (foreign-ref 'double-float $fd-a 5))
                 -5.4))

     ; this needs to be done last
     (begin
       (set! $raw-fd-a #f)
       (set! $fd-a #f)
       (foreign-free $real-fd-a)
       (set! $real-fd-a #f)
       #t))

(mat $integer-xxx?
     (not (#%$integer-8? 'a))
     (not (#%$integer-16? '3.4))
     (not (#%$integer-32? '3/4))
     (not (#%$integer-64? '4+3i))
     (not (#%$integer-8?
            #x-10000000000000000000000000000000000000000000000000000000000000000))
     (not (#%$integer-8? #x-81))
     (#%$integer-8? #x-80)
     (#%$integer-8? #x-1)
     (#%$integer-8? #x7f)
     (#%$integer-8? #x80)
     (#%$integer-8? #xff)
     (not (#%$integer-8? #x100))
     (not (#%$integer-8?
            #x+10000000000000000000000000000000000000000000000000000000000000000))
     (not (#%$integer-16?
            #x-10000000000000000000000000000000000000000000000000000000000000000))
     (not (#%$integer-16? #x-8001))
     (#%$integer-16? #x-8000)
     (#%$integer-16? #x-1)
     (#%$integer-16? #x7fff)
     (#%$integer-16? #x8000)
     (#%$integer-16? #xffff)
     (not (#%$integer-16? #x10000))
     (not (#%$integer-16?
            #x+10000000000000000000000000000000000000000000000000000000000000000))
     (not (#%$integer-32?
            #x-10000000000000000000000000000000000000000000000000000000000000000))
     (not (#%$integer-32? #x-80000001))
     (#%$integer-32? #x-80000000)
     (#%$integer-32? #x-1)
     (#%$integer-32? #x7fffffff)
     (#%$integer-32? #x80000000)
     (#%$integer-32? #xffffffff)
     (not (#%$integer-32? #x100000000))
     (not (#%$integer-32?
            #x+10000000000000000000000000000000000000000000000000000000000000000))
     (not (#%$integer-64?
            #x-10000000000000000000000000000000000000000000000000000000000000000))
     (not (#%$integer-64? #x-8000000000000001))
     (#%$integer-64? #x-8000000000000000)
     (#%$integer-64? #x-1)
     (#%$integer-64? #x7fffffffffffffff)
     (#%$integer-64? #x8000000000000000)
     (#%$integer-64? #xffffffffffffffff)
     (not (#%$integer-64? #x10000000000000000))
     (not (#%$integer-64?
            #x+10000000000000000000000000000000000000000000000000000000000000000)))

(mat object-address
     (equal? (with-interrupts-disabled ; or lock r
               (let ()
                 (import $system)
                 (define-syntax record-field-address
                   (lambda (x)
                     (define-syntax datum
                       (syntax-rules ()
                         [(_ x) (syntax-object->datum #'x)]))
                     (define rtd-flds
                       (csv7:record-field-accessor
                         (record-rtd (make-record-type "foo" '()))
                         'flds))
                     ; fld structure is vector:  #5(fld name mutable type offset)
                     (define fld-check
                       (lambda (who x)
                         (unless (and (vector? x)
                                      (= (vector-length x) 5)
                                      (eq? (vector-ref x 0) 'fld))
                                 (errorf who "~s is not a fld" x))))
                     (define fld-name
                       (lambda (x)
                         (fld-check 'fld-name x)
                         (vector-ref x 1)))
                     (define fld-mutable?
                       (lambda (x)
                         (fld-check 'fld-mutable? x)
                         (vector-ref x 2)))
                     (define fld-type
                       (lambda (x)
                         (fld-check 'fld-type x)
                         (vector-ref x 3)))
                     (define fld-byte
                       (lambda (x)
                         (fld-check 'fld-byte x)
                         (vector-ref x 4)))
                     (syntax-case x ()
                       [(_ recid record field-name)
                        (and (identifier? #'recid)
                             (identifier? #'field-name))
                        (lambda (r)
                          (let ([rinfo (r #'recid)])
                            (unless (and (pair? rinfo)
                                         (eq? (car rinfo) '#{record val9xfsq6oa12q4-a})
                                         (record-type-descriptor? (cadr rinfo)))
                                    (syntax-error #'recid "unrecognized record"))
                            (let ([rtd (cadr rinfo)])
                              (with-syntax
                                ([offset (or (let ([field-name (datum field-name)])
                                               (ormap (lambda (fld)
                                                        (and (eq? (fld-name fld) field-name)
                                                             (fld-byte fld)))
                                                      (rtd-flds rtd)))
                                             (syntax-error
                                               "unrecognized field name"
                                               #'field-name))])
                                #'($object-address record offset)))))])))
                 (define-record foo ((integer-32 x) (double-float y)))
                 (let* ([r (make-foo 666 66.6)]
                        [x (record-field-address foo r x)]
                        [y (record-field-address foo r y)])
                   (let ([t1 (foreign-ref 'integer-32 x 0)]
                         [t2 (foreign-ref 'double-float y 0)])
                     (foreign-set! 'integer-32 x 0 -1)
                     (foreign-set! 'double-float y 0 .25)
                     (list t1 t2 (foo-x r) (foo-y r))))))
             '(666 66.6 -1 .25))
     (#%$address-in-heap? (#%$object-address cons 0))
     (not (#%$address-in-heap? 0)))

(mat record-inheritance
     (equal? (let ()
               (define-record soy ([double-float milk]))
               (define-record toast soy (y))
               (let ([x (make-toast #0=3.4 #1="hello")])
                 (list (soy-milk x) (toast-y x))))
             '(#0# #1#))
     (equivalent-expansion? ; optimize-level 2 expansion of above
       (parameterize
         ([optimize-level 2]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(let ()
              (define-record soy ([double-float milk]))
              (define-record toast soy (y))
              (let ([x (make-toast 3.4 "hello")])
                (list (soy-milk x) (toast-y x))))))
       `(let ([x (let ([y (#3%$record ',record-type-descriptor? . ,list?)])
                   (#3%$object-set! 'double-float y ,fixnum? 3.4)
                   y)])
          (#2%list (#3%$object-ref 'double-float x ,fixnum?)
                   (#3%$object-ref 'scheme-object x ,fixnum?))))
     (equivalent-expansion? ; optimize-level 3 expansion of above
       (parameterize
         ([optimize-level 3]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(let ()
              (define-record soy ([double-float milk]))
              (define-record toast soy (y))
              (let ([x (make-toast 3.4 "hello")])
                (list (soy-milk x) (toast-y x))))))
       `(let ([x (let ([y (#3%$record ',record-type-descriptor? . ,list?)])
                   (#3%$object-set! 'double-float y ,fixnum? 3.4)
                   y)])
          (#3%list (#3%$object-ref 'double-float x ,fixnum?)
                   (#3%$object-ref 'scheme-object x ,fixnum?))))
     (let ()
       (define-record p (x))
       (define-record c p (x))
       (let ()
         (define prtd (record-rtd (make-p 1)))
         (define crtd (record-rtd (make-c 1 2)))
         (let ()
           (define px1a
             (csv7:record-field-accessor prtd 'x))
           (define px1b (csv7:record-field-accessor prtd 0))
           (define cx1b (csv7:record-field-accessor crtd 0))
           (define cx2a
             (csv7:record-field-accessor crtd 'x))
           (define cx2b (csv7:record-field-accessor crtd 1))
           (define d1 (cons 1 2))
           (define d2 (cons 3 4))
           (let ()
             (define r (make-c d1 d2))
             (and (eq? (p-x r) d1)
                  (eq? (px1a r) (p-x r))
                  (eq? (px1b r) (p-x r))
                  (eq? (cx1b r) (p-x r))
                  (eq? (c-x r) d2)
                  (eq? (cx2a r) (c-x r))
                  (eq? (cx2b r) (c-x r)))))))
     (let ()
       (define-record p (x))
       (define-record c p (x))
       (record-reader 'c (record-rtd (make-c 1 2)))
       (let ([r1 (read (open-input-string "#[c #0=(a b) #0#]"))]
             [r2 (read (open-input-string "#0=#[c #0# 0]"))]
             [r3 (read (open-input-string "#0=#[c 0 #0#]"))]
             [r4 (read (open-input-string "#0=#[c #0# #0#]"))])
         (and (eq? (p-x r1) (c-x r1))
              (eq? (p-x r2) r2)
              (eq? (c-x r2) 0)
              (eq? (p-x r3) 0)
              (eq? (c-x r3) r3)
              (eq? (p-x r4) r4)
              (eq? (c-x r4) r4))))
     (equivalent-expansion? ; optimize-level 3 expansion of above
       (parameterize
         ([optimize-level 3]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(let ()
              (define-record p (x))
              (define-record c p (x))
              (record-reader 'c (record-rtd (make-c 1 2)))
              (let ([r1 (read (open-input-string "#[c #0=(a b) #0#]"))]
                    [r2 (read (open-input-string "#0=#[c #0# 0]"))]
                    [r3 (read (open-input-string "#0=#[c 0 #0#]"))]
                    [r4 (read (open-input-string "#0=#[c #0# #0#]"))])
                (and (eq? (p-x r1) (c-x r1))
                     (eq? (p-x r2) r2)
                     (eq? (c-x r2) 0)
                     (eq? (p-x r3) 0)
                     (eq? (c-x r3) r3)
                     (eq? (p-x r4) r4)
                     (eq? (c-x r4) r4))))))
       `(begin
          (#3%record-reader 'c ',record-type-descriptor?)
          (let ([r1 (#3%read (#3%open-input-string "#[c #0=(a b) #0#]"))]
                [r2 (#3%read (#3%open-input-string "#0=#[c #0# 0]"))]
                [r3 (#3%read (#3%open-input-string "#0=#[c 0 #0#]"))]
                [r4 (#3%read (#3%open-input-string "#0=#[c #0# #0#]"))])
            (if (#3%eq? (#3%$object-ref 'scheme-object r1 ,fixnum?)
                        (#3%$object-ref 'scheme-object r1 ,fixnum?))
                (if (#3%eq? (#3%$object-ref 'scheme-object r2 ,fixnum?) r2)
                    (if (#3%eq? (#3%$object-ref 'scheme-object r2 ,fixnum?)
                                0)
                        (if (#3%eq? (#3%$object-ref 'scheme-object r3 ,fixnum?)
                                    0)
                            (if (#3%eq? (#3%$object-ref 'scheme-object r3 ,fixnum?)
                                        r3)
                                (if (#3%eq? (#3%$object-ref 'scheme-object r4 ,fixnum?)
                                            r4)
                                    (#3%eq? (#3%$object-ref 'scheme-object r4 ,fixnum?)
                                            r4)
                                    #f)
                                #f)
                            #f)
                        #f)
                    #f)
                #f)))))

(mat record-writer
     (begin
       (define-record $froz (a b) ([c (+ a b)]))
       (define-record $fruz $froz (d))
       (define-record $friz $fruz ())
       (define-record $fraz $friz ())
       (record-writer (type-descriptor $fraz)
         (lambda (x p wr) (display "<fraz>" p)))
       (record-writer (type-descriptor $froz)
         (lambda (x p wr)
           (wr `(* hi john ,($froz-c x) *) p)))
       (and (equal? (format "~s" (make-$froz 17 23)) "(* hi john 40 *)")
            (equal? (format "~s" (make-$fruz 17 24 37)) "(* hi john 41 *)")
            (equal? (format "~s" (make-$friz 17 25 38)) "(* hi john 42 *)")
            (equal? (format "~s" (make-$fraz 17 26 39)) "<fraz>")))
     (begin
       (record-writer (type-descriptor $froz)
         (lambda (x p wr)
           (fprintf p "<$froz c=~s>" ($froz-c x))))
       (and (equal? (format "~s" (make-$froz 18 23)) "<$froz c=41>")
            (equal? (format "~s" (make-$fruz 18 24 37)) "<$froz c=42>")
            (equal? (format "~s" (make-$friz 18 25 38)) "<$froz c=43>")
            (equal? (format "~s" (make-$fraz 18 26 39)) "<fraz>")))
     (begin
       (record-writer (type-descriptor $fruz)
         (lambda (x p wr)
           (fprintf p "<$fruz d=~s>" ($fruz-d x))))
       (and (equal? (format "~s" (make-$froz 19 23)) "<$froz c=42>")
            (equal? (format "~s" (make-$fruz 19 24 37)) "<$fruz d=37>")
            (equal? (format "~s" (make-$friz 19 25 38)) "<$fruz d=38>")
            (equal? (format "~s" (make-$fraz 18 26 39)) "<fraz>")))
     (let ()
       (define-record pair
         ((mutable car) (immutable cdr))
         ()
         ((constructor cons) (prefix "")))
       (record-writer (type-descriptor pair)
         (lambda (x p wr)
           (display "(" p)
           ; )
           (wr (car x) p)
           (display " . " p)
           (wr (cdr x) p)
           ; (
           (display ")" p)))
       (and (pair? (cons 3 4))
            (not (pair? '(3 . 4)))
            (eq? (car (cons 3 4)) 3)
            (eq? (cdr (cons 3 4)) 4)
            (equal? (format "~s" (cons 3 (cons 4 '()))) "(3 . (4 . ()))")
            (let ((x (cons 3 4)))
              (set-car! x x)
              (equal? (format "~s" x) "#0=(#0# . 4)")))))

(mat record-equal/hash
     (begin
       (define (equiv? v1 v2)
         (and (equal? v1 v2)
              (= (equal-hash v1) (equal-hash v2))
              (let ([ht (make-hashtable equal-hash equal?)])
                (hashtable-set! ht v1 "yes")
                (equal? "yes" (hashtable-ref ht v2 "no")))))
       (define (not-equiv? v1 v2)
         (and (not (equal? v1 v2))
              (let ([ht (make-hashtable equal-hash equal?)])
                (hashtable-set! ht v1 "yes")
                (equal? "no" (hashtable-ref ht v2 "no")))))

       (define-record-type E+H$a
         (fields (mutable x) (immutable y)))

       (define-record-type E+H$a+
         (parent E+H$a)
         (fields (mutable z)))

       (define-record-type E+H$b
         (fields (immutable x) (mutable y))
         (opaque #t))

       (define-record-type E+H$b+
         (parent E+H$b)
         (fields (mutable z))
         (opaque #t))

       (define (E+H$a-equal? a1 a2 eql?)
         (eql? (E+H$a-x a1) (E+H$a-x a2)))
       (define (E+H$a-hash a hc) (hc (E+H$a-x a)))

       (define (E+H$b-equal? b1 b2 eql?)
         (eql? (E+H$b-y b1) (E+H$b-y b2)))
       (define (E+H$b-hash b hc) (hc (E+H$b-y b)))

       (define cyclic-E+H$a1 (make-E+H$a 1 2))
       (E+H$a-x-set! cyclic-E+H$a1 cyclic-E+H$a1)
       (define cyclic-E+H$a2 (make-E+H$a 1 2))
       (E+H$a-x-set! cyclic-E+H$a2 cyclic-E+H$a2)

       (define cyclic-E+H$b+1 (make-E+H$b+ 1 2 3))
       (define cyclic-E+H$b+2 (make-E+H$b+ 1 2 3))
       (E+H$b-y-set! cyclic-E+H$b+1 (list 1 2 3 (box cyclic-E+H$b+2)))
       (E+H$b-y-set! cyclic-E+H$b+2 (list 1 2 3 (box cyclic-E+H$b+1)))

       #t)

     (not-equiv? (make-E+H$a 1 2) (make-E+H$a 1 2))
     (not-equiv? (make-E+H$b 1 2) (make-E+H$b 1 2))

     (not (record-type-equal-procedure (record-type-descriptor E+H$a)))
     (not (record-type-hash-procedure (record-type-descriptor E+H$a)))
     (not (record-type-equal-procedure (record-type-descriptor E+H$a+)))
     (not (record-type-hash-procedure (record-type-descriptor E+H$a+)))
     (not (record-type-equal-procedure (record-type-descriptor E+H$b+)))
     (not (record-type-hash-procedure (record-type-descriptor E+H$b+)))
     (not (record-type-equal-procedure (record-type-descriptor E+H$b)))
     (not (record-type-hash-procedure (record-type-descriptor E+H$b)))

     (begin
       (record-type-equal-procedure
         (record-type-descriptor E+H$a)
         E+H$a-equal?)
       (record-type-hash-procedure
         (record-type-descriptor E+H$a)
         E+H$a-hash)
       #t)

     (eq? (record-type-equal-procedure (record-type-descriptor E+H$a))
          E+H$a-equal?)
     (eq? (record-type-hash-procedure (record-type-descriptor E+H$a))
          E+H$a-hash)
     (not (record-type-equal-procedure (record-type-descriptor E+H$a+)))
     (not (record-type-hash-procedure (record-type-descriptor E+H$a+)))
     (eq? (record-equal-procedure (make-E+H$a 1 2) (make-E+H$a 1 2))
          E+H$a-equal?)
     (eq? (record-equal-procedure (make-E+H$a+ 1 3 5) (make-E+H$a 1 2))
          E+H$a-equal?)
     (eq? (record-equal-procedure (make-E+H$a 1 2) (make-E+H$a+ 1 3 5))
          E+H$a-equal?)
     (eq? (record-equal-procedure (make-E+H$a+ 1 3 5) (make-E+H$a+ 1 3 5))
          E+H$a-equal?)
     (eq? (record-hash-procedure (make-E+H$a 1 2)) E+H$a-hash)
     (eq? (record-hash-procedure (make-E+H$a+ 1 3 5)) E+H$a-hash)
     (not (record-type-equal-procedure (record-type-descriptor E+H$a+)))
     (not (record-type-hash-procedure (record-type-descriptor E+H$a+)))
     (equiv? (make-E+H$a 1 2) (make-E+H$a 1 2))
     (equiv? (make-E+H$a 1 2) (make-E+H$a 1 3))
     (equiv? (make-E+H$a 1 2) (make-E+H$a+ 1 3 5))
     (equiv? (make-E+H$a+ 1 3 5) (make-E+H$a 1 2))
     (not-equiv? (make-E+H$a+ 2 3 5) (make-E+H$a 1 2))
     (not-equiv? (make-E+H$a+ 2 3 5) (make-E+H$a+ 1 2 4))

     (not (equiv? (make-E+H$a 1 2) (make-E+H$b 1 2)))

     (not-equiv? (make-E+H$b 1 2) (make-E+H$b 1 2))
     (not-equiv? (make-E+H$b+ 1 2 3) (make-E+H$b+ 1 2 3))

     (not (record-type-equal-procedure (record-type-descriptor E+H$b+)))
     (not (record-type-hash-procedure (record-type-descriptor E+H$b+)))
     (not (record-type-equal-procedure (record-type-descriptor E+H$b)))
     (not (record-type-hash-procedure (record-type-descriptor E+H$b)))

     (begin
       (record-type-equal-procedure
         (record-type-descriptor E+H$b+)
         E+H$b-equal?)
       (record-type-hash-procedure
         (record-type-descriptor E+H$b+)
         E+H$b-hash)
       #t)

     (not-equiv? (make-E+H$b 1 2) (make-E+H$b 1 2))
     (equiv? (make-E+H$b+ 0 2 4) (make-E+H$b+ 1 2 3))

     (equiv? cyclic-E+H$a1 cyclic-E+H$a2)
     (equiv? cyclic-E+H$a1 (make-E+H$a cyclic-E+H$a2 3))

     (equiv? cyclic-E+H$b+1 cyclic-E+H$b+2)

     (begin
       (record-type-equal-procedure
         (record-type-descriptor E+H$a+)
         E+H$a-equal?)
       (record-type-hash-procedure
         (record-type-descriptor E+H$a+)
         E+H$a-hash)
       #t)

     (eq? (record-type-equal-procedure (record-type-descriptor E+H$a))
          E+H$a-equal?)
     (eq? (record-type-hash-procedure (record-type-descriptor E+H$a))
          E+H$a-hash)

     (equiv? (make-E+H$a+ 1 2 4) (make-E+H$a+ 1 3 5))
     (not-equiv? (make-E+H$a+ 1 3 5) (make-E+H$a 1 2))
     (not-equiv? (make-E+H$a 1 2) (make-E+H$a+ 1 3 5))

     (begin
       (record-type-equal-procedure
         (record-type-descriptor E+H$a)
         E+H$a-equal?)
       (record-type-hash-procedure
         (record-type-descriptor E+H$a)
         E+H$a-hash)
       #t)

     (not (record-equal-procedure (make-E+H$a+ 1 3 5) (make-E+H$a 1 2)))

     (equiv? (make-E+H$a+ 1 2 4) (make-E+H$a+ 1 3 5))
     (not-equiv? (make-E+H$a+ 1 3 5) (make-E+H$a 1 2))
     (not-equiv? (make-E+H$a 1 2) (make-E+H$a+ 1 3 5))

     (begin
       (record-type-equal-procedure (record-type-descriptor E+H$a+) #f)
       (record-type-hash-procedure (record-type-descriptor E+H$a+) #f)
       #t)

     (not (record-type-equal-procedure (record-type-descriptor E+H$a+)))
     (not (record-type-hash-procedure (record-type-descriptor E+H$a+)))

     (eq? (record-equal-procedure (make-E+H$a+ 1 3 5) (make-E+H$a 1 2))
          E+H$a-equal?)
     (eq? (record-hash-procedure (make-E+H$a+ 1 3 5)) E+H$a-hash)

     (equiv? (make-E+H$a+ 1 3 5) (make-E+H$a 1 2))
     (equiv? (make-E+H$a 1 2) (make-E+H$a+ 1 3 5))
     (equiv? (make-E+H$a+ 1 2 4) (make-E+H$a+ 1 3 5))

     (error? ; not an rtd
             (record-type-equal-procedure 7))
     (error? ; not an rtd
       (record-type-equal-procedure 7 (lambda (x y e?) #f)))
     (error? ; not a procedure or #f
       (record-type-equal-procedure (record-type-descriptor E+H$a+) 7))
     (error? ; not an rtd
             (record-type-hash-procedure 7))
     (error? ; not an rtd
       (record-type-hash-procedure 7 (lambda (x y e?) #f)))
     (error? ; not a procedure or #f
       (record-type-hash-procedure (record-type-descriptor E+H$a+) 7))
     (error? ; not a record
       (record-equal-procedure 7 (make-E+H$a 1 2)))
     (error? ; not a record
       (record-equal-procedure (make-E+H$a 1 2) 7))
     (error? ; not a record
             (record-hash-procedure 7))

     ; csug examples
     (begin (define-record marble (color quality)) #t)

     (not (record-type-equal-procedure (record-type-descriptor marble)))
     (not (equal? (make-marble 'blue 'medium) (make-marble 'blue 'medium)))
     (not (equal? (make-marble 'blue 'medium) (make-marble 'blue 'high)))

     ; Treat marbles as equal when they have the same color
     (begin
       (record-type-equal-procedure (record-type-descriptor marble)
         (lambda (m1 m2 eql?)
           (eql? (marble-color m1) (marble-color m2))))
       (record-type-hash-procedure (record-type-descriptor marble)
         (lambda (m hash) (hash (marble-color m))))
       #t)

     (equal? (make-marble 'blue 'medium) (make-marble 'blue 'high))
     (not (equal? (make-marble 'red 'high) (make-marble 'blue 'high)))

     (begin
       (define ht (make-hashtable equal-hash equal?))
       (hashtable-set! ht (make-marble 'blue 'medium) "glass")
       #t)

     (equal? (hashtable-ref ht (make-marble 'blue 'high) #f) "glass")

     (begin (define-record shooter marble (size)) #t)

     (equal? (make-marble 'blue 'medium) (make-shooter 'blue 'large 17))
     ;=> #t
     (equal? (make-shooter 'blue 'large 17) (make-marble 'blue 'medium))
     ;=> #t
     (equal? (hashtable-ref ht (make-shooter 'blue 'high 17) #f) "glass")

     (begin
       (define-record-type node
         (nongenerative)
         (fields (mutable left) (mutable right)))
       (record-type-equal-procedure (record-type-descriptor node)
         (lambda (x y e?)
           (and (e? (node-left x) (node-left y))
                (e? (node-right x) (node-right y)))))
       (record-type-hash-procedure (record-type-descriptor marble)
         (lambda (x hash)
           (+ (hash (node-left x)) (hash (node-right x)) 23)))
       (define graph1
         (let ([x (make-node "a" (make-node #f "b"))])
           (node-left-set! (node-right x) x)
           x))
       (define graph2
         (let ([x (make-node "a" (make-node (make-node "a" #f) "b"))])
           (node-right-set! (node-left (node-right x)) (node-right x))
           x))
       (define graph3
         (let ([x (make-node "a" (make-node #f "c"))])
           (node-left-set! (node-right x) x)
           x))
       #t)

     (equal? graph1 graph2)
     (not (equal? graph1 graph3))
     (not (equal? graph2 graph3))

     (begin
       (define h (make-hashtable equal-hash equal?))
       (hashtable-set! h graph1 #t)
       #t)

     (hashtable-ref h graph1 #f)
     (hashtable-ref h graph2 #f)
     (not (hashtable-ref h graph3 #f))

     (begin
       (define record-hash
         (lambda (x hash)
           (let ([rtd (record-rtd x)])
             (do ([field-name* (csv7:record-type-field-names rtd)
                    (cdr field-name*)]
                  [i 0 (fx+ i 1)]
                  [h 0 (+ h (hash ((csv7:record-field-accessor rtd i) x)))])
                 ((null? field-name*) h)))))
       (define record-equal?
         (lambda (x y e?)
           (let ([rtd (record-rtd x)])
             (and (eq? (record-rtd y) rtd)
                  (let f ([field-name* (csv7:record-type-field-names rtd)] [i 0])
                    (or (null? field-name*)
                        (and (let ([accessor (csv7:record-field-accessor rtd i)])
                               (e? (accessor x) (accessor y)))
                             (f (cdr field-name*) (fx+ i 1)))))))))
       (define equiv?
         (lambda (x y)
           (parameterize ([default-record-equal-procedure record-equal?])
             (equal? x y))))
       (define equiv-hash
         (lambda (x)
           (parameterize ([default-record-hash-procedure record-hash])
             (equal-hash x))))
       (define-record-type frob (fields (mutable q)))
       (define-record-type frub (fields (mutable x) y z))
       (define frob-hash
         (lambda (x hash) (raise 'frob-hash)))
       (define frob-equal? (lambda (x y e?) #f))
       (define rthp
         (lambda (rtd)
           (case-lambda
             [() (record-type-hash-procedure rtd)]
             [(x) (record-type-hash-procedure rtd x)])))
       (define rtep
         (lambda (rtd)
           (case-lambda
             [() (record-type-equal-procedure rtd)]
             [(x) (record-type-equal-procedure rtd x)])))
       #t)
     (not (record-type-equal-procedure (record-type-descriptor frob)))
     (not (record-type-hash-procedure (record-type-descriptor frob)))
     (not (record-type-equal-procedure (record-type-descriptor frub)))
     (not (record-type-hash-procedure (record-type-descriptor frub)))
     (equal? (parameterize
               ([(rthp (record-type-descriptor frob)) record-hash])
               (list (record-hash-procedure (make-frob #\q))
                     (record-hash-procedure (make-frub 1 2 3))))
             (list record-hash #f))
     (equal? (parameterize
               ([(rtep (record-type-descriptor frob)) record-equal?])
               (list (record-equal-procedure (make-frub 1 2 3)
                       (make-frub 1 2 3))
                     (record-equal-procedure (make-frub 1 2 3)
                       (make-frob #\q))
                     (record-equal-procedure (make-frob #\q)
                       (make-frub 1 2 3))
                     (record-equal-procedure (make-frob #\q)
                       (make-frob #\q))))
             (list #f #f #f record-equal?))
     (equal? (parameterize ([default-record-hash-procedure record-hash])
               (list (record-hash-procedure (make-frob #\q))
                     (record-hash-procedure (make-frub 1 2 3))))
             (list record-hash record-hash))
     (equal? (parameterize ([default-record-equal-procedure record-equal?])
               (list (record-equal-procedure (make-frub 1 2 3)
                       (make-frub 1 2 3))
                     (record-equal-procedure (make-frub 1 2 3)
                       (make-frob #\q))
                     (record-equal-procedure (make-frob #\q)
                       (make-frub 1 2 3))
                     (record-equal-procedure (make-frob #\q)
                       (make-frob #\q))))
             (list record-equal? record-equal? record-equal? record-equal?))
     (equal? (parameterize
               ([default-record-hash-procedure record-hash]
                [(rthp (record-type-descriptor frob)) frob-hash])
               (list (record-hash-procedure (make-frob #\q))
                     (record-hash-procedure (make-frub 1 2 3))))
             (list frob-hash record-hash))
     (equal? (parameterize
               ([default-record-equal-procedure record-equal?]
                [(rtep (record-type-descriptor frob)) frob-equal?])
               (list (record-equal-procedure (make-frub 1 2 3)
                       (make-frub 1 2 3))
                     (record-equal-procedure (make-frub 1 2 3)
                       (make-frob #\q))
                     (record-equal-procedure (make-frob #\q)
                       (make-frub 1 2 3))
                     (record-equal-procedure (make-frob #\q)
                       (make-frob #\q))))
             (list record-equal? #f #f frob-equal?))
     ((lambda (x) (and (integer? x) (exact? x) (nonnegative? x)))
      (parameterize ([default-record-hash-procedure record-hash])
        (equal-hash (vector 1 2 (make-frub 1 2 3) 5 (make-frob #\q) 7))))
     (eq? (guard (c [(eq? c 'frob-hash) 'yup] [else (raise c)])
            (parameterize
              ([default-record-hash-procedure record-hash]
               [(rthp (record-type-descriptor frob)) frob-hash])
              (equal-hash (list "hello" (make-frob #\q)))))
          'yup)
     ((lambda (x) (and (integer? x) (exact? x) (nonnegative? x)))
      (parameterize
        ([default-record-hash-procedure record-hash]
         [(rthp (record-type-descriptor frob)) frob-hash])
        (equal-hash (vector 1 2 (make-frub 1 2 3) 5 6))))
     (equiv? (make-frob #\q) (make-frob #\q))
     (equiv? (make-frub 1 2 3) (make-frub 1 2 3))
     (not (parameterize
            ([(rtep (record-type-descriptor frob)) frob-equal?])
            (equiv? (make-frob #\q) (make-frob #\q))))
     (parameterize ([(rtep (record-type-descriptor frob)) frob-equal?])
       (equiv? (make-frub 1 2 3) (make-frub 1 2 3)))
     (equal? (let ([ht (make-hashtable equiv-hash equiv?)])
               (hashtable-set! ht (make-frob #\q) 'one)
               (hashtable-set! ht (make-frub 1 2 3) 'two)
               (hashtable-set! ht (make-frub 'a 'b 'c) 'three)
               (list (hashtable-ref ht (make-frob #\q) #f)
                     (hashtable-ref ht (make-frub 1 2 3) #f)
                     (hashtable-ref ht (make-frub 'a 'b 'c) #f)
                     (hashtable-ref ht (make-frub 'x 'y 'z) #f)))
             '(one two three #f)))

(mat record19 ; test ellipses in init expressions
     (equal? (let ()
               (define-record foo
                 ()
                 ([a (let ()
                       (define-syntax f
                         (syntax-rules ()
                           [(_ b ...) (list 'b ...)]))
                       (f 1 2 3))]))
               (foo-a (make-foo)))
             '(1 2 3)))

(mat record20
     ; test argument-name handing in generated record constructors
     (equal? (let ()
               (define foo
                 (make-record-type "foo"
                   '((integer-32 fixnum?) (double-float flonum?) unless unless)))
               (let ()
                 (define make-foo (record-constructor foo))
                 (define foo? (record-predicate foo))
                 (define foo.0
                   (csv7:record-field-accessor foo 'fixnum?))
                 (define foo.1
                   (csv7:record-field-accessor foo 'flonum?))
                 (define foo.2
                   (csv7:record-field-accessor foo 2))
                 (define foo.3
                   (csv7:record-field-accessor foo 3))
                 (let ([x (make-foo 1 3.0 'a 'b)])
                   (list (foo? x) (foo.0 x) (foo.1 x) (foo.2 x) (foo.3 x)))))
             '(#t 1 3.0 a b))
     (equal? (let ([foo (make-record-type "foo" '(a a a))])
               (define make-foo (record-constructor foo))
               (define foo? (record-predicate foo))
               (define foo.0
                 (csv7:record-field-accessor foo 0))
               (define foo.1
                 (csv7:record-field-accessor foo 1))
               (define foo.2
                 (csv7:record-field-accessor foo 2))
               (let ([x (make-foo 'a 'b 'c)])
                 (list (foo? x) (foo.0 x) (foo.1 x) (foo.2 x))))
             '(#t a b c))
     (equal? (let* ([names '(a a a a a a a a a a a a)]
                    [foo (make-record-type "foo" names)])
               (define make-foo (record-constructor foo))
               (define foo? (record-predicate foo))
               (define foos
                 (let ([n (length names)])
                   (let f ([i 0])
                     (if (= i n)
                         '()
                         (cons (csv7:record-field-accessor foo i)
                               (f (+ i 1)))))))
               (let ([x (make-foo 1 2 3 4 5 6 7 8 9 10 11 12)])
                 (cons (foo? x)
                       (map (lambda (p) (p x)) foos))))
             '(#t 1 2 3 4 5 6 7 8 9 10 11 12))
     (equal? (let* ([foo (make-record-type "foo" '((integer-32 a)))]
                    [bar (make-record-type foo "bar" '((double-float a)))])
               (define make-bar (record-constructor bar))
               (define bar? (record-predicate bar))
               (define bar.0
                 (csv7:record-field-accessor bar 0))
               (define bar.1
                 (csv7:record-field-accessor bar 1))
               (let ([x (make-bar 17 23.5)])
                 (list (bar? x) (bar.0 x) (bar.1 x))))
             '(#t 17 23.5))
     (equivalent-expansion? ; optimize-level 2 expansion of above
       (parameterize
         ([optimize-level 2]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(let* ([foo (make-record-type "foo" '((integer-32 a)))]
                   [bar (make-record-type foo "bar" '((double-float a)))])
              (define make-bar (record-constructor bar))
              (define bar? (record-predicate bar))
              (define bar.0
                (csv7:record-field-accessor bar 0))
              (define bar.1
                (csv7:record-field-accessor bar 1))
              (let ([x (make-bar 17 23.5)])
                (list (bar? x) (bar.0 x) (bar.1 x))))))
       `(let ([x (let ([y (#3%$record
                            (#2%make-record-type
                              (#2%make-record-type "foo" '((integer-32 a)))
                              "bar"
                              '((double-float a)))
                            .
                            ,list?)])
                   (#3%$object-set! 'double-float y ,fixnum? 23.5)
                   (#3%$object-set! 'integer-32 y ,fixnum? 17)
                   y)])
          (#2%list #t
            (#3%$object-ref 'integer-32 x ,fixnum?)
            (#3%$object-ref 'double-float x ,fixnum?))))
     (equivalent-expansion? ; optimize-level 3 expansion of above
       (parameterize
         ([optimize-level 3]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(let* ([foo (make-record-type "foo" '((integer-32 a)))]
                   [bar (make-record-type foo "bar" '((double-float a)))])
              (define make-bar (record-constructor bar))
              (define bar? (record-predicate bar))
              (define bar.0
                (csv7:record-field-accessor bar 0))
              (define bar.1
                (csv7:record-field-accessor bar 1))
              (let ([x (make-bar 17 23.5)])
                (list (bar? x) (bar.0 x) (bar.1 x))))))
       `(let ([x (let ([y (#3%$record
                            (#3%make-record-type
                              (#3%make-record-type "foo" '((integer-32 a)))
                              "bar"
                              '((double-float a)))
                            .
                            ,list?)])
                   (#3%$object-set! 'double-float y ,fixnum? 23.5)
                   (#3%$object-set! 'integer-32 y ,fixnum? 17)
                   y)])
          (#3%list #t
            (#3%$object-ref 'integer-32 x ,fixnum?)
            (#3%$object-ref 'double-float x ,fixnum?)))))

(mat record21
     ; duplicate field names and invalid field syntax
     (error? ; duplicate field name
             (define-record foo (x x)))
     (error? ; duplicate field name
             (define-record foo (x (mutable x))))
     (error? ; duplicate field name
             (define-record foo (x) ([x 3])))
     (error? ; duplicate field name
             (define-record foo (x) ([(immutable x) 3])))
     (error? ; duplicate field name
             (define-record foo () ([x 4] [x 3])))
     (error? ; duplicate field name
             (define-record foo () ([x 4] [(immutable x) 3])))
     (error? ; invalid field syntax
             (define-record foo ([x 4])))
     (error? ; invalid field syntax
             (define-record foo ([(mutable foo) 3])))
     (error? ; duplicate field name
       ; would be okay if we used field name rather than record name as template
       ; for generated accessor and mutator identifiers
       (equal? (let ()
                 (define-syntax a
                   (syntax-rules ()
                     [(_ name fld get)
                      (begin
                        (define-record name (fld x) () ([prefix ""]))
                        (define get x))]))
                 (a rt x g)
                 (let ([r (make-rt 3 4)])
                   (list (x r) (g r))))
               '(3 4))))

(mat record22
     ; make sure inlined record routines make proper checks
     (eqv? (let ()
             (define ty
               (make-record-type "bar" '((mutable q))))
             (define q! (csv7:record-field-mutator ty 'q))
             (let ([x ((record-constructor ty) 3)])
               (q! x 'hello)
               ((csv7:record-field-accessor ty 0) x)))
           'hello)
     (error? (let ()
               (define ty
                 (make-record-type "bar" '((immutable q))))
               (define q! (csv7:record-field-mutator ty 'q))
               (let ([x ((record-constructor ty) 3)])
                 (q! x 'hello)
                 ((csv7:record-field-accessor ty 0) x))))
     (procedure?
       (lambda ()
         (define ty
           (make-record-type "bar" '((immutable q))))
         (define q! (csv7:record-field-mutator ty 'q))
         (let ([x ((record-constructor ty) 3)])
           (q! x 'hello)
           ((csv7:record-field-accessor ty 0) x))))
     (error? (let ()
               (define ty
                 (make-record-type "bar" '((mutable q))))
               (define q! (csv7:record-field-mutator ty 'q))
               (let ([x ((record-constructor ty) 3)])
                 (q! x 'hello)
                 ((csv7:record-field-accessor ty 'z) x))))
     (procedure?
       (lambda ()
         (define ty (make-record-type "bar" '((mutable q))))
         (define q! (csv7:record-field-mutator ty 'q))
         (let ([x ((record-constructor ty) 3)])
           (q! x 'hello)
           ((csv7:record-field-accessor ty 'z) x))))
     (error? (let ()
               (define ty
                 (make-record-type "bar" '((mutable q))))
               (define q! (csv7:record-field-mutator ty 'z))
               (let ([x ((record-constructor ty) 3)])
                 (q! x 'hello)
                 ((csv7:record-field-accessor ty 0) x))))
     (procedure?
       (lambda ()
         (define ty (make-record-type "bar" '((mutable q))))
         (define q! (csv7:record-field-mutator ty 'z))
         (let ([x ((record-constructor ty) 3)])
           (q! x 'hello)
           ((csv7:record-field-accessor ty 0) x))))
     (error? (let ()
               (define ty
                 (make-record-type "bar" '((mutable q))))
               (csv7:record-field-accessible? ty 3)))
     (procedure?
       (lambda ()
         (define ty (make-record-type "bar" '((mutable q))))
         (csv7:record-field-accessible? ty 3)))
     (equal? (let ([n 0])
               (define ty
                 (make-record-type "bar" '((mutable q))))
               (let ([b (csv7:record-field-accessible?
                          (begin (set! n (+ n 5)) ty)
                          (begin (set! n (+ n 12)) 0))])
                 (cons b n)))
             '(#t . 17))
     (error? (let ()
               (define ty
                 (make-record-type "bar" '((mutable q))))
               (csv7:record-field-mutable? ty 'notq)))
     (procedure?
       (lambda ()
         (define ty (make-record-type "bar" '((mutable q))))
         (csv7:record-field-mutable? ty 'notq)))
     (error? (let ()
               (define ty
                 (make-record-type "bar" '((mutable creepy q))))
               (csv7:record-field-mutable? ty 'notq)))
     (procedure?
       (lambda ()
         (define ty
           (make-record-type "bar" '((mutable creepy q))))
         (csv7:record-field-mutable? ty 'notq)))
     (error? (let ()
               (define-record bar ((immutable creepy q)))
               (make-bar 3)))
     (error? (lambda ()
               (define-record bar ((immutable creepy q)))
               (make-bar 3))))

(mat record23
     ; test general make-record-type interface
     (equal? (let ()
               (define enum-base-rtd
                 (make-record-type
                   ; not sealed, not opaque
                   #!base-rtd
                   ; undocumented $base-rtd
                   '#{enum b9s78zmm79qs7j22-a}
                   ; make enum-base-rtd type nongenerative
                   '((immutable sym->index) (immutable index->sym))))
               (define get-sym->index
                 (csv7:record-field-accessor enum-base-rtd 'sym->index))
               (define get-index->sym
                 (csv7:record-field-accessor enum-base-rtd 'index->sym))
               (define enum-parent-rtd
                 ; not sealed, not opaque
                 (make-record-type "enum-parent" '((immutable members))))
               (define get-members
                 (csv7:record-field-accessor enum-parent-rtd 'members))
               (let ([this-enum-rtd
                       (#%$make-record-type
                         enum-base-rtd
                         enum-parent-rtd
                         "enum"
                         '()
                         ; no fields to add
                         #t
                         ; sealed
                         #f
                         ; not opaque
                         '*sym->index*
                         ; extras (tacked onto end of rtd)
                         '*index->sym*)])
                 ; i.e., static (per enumeration type) fields
                 (let ([make-this-enum (record-constructor this-enum-rtd)])
                   (let ([enum (make-this-enum '*members*)])
                     (let ([rtd (record-rtd enum)])
                       (list (get-members enum)
                             (get-sym->index rtd)
                             (get-index->sym rtd)))))))
             '(*members* *sym->index* *index->sym*))
     (error? ; cannot extend sealed record type
       (let ([rtd1 (#%$make-record-type #!base-rtd #f "foo" '() #t #f '())])
         (#%$make-record-type #!base-rtd rtd1 "bar" '() #f #f '()))))

(mat record25
     ; test generic C aliases for specific types
     (begin
       (define-record r25-bar
         ((int a)
          (unsigned b)
          (unsigned-int c)
          (short d)
          (unsigned-short e)
          (long f)
          (unsigned-long g)
          (iptr h)
          (uptr i)
          (float j)
          (double k)
          (ptr l)
          (char m)
          (wchar n)
          (fixnum o)
          (void* p)
          (boolean q)
          (long-long r)
          (unsigned-long-long s)))
       #t)
     (error? (make-r25-bar
               1.0
               2
               3
               4
               5
               6
               7
               8
               9
               10.0
               11.0
               'blue
               #\a
               #\x3bb
               75
               #xc7c7c7c7
               'a
               12
               13))
     (error? (make-r25-bar
               1
               2.0
               3
               4
               5
               6
               7
               8
               9
               10.0
               11.0
               'blue
               #\a
               #\x3bb
               75
               #xc7c7c7c7
               'a
               12
               13))
     (error? (make-r25-bar
               1
               2
               'three
               4
               5
               6
               7
               8
               9
               10.0
               11.0
               'blue
               #\a
               #\x3bb
               75
               #xc7c7c7c7
               'a
               12
               13))
     (error? (make-r25-bar
               1
               2
               3
               1/4
               5
               6
               7
               8
               9
               10.0
               11.0
               'blue
               #\a
               #\x3bb
               75
               #xc7c7c7c7
               'a
               12
               13))
     (error? (make-r25-bar
               1
               2
               3
               4
               "five"
               6
               7
               8
               9
               10.0
               11.0
               'blue
               #\a
               #\x3bb
               75
               #xc7c7c7c7
               'a
               12
               13))
     (error? (make-r25-bar
               1
               2
               3
               4
               5
               '(6)
               7
               8
               9
               10.0
               11.0
               'blue
               #\a
               #\x3bb
               75
               #xc7c7c7c7
               'a
               12
               13))
     (error? (make-r25-bar
               1
               2
               3
               4
               5
               6
               '#(a b c d e f g)
               8
               9
               10.0
               11.0
               'blue
               #\a
               #\x3bb
               75
               #xc7c7c7c7
               'a
               12
               13))
     (error? (make-r25-bar
               1
               2
               3
               4
               5
               6
               7
               'ate
               9
               10.0
               11.0
               'blue
               #\a
               #\x3bb
               75
               #xc7c7c7c7
               'a
               12
               13))
     (error? (make-r25-bar
               1
               2
               3
               4
               5
               6
               7
               8
               #\9
               10.0
               11.0
               'blue
               #\a
               #\x3bb
               75
               #xc7c7c7c7
               'a
               12
               13))
     (error? (make-r25-bar
               1
               2
               3
               4
               5
               6
               7
               8
               9
               10
               11.0
               'blue
               #\a
               #\x3bb
               75
               #xc7c7c7c7
               'a
               12
               13))
     (error? (make-r25-bar
               1
               2
               3
               4
               5
               6
               7
               8
               9
               10.0
               11.0+0.0i
               'blue
               #\a
               #\x3bb
               75
               #xc7c7c7c7
               'a
               12
               13))
     (error? (make-r25-bar
               1
               2
               3
               4
               5
               6
               7
               8
               9
               10.0
               11.0
               #\a
               #\x3bb
               75
               #xc7c7c7c7
               'a
               12
               13))
     (error? (make-r25-bar
               1
               2
               3
               4
               5
               6
               7
               8
               9
               10.0
               11.0
               'blue
               #\a
               #\x3bb
               75
               #xc7c7c7c7
               'a
               12.0
               13))
     (error? (make-r25-bar
               1
               2
               3
               4
               5
               6
               7
               8
               9
               10.0
               11.0
               'blue
               #\a
               #\x3bb
               75
               #xc7c7c7c7
               'a
               12
               13.0))
     (begin
       (define r25-x
         (make-r25-bar
           1
           2
           3
           4
           5
           6
           7
           8
           9
           10.0
           11.0
           'blue
           #\a
           #\x3bb
           75
           #xc7c7c7c7
           'a
           12
           13))
       (and (r25-bar? r25-x) (not (r25-bar? '(foo)))))
     (error? (set-r25-bar-a! r25-x 3.0))
     (eq? (set-r25-bar-a! r25-x (+ (r25-bar-a r25-x) 73)) (void))
     (error? (set-r25-bar-b! r25-x 3.0))
     (eq? (set-r25-bar-b! r25-x (+ (r25-bar-b r25-x) 73)) (void))
     (error? (set-r25-bar-c! r25-x 3.0))
     (eq? (set-r25-bar-c! r25-x (+ (r25-bar-c r25-x) 73)) (void))
     (error? (set-r25-bar-d! r25-x 3.0))
     (eq? (set-r25-bar-d! r25-x (+ (r25-bar-d r25-x) 73)) (void))
     (error? (set-r25-bar-e! r25-x 3.0))
     (eq? (set-r25-bar-e! r25-x (+ (r25-bar-e r25-x) 73)) (void))
     (error? (set-r25-bar-f! r25-x 3.0))
     (eq? (set-r25-bar-f! r25-x (- (r25-bar-f r25-x) 73)) (void))
     (error? (set-r25-bar-g! r25-x 3.0))
     (eq? (set-r25-bar-g! r25-x (+ (r25-bar-g r25-x) 73)) (void))
     (error? (set-r25-bar-h! r25-x 3.0))
     (eq? (set-r25-bar-h! r25-x (+ (r25-bar-h r25-x) 73)) (void))
     (error? (set-r25-bar-i! r25-x 3.0))
     (eq? (set-r25-bar-i! r25-x (+ (r25-bar-i r25-x) 73)) (void))
     (error? (set-r25-bar-j! r25-x 3))
     (eq? (set-r25-bar-j! r25-x (+ (r25-bar-j r25-x) 73)) (void))
     (error? (set-r25-bar-k! r25-x 3))
     (eq? (set-r25-bar-k! r25-x (+ (r25-bar-k r25-x) 73)) (void))
     (eq? (set-r25-bar-l! r25-x (cons (r25-bar-l r25-x) 73)) (void))
     (error? (set-r25-bar-m! r25-x 3.0))
     (eq? (set-r25-bar-m! r25-x
            (integer->char (+ (char->integer (r25-bar-m r25-x)) 1)))
          (void))
     (error? (set-r25-bar-n! r25-x 3.0))
     (eq? (set-r25-bar-n! r25-x
            (integer->char (+ (char->integer (r25-bar-n r25-x)) 1)))
          (void))
     (error? (set-r25-bar-o! r25-x 3.0))
     (eq? (set-r25-bar-o! r25-x (+ (r25-bar-o r25-x) 73)) (void))
     (error? (set-r25-bar-p! r25-x 3.0))
     (eq? (set-r25-bar-p! r25-x (+ (r25-bar-p r25-x) 73)) (void))
     (eq? (set-r25-bar-q! r25-x (not (r25-bar-q r25-x))) (void))
     (error? (set-r25-bar-r! r25-x 3.0))
     (eq? (set-r25-bar-r! r25-x (- (r25-bar-r r25-x) 73)) (void))
     (error? (set-r25-bar-s! r25-x 3.0))
     (eq? (set-r25-bar-s! r25-x (+ (r25-bar-s r25-x) 73)) (void))
     (equal? (list (r25-bar-a r25-x)
                   (r25-bar-b r25-x)
                   (r25-bar-c r25-x)
                   (r25-bar-d r25-x)
                   (r25-bar-e r25-x)
                   (r25-bar-f r25-x)
                   (r25-bar-g r25-x)
                   (r25-bar-h r25-x)
                   (r25-bar-i r25-x)
                   (r25-bar-j r25-x)
                   (r25-bar-k r25-x)
                   (r25-bar-l r25-x)
                   (r25-bar-m r25-x)
                   (r25-bar-n r25-x)
                   (r25-bar-o r25-x)
                   (r25-bar-p r25-x)
                   (r25-bar-q r25-x)
                   (r25-bar-r r25-x)
                   (r25-bar-s r25-x))
             '(74 75
                  76
                  77
                  78
                  -67
                  80
                  81
                  82
                  83.0
                  84.0
                  (blue . 73)
                  #\b
                  #\x3bc
                  148
                  #xc7c7c810
                  #f
                  -61
                  86))
     (error? (set-r25-bar-a! r25-x (expt 256 (foreign-sizeof 'int))))
     (error? (set-r25-bar-a! r25-x
               (- -1 (ash (expt 256 (foreign-sizeof 'int)) -1))))
     (begin
       (define ($test-int x size get put)
         (let* ([n10000 (expt 256 size)]
                [nffff (- n10000 1)]
                [n8000 (ash n10000 -1)]
                [n7fff (- n8000 1)]
                [n-8000 (- n8000)]
                [n-8001 (- n-8000 1)])
           (and (or (= (optimize-level) 3)
                    (guard (c [#t]) (put x n10000) #f))
                (eq? (put x nffff) (void))
                (eqv? (get x) -1)
                (eq? (put x n8000) (void))
                (eqv? (get x) n-8000)
                (eq? (put x n7fff) (void))
                (eqv? (get x) n7fff)
                (eq? (put x 0) (void))
                (eqv? (get x) 0)
                (eq? (put x -1) (void))
                (eqv? (get x) -1)
                (eq? (put x n-8000) (void))
                (eqv? (get x) n-8000)
                (or (= (optimize-level) 3)
                    (guard (c [#t]) (put x n-8001) #f))
                (eqv? (get x) n-8000))))
       (define ($test-uint x size get put)
         (let* ([n10000 (expt 256 size)]
                [nffff (- n10000 1)]
                [n8000 (ash n10000 -1)]
                [n7fff (- n8000 1)]
                [n-8000 (- n8000)]
                [n-8001 (- n-8000 1)])
           (and (or (= (optimize-level) 3)
                    (guard (c [#t]) (put x n10000) #f))
                (eq? (put x nffff) (void))
                (eqv? (get x) nffff)
                (eq? (put x n8000) (void))
                (eqv? (get x) n8000)
                (eq? (put x n7fff) (void))
                (eqv? (get x) n7fff)
                (eq? (put x 0) (void))
                (eqv? (get x) 0)
                (eq? (put x -1) (void))
                (eqv? (get x) nffff)
                (eq? (put x n-8000) (void))
                (eqv? (get x) n8000)
                (or (= (optimize-level) 3)
                    (guard (c [#t]) (put x n-8001) #f))
                (eqv? (get x) n8000))))
       (define ($test-fixnum x get put)
         (let ([n8000 (+ (greatest-fixnum) 1)]
               [n7fff (greatest-fixnum)]
               [n-8000 (least-fixnum)]
               [n-8001 (- (least-fixnum) 1)])
           (and (or (= (optimize-level) 3)
                    (guard (c [#t]) (put x n8000) #f))
                (eq? (put x n7fff) (void))
                (eqv? (get x) n7fff)
                (eq? (put x 0) (void))
                (eqv? (get x) 0)
                (eq? (put x -1) (void))
                (eqv? (get x) -1)
                (eq? (put x n-8000) (void))
                (eqv? (get x) n-8000)
                (or (= (optimize-level) 3)
                    (guard (c [#t]) (put x n-8001) #f))
                (eqv? (get x) n-8000))))
       #t)
     ($test-int r25-x (foreign-sizeof 'int) r25-bar-a set-r25-bar-a!)
     ($test-uint r25-x (foreign-sizeof 'unsigned) r25-bar-b set-r25-bar-b!)
     ($test-uint r25-x
       (foreign-sizeof 'unsigned-int)
       r25-bar-c
       set-r25-bar-c!)
     ($test-int r25-x (foreign-sizeof 'short) r25-bar-d set-r25-bar-d!)
     ($test-uint r25-x
       (foreign-sizeof 'unsigned-short)
       r25-bar-e
       set-r25-bar-e!)
     ($test-int r25-x (foreign-sizeof 'long) r25-bar-f set-r25-bar-f!)
     ($test-uint r25-x
       (foreign-sizeof 'unsigned-long)
       r25-bar-g
       set-r25-bar-g!)
     ($test-int r25-x (foreign-sizeof 'long-long) r25-bar-r set-r25-bar-r!)
     ($test-uint r25-x
       (foreign-sizeof 'unsigned-long-long)
       r25-bar-s
       set-r25-bar-s!)
     ($test-int r25-x (foreign-sizeof 'iptr) r25-bar-h set-r25-bar-h!)
     ($test-uint r25-x (foreign-sizeof 'uptr) r25-bar-i set-r25-bar-i!)
     ($test-fixnum r25-x r25-bar-o set-r25-bar-o!)
     ($test-uint r25-x (foreign-sizeof 'void*) r25-bar-p set-r25-bar-p!))

(mat fasl-records
     ; make sure we can fasl out cyclic record type descriptors
     (begin
       (with-output-to-file "testfile.ss"
         (lambda ()
           (pretty-print
             '(define $fsr-a
                (let ()
                  (define-syntax a
                    (lambda (x)
                      (let* ([rtd1 (#%$make-record-type
                                     #!base-rtd
                                     #!base-rtd
                                     "rtd1"
                                     '((mutable q))
                                     #f
                                     #f)]
                             [rtd2 (#%$make-record-type
                                     rtd1
                                     #!base-rtd
                                     "rtd2"
                                     '()
                                     #f
                                     #f
                                     #f)])
                        ((record-mutator rtd1 0) rtd2 rtd2)
                        #`(quote #,rtd2))))
                  a))))
         'replace)
       (load "testfile.ss")
       #t)
     (eq? ((record-accessor (record-rtd $fsr-a) 0) $fsr-a) $fsr-a)
     (begin
       (separate-compile "testfile")
       (load "testfile.so")
       #t)
     (eq? ((record-accessor (record-rtd $fsr-a) 0) $fsr-a) $fsr-a)
     ; ... even when cycle involves the record's base rtd
     (begin
       (with-output-to-file "testfile.ss"
         (lambda ()
           (pretty-print
             '(define $fsr-b
                (let ()
                  (define-syntax a
                    (lambda (x)
                      (let* ([rtd1 (#%$make-record-type
                                     #!base-rtd
                                     #!base-rtd
                                     "rtd1"
                                     '((mutable q))
                                     #f
                                     #f)]
                             [rtd2 (#%$make-record-type
                                     rtd1
                                     #!base-rtd
                                     "rtd2"
                                     '()
                                     #f
                                     #f
                                     #f)]
                             [rtd3 (#%$make-record-type
                                     rtd2
                                     #!base-rtd
                                     "rtd3"
                                     '()
                                     #f
                                     #f)])
                        ((record-mutator rtd1 0) rtd2 rtd3)
                        #`(quote #,rtd3))))
                  a))))
         'replace)
       (load "testfile.ss")
       #t)
     (eq? ((record-accessor (record-rtd (record-rtd $fsr-b)) 0)
           (record-rtd $fsr-b))
          $fsr-b)
     (begin
       (separate-compile "testfile")
       (load "testfile.so")
       #t)
     (eq? ((record-accessor (record-rtd (record-rtd $fsr-b)) 0)
           (record-rtd $fsr-b))
          $fsr-b)
     (begin
       (with-output-to-file "testfile.ss"
         (lambda ()
           (pretty-print
             '(define $fsr-c
                (let ()
                  (define-syntax a
                    (lambda (x)
                      (let* ([rtd1 (#%$make-record-type
                                     #!base-rtd
                                     #!base-rtd
                                     "rtd1"
                                     '((mutable q))
                                     #f
                                     #f)]
                             [rtd2 (#%$make-record-type
                                     rtd1
                                     #!base-rtd
                                     "rtd2"
                                     '()
                                     #f
                                     #f
                                     #f)]
                             [rtd3 (#%$make-record-type
                                     rtd2
                                     #f
                                     "rtd3"
                                     '((immutable a))
                                     #f
                                     #f)])
                        ((record-mutator rtd1 0)
                         rtd2
                         ((record-constructor rtd3) 23))
                        #`(quote #,rtd3))))
                  a))))
         'replace)
       (load "testfile.ss")
       #t)
     (record? ((record-accessor (record-rtd (record-rtd $fsr-c)) 0)
               (record-rtd $fsr-c))
              $fsr-c)
     (begin
       (separate-compile "testfile")
       (load "testfile.so")
       #t)
     (record? ((record-accessor (record-rtd (record-rtd $fsr-c)) 0)
               (record-rtd $fsr-c))
              $fsr-c)
     ; fasl out typed fields
     (begin
       (with-output-to-file "testfile.ss"
         (lambda ()
           (pretty-print
             '(define $fsr-d-inst
                (let ()
                  (define-syntax a
                    (lambda (x)
                      (define-record $fsr-d
                        ((immutable integer-32 a) (mutable unsigned-40 b)))
                      #`(quote #,(make-$fsr-d #x1234abcd #xfedcba6543))))
                  a))))
         'replace)
       (load "testfile.ss")
       #t)
     (eqv? ((record-accessor (record-rtd $fsr-d-inst) 0) $fsr-d-inst)
           #x1234abcd)
     (eqv? ((record-accessor (record-rtd $fsr-d-inst) 1) $fsr-d-inst)
           #xfedcba6543)
     (begin
       (separate-compile "testfile")
       (load "testfile.so")
       #t)
     (eqv? ((record-accessor (record-rtd $fsr-d-inst) 0) $fsr-d-inst)
           #x1234abcd)
     (eqv? ((record-accessor (record-rtd $fsr-d-inst) 1) $fsr-d-inst)
           #xfedcba6543)
     (begin
       (with-output-to-file "testfile.ss"
         (lambda ()
           (pretty-print
             '(eval-when (compile load)
                (define-record $fsr-e
                  ((immutable integer-8 i8)
                   (immutable integer-16 i16)
                   (immutable integer-24 i24)
                   (immutable integer-32 i32)
                   (immutable integer-40 i40)
                   (immutable integer-48 i48)
                   (immutable integer-56 i56)
                   (immutable integer-64 i64)
                   (immutable unsigned-8 u8)
                   (immutable unsigned-16 u16)
                   (immutable unsigned-24 u24)
                   (immutable unsigned-32 u32)
                   (immutable unsigned-40 u40)
                   (immutable unsigned-48 u48)
                   (immutable unsigned-56 u56)
                   (immutable unsigned-64 u64)
                   (immutable char c)
                   (immutable single-float sf)
                   (immutable wchar wc)
                   (immutable double-float df)
                   (immutable fixnum f)))))
           (pretty-print
             '(define $fsr-e-inst1
                (let-syntax
                  ([a (lambda (x)
                        #`'#,(make-$fsr-e
                               0
                               -1
                               0
                               -1
                               0
                               -1
                               0
                               -1
                               0
                               #xffff
                               0
                               #xffffffff
                               0
                               #xffffffffffff
                               0
                               #xffffffffffffffff
                               #\nul
                               3.14
                               #\x3bc
                               -3.14
                               0))])
                  a)))
           (pretty-print
             '(define $fsr-e-inst2
                (let-syntax
                  ([a (lambda (x)
                        #`'#,(make-$fsr-e
                               -1
                               0
                               -1
                               0
                               -1
                               0
                               -1
                               0
                               #xff
                               0
                               #xffffff
                               0
                               #xffffffffff
                               0
                               #xffffffffffffff
                               0
                               #\a
                               -3.14
                               #\nul
                               3.14
                               -1))])
                  a)))
           (pretty-print
             '(define $fsr-e-inst3
                (let-syntax
                  ([a (lambda (x)
                        #`'#,(make-$fsr-e
                               #x7f
                               #x-8000
                               #x7fffff
                               #x-80000000
                               #x7fffffffff
                               #x-800000000000
                               #x7fffffffffffff
                               #x-8000000000000000
                               #x7f
                               #x8000
                               #x7fffff
                               #x80000000
                               #x7fffffffff
                               #x800000000000
                               #x7fffffffffffff
                               #x8000000000000000
                               #\a
                               +inf.0
                               #\nul
                               -0.0
                               -1))])
                  a)))
           (pretty-print
             '(define $fsr-e-inst4
                (let-syntax
                  ([a (lambda (x)
                        #`'#,(make-$fsr-e
                               #x-80
                               #x7fff
                               #x-800000
                               #x7fffffff
                               #x-8000000000
                               #x7fffffffffff
                               #x-80000000000000
                               #x7fffffffffffffff
                               #x80
                               #x7fff
                               #x800000
                               #x7fffffff
                               #x8000000000
                               #x7fffffffffff
                               #x80000000000000
                               #x7fffffffffffffff
                               #\a
                               +0.0
                               #\nul
                               +inf.0
                               -1))])
                  a))))
         'replace)
       #t)
     (begin
       (separate-compile "testfile")
       (load "testfile.so")
       #t)
     ($fsr-e? $fsr-e-inst1)
     ($fsr-e? $fsr-e-inst2)
     ($fsr-e? $fsr-e-inst3)
     ($fsr-e? $fsr-e-inst4)
     (equal? ($record->vector $fsr-e-inst1)
       ($record->vector
         (make-$fsr-e
           0
           -1
           0
           -1
           0
           -1
           0
           -1
           0
           #xffff
           0
           #xffffffff
           0
           #xffffffffffff
           0
           #xffffffffffffffff
           #\nul
           3.14
           #\x3bc
           -3.14
           0)))
     (equal? ($record->vector $fsr-e-inst2)
       ($record->vector
         (make-$fsr-e
           -1
           0
           -1
           0
           -1
           0
           -1
           0
           #xff
           0
           #xffffff
           0
           #xffffffffff
           0
           #xffffffffffffff
           0
           #\a
           -3.14
           #\nul
           3.14
           -1)))
     (equal? ($record->vector $fsr-e-inst3)
       ($record->vector
         (make-$fsr-e
           #x7f
           #x-8000
           #x7fffff
           #x-80000000
           #x7fffffffff
           #x-800000000000
           #x7fffffffffffff
           #x-8000000000000000
           #x7f
           #x8000
           #x7fffff
           #x80000000
           #x7fffffffff
           #x800000000000
           #x7fffffffffffff
           #x8000000000000000
           #\a
           +inf.0
           #\nul
           -0.0
           -1)))
     (equal? ($record->vector $fsr-e-inst4)
       ($record->vector
         (make-$fsr-e
           #x-80
           #x7fff
           #x-800000
           #x7fffffff
           #x-8000000000
           #x7fffffffffff
           #x-80000000000000
           #x7fffffffffffffff
           #x80
           #x7fff
           #x800000
           #x7fffffff
           #x8000000000
           #x7fffffffffff
           #x80000000000000
           #x7fffffffffffffff
           #\a
           +0.0
           #\nul
           +inf.0
           -1))))

(mat record?
     (eq? (record? 3) #f)
     (eq? (record? 'a) #f)
     (eq? (record? '#(1 2 3)) #f)
     (eq? (record? (make-record-type "foo" '())) #t)
     (eq? (record? ((record-constructor (make-record-type "foo" '())))) #t)
     (equal? (let ([rtd1 (make-record-type "foo" '())]
                   [rtd2 (make-record-type "bar" '())])
               (let ([rtd3 (make-record-type rtd1 "xfoo" '())])
                 (list (record? ((record-constructor rtd1)) rtd1)
                       (record? ((record-constructor rtd1)) rtd2)
                       (record? ((record-constructor rtd1)) rtd3)
                       (record? ((record-constructor rtd3)) rtd1)
                       (record? ((record-constructor rtd3)) rtd2)
                       (record? ((record-constructor rtd3)) rtd3))))
             '(#t #f #f #t #f #t))
     (error? (record? 3 4))
     (error? (record? ((record-constructor (make-record-type "foo" '())))
                      'a))
     (error? (record? ((record-constructor (make-record-type "foo" '())))
                      '#(1)))
     (let ()
       (define-record-type A)
       (define-record-type B (parent A))
       (define-record-type C (parent B))
       (define-record-type D (parent C) (sealed #t))
       (define-record-type E (parent C) (opaque #t))
       (define a (make-A))
       (define b (make-B))
       (define c (make-C))
       (define d (make-D))
       (define e (make-E))
       (define Atd (record-type-descriptor A))
       (define Btd (record-type-descriptor B))
       (define Ctd (record-type-descriptor C))
       (define Dtd (record-type-descriptor D))
       (define Etd (record-type-descriptor E))
       (and (equal? (list (record? 3)
                          (record? a)
                          (record? b)
                          (record? c)
                          (record? d)
                          (record? e))
                    '(#f #t #t #t #t #f))
            (equal? (let ()
                      (import (rnrs))
                      (list (record? 3)
                            (record? a)
                            (record? b)
                            (record? c)
                            (record? d)
                            (record? e)))
                    '(#f #t #t #t #t #f))
            (equal? (list (record? 3 Atd)
                          (record? a Atd)
                          (record? b Atd)
                          (record? c Atd)
                          (record? d Atd)
                          (record? e Atd))
                    '(#f #t #t #t #t #t))
            (equal? (list (record? 3 Btd)
                          (record? a Btd)
                          (record? b Btd)
                          (record? c Btd)
                          (record? d Btd)
                          (record? e Btd))
                    '(#f #f #t #t #t #t))
            (equal? (list (record? 3 Ctd)
                          (record? a Ctd)
                          (record? b Ctd)
                          (record? c Ctd)
                          (record? d Ctd)
                          (record? e Ctd))
                    '(#f #f #f #t #t #t))
            (equal? (list (record? 3 Dtd)
                          (record? a Dtd)
                          (record? b Dtd)
                          (record? c Dtd)
                          (record? d Dtd)
                          (record? e Dtd))
                    '(#f #f #f #f #t #f))
            (equal? (list (record? 3 Etd)
                          (record? a Etd)
                          (record? b Etd)
                          (record? c Etd)
                          (record? d Etd)
                          (record? e Etd))
                    '(#f #f #f #f #f #t))
            (equal? (let ([record? #%$sealed-record?])
                      (list (record? 3 Dtd)
                            (record? a Dtd)
                            (record? b Dtd)
                            (record? c Dtd)
                            (record? d Dtd)
                            (record? e Dtd)))
                    '(#f #f #f #f #t #f)))))

(mat record-type-mismatch
     (begin
       (define-record-type flotsam
         (nongenerative #{flotsam flotsam})
         (fields x y))
       #t)
     (record-type-descriptor?
       (make-record-type '#{flotsam flotsam}
         '((immutable x) (immutable y))))
     (error? ; different parent
       (begin
         (define-record-type pflotsam
           (nongenerative pflotsam))
         (define-record-type flotsam
           (nongenerative #{flotsam flotsam})
           (parent pflotsam)
           (fields x y))))
     (error? ; different fields
       (define-record-type flotsam
         (nongenerative #{flotsam flotsam})
         (fields x y z)))
     (error? ; different fields
       (make-record-type '#{flotsam flotsam} '((int x) y)))
     (error? ; different mutability
       (define-record-type flotsam
         (nongenerative #{flotsam flotsam})
         (fields (mutable x) y)))
     (error? ; different flags
       (define-record-type flotsam
         (nongenerative #{flotsam flotsam})
         (sealed #t)
         (fields x y)))
     (error? ; different flags
       (define-record-type flotsam
         (nongenerative #{flotsam flotsam})
         (opaque #t)
         (fields x y))))

(mat r6rs-records-procedural
     ((lambda (x)
        (and (list? x)
             (record? (car x))
             (equal? (cdr x)
               '(765 45
                     25
                     #t
                     #t
                     #f
                     #f
                     #t
                     #t
                     #f
                     foo
                     bar
                     #1(x)
                     #2(y z)
                     #f
                     #t
                     (#t #f)
                     (#f #f)
                     (#f #t)
                     #t
                     pluto))))
      (let ()
        (define prtd
          (make-record-type-descriptor 'foo #f #f #f #f '#((mutable x))))
        (define rtd
          (make-record-type-descriptor
            'bar
            prtd
            'pluto
            #t
            #f
            '#((mutable y) (immutable z))))
        (define rcd
          (make-record-constructor-descriptor rtd #f #f))
        (define rc (r6rs:record-constructor rcd))
        (define foo-x (record-accessor prtd 0))
        (define foo-x! (record-mutator prtd 0))
        (define bar-y (record-accessor rtd 0))
        (define bar-y! (record-mutator rtd 0))
        (define bar-z (record-accessor rtd 1))
        (define x (rc 17 20 25))
        (bar-y! x (+ (bar-y x) (bar-z x)))
        (foo-x! x (* (bar-y x) (foo-x x)))
        (list x
              (foo-x x)
              (bar-y x)
              (bar-z x)
              (record-type-descriptor? rtd)
              (record-constructor-descriptor? rcd)
              (record-type-descriptor? rcd)
              (record-constructor-descriptor? rtd)
              (record-field-mutable? prtd 0)
              (record-field-mutable? rtd 0)
              (record-field-mutable? rtd 1)
              (record-type-name prtd)
              (record-type-name rtd)
              (record-type-field-names prtd)
              (record-type-field-names rtd)
              (eq? (record-rtd x) prtd)
              (eq? (record-rtd x) rtd)
              (list (record-type-generative? prtd)
                    (record-type-generative? rtd))
              (list (record-type-opaque? prtd) (record-type-opaque? rtd))
              (list (record-type-sealed? prtd) (record-type-sealed? rtd))
              (gensym? (record-type-uid prtd))
              (record-type-uid rtd))))

     (equal? (parameterize ([current-output-port (open-output-string)])
               (define a-rtd
                 (make-record-type-descriptor
                   'a
                   #f
                   #f
                   #f
                   #f
                   '#((mutable x))))
               (define b-rtd
                 (make-record-type-descriptor
                   'b
                   a-rtd
                   #f
                   #f
                   #f
                   '#((immutable x) (mutable y))))
               (define a? (record-predicate a-rtd))
               (define b? (record-predicate b-rtd))
               (define a-x (record-accessor a-rtd 0))
               (define a-x! (record-mutator a-rtd 0))
               (define b-x (record-accessor b-rtd 0))
               (define b-y (record-accessor b-rtd 1))
               (define b-y! (record-mutator b-rtd 1))
               (define (a->list b)
                 (if (b? b)
                     (list (a-x b) (b-x b) (b-y b))
                     (list (a-x b))))
               (define a-rcd0
                 (make-record-constructor-descriptor a-rtd #f #f))
               (define b-rcd0
                 (make-record-constructor-descriptor b-rtd #f #f))
               #;
               (define make-a0
                 (r6rs:record-constructor a-rcd0))
               #;
               (define make-b0
                 (r6rs:record-constructor b-rcd0))
               (define make-a0 (record-constructor a-rcd0))
               ; should handle rcd too
               (define make-b0 (record-constructor b-rcd0))
               ; should handle rcd too
               (define b-rcd1
                 (make-record-constructor-descriptor b-rtd a-rcd0 #f))
               (define make-b1
                 (r6rs:record-constructor b-rcd1))
               (define a-rcd2
                 (make-record-constructor-descriptor a-rtd #f
                   (lambda (p)
                     (lambda (x y)
                       (let ([r (p (- x y))])
                         (printf "make-a2: ~s\n" (a->list r))
                         (a-x r)
                         r)))))
               (define make-a2
                 (r6rs:record-constructor a-rcd2))
               (let ([ls (map a->list
                              (list (make-a0 3)
                                    (make-b0 4 5 6)
                                    (make-b1 7 8 9)
                                    (make-a2 10 11)))])
                 (cons (get-output-string (current-output-port))
                       ls)))
             '("make-a2: (-1)\n" (3) (4 5 6) (7 8 9) (-1)))

     (equal? (parameterize ([current-output-port (open-output-string)])
               (define a-rtd
                 (make-record-type-descriptor
                   'a
                   #f
                   #f
                   #f
                   #f
                   '#((mutable x))))
               (define a? (record-predicate a-rtd))
               (define a-x (record-accessor a-rtd 0))
               (define (a->list b) (list (a-x b)))
               (define-syntax echo
                 (syntax-rules ()
                   [(_ s e)
                    (begin
                      (printf "~a in\n" s)
                      (let ([x e])
                        (printf "~a out: ~s\n" s (record? x))
                        x))]))
               (define a-rcd
                 (make-record-constructor-descriptor a-rtd #f
                   (lambda (m)
                     (lambda (q t) (echo "A" (m (* q t)))))))
               (define make-a
                 (r6rs:record-constructor a-rcd))
               (let ([ls (map a->list (list (make-a 3 4)))])
                 (cons (get-output-string (current-output-port))
                       ls)))
             '("A in\nA out: #t\n" (12)))

     (equal? (parameterize ([current-output-port (open-output-string)])
               (define a-rtd
                 (make-record-type-descriptor
                   'a
                   #f
                   #f
                   #f
                   #f
                   '#((mutable x))))
               (define b-rtd
                 (make-record-type-descriptor
                   'b
                   a-rtd
                   #f
                   #f
                   #f
                   '#((immutable x) (mutable y))))
               (define a? (record-predicate a-rtd))
               (define b? (record-predicate b-rtd))
               (define a-x (record-accessor a-rtd 0))
               (define a-x! (record-mutator a-rtd 0))
               (define b-x (record-accessor b-rtd 0))
               (define b-y (record-accessor b-rtd 1))
               (define b-y! (record-mutator b-rtd 1))
               (define (a->list b)
                 (if (b? b)
                     (list (a-x b) (b-x b) (b-y b))
                     (list (a-x b))))
               (define-syntax echo
                 (syntax-rules ()
                   [(_ s e)
                    (begin
                      (printf "~a in\n" s)
                      (let ([x e])
                        (printf "~a out: ~s\n" s (record? x))
                        x))]))
               (define a-rcd
                 (make-record-constructor-descriptor a-rtd #f
                   (lambda (m)
                     (lambda (q) (echo "A" (m (* q q)))))))
               (define b-rcd
                 (make-record-constructor-descriptor b-rtd a-rcd
                   (lambda (m)
                     (lambda (q)
                       (echo "B" ((m q) (- q) (/ q)))))))
               (define make-b
                 (r6rs:record-constructor b-rcd))
               (let ([ls (map a->list (list (make-b 3)))])
                 (cons (get-output-string (current-output-port))
                       ls)))
             '("B in\nA in\nA out: #t\nB out: #t\n" (9 -3 1/3)))

     (equal? (parameterize ([current-output-port (open-output-string)])
               (define a-rtd
                 (make-record-type-descriptor
                   'a
                   #f
                   #f
                   #f
                   #f
                   '#((mutable x))))
               (define b-rtd
                 (make-record-type-descriptor
                   'b
                   a-rtd
                   #f
                   #f
                   #f
                   '#((immutable x) (mutable y))))
               (define c-rtd
                 (make-record-type-descriptor
                   'c
                   b-rtd
                   #f
                   #f
                   #f
                   '#((immutable z) (mutable w))))
               (define a? (record-predicate a-rtd))
               (define b? (record-predicate b-rtd))
               (define c? (record-predicate c-rtd))
               (define a-x (record-accessor a-rtd 0))
               (define a-x! (record-mutator a-rtd 0))
               (define b-x (record-accessor b-rtd 0))
               (define b-y (record-accessor b-rtd 1))
               (define b-y! (record-mutator b-rtd 1))
               (define c-z (record-accessor c-rtd 0))
               (define c-w (record-accessor c-rtd 1))
               (define c-w! (record-mutator c-rtd 1))
               (define (a->list b)
                 (if (c? b)
                     (list (a-x b) (b-x b) (b-y b) (c-z b) (c-w b))
                     (if (b? b)
                         (list (a-x b) (b-x b) (b-y b))
                         (list (a-x b)))))
               (define-syntax echo
                 (syntax-rules ()
                   [(_ s e)
                    (begin
                      (printf "~a in\n" s)
                      (let ([x e])
                        (printf "~a out: ~s\n" s (record? x))
                        x))]))
               (define a-rcd
                 (make-record-constructor-descriptor a-rtd #f
                   (lambda (m)
                     (lambda (q) (echo "A" (m (* q q)))))))
               (define b-rcd
                 (make-record-constructor-descriptor b-rtd a-rcd
                   (lambda (m)
                     (lambda (q)
                       (echo "B" ((m q) (- q) (/ q)))))))
               (define c-rcd
                 (make-record-constructor-descriptor c-rtd b-rcd
                   (lambda (m)
                     (lambda (q t)
                       (echo "C" ((m (+ q t)) (* q t) (cons q t)))))))
               (define make-c
                 (r6rs:record-constructor c-rcd))
               (let ([ls (map a->list (list (make-c 3 4)))])
                 (cons (get-output-string (current-output-port))
                       ls)))
             '("C in\nB in\nA in\nA out: #t\nB out: #t\nC out: #t\n"
                (49 -7 1/7 12 (3 . 4))))
     (error? ; rtd/rcd mismatch
       (let ()
         (define-syntax rtd1
           (lambda (x) #`'#,(make-record-type "foo" '(x))))
         (define-syntax rtd2
           (lambda (x)
             #`'#,(make-record-type rtd1 "bar" '(y))))
         (define-syntax rtd3
           (lambda (x)
             #`'#,(make-record-type "foo2" '(a b))))
         (define-syntax rtd4
           (lambda (x)
             #`'#,(make-record-type rtd3 "bar2" '(c d))))
         (define rcd1
           (make-record-constructor-descriptor rtd1 #f
             (lambda (n) (lambda (q) (n (* q q))))))
         (define rcd3
           (make-record-constructor-descriptor rtd3 rcd1
             (lambda (p) (lambda (t u v) ((p t u) v 0)))))
         (define cons3 (r6rs:record-constructor rcd3))
         (cons3 1 2 3)))

     ; make sure appropriate error checking is done for protocols
     (error? ; not a procedure (parent protocol)
       (let ([pprot (cons 'ugly 'ducking)]
             [cprot (lambda (p) (lambda (x y) ((p x 0 17) y)))])
         (define prtd (make-record-type "parent" '(x y)))
         (define crtd (make-record-type prtd "child" '(z)))
         (define prcd
           (make-record-constructor-descriptor prtd #f pprot))
         (define crcd
           (make-record-constructor-descriptor crtd prcd cprot))
         (define pcons (r6rs:record-constructor prcd))
         (define ccons (r6rs:record-constructor crcd))
         (list (pcons 1 2) (ccons 1 2))))
     (error? ; not a procedure (child protocol)
       (let ([pprot (lambda (n) n)] [cprot 'flimflam])
         (define prtd (make-record-type "parent" '(x y)))
         (define crtd (make-record-type prtd "child" '(z)))
         (define prcd
           (make-record-constructor-descriptor prtd #f pprot))
         (define crcd
           (make-record-constructor-descriptor crtd prcd cprot))
         (define pcons (r6rs:record-constructor prcd))
         (define ccons (r6rs:record-constructor crcd))
         (list (pcons 1 2) (ccons 1 2))))
     (error? ; not a procedure (returned from parent protocol)
       (let ([pprot (lambda (n) 'not-a-procedure)]
             [cprot (lambda (p) (lambda (x y) ((p x 17) y)))])
         (define prtd (make-record-type "parent" '(x y)))
         (define crtd (make-record-type prtd "child" '(z)))
         (define prcd
           (make-record-constructor-descriptor prtd #f pprot))
         (define crcd
           (make-record-constructor-descriptor crtd prcd cprot))
         (define pcons (r6rs:record-constructor prcd))
         (define ccons (r6rs:record-constructor crcd))
         (list (pcons 1 2) (ccons 1 2))))
     (error? ; not a procedure (returned from child protocol)
       (let ([pprot (lambda (n) (lambda (z w) (n (+ z 7) w)))]
             [cprot (lambda (p) 'spam)])
         (define prtd (make-record-type "parent" '(x y)))
         (define crtd (make-record-type prtd "child" '(z)))
         (define prcd
           (make-record-constructor-descriptor prtd #f pprot))
         (define crcd
           (make-record-constructor-descriptor crtd prcd cprot))
         (define pcons (r6rs:record-constructor prcd))
         (define ccons (r6rs:record-constructor crcd))
         (list (pcons 1 2) (ccons 1 2))))
     (error? ; wrong number of arguments (to parent protocol)
       (let ([pprot (lambda (n) n)]
             [cprot (lambda (p) (lambda (x y) ((p x 0 17) y)))])
         (define prtd (make-record-type "parent" '(x y)))
         (define crtd (make-record-type prtd "child" '(z)))
         (define prcd
           (make-record-constructor-descriptor prtd #f pprot))
         (define crcd
           (make-record-constructor-descriptor crtd prcd cprot))
         (define pcons (r6rs:record-constructor prcd))
         (define ccons (r6rs:record-constructor crcd))
         (list (pcons 1 2) (ccons 1 2))))
     (error? ; wrong number of arguments (to parent protocol)
       (let ([pprot (lambda (n) n)]
             [cprot (lambda (p) (lambda (x y) ((p x) y)))])
         (define prtd (make-record-type "parent" '(x y)))
         (define crtd (make-record-type prtd "child" '(z)))
         (define prcd
           (make-record-constructor-descriptor prtd #f pprot))
         (define crcd
           (make-record-constructor-descriptor crtd prcd cprot))
         (define pcons (r6rs:record-constructor prcd))
         (define ccons (r6rs:record-constructor crcd))
         (list (pcons 1 2) (ccons 1 2))))
     (error? ; wrong number of arguments (to parent protocol)
       (let ([pprot (lambda (n) (lambda (z w) (n (+ z 7) w)))]
             [cprot (lambda (p) (lambda (x y) ((p x 17 'xtra) y)))])
         (define prtd (make-record-type "parent" '(x y)))
         (define crtd (make-record-type prtd "child" '(z)))
         (define prcd
           (make-record-constructor-descriptor prtd #f pprot))
         (define crcd
           (make-record-constructor-descriptor crtd prcd cprot))
         (define pcons (r6rs:record-constructor prcd))
         (define ccons (r6rs:record-constructor crcd))
         (list (pcons 1 2) (ccons 1 2))))
     (error? ; wrong number of arguments (to parent protocol)
       (let ([pprot (lambda (n) (lambda (z w) (n (+ z 7) w)))]
             [cprot (lambda (p) (lambda (x y) ((p x) y)))])
         (define prtd (make-record-type "parent" '(x y)))
         (define crtd (make-record-type prtd "child" '(z)))
         (define prcd
           (make-record-constructor-descriptor prtd #f pprot))
         (define crcd
           (make-record-constructor-descriptor crtd prcd cprot))
         (define pcons (r6rs:record-constructor prcd))
         (define ccons (r6rs:record-constructor crcd))
         (list (pcons 1 2) (ccons 1 2))))
     (error? ; wrong number of arguments (to child constructor)
       (let ([pprot (lambda (n) (lambda (z w) (n (+ z 7) w)))]
             [cprot (lambda (p) (lambda (x y) ((p x 17) y)))])
         (define prtd (make-record-type "parent" '(x y)))
         (define crtd (make-record-type prtd "child" '(z)))
         (define prcd
           (make-record-constructor-descriptor prtd #f pprot))
         (define crcd
           (make-record-constructor-descriptor crtd prcd cprot))
         (define pcons (r6rs:record-constructor prcd))
         (define ccons (r6rs:record-constructor crcd))
         (list (pcons 1 2) (ccons 1))))
     (error? ; wrong number of arguments (to child constructor)
       (let ([pprot (lambda (n) (lambda (z w) (n (+ z 7) w)))]
             [cprot (lambda (p) (lambda (x y) ((p x 17) y)))])
         (define prtd (make-record-type "parent" '(x y)))
         (define crtd (make-record-type prtd "child" '(z)))
         (define prcd
           (make-record-constructor-descriptor prtd #f pprot))
         (define crcd
           (make-record-constructor-descriptor crtd prcd cprot))
         (define pcons (r6rs:record-constructor prcd))
         (define ccons (r6rs:record-constructor crcd))
         (list (pcons 1 2) (ccons 1 2 3))))
     (error? ; wrong number of arguments (to parent "new" procedure)
       (let ([pprot (lambda (n) (lambda (z w) (n (+ z 7) w "what?")))]
             [cprot (lambda (p) (lambda (x y) ((p x 17) y)))])
         (define prtd (make-record-type "parent" '(x y)))
         (define crtd (make-record-type prtd "child" '(z)))
         (define prcd
           (make-record-constructor-descriptor prtd #f pprot))
         (define crcd
           (make-record-constructor-descriptor crtd prcd cprot))
         (define pcons (r6rs:record-constructor prcd))
         (define ccons (r6rs:record-constructor crcd))
         (list (pcons 1 2) (ccons 1 2))))
     (error? ; wrong number of arguments (to child "new" procedure)
       (let ([pprot (lambda (n) (lambda (z w) (n (+ z 7) w)))]
             [cprot (lambda (p) (lambda (x y) ((p x 17) y '#(oops))))])
         (define prtd (make-record-type "parent" '(x y)))
         (define crtd (make-record-type prtd "child" '(z)))
         (define prcd
           (make-record-constructor-descriptor prtd #f pprot))
         (define crcd
           (make-record-constructor-descriptor crtd prcd cprot))
         (define pcons (r6rs:record-constructor prcd))
         (define ccons (r6rs:record-constructor crcd))
         (list (pcons 1 2) (ccons 1 2))))

     ; make sure we can use modifiers and types as field names
     (equal? (let ()
               (define foo
                 (make-record-type-descriptor
                   'umph
                   #f
                   #f
                   #f
                   #f
                   '#((mutable mutable)
                      (immutable int)
                      (immutable integer-32))))
               (let ([x ((r6rs:record-constructor
                           (make-record-constructor-descriptor foo #f #f)) 3 4 5)])
                 ((record-mutator foo 0) x 75)
                 (list ($record->vector x)
                       ((record-accessor foo 0) x)
                       ((record-accessor foo 1) x)
                       ((record-accessor foo 2) x))))
             '(#(umph 75 4 5) 75 4 5))

     ; optimization tests---observe with expand/optimize
     (equal? (map $record->vector
                  (let ()
                    (define prtd
                      (make-record-type "parent" '(x y)))
                    (define crtd
                      (make-record-type prtd "child" '(z)))
                    (define prcd
                      (make-record-constructor-descriptor prtd #f #f))
                    (define crcd
                      (make-record-constructor-descriptor crtd #f #f))
                    (define pcons
                      (r6rs:record-constructor prcd))
                    (define ccons
                      (r6rs:record-constructor crcd))
                    (list (pcons 1 2) (ccons 1 2 3))))
             '(#(parent 1 2) #(child 1 2 3)))
     (equivalent-expansion? ; optimize-level 2 expansion of above
       (parameterize
         ([optimize-level 2]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(let ()
              (define prtd
                (make-record-type "parent" '(x y)))
              (define crtd
                (make-record-type prtd "child" '(z)))
              (define prcd
                (make-record-constructor-descriptor prtd #f #f))
              (define crcd
                (make-record-constructor-descriptor crtd #f #f))
              (define pcons (r6rs:record-constructor prcd))
              (define ccons (r6rs:record-constructor crcd))
              (list (pcons 1 2) (ccons 1 2 3)))))
       '(let ([prtd (#2%make-record-type "parent" '(x y))])
          (let ([crtd (#2%make-record-type prtd "child" '(z))])
            (#2%list (#3%$record prtd 1 2) (#3%$record crtd 1 2 3)))))
     (equivalent-expansion? ; optimize-level 3 expansion of above
       (parameterize
         ([optimize-level 3]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(let ()
              (define prtd
                (make-record-type "parent" '(x y)))
              (define crtd
                (make-record-type prtd "child" '(z)))
              (define prcd
                (make-record-constructor-descriptor prtd #f #f))
              (define crcd
                (make-record-constructor-descriptor crtd #f #f))
              (define pcons (r6rs:record-constructor prcd))
              (define ccons (r6rs:record-constructor crcd))
              (list (pcons 1 2) (ccons 1 2 3)))))
       '(let ([prtd (#3%make-record-type "parent" '(x y))])
          (let ([crtd (#3%make-record-type prtd "child" '(z))])
            (#3%list (#3%$record prtd 1 2) (#3%$record crtd 1 2 3)))))
     ; same as set above except with r6rs:record-constructor
     ; replaced by record:constructor, which should handle rcds
     (equal? (map $record->vector
                  (let ()
                    (define prtd
                      (make-record-type "parent" '(x y)))
                    (define crtd
                      (make-record-type prtd "child" '(z)))
                    (define prcd
                      (make-record-constructor-descriptor prtd #f #f))
                    (define crcd
                      (make-record-constructor-descriptor crtd #f #f))
                    (define pcons (record-constructor prcd))
                    (define ccons (record-constructor crcd))
                    (list (pcons 1 2) (ccons 1 2 3))))
             '(#(parent 1 2) #(child 1 2 3)))
     (equivalent-expansion? ; optimize-level 2 expansion of above
       (parameterize
         ([optimize-level 2]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(let ()
              (define prtd
                (make-record-type "parent" '(x y)))
              (define crtd
                (make-record-type prtd "child" '(z)))
              (define prcd
                (make-record-constructor-descriptor prtd #f #f))
              (define crcd
                (make-record-constructor-descriptor crtd #f #f))
              (define pcons (record-constructor prcd))
              (define ccons (record-constructor crcd))
              (list (pcons 1 2) (ccons 1 2 3)))))
       '(let ([prtd (#2%make-record-type "parent" '(x y))])
          (let ([crtd (#2%make-record-type prtd "child" '(z))])
            (#2%list (#3%$record prtd 1 2) (#3%$record crtd 1 2 3)))))
     (equivalent-expansion? ; optimize-level 3 expansion of above
       (parameterize
         ([optimize-level 3]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(let ()
              (define prtd
                (make-record-type "parent" '(x y)))
              (define crtd
                (make-record-type prtd "child" '(z)))
              (define prcd
                (make-record-constructor-descriptor prtd #f #f))
              (define crcd
                (make-record-constructor-descriptor crtd #f #f))
              (define pcons (record-constructor prcd))
              (define ccons (record-constructor crcd))
              (list (pcons 1 2) (ccons 1 2 3)))))
       '(let ([prtd (#3%make-record-type "parent" '(x y))])
          (let ([crtd (#3%make-record-type prtd "child" '(z))])
            (#3%list (#3%$record prtd 1 2) (#3%$record crtd 1 2 3)))))
     (equal? (map $record->vector
                  ; same thing except supplying prcd in place of #f, which should
                  ; result in the same residual code
                  (let ()
                    (define prtd
                      (make-record-type "parent" '(x y)))
                    (define crtd
                      (make-record-type prtd "child" '(z)))
                    (define prcd
                      (make-record-constructor-descriptor prtd #f #f))
                    (define crcd
                      (make-record-constructor-descriptor crtd prcd #f))
                    (define pcons
                      (r6rs:record-constructor prcd))
                    (define ccons
                      (r6rs:record-constructor crcd))
                    (list (pcons 1 2) (ccons 1 2 3))))
             '(#(parent 1 2) #(child 1 2 3)))
     (equivalent-expansion? ; optimize-level 2 expansion of above
       (parameterize
         ([optimize-level 2]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(let ()
              (define prtd
                (make-record-type "parent" '(x y)))
              (define crtd
                (make-record-type prtd "child" '(z)))
              (define prcd
                (make-record-constructor-descriptor prtd #f #f))
              (define crcd
                (make-record-constructor-descriptor crtd prcd #f))
              (define pcons (r6rs:record-constructor prcd))
              (define ccons (r6rs:record-constructor crcd))
              (list (pcons 1 2) (ccons 1 2 3)))))
       '(let ([prtd (#2%make-record-type "parent" '(x y))])
          (let ([crtd (#2%make-record-type prtd "child" '(z))])
            (#2%list (#3%$record prtd 1 2) (#3%$record crtd 1 2 3)))))
     (equivalent-expansion? ; optimize-level 3 expansion of above
       (parameterize
         ([optimize-level 3]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(let ()
              (define prtd
                (make-record-type "parent" '(x y)))
              (define crtd
                (make-record-type prtd "child" '(z)))
              (define prcd
                (make-record-constructor-descriptor prtd #f #f))
              (define crcd
                (make-record-constructor-descriptor crtd prcd #f))
              (define pcons (r6rs:record-constructor prcd))
              (define ccons (r6rs:record-constructor crcd))
              (list (pcons 1 2) (ccons 1 2 3)))))
       '(let ([prtd (#3%make-record-type "parent" '(x y))])
          (let ([crtd (#3%make-record-type prtd "child" '(z))])
            (#3%list (#3%$record prtd 1 2) (#3%$record crtd 1 2 3)))))
     (equal? (map $record->vector
                  ; test with variables bound to protocol lambda expressions
                  (let ([pprot (lambda (n) n)]
                        [cprot (lambda (p) (lambda (x y) ((p x 0) y)))])
                    (define prtd
                      (make-record-type "parent" '(x y)))
                    (define crtd
                      (make-record-type prtd "child" '(z)))
                    (define prcd
                      (make-record-constructor-descriptor prtd #f pprot))
                    (define crcd
                      (make-record-constructor-descriptor crtd prcd cprot))
                    (define pcons
                      (r6rs:record-constructor prcd))
                    (define ccons
                      (r6rs:record-constructor crcd))
                    (list (pcons 1 2) (ccons 1 2))))
             '(#(parent 1 2) #(child 1 0 2)))
     (equivalent-expansion? ; optimize-level 2 expansion of above
       (parameterize
         ([optimize-level 2]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(let ([pprot (lambda (n) n)]
                  [cprot (lambda (p) (lambda (x y) ((p x 0) y)))])
              (define prtd
                (make-record-type "parent" '(x y)))
              (define crtd
                (make-record-type prtd "child" '(z)))
              (define prcd
                (make-record-constructor-descriptor prtd #f pprot))
              (define crcd
                (make-record-constructor-descriptor crtd prcd cprot))
              (define pcons (r6rs:record-constructor prcd))
              (define ccons (r6rs:record-constructor crcd))
              (list (pcons 1 2) (ccons 1 2)))))
       '(let ([prtd (#2%make-record-type "parent" '(x y))])
          (let ([crtd (#2%make-record-type prtd "child" '(z))])
            (#2%list (#3%$record prtd 1 2) (#3%$record crtd 1 0 2)))))
     (equivalent-expansion? ; optimize-level 3 expansion of above
       (parameterize
         ([optimize-level 3]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(let ([pprot (lambda (n) n)]
                  [cprot (lambda (p) (lambda (x y) ((p x 0) y)))])
              (define prtd
                (make-record-type "parent" '(x y)))
              (define crtd
                (make-record-type prtd "child" '(z)))
              (define prcd
                (make-record-constructor-descriptor prtd #f pprot))
              (define crcd
                (make-record-constructor-descriptor crtd prcd cprot))
              (define pcons (r6rs:record-constructor prcd))
              (define ccons (r6rs:record-constructor crcd))
              (list (pcons 1 2) (ccons 1 2)))))
       '(let ([prtd (#3%make-record-type "parent" '(x y))])
          (let ([crtd (#3%make-record-type prtd "child" '(z))])
            (#3%list (#3%$record prtd 1 2) (#3%$record crtd 1 0 2)))))
     (begin (define $global 'worldwide) #t)
     (equal? (map $record->vector
                  ; same but with a global variable in place of the constant 0
                  (let ([pprot (lambda (n) n)]
                        [cprot (lambda (p)
                                 (lambda (x y)
                                   ((p x $global) y)))])
                    (define prtd
                      (make-record-type "parent" '(x y)))
                    (define crtd
                      (make-record-type prtd "child" '(z)))
                    (define prcd
                      (make-record-constructor-descriptor prtd #f pprot))
                    (define crcd
                      (make-record-constructor-descriptor crtd prcd cprot))
                    (define pcons
                      (r6rs:record-constructor prcd))
                    (define ccons
                      (r6rs:record-constructor crcd))
                    (list (pcons 1 2) (ccons 1 2))))
             '(#(parent 1 2) #(child 1 worldwide 2)))
     (equivalent-expansion? ; optimize-level 2 expansion of above
       (parameterize
         ([optimize-level 2]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(let ([pprot (lambda (n) n)]
                  [cprot (lambda (p) (lambda (x y) ((p x $global) y)))])
              (define prtd
                (make-record-type "parent" '(x y)))
              (define crtd
                (make-record-type prtd "child" '(z)))
              (define prcd
                (make-record-constructor-descriptor prtd #f pprot))
              (define crcd
                (make-record-constructor-descriptor crtd prcd cprot))
              (define pcons (r6rs:record-constructor prcd))
              (define ccons (r6rs:record-constructor crcd))
              (list (pcons 1 2) (ccons 1 2)))))
       '(let ([prtd (#2%make-record-type "parent" '(x y))])
          (let ([crtd (#2%make-record-type prtd "child" '(z))])
            (#2%list (#3%$record prtd 1 2) (#3%$record crtd 1 $global 2)))))
     (equivalent-expansion? ; optimize-level 3 expansion of above
       (parameterize
         ([optimize-level 3]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(let ([pprot (lambda (n) n)]
                  [cprot (lambda (p) (lambda (x y) ((p x $global) y)))])
              (define prtd
                (make-record-type "parent" '(x y)))
              (define crtd
                (make-record-type prtd "child" '(z)))
              (define prcd
                (make-record-constructor-descriptor prtd #f pprot))
              (define crcd
                (make-record-constructor-descriptor crtd prcd cprot))
              (define pcons (r6rs:record-constructor prcd))
              (define ccons (r6rs:record-constructor crcd))
              (list (pcons 1 2) (ccons 1 2)))))
       '(let ([prtd (#3%make-record-type "parent" '(x y))])
          (let ([crtd (#3%make-record-type prtd "child" '(z))])
            (#3%list (#3%$record prtd 1 2) (#3%$record crtd 1 $global 2)))))
     (equal? (map $record->vector
                  ; same but with a outer lexical variable in place of the constant 0
                  (let ([lex $global])
                    (let ([pprot (lambda (n) n)]
                          [cprot (lambda (p) (lambda (x y) ((p x lex) y)))])
                      (define prtd
                        (make-record-type "parent" '(x y)))
                      (define crtd
                        (make-record-type prtd "child" '(z)))
                      (define prcd
                        (make-record-constructor-descriptor prtd #f pprot))
                      (define crcd
                        (make-record-constructor-descriptor crtd prcd cprot))
                      (define pcons
                        (r6rs:record-constructor prcd))
                      (define ccons
                        (r6rs:record-constructor crcd))
                      (list (pcons 1 2) (ccons 1 2)))))
             '(#(parent 1 2) #(child 1 worldwide 2)))
     (equivalent-expansion? ; optimize-level 2 expansion of above
       (parameterize
         ([optimize-level 2]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(let ([lex $global])
              (let ([pprot (lambda (n) n)]
                    [cprot (lambda (p) (lambda (x y) ((p x lex) y)))])
                (define prtd
                  (make-record-type "parent" '(x y)))
                (define crtd
                  (make-record-type prtd "child" '(z)))
                (define prcd
                  (make-record-constructor-descriptor prtd #f pprot))
                (define crcd
                  (make-record-constructor-descriptor crtd prcd cprot))
                (define pcons
                  (r6rs:record-constructor prcd))
                (define ccons
                  (r6rs:record-constructor crcd))
                (list (pcons 1 2) (ccons 1 2))))))
       '(let ([lex $global])
          (let ([prtd (#2%make-record-type "parent" '(x y))])
            (let ([crtd (#2%make-record-type prtd "child" '(z))])
              (#2%list (#3%$record prtd 1 2) (#3%$record crtd 1 lex 2))))))
     (equivalent-expansion? ; optimize-level 3 expansion of above
       (parameterize
         ([optimize-level 3]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(let ([lex $global])
              (let ([pprot (lambda (n) n)]
                    [cprot (lambda (p) (lambda (x y) ((p x lex) y)))])
                (define prtd
                  (make-record-type "parent" '(x y)))
                (define crtd
                  (make-record-type prtd "child" '(z)))
                (define prcd
                  (make-record-constructor-descriptor prtd #f pprot))
                (define crcd
                  (make-record-constructor-descriptor crtd prcd cprot))
                (define pcons
                  (r6rs:record-constructor prcd))
                (define ccons
                  (r6rs:record-constructor crcd))
                (list (pcons 1 2) (ccons 1 2))))))
       '(let ([lex $global])
          (let ([prtd (#3%make-record-type "parent" '(x y))])
            (let ([crtd (#3%make-record-type prtd "child" '(z))])
              (#3%list (#3%$record prtd 1 2) (#3%$record crtd 1 lex 2))))))
     (equal? (map $record->vector
                  ; same but slightly more complicated parent protocol
                  (let ([lex $global])
                    (let ([pprot (lambda (n) (lambda (z w) (n (+ z 7) w)))]
                          [cprot (lambda (p) (lambda (x y) ((p x lex) y)))])
                      (define prtd
                        (make-record-type "parent" '(x y)))
                      (define crtd
                        (make-record-type prtd "child" '(z)))
                      (define prcd
                        (make-record-constructor-descriptor prtd #f pprot))
                      (define crcd
                        (make-record-constructor-descriptor crtd prcd cprot))
                      (define pcons
                        (r6rs:record-constructor prcd))
                      (define ccons
                        (r6rs:record-constructor crcd))
                      (list (pcons 1 2) (ccons 1 2)))))
             '(#(parent 8 2) #(child 8 worldwide 2)))
     (equivalent-expansion? ; optimize-level 2 expansion of above
       (parameterize
         ([optimize-level 2]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(let ([lex $global])
              (let ([pprot (lambda (n) (lambda (z w) (n (+ z 7) w)))]
                    [cprot (lambda (p) (lambda (x y) ((p x lex) y)))])
                (define prtd
                  (make-record-type "parent" '(x y)))
                (define crtd
                  (make-record-type prtd "child" '(z)))
                (define prcd
                  (make-record-constructor-descriptor prtd #f pprot))
                (define crcd
                  (make-record-constructor-descriptor crtd prcd cprot))
                (define pcons
                  (r6rs:record-constructor prcd))
                (define ccons
                  (r6rs:record-constructor crcd))
                (list (pcons 1 2) (ccons 1 2))))))
       '(let ([lex $global])
          (let ([prtd (#2%make-record-type "parent" '(x y))])
            (let ([crtd (#2%make-record-type prtd "child" '(z))])
              (#2%list (#3%$record prtd 8 2) (#3%$record crtd 8 lex 2))))))
     (equivalent-expansion? ; optimize-level 3 expansion of above
       (parameterize
         ([optimize-level 3]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(let ([lex $global])
              (let ([pprot (lambda (n) (lambda (z w) (n (+ z 7) w)))]
                    [cprot (lambda (p) (lambda (x y) ((p x lex) y)))])
                (define prtd
                  (make-record-type "parent" '(x y)))
                (define crtd
                  (make-record-type prtd "child" '(z)))
                (define prcd
                  (make-record-constructor-descriptor prtd #f pprot))
                (define crcd
                  (make-record-constructor-descriptor crtd prcd cprot))
                (define pcons
                  (r6rs:record-constructor prcd))
                (define ccons
                  (r6rs:record-constructor crcd))
                (list (pcons 1 2) (ccons 1 2))))))
       '(let ([lex $global])
          (let ([prtd (#3%make-record-type "parent" '(x y))])
            (let ([crtd (#3%make-record-type prtd "child" '(z))])
              (#3%list (#3%$record prtd 8 2) (#3%$record crtd 8 lex 2))))))
     (equal? (map $record->vector
                  ; same but ignore one of the parent args
                  (let ([lex $global])
                    (let ([pprot (lambda (n) (lambda (z w) (n (+ z 7) 53)))]
                          [cprot (lambda (p) (lambda (x y) ((p x lex) y)))])
                      (define prtd
                        (make-record-type "parent" '(x y)))
                      (define crtd
                        (make-record-type prtd "child" '(z)))
                      (define prcd
                        (make-record-constructor-descriptor prtd #f pprot))
                      (define crcd
                        (make-record-constructor-descriptor crtd prcd cprot))
                      (define pcons
                        (r6rs:record-constructor prcd))
                      (define ccons
                        (r6rs:record-constructor crcd))
                      (list (pcons 1 2) (ccons 1 2)))))
             '(#(parent 8 53) #(child 8 53 2)))
     (equivalent-expansion? ; optimize-level 2 expansion of above
       (parameterize
         ([optimize-level 2]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(let ([lex $global])
              (let ([pprot (lambda (n) (lambda (z w) (n (+ z 7) 53)))]
                    [cprot (lambda (p) (lambda (x y) ((p x lex) y)))])
                (define prtd
                  (make-record-type "parent" '(x y)))
                (define crtd
                  (make-record-type prtd "child" '(z)))
                (define prcd
                  (make-record-constructor-descriptor prtd #f pprot))
                (define crcd
                  (make-record-constructor-descriptor crtd prcd cprot))
                (define pcons
                  (r6rs:record-constructor prcd))
                (define ccons
                  (r6rs:record-constructor crcd))
                (list (pcons 1 2) (ccons 1 2))))))
       '(begin
          $global
          (let ([prtd (#2%make-record-type "parent" '(x y))])
            (let ([crtd (#2%make-record-type prtd "child" '(z))])
              (#2%list (#3%$record prtd 8 53) (#3%$record crtd 8 53 2))))))
     (equivalent-expansion? ; optimize-level 3 expansion of above
       (parameterize
         ([optimize-level 3]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(let ([lex $global])
              (let ([pprot (lambda (n) (lambda (z w) (n (+ z 7) 53)))]
                    [cprot (lambda (p) (lambda (x y) ((p x lex) y)))])
                (define prtd
                  (make-record-type "parent" '(x y)))
                (define crtd
                  (make-record-type prtd "child" '(z)))
                (define prcd
                  (make-record-constructor-descriptor prtd #f pprot))
                (define crcd
                  (make-record-constructor-descriptor crtd prcd cprot))
                (define pcons
                  (r6rs:record-constructor prcd))
                (define ccons
                  (r6rs:record-constructor crcd))
                (list (pcons 1 2) (ccons 1 2))))))
       '(let ([prtd (#3%make-record-type "parent" '(x y))])
          (let ([crtd (#3%make-record-type prtd "child" '(z))])
            (#3%list (#3%$record prtd 8 53) (#3%$record crtd 8 53 2)))))
     (equal? (map $record->vector
                  ; same thing except pprot and cprot lambda expressions
                  ; appear directly in the calls to m-r-c-d
                  (let ()
                    (define prtd
                      (make-record-type "parent" '(x y)))
                    (define crtd
                      (make-record-type prtd "child" '(z)))
                    (define prcd
                      (make-record-constructor-descriptor prtd #f
                        (lambda (n) n)))
                    (define crcd
                      (make-record-constructor-descriptor crtd prcd
                        (lambda (p)
                          (lambda (x y) ((p x 0) y)))))
                    (define pcons
                      (r6rs:record-constructor prcd))
                    (define ccons
                      (r6rs:record-constructor crcd))
                    (list (pcons 1 2) (ccons 1 2))))
             '(#(parent 1 2) #(child 1 0 2)))
     (equivalent-expansion? ; optimize-level 2 expansion of above
       (parameterize
         ([optimize-level 2]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(let ()
              (define prtd
                (make-record-type "parent" '(x y)))
              (define crtd
                (make-record-type prtd "child" '(z)))
              (define prcd
                (make-record-constructor-descriptor prtd #f (lambda (n) n)))
              (define crcd
                (make-record-constructor-descriptor crtd prcd
                  (lambda (p) (lambda (x y) ((p x 0) y)))))
              (define pcons (r6rs:record-constructor prcd))
              (define ccons (r6rs:record-constructor crcd))
              (list (pcons 1 2) (ccons 1 2)))))
       '(let ([prtd (#2%make-record-type "parent" '(x y))])
          (let ([crtd (#2%make-record-type prtd "child" '(z))])
            (#2%list (#3%$record prtd 1 2) (#3%$record crtd 1 0 2)))))
     (equivalent-expansion? ; optimize-level 3 expansion of above
       (parameterize
         ([optimize-level 3]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(let ()
              (define prtd
                (make-record-type "parent" '(x y)))
              (define crtd
                (make-record-type prtd "child" '(z)))
              (define prcd
                (make-record-constructor-descriptor prtd #f (lambda (n) n)))
              (define crcd
                (make-record-constructor-descriptor crtd prcd
                  (lambda (p) (lambda (x y) ((p x 0) y)))))
              (define pcons (r6rs:record-constructor prcd))
              (define ccons (r6rs:record-constructor crcd))
              (list (pcons 1 2) (ccons 1 2)))))
       '(let ([prtd (#3%make-record-type "parent" '(x y))])
          (let ([crtd (#3%make-record-type prtd "child" '(z))])
            (#3%list (#3%$record prtd 1 2) (#3%$record crtd 1 0 2)))))
     (equal? (map $record->vector
                  ; same thing except with slightly more complicated parent protocol
                  (let ()
                    (define prtd
                      (make-record-type "parent" '(x y)))
                    (define crtd
                      (make-record-type prtd "child" '(z)))
                    (define prcd
                      (make-record-constructor-descriptor prtd #f
                        (lambda (n)
                          (lambda (z w) (n (+ z 7) w)))))
                    (define crcd
                      (make-record-constructor-descriptor crtd prcd
                        (lambda (p)
                          (lambda (x y) ((p x y) 0)))))
                    (define pcons
                      (r6rs:record-constructor prcd))
                    (define ccons
                      (r6rs:record-constructor crcd))
                    (list (pcons 1 2) (ccons 1 2))))
             '(#(parent 8 2) #(child 8 2 0)))
     (equivalent-expansion? ; optimize-level 2 expansion of above
       (parameterize
         ([optimize-level 2]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(let ()
              (define prtd
                (make-record-type "parent" '(x y)))
              (define crtd
                (make-record-type prtd "child" '(z)))
              (define prcd
                (make-record-constructor-descriptor prtd #f
                  (lambda (n) (lambda (z w) (n (+ z 7) w)))))
              (define crcd
                (make-record-constructor-descriptor crtd prcd
                  (lambda (p) (lambda (x y) ((p x y) 0)))))
              (define pcons (r6rs:record-constructor prcd))
              (define ccons (r6rs:record-constructor crcd))
              (list (pcons 1 2) (ccons 1 2)))))
       '(let ([prtd (#2%make-record-type "parent" '(x y))])
          (let ([crtd (#2%make-record-type prtd "child" '(z))])
            (#2%list (#3%$record prtd 8 2) (#3%$record crtd 8 2 0)))))
     (equivalent-expansion? ; optimize-level 3 expansion of above
       (parameterize
         ([optimize-level 3]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(let ()
              (define prtd
                (make-record-type "parent" '(x y)))
              (define crtd
                (make-record-type prtd "child" '(z)))
              (define prcd
                (make-record-constructor-descriptor prtd #f
                  (lambda (n) (lambda (z w) (n (+ z 7) w)))))
              (define crcd
                (make-record-constructor-descriptor crtd prcd
                  (lambda (p) (lambda (x y) ((p x y) 0)))))
              (define pcons (r6rs:record-constructor prcd))
              (define ccons (r6rs:record-constructor crcd))
              (list (pcons 1 2) (ccons 1 2)))))
       '(let ([prtd (#3%make-record-type "parent" '(x y))])
          (let ([crtd (#3%make-record-type prtd "child" '(z))])
            (#3%list (#3%$record prtd 8 2) (#3%$record crtd 8 2 0)))))
     (equal? (map $record->vector
                  ; same thing but ignore one of the parent args
                  (let ()
                    (define prtd
                      (make-record-type "parent" '(x y)))
                    (define crtd
                      (make-record-type prtd "child" '(z)))
                    (define prcd
                      (make-record-constructor-descriptor prtd #f
                        (lambda (n)
                          (lambda (z w) (n (+ z 7) 53)))))
                    (define crcd
                      (make-record-constructor-descriptor crtd prcd
                        (lambda (p)
                          (lambda (x y) ((p x y) 0)))))
                    (define pcons
                      (r6rs:record-constructor prcd))
                    (define ccons
                      (r6rs:record-constructor crcd))
                    (list (pcons 1 2) (ccons 1 2))))
             '(#(parent 8 53) #(child 8 53 0)))
     (equivalent-expansion? ; optimize-level 2 expansion of above
       (parameterize
         ([optimize-level 2]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(let ()
              (define prtd
                (make-record-type "parent" '(x y)))
              (define crtd
                (make-record-type prtd "child" '(z)))
              (define prcd
                (make-record-constructor-descriptor prtd #f
                  (lambda (n) (lambda (z w) (n (+ z 7) 53)))))
              (define crcd
                (make-record-constructor-descriptor crtd prcd
                  (lambda (p) (lambda (x y) ((p x y) 0)))))
              (define pcons (r6rs:record-constructor prcd))
              (define ccons (r6rs:record-constructor crcd))
              (list (pcons 1 2) (ccons 1 2)))))
       '(let ([prtd (#2%make-record-type "parent" '(x y))])
          (let ([crtd (#2%make-record-type prtd "child" '(z))])
            (#2%list (#3%$record prtd 8 53) (#3%$record crtd 8 53 0)))))
     (equivalent-expansion? ; optimize-level 3 expansion of above
       (parameterize
         ([optimize-level 3]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(let ()
              (define prtd
                (make-record-type "parent" '(x y)))
              (define crtd
                (make-record-type prtd "child" '(z)))
              (define prcd
                (make-record-constructor-descriptor prtd #f
                  (lambda (n) (lambda (z w) (n (+ z 7) 53)))))
              (define crcd
                (make-record-constructor-descriptor crtd prcd
                  (lambda (p) (lambda (x y) ((p x y) 0)))))
              (define pcons (r6rs:record-constructor prcd))
              (define ccons (r6rs:record-constructor crcd))
              (list (pcons 1 2) (ccons 1 2)))))
       '(let ([prtd (#3%make-record-type "parent" '(x y))])
          (let ([crtd (#3%make-record-type prtd "child" '(z))])
            (#3%list (#3%$record prtd 8 53) (#3%$record crtd 8 53 0)))))
     (equal? (map $record->vector
                  ; same thing except don't give a name to the child rcd
                  ; surprisingly, this folds up because the call to r6rs:record-constructor
                  ; (as with any primitive call) gets pushed into the letrec produced by
                  ; make-record-constructor-descriptor
                  ; > (print-gensym #f)
                  ; > (new-cafe expand/optimize)
                  ; >> (#%r6rs:record-constructor (letrec ((x (lambda (n) n))) (foo x)))
                  ; (letrec ([x (lambda (n) n)]) (#2%r6rs:record-constructor (foo x)))
                  ; >> (#%car (letrec ((x (lambda (n) n))) (foo x)))
                  ; (letrec ([x (lambda (n) n)]) (#2%car (foo x)))
                  (let ()
                    (define prtd
                      (make-record-type "parent" '(x y)))
                    (define crtd
                      (make-record-type prtd "child" '(z)))
                    (define prcd
                      (make-record-constructor-descriptor prtd #f
                        (lambda (n)
                          (lambda (z w) (n (+ z 7) w)))))
                    (define pcons
                      (r6rs:record-constructor prcd))
                    (define ccons
                      (r6rs:record-constructor
                        (make-record-constructor-descriptor crtd prcd
                          (lambda (p)
                            (lambda (x y) ((p x y) 0))))))
                    (list (pcons 1 2) (ccons 1 2))))
             '(#(parent 8 2) #(child 8 2 0)))
     (equivalent-expansion? ; optimize-level 2 expansion of above
       (parameterize
         ([optimize-level 2]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(let ()
              (define prtd
                (make-record-type "parent" '(x y)))
              (define crtd
                (make-record-type prtd "child" '(z)))
              (define prcd
                (make-record-constructor-descriptor prtd #f
                  (lambda (n) (lambda (z w) (n (+ z 7) w)))))
              (define pcons (r6rs:record-constructor prcd))
              (define ccons
                (r6rs:record-constructor
                  (make-record-constructor-descriptor crtd prcd
                    (lambda (p) (lambda (x y) ((p x y) 0))))))
              (list (pcons 1 2) (ccons 1 2)))))
       '(let ([prtd (#2%make-record-type "parent" '(x y))])
          (let ([crtd (#2%make-record-type prtd "child" '(z))])
            (#2%list (#3%$record prtd 8 2) (#3%$record crtd 8 2 0)))))
     (equivalent-expansion? ; optimize-level 3 expansion of above
       (parameterize
         ([optimize-level 3]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(let ()
              (define prtd
                (make-record-type "parent" '(x y)))
              (define crtd
                (make-record-type prtd "child" '(z)))
              (define prcd
                (make-record-constructor-descriptor prtd #f
                  (lambda (n) (lambda (z w) (n (+ z 7) w)))))
              (define pcons (r6rs:record-constructor prcd))
              (define ccons
                (r6rs:record-constructor
                  (make-record-constructor-descriptor crtd prcd
                    (lambda (p) (lambda (x y) ((p x y) 0))))))
              (list (pcons 1 2) (ccons 1 2)))))
       '(let ([prtd (#3%make-record-type "parent" '(x y))])
          (let ([crtd (#3%make-record-type prtd "child" '(z))])
            (#3%list (#3%$record prtd 8 2) (#3%$record crtd 8 2 0)))))
     (equal? (map $record->vector
                  ; same thing except give pprot a name
                  (let ()
                    (define prtd
                      (make-record-type "parent" '(x y)))
                    (define crtd
                      (make-record-type prtd "child" '(z)))
                    (define pprot
                      (lambda (n)
                        (lambda (z w) (n (+ z 7) w))))
                    (define prcd
                      (make-record-constructor-descriptor prtd #f pprot))
                    (define pcons
                      (r6rs:record-constructor prcd))
                    (define ccons
                      (r6rs:record-constructor
                        (make-record-constructor-descriptor crtd prcd
                          (lambda (p)
                            (lambda (x y) ((p x y) 0))))))
                    (list (pcons 1 2) (ccons 1 2))))
             '(#(parent 8 2) #(child 8 2 0)))
     (equivalent-expansion? ; optimize-level 2 expansion of above
       (parameterize
         ([optimize-level 2]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(let ()
              (define prtd
                (make-record-type "parent" '(x y)))
              (define crtd
                (make-record-type prtd "child" '(z)))
              (define pprot
                (lambda (n) (lambda (z w) (n (+ z 7) w))))
              (define prcd
                (make-record-constructor-descriptor prtd #f pprot))
              (define pcons (r6rs:record-constructor prcd))
              (define ccons
                (r6rs:record-constructor
                  (make-record-constructor-descriptor crtd prcd
                    (lambda (p) (lambda (x y) ((p x y) 0))))))
              (list (pcons 1 2) (ccons 1 2)))))
       '(let ([prtd (#2%make-record-type "parent" '(x y))])
          (let ([crtd (#2%make-record-type prtd "child" '(z))])
            (#2%list (#3%$record prtd 8 2) (#3%$record crtd 8 2 0)))))
     (equivalent-expansion? ; optimize-level 3 expansion of above
       (parameterize
         ([optimize-level 3]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(let ()
              (define prtd
                (make-record-type "parent" '(x y)))
              (define crtd
                (make-record-type prtd "child" '(z)))
              (define pprot
                (lambda (n) (lambda (z w) (n (+ z 7) w))))
              (define prcd
                (make-record-constructor-descriptor prtd #f pprot))
              (define pcons (r6rs:record-constructor prcd))
              (define ccons
                (r6rs:record-constructor
                  (make-record-constructor-descriptor crtd prcd
                    (lambda (p) (lambda (x y) ((p x y) 0))))))
              (list (pcons 1 2) (ccons 1 2)))))
       '(let ([prtd (#3%make-record-type "parent" '(x y))])
          (let ([crtd (#3%make-record-type prtd "child" '(z))])
            (#3%list (#3%$record prtd 8 2) (#3%$record crtd 8 2 0)))))
     (equal? (map $record->vector
                  ; push our luck: don't give a name to parent rcd either.
                  ; this one doesn't fold up.  to fix it, we'd need to (a)
                  ; pull the inner m-r-c-d call and outer protocol expr into a
                  ; let or letrec wrapping the outer m-r-c-d call, and (b)
                  ; pull the bindings for both outside of the r6rs:r-c call ...
                  (let ()
                    (define prtd
                      (make-record-type "parent" '(x y)))
                    (define crtd
                      (make-record-type prtd "child" '(z)))
                    (define pcons
                      (r6rs:record-constructor
                        (make-record-constructor-descriptor prtd #f
                          (lambda (n)
                            (lambda (z w) (n (+ z 7) w))))))
                    (define ccons
                      (r6rs:record-constructor
                        (make-record-constructor-descriptor crtd
                          (make-record-constructor-descriptor prtd #f
                            (lambda (n)
                              (lambda (z w) (n (+ z 7) w))))
                          (lambda (p)
                            (lambda (x y) ((p x y) 0))))))
                    (list (pcons 1 2) (ccons 1 2))))
             '(#(parent 8 2) #(child 8 2 0)))
     (equal? (map $record->vector
                  ; ... like this (at optimize-level 3, anyway)
                  (let ()
                    (define prtd
                      (make-record-type "parent" '(x y)))
                    (define crtd
                      (make-record-type prtd "child" '(z)))
                    (define pcons
                      (r6rs:record-constructor
                        (make-record-constructor-descriptor prtd #f
                          (lambda (n)
                            (lambda (z w) (n (+ z 7) w))))))
                    (define ccons
                      (let ([prcd (make-record-constructor-descriptor
                                    prtd
                                    #f
                                    (lambda (n)
                                      (lambda (z w)
                                        (n (+ z 7) w))))]
                            [cprot (lambda (p) (lambda (x y) ((p x y) 0)))])
                        (r6rs:record-constructor
                          (make-record-constructor-descriptor crtd prcd cprot))))
                    (list (pcons 1 2) (ccons 1 2))))
             '(#(parent 8 2) #(child 8 2 0)))
     (equivalent-expansion? ; optimize-level 2 expansion of above
       (parameterize
         ([optimize-level 2]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(let ()
              (define prtd
                (make-record-type "parent" '(x y)))
              (define crtd
                (make-record-type prtd "child" '(z)))
              (define pcons
                (r6rs:record-constructor
                  (make-record-constructor-descriptor prtd #f
                    (lambda (n)
                      (lambda (z w) (n (+ z 7) w))))))
              (define ccons
                (let ([prcd (make-record-constructor-descriptor prtd #f
                              (lambda (n)
                                (lambda (z w) (n (+ z 7) w))))]
                      [cprot (lambda (p) (lambda (x y) ((p x y) 0)))])
                  (r6rs:record-constructor
                    (make-record-constructor-descriptor crtd prcd cprot))))
              (list (pcons 1 2) (ccons 1 2)))))
       ; this is now as good as it gets at optimize-level 2
       '(let ([prtd (#2%make-record-type "parent" '(x y))])
          (let ([crtd (#2%make-record-type prtd "child" '(z))])
            (#2%list (#3%$record prtd 8 2) (#3%$record crtd 8 2 0)))))
     (equivalent-expansion? ; optimize-level 3 expansion of above
       (parameterize
         ([optimize-level 3]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(let ()
              (define prtd
                (make-record-type "parent" '(x y)))
              (define crtd
                (make-record-type prtd "child" '(z)))
              (define pcons
                (r6rs:record-constructor
                  (make-record-constructor-descriptor prtd #f
                    (lambda (n)
                      (lambda (z w) (n (+ z 7) w))))))
              (define ccons
                (let ([prcd (make-record-constructor-descriptor prtd #f
                              (lambda (n)
                                (lambda (z w) (n (+ z 7) w))))]
                      [cprot (lambda (p) (lambda (x y) ((p x y) 0)))])
                  (r6rs:record-constructor
                    (make-record-constructor-descriptor crtd prcd cprot))))
              (list (pcons 1 2) (ccons 1 2)))))
       '(let ([prtd (#3%make-record-type "parent" '(x y))])
          (let ([crtd (#3%make-record-type prtd "child" '(z))])
            (#3%list (#3%$record prtd 8 2) (#3%$record crtd 8 2 0)))))
     (equal? (map $record->vector
                  ; ... this isn't good enough
                  (let ()
                    (define prtd
                      (make-record-type "parent" '(x y)))
                    (define crtd
                      (make-record-type prtd "child" '(z)))
                    (define pcons
                      (r6rs:record-constructor
                        (make-record-constructor-descriptor prtd #f
                          (lambda (n)
                            (lambda (z w) (n (+ z 7) w))))))
                    (define ccons
                      (let ([tmp (make-record-constructor-descriptor crtd
                                   (make-record-constructor-descriptor
                                     prtd
                                     #f
                                     (lambda (n)
                                       (lambda (z w)
                                         (n (+ z 7) w))))
                                   (lambda (p)
                                     (lambda (x y)
                                       ((p x y) 0))))])
                        (r6rs:record-constructor tmp)))
                    (list (pcons 1 2) (ccons 1 2))))
             '(#(parent 8 2) #(child 8 2 0)))
     (equal? (map $record->vector
                  ; try some with inlining
                  (let ()
                    (define prtd
                      (make-record-type "parent" '(x y)))
                    (define crtd
                      (make-record-type prtd "child" '(z)))
                    (define (make-prcd f)
                      (make-record-constructor-descriptor prtd #f f))
                    (define prcd
                      (make-prcd (lambda (n) (lambda (z w) (n (+ z 7) w)))))
                    (define (make-crcd z)
                      (make-record-constructor-descriptor crtd prcd
                        (lambda (p)
                          (lambda (x y) ((p x y) z)))))
                    (define crcd (make-crcd -17))
                    (define (make-pcons)
                      (r6rs:record-constructor prcd))
                    (define pcons (make-pcons))
                    (define (make-ccons x)
                      (r6rs:record-constructor x))
                    (define ccons (make-ccons crcd))
                    (list (pcons 1 2) (ccons 1 2))))
             '(#(parent 8 2) #(child 8 2 -17)))
     (equivalent-expansion? ; optimize-level 2 expansion of above
       (parameterize
         ([optimize-level 2]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(let ()
              (define prtd
                (make-record-type "parent" '(x y)))
              (define crtd
                (make-record-type prtd "child" '(z)))
              (define (make-prcd f)
                (make-record-constructor-descriptor prtd #f f))
              (define prcd
                (make-prcd (lambda (n) (lambda (z w) (n (+ z 7) w)))))
              (define (make-crcd z)
                (make-record-constructor-descriptor crtd prcd
                  (lambda (p) (lambda (x y) ((p x y) z)))))
              (define crcd (make-crcd -17))
              (define (make-pcons)
                (r6rs:record-constructor prcd))
              (define pcons (make-pcons))
              (define (make-ccons x)
                (r6rs:record-constructor x))
              (define ccons (make-ccons crcd))
              (list (pcons 1 2) (ccons 1 2)))))
       '(let ([prtd (#2%make-record-type "parent" '(x y))])
          (let ([crtd (#2%make-record-type prtd "child" '(z))])
            (#2%list (#3%$record prtd 8 2) (#3%$record crtd 8 2 -17)))))
     (equivalent-expansion? ; optimize-level 3 expansion of above
       (parameterize
         ([optimize-level 3]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(let ()
              (define prtd
                (make-record-type "parent" '(x y)))
              (define crtd
                (make-record-type prtd "child" '(z)))
              (define (make-prcd f)
                (make-record-constructor-descriptor prtd #f f))
              (define prcd
                (make-prcd (lambda (n) (lambda (z w) (n (+ z 7) w)))))
              (define (make-crcd z)
                (make-record-constructor-descriptor crtd prcd
                  (lambda (p) (lambda (x y) ((p x y) z)))))
              (define crcd (make-crcd -17))
              (define (make-pcons)
                (r6rs:record-constructor prcd))
              (define pcons (make-pcons))
              (define (make-ccons x)
                (r6rs:record-constructor x))
              (define ccons (make-ccons crcd))
              (list (pcons 1 2) (ccons 1 2)))))
       '(let ([prtd (#3%make-record-type "parent" '(x y))])
          (let ([crtd (#3%make-record-type prtd "child" '(z))])
            (#3%list (#3%$record prtd 8 2) (#3%$record crtd 8 2 -17)))))
     (equal? (parameterize ([print-vector-length #f])
               (with-output-to-string
                 ; more elaborate test with side effects
                 (lambda ()
                   (define prtd
                     (make-record-type "parent" '(x y)))
                   (define crtd
                     (make-record-type prtd "child" '(z)))
                   (define prcd
                     (make-record-constructor-descriptor prtd #f
                       (rec pprot
                            (lambda (new)
                              (lambda (x n m)
                                (let ([r (new x (+ n m))])
                                  (pretty-print `(parent ,($record->vector r)))
                                  r))))))
                   (define crcd
                     (make-record-constructor-descriptor crtd prcd
                       (rec cprot
                            (lambda (p)
                              (lambda (z x n m)
                                (let ([r ((p x n m) z)])
                                  (pretty-print `(child ,($record->vector r)))
                                  r))))))
                   (define pcons
                     (r6rs:record-constructor prcd))
                   (define ccons
                     (r6rs:record-constructor crcd))
                   (pretty-print ($record->vector (pcons 1 2 3)))
                   (pretty-print ($record->vector (ccons 1 2 3 4))))))
             "(parent #(parent 1 5))\n#(parent 1 5)\n(parent #(child 2 7 1))\n(child #(child 2 7 1))\n#(child 2 7 1)\n")
     (equivalent-expansion? ; optimize-level 2 expansion of above
       (parameterize
         ([optimize-level 2]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(lambda ()
              (define prtd
                (make-record-type "parent" '(x y)))
              (define crtd
                (make-record-type prtd "child" '(z)))
              (define prcd
                (make-record-constructor-descriptor prtd #f
                  (rec pprot
                       (lambda (new)
                         (lambda (x n m)
                           (let ([r (new x (+ n m))])
                             (pretty-print `(parent ,($record->vector r)))
                             r))))))
              (define crcd
                (make-record-constructor-descriptor crtd prcd
                  (rec cprot
                       (lambda (p)
                         (lambda (z x n m)
                           (let ([r ((p x n m) z)])
                             (pretty-print `(child ,($record->vector r)))
                             r))))))
              (define pcons (r6rs:record-constructor prcd))
              (define ccons (r6rs:record-constructor crcd))
              (pretty-print ($record->vector (pcons 1 2 3)))
              (pretty-print ($record->vector (ccons 1 2 3 4))))))
       '(lambda ()
          (let ([prtd (#2%make-record-type "parent" '(x y))])
            (let ([crtd (#2%make-record-type prtd "child" '(z))])
              (#2%pretty-print
                ($record->vector
                  (let ([r (#3%$record prtd 1 5)])
                    (#2%pretty-print (#2%list 'parent ($record->vector r)))
                    r)))
              (#2%pretty-print
                ($record->vector
                  (let ([r (let ([r (#3%$record crtd 2 7 1)])
                             (#2%pretty-print
                               (#2%list 'parent ($record->vector r)))
                             r)])
                    (#2%pretty-print (#2%list 'child ($record->vector r)))
                    r)))))))
     (equivalent-expansion? ; optimize-level 3 expansion of above
       (parameterize
         ([optimize-level 3]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(lambda ()
              (define prtd
                (make-record-type "parent" '(x y)))
              (define crtd
                (make-record-type prtd "child" '(z)))
              (define prcd
                (make-record-constructor-descriptor prtd #f
                  (rec pprot
                       (lambda (new)
                         (lambda (x n m)
                           (let ([r (new x (+ n m))])
                             (pretty-print `(parent ,($record->vector r)))
                             r))))))
              (define crcd
                (make-record-constructor-descriptor crtd prcd
                  (rec cprot
                       (lambda (p)
                         (lambda (z x n m)
                           (let ([r ((p x n m) z)])
                             (pretty-print `(child ,($record->vector r)))
                             r))))))
              (define pcons (r6rs:record-constructor prcd))
              (define ccons (r6rs:record-constructor crcd))
              (pretty-print ($record->vector (pcons 1 2 3)))
              (pretty-print ($record->vector (ccons 1 2 3 4))))))
       '(lambda ()
          (let ([prtd (#3%make-record-type "parent" '(x y))])
            (let ([crtd (#3%make-record-type prtd "child" '(z))])
              (#3%pretty-print
                ($record->vector
                  (let ([r (#3%$record prtd 1 5)])
                    (#3%pretty-print (#3%list 'parent ($record->vector r)))
                    r)))
              (#3%pretty-print
                ($record->vector
                  (let ([r (let ([r (#3%$record crtd 2 7 1)])
                             (#3%pretty-print
                               (#3%list 'parent ($record->vector r)))
                             r)])
                    (#3%pretty-print (#3%list 'child ($record->vector r)))
                    r)))))))
     (equal? (parameterize ([print-vector-length #f])
               (with-output-to-string ; adding a grandchild
                 (lambda ()
                   (define prtd
                     (make-record-type "parent" '(x y)))
                   (define crtd
                     (make-record-type prtd "child" '(z)))
                   (define gcrtd
                     (make-record-type crtd "grand-child" '(w)))
                   (define prcd
                     (make-record-constructor-descriptor prtd #f
                       (rec pprot
                            (lambda (new)
                              (lambda (x n m)
                                (let ([r (new x (+ n m))])
                                  (pretty-print `(parent ,($record->vector r)))
                                  r))))))
                   (define crcd
                     (make-record-constructor-descriptor crtd prcd
                       (rec cprot
                            (lambda (p)
                              (lambda (z x n m)
                                (let ([r ((p x n m) z)])
                                  (pretty-print `(child ,($record->vector r)))
                                  r))))))
                   (define gcrcd
                     (make-record-constructor-descriptor gcrtd crcd
                       (rec gcprot
                            (lambda (p)
                              (lambda (w x q z)
                                (let ([r ((p z x q 7) (* w 3))])
                                  (pretty-print `(grand-child ,($record->vector r)))
                                  r))))))
                   (define pcons
                     (r6rs:record-constructor prcd))
                   (define ccons
                     (r6rs:record-constructor crcd))
                   (define gccons
                     (r6rs:record-constructor gcrcd))
                   (pretty-print ($record->vector (pcons 1 2 3)))
                   (pretty-print ($record->vector (ccons 1 2 3 4)))
                   (pretty-print ($record->vector (gccons 1 2 3 4))))))
             (format "~
      (parent #(parent 1 5))\n~
      #(parent 1 5)\n~
      (parent #(child 2 7 1))\n~
      (child #(child 2 7 1))\n~
      #(child 2 7 1)\n~
      (parent #(grand-child 2 10 4 3))\n~
      (child #(grand-child 2 10 4 3))\n~
      (grand-child #(grand-child 2 10 4 3))\n~
      #(grand-child 2 10 4 3)\n"))
     (equivalent-expansion? ; optimize-level 2 expansion of above
       (parameterize
         ([optimize-level 2]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(lambda ()
              (define prtd
                (make-record-type "parent" '(x y)))
              (define crtd
                (make-record-type prtd "child" '(z)))
              (define gcrtd
                (make-record-type crtd "grand-child" '(w)))
              (define prcd
                (make-record-constructor-descriptor prtd #f
                  (rec pprot
                       (lambda (new)
                         (lambda (x n m)
                           (let ([r (new x (+ n m))])
                             (pretty-print `(parent ,($record->vector r)))
                             r))))))
              (define crcd
                (make-record-constructor-descriptor crtd prcd
                  (rec cprot
                       (lambda (p)
                         (lambda (z x n m)
                           (let ([r ((p x n m) z)])
                             (pretty-print `(child ,($record->vector r)))
                             r))))))
              (define gcrcd
                (make-record-constructor-descriptor gcrtd crcd
                  (rec gcprot
                       (lambda (p)
                         (lambda (w x q z)
                           (let ([r ((p z x q 7) (* w 3))])
                             (pretty-print `(grand-child ,($record->vector r)))
                             r))))))
              (define pcons (r6rs:record-constructor prcd))
              (define ccons (r6rs:record-constructor crcd))
              (define gccons
                (r6rs:record-constructor gcrcd))
              (pretty-print ($record->vector (pcons 1 2 3)))
              (pretty-print ($record->vector (ccons 1 2 3 4)))
              (pretty-print ($record->vector (gccons 1 2 3 4))))))
       '(lambda ()
          (let ([prtd (#2%make-record-type "parent" '(x y))])
            (let ([crtd (#2%make-record-type prtd "child" '(z))])
              (let ([gcrtd (#2%make-record-type crtd "grand-child" '(w))])
                (#2%pretty-print
                  ($record->vector
                    (let ([r (#3%$record prtd 1 5)])
                      (#2%pretty-print
                        (#2%list 'parent ($record->vector r)))
                      r)))
                (#2%pretty-print
                  ($record->vector
                    (let ([r (let ([r (#3%$record crtd 2 7 1)])
                               (#2%pretty-print
                                 (#2%list 'parent ($record->vector r)))
                               r)])
                      (#2%pretty-print
                        (#2%list 'child ($record->vector r)))
                      r)))
                (#2%pretty-print
                  ($record->vector
                    (let ([r (let ([r (let ([r (#3%$record gcrtd 2 10 4 3)])
                                        (#2%pretty-print
                                          (#2%list 'parent ($record->vector r)))
                                        r)])
                               (#2%pretty-print
                                 (#2%list 'child ($record->vector r)))
                               r)])
                      (#2%pretty-print
                        (#2%list 'grand-child ($record->vector r)))
                      r))))))))
     (equivalent-expansion? ; optimize-level 3 expansion of above
       (parameterize
         ([optimize-level 3]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(lambda ()
              (define prtd
                (make-record-type "parent" '(x y)))
              (define crtd
                (make-record-type prtd "child" '(z)))
              (define gcrtd
                (make-record-type crtd "grand-child" '(w)))
              (define prcd
                (make-record-constructor-descriptor prtd #f
                  (rec pprot
                       (lambda (new)
                         (lambda (x n m)
                           (let ([r (new x (+ n m))])
                             (pretty-print `(parent ,($record->vector r)))
                             r))))))
              (define crcd
                (make-record-constructor-descriptor crtd prcd
                  (rec cprot
                       (lambda (p)
                         (lambda (z x n m)
                           (let ([r ((p x n m) z)])
                             (pretty-print `(child ,($record->vector r)))
                             r))))))
              (define gcrcd
                (make-record-constructor-descriptor gcrtd crcd
                  (rec gcprot
                       (lambda (p)
                         (lambda (w x q z)
                           (let ([r ((p z x q 7) (* w 3))])
                             (pretty-print `(grand-child ,($record->vector r)))
                             r))))))
              (define pcons (r6rs:record-constructor prcd))
              (define ccons (r6rs:record-constructor crcd))
              (define gccons
                (r6rs:record-constructor gcrcd))
              (pretty-print ($record->vector (pcons 1 2 3)))
              (pretty-print ($record->vector (ccons 1 2 3 4)))
              (pretty-print ($record->vector (gccons 1 2 3 4))))))
       '(lambda ()
          (let ([prtd (#3%make-record-type "parent" '(x y))])
            (let ([crtd (#3%make-record-type prtd "child" '(z))])
              (let ([gcrtd (#3%make-record-type crtd "grand-child" '(w))])
                (#3%pretty-print
                  ($record->vector
                    (let ([r (#3%$record prtd 1 5)])
                      (#3%pretty-print
                        (#3%list 'parent ($record->vector r)))
                      r)))
                (#3%pretty-print
                  ($record->vector
                    (let ([r (let ([r (#3%$record crtd 2 7 1)])
                               (#3%pretty-print
                                 (#3%list 'parent ($record->vector r)))
                               r)])
                      (#3%pretty-print
                        (#3%list 'child ($record->vector r)))
                      r)))
                (#3%pretty-print
                  ($record->vector
                    (let ([r (let ([r (let ([r (#3%$record gcrtd 2 10 4 3)])
                                        (#3%pretty-print
                                          (#3%list 'parent ($record->vector r)))
                                        r)])
                               (#3%pretty-print
                                 (#3%list 'child ($record->vector r)))
                               r)])
                      (#3%pretty-print
                        (#3%list 'grand-child ($record->vector r)))
                      r))))))))
     (error? ; given prcd is not for parent rtd
       (parameterize ([print-vector-length #f])
         (with-output-to-string ; adding a grandchild
           (lambda ()
             (define prtd
               (make-record-type "parent" '(x y)))
             (define crtd
               (make-record-type prtd "child" '(z)))
             (define gcrtd
               (make-record-type prtd "grand-child" '(w)))
             (define prcd
               (make-record-constructor-descriptor prtd #f
                 (rec pprot
                      (lambda (new)
                        (lambda (x n m)
                          (let ([r (new x (+ n m))])
                            (pretty-print `(parent ,($record->vector r)))
                            r))))))
             (define crcd
               (make-record-constructor-descriptor crtd prcd
                 (rec cprot
                      (lambda (p)
                        (lambda (z x n m)
                          (let ([r ((p x n m) z)])
                            (pretty-print `(child ,($record->vector r)))
                            r))))))
             (define gcrcd
               (make-record-constructor-descriptor gcrtd crcd
                 (rec gcprot
                      (lambda (p)
                        (lambda (w x q z)
                          (let ([r ((p z x q 7) (* w 3))])
                            (pretty-print `(grand-child ,($record->vector r)))
                            r))))))
             (define pcons (r6rs:record-constructor prcd))
             (define ccons (r6rs:record-constructor crcd))
             (define gccons (r6rs:record-constructor gcrcd))
             (pretty-print ($record->vector (pcons 1 2 3)))
             (pretty-print ($record->vector (ccons 1 2 3 4)))
             (pretty-print ($record->vector (gccons 1 2 3 4)))))))
     (eqv? (make-record-type-descriptor
             'foo
             #f
             '#{rats c7ajhty66y4x1og-a}
             #f
             #f
             '#())
           (make-record-type-descriptor
             'bar
             #f
             '#{rats c7ajhty66y4x1og-a}
             #f
             #f
             '#()))
     (eqv? (let ()
             (define rtd
               (make-record-type-descriptor 'bar #f #f #f #f '#()))
             (record-type-sealed? rtd))
           #f)
     (eqv? (let ()
             (define rtd
               (make-record-type-descriptor 'bar #f #f #t #f '#()))
             (record-type-sealed? rtd))
           #t)
     (equivalent-expansion? ; optimize-level 2 expansion of above
       (parameterize
         ([optimize-level 2]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(let ()
              (define rtd
                (make-record-type-descriptor 'bar #f #f #t #f '#()))
              (record-type-sealed? rtd))))
       '(begin
          (#2%make-record-type-descriptor 'bar #f #f #t #f '#0())
          #t))
     (equivalent-expansion? ; optimize-level 3 expansion of above
       (parameterize
         ([optimize-level 3]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(let ()
              (define rtd
                (make-record-type-descriptor 'bar #f #f #t #f '#()))
              (record-type-sealed? rtd))))
       '#t)
     (eqv? (let ()
             (define rtd
               (make-record-type-descriptor 'bar #f #f #t #f '#()))
             (record? ((record-constructor rtd))))
           #t)
     (eqv? (let ()
             (define rtd
               (make-record-type-descriptor 'bar #f #f #t #f '#()))
             (r6rs:record? ((record-constructor rtd))))
           #t)
     (eqv? (let ()
             (define rtd
               (make-record-type-descriptor 'bar #f #f #t #f '#()))
             (record? ((record-constructor rtd)) rtd))
           #t)
     (eqv? (let ()
             (define prtd
               (make-record-type-descriptor 'bar #f #f #f #f '#()))
             (define crtd
               (make-record-type-descriptor 'foo prtd #f #f #f '#()))
             (record? ((record-constructor crtd)) prtd))
           #t)
     (error? ; parent sealed
       (let ()
         (define prtd
           (make-record-type-descriptor 'bar #f #f #t #f '#()))
         (define crtd
           (make-record-type-descriptor 'foo prtd #f #f #f '#()))
         (record? ((record-constructor crtd)) prtd)))
     (eqv? (let ()
             (define prtd
               (make-record-type-descriptor 'bar #f #f #f #f '#()))
             (define crtd
               (make-record-type-descriptor 'foo prtd #f #f #f '#()))
             (define xrtd
               (make-record-type-descriptor 'poo #f #f #f #f '#()))
             (record? ((record-constructor xrtd)) prtd))
           #f)
     (equivalent-expansion?
       (parameterize
         ([optimize-level 2]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(lambda (x)
              (define rtd
                (make-record-type-descriptor 'bar #f #f #f #f '#()))
              (record? x rtd))))
       '(lambda (x)
          (#3%record? x
            (#2%make-record-type-descriptor 'bar #f #f #f #f '#()))))
     (equivalent-expansion?
       (parameterize
         ([optimize-level 2]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(lambda (x)
              (define rtd
                (make-record-type-descriptor 'bar #f #f #t #f '#()))
              (record? x rtd))))
       '(lambda (x)
          (#3%$sealed-record? x
            (#2%make-record-type-descriptor 'bar #f #f #t #f '#0())))))

(mat r6rs-records-procedural2
     (equal? (with-output-to-string
               (lambda ()
                 (define-syntax uid
                   (lambda (x)
                     #`(quote #,(datum->syntax #'* (gensym)))))
                 (define rtd
                   (begin
                     (write 'a)
                     (make-record-type-descriptor
                       'foo
                       #f
                       uid
                       #f
                       #f
                       '#((immutable x)))))
                 (define a
                   (begin
                     (write 'b)
                     (record-accessor (begin (write 'c) rtd) 0)))
                 (write (a ((begin
                              (write 'd)
                              (record-constructor (begin (write 'e) rtd))) 17)))))
             "abcde17")
     (equivalent-expansion?
       (parameterize
         ([optimize-level 2]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(lambda ()
              (define-syntax uid
                (lambda (x)
                  #`(quote #,(datum->syntax #'* (gensym)))))
              (define rtd
                (begin
                  (write 'a)
                  (make-record-type-descriptor
                    'foo
                    #f
                    uid
                    #f
                    #f
                    '#((immutable x)))))
              (define a
                (begin
                  (write 'b)
                  (record-accessor (begin (write 'c) rtd) 0)))
              (write (a ((begin
                           (write 'd)
                           (record-constructor (begin (write 'e) rtd))) 17))))))
       '(lambda ()
          (#2%write 'a)
          (#2%write 'b)
          (#2%write 'c)
          (#2%write (begin (#2%write 'd) (#2%write 'e) 17))))
     (equivalent-expansion?
       (parameterize
         ([optimize-level 3]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(lambda ()
              (define-syntax uid
                (lambda (x)
                  #`(quote #,(datum->syntax #'* (gensym)))))
              (define rtd
                (begin
                  (write 'a)
                  (make-record-type-descriptor
                    'foo
                    #f
                    uid
                    #f
                    #f
                    '#((immutable x)))))
              (define a
                (begin
                  (write 'b)
                  (record-accessor (begin (write 'c) rtd) 0)))
              (write (a ((begin
                           (write 'd)
                           (record-constructor (begin (write 'e) rtd))) 17))))))
       '(lambda ()
          (#3%write 'a)
          (#3%write 'b)
          (#3%write 'c)
          (#3%write (begin (#3%write 'd) (#3%write 'e) 17))))

     (equal? (with-output-to-string
               (lambda ()
                 (define-syntax uid
                   (lambda (x)
                     #`(quote #,(datum->syntax #'* (gensym)))))
                 (define rtd
                   (begin
                     (write 'a)
                     (make-record-type-descriptor
                       'foo
                       #f
                       uid
                       #f
                       #f
                       '#((immutable x)))))
                 (write ((begin
                           (write 'b)
                           (record-accessor (begin (write 'c) rtd) 0))
                         ((begin
                            (write 'b)
                            (record-constructor (begin (write 'c) rtd))) 17)))))
             "abcbc17")
     (equivalent-expansion?
       (parameterize
         ([optimize-level 2]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(lambda ()
              (define-syntax uid
                (lambda (x)
                  #`(quote #,(datum->syntax #'* (gensym)))))
              (define rtd
                (begin
                  (write 'a)
                  (make-record-type-descriptor
                    'foo
                    #f
                    uid
                    #f
                    #f
                    '#((immutable x)))))
              (write ((begin
                        (write 'b)
                        (record-accessor (begin (write 'c) rtd) 0))
                      ((begin
                         (write 'b)
                         (record-constructor (begin (write 'c) rtd))) 17))))))
       '(lambda ()
          (#2%write 'a)
          (#2%write (begin
                      (#2%write 'b)
                      (#2%write 'c)
                      (#2%write 'b)
                      (#2%write 'c)
                      17))))
     (equivalent-expansion?
       (parameterize
         ([optimize-level 3]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(lambda ()
              (define-syntax uid
                (lambda (x)
                  #`(quote #,(datum->syntax #'* (gensym)))))
              (define rtd
                (begin
                  (write 'a)
                  (make-record-type-descriptor
                    'foo
                    #f
                    uid
                    #f
                    #f
                    '#((immutable x)))))
              (write ((begin
                        (write 'b)
                        (record-accessor (begin (write 'c) rtd) 0))
                      ((begin
                         (write 'b)
                         (record-constructor (begin (write 'c) rtd))) 17))))))
       '(lambda ()
          (#3%write 'a)
          (#3%write (begin
                      (#3%write 'b)
                      (#3%write 'c)
                      (#3%write 'b)
                      (#3%write 'c)
                      17))))

     ((lambda (x y) (and (member x y) #t))
      (with-output-to-string
        (lambda ()
          (define-syntax uid
            (lambda (x)
              #`(quote #,(datum->syntax #'* (gensym)))))
          (define-syntax rtd
            (lambda (x)
              #`(quote #,(make-record-type-descriptor
                           'foo
                           #f
                           uid
                           #f
                           #f
                           '#((mutable x))))))
          (define-syntax qr
            (lambda (x)
              #`(quote #,((record-constructor rtd) 17))))
          (write (let ([r qr])
                   ((begin
                      (write 'b)
                      (record-mutator (begin (write 'c) rtd) 0)) r 23)
                   ((begin
                      (write 'b)
                      (record-accessor (begin (write 'c) (record-rtd r)) 0)) r)))))
      '("bcbc17" "bcbc23"))
     (equivalent-expansion?
       (parameterize
         ([optimize-level 2]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(lambda ()
              (define-syntax uid
                (lambda (x)
                  #`(quote #,(datum->syntax #'* (gensym)))))
              (define-syntax rtd
                (lambda (x)
                  #`(quote #,(make-record-type-descriptor
                               'foo
                               #f
                               uid
                               #f
                               #f
                               '#((mutable x))))))
              (define-syntax qr
                (lambda (x)
                  #`(quote #,((record-constructor rtd) 17))))
              (write (let ([r qr])
                       ((begin
                          (write 'b)
                          (record-mutator (begin (write 'c) rtd) 0)) r 23)
                       ((begin
                          (write 'b)
                          (record-accessor
                            (begin
                              (write 'c)
                              (record-rtd r))
                            0)) r))))))
       `(lambda ()
          (#2%write (begin
                      (#2%write 'b)
                      (#2%write 'c)
                      (#3%$object-set!
                        'scheme-object
                        ',record?
                        ,fixnum?
                        23)
                      (#2%write 'b)
                      (#2%write 'c)
                      17))))
     (equivalent-expansion?
       (parameterize
         ([optimize-level 3]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(lambda ()
              (define-syntax uid
                (lambda (x)
                  #`(quote #,(datum->syntax #'* (gensym)))))
              (define-syntax rtd
                (lambda (x)
                  #`(quote #,(make-record-type-descriptor
                               'foo
                               #f
                               uid
                               #f
                               #f
                               '#((mutable x))))))
              (define-syntax qr
                (lambda (x)
                  #`(quote #,((record-constructor rtd) 17))))
              (write (let ([r qr])
                       ((begin
                          (write 'b)
                          (record-mutator (begin (write 'c) rtd) 0)) r 23)
                       ((begin
                          (write 'b)
                          (record-accessor
                            (begin
                              (write 'c)
                              (record-rtd r))
                            0)) r))))))
       `(lambda ()
          (#3%write (begin
                      (#3%write 'b)
                      (#3%write 'c)
                      (#3%$object-set!
                        'scheme-object
                        ',record?
                        ,fixnum?
                        23)
                      (#3%write 'b)
                      (#3%write 'c)
                      17))))

     (equal? (with-output-to-string
               (lambda ()
                 (define-syntax uid
                   (lambda (x)
                     #`(quote #,(datum->syntax #'* (gensym)))))
                 (define rtd
                   (begin
                     (write 'a)
                     (make-record-type-descriptor
                       'foo
                       #f
                       uid
                       #f
                       #f
                       '#((immutable x)))))
                 (write ((begin
                           (write 'b)
                           (record-predicate (begin (write 'c) rtd)))
                         ((begin
                            (write 'b)
                            (record-constructor (begin (write 'c) rtd))) 17)))))
             "abcbc#t")
     (equivalent-expansion?
       (parameterize
         ([optimize-level 2]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(lambda ()
              (define-syntax uid
                (lambda (x)
                  #`(quote #,(datum->syntax #'* (gensym)))))
              (define rtd
                (begin
                  (write 'a)
                  (make-record-type-descriptor
                    'foo
                    #f
                    uid
                    #f
                    #f
                    '#((immutable x)))))
              (write ((begin
                        (write 'b)
                        (record-predicate (begin (write 'c) rtd)))
                      ((begin
                         (write 'b)
                         (record-constructor (begin (write 'c) rtd))) 17))))))
       '(lambda ()
          (#2%write 'a)
          (#2%write (begin
                      (#2%write 'b)
                      (#2%write 'c)
                      (#2%write 'b)
                      (#2%write 'c)
                      #t))))
     (equivalent-expansion?
       (parameterize
         ([optimize-level 3]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(lambda ()
              (define-syntax uid
                (lambda (x)
                  #`(quote #,(datum->syntax #'* (gensym)))))
              (define rtd
                (begin
                  (write 'a)
                  (make-record-type-descriptor
                    'foo
                    #f
                    uid
                    #f
                    #f
                    '#((immutable x)))))
              (write ((begin
                        (write 'b)
                        (record-predicate (begin (write 'c) rtd)))
                      ((begin
                         (write 'b)
                         (record-constructor (begin (write 'c) rtd))) 17))))))
       '(lambda ()
          (#3%write 'a)
          (#3%write (begin
                      (#3%write 'b)
                      (#3%write 'c)
                      (#3%write 'b)
                      (#3%write 'c)
                      #t))))

     (equal? (with-output-to-string
               (lambda ()
                 (define-syntax uid
                   (lambda (x)
                     #`(quote #,(datum->syntax #'* (gensym)))))
                 (define rtd
                   (begin
                     (write 'a)
                     (make-record-type-descriptor
                       'foo
                       #f
                       uid
                       #f
                       #f
                       '#((immutable x)))))
                 (define make
                   (begin
                     (write 'b)
                     (record-constructor (begin (write 'c) rtd))))
                 (define a
                   (begin
                     (write 'd)
                     (record-accessor (begin (write 'e) rtd) 0)))
                 (define x
                   (make (let ((f (begin (write 'f) (lambda (x) x))))
                           (let ([g (begin
                                      (write 'g)
                                      (lambda (x) (or x f)))])
                             (g 3)
                             (g 17)))))
                 (write (a x))))
             "abcdefg17")
     (equivalent-expansion?
       (parameterize
         ([optimize-level 2]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(lambda ()
              (define-syntax uid
                (lambda (x)
                  #`(quote #,(datum->syntax #'* (gensym)))))
              (define rtd
                (begin
                  (write 'a)
                  (make-record-type-descriptor
                    'foo
                    #f
                    uid
                    #f
                    #f
                    '#((immutable x)))))
              (define make
                (begin
                  (write 'b)
                  (record-constructor (begin (write 'c) rtd))))
              (define a
                (begin
                  (write 'd)
                  (record-accessor (begin (write 'e) rtd) 0)))
              (define x
                (make (let ((f (begin (write 'f) (lambda (x) x))))
                        (let ([g (begin (write 'g) (lambda (x) (or x f)))])
                          (g 3)
                          (g 17)))))
              (write (a x)))))
       '(lambda ()
          (#2%write 'a)
          (#2%write 'b)
          (#2%write 'c)
          (#2%write 'd)
          (#2%write 'e)
          (#2%write 'f)
          (#2%write 'g)
          (#2%write 17)))
     (equivalent-expansion?
       (parameterize
         ([optimize-level 3]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(lambda ()
              (define-syntax uid
                (lambda (x)
                  #`(quote #,(datum->syntax #'* (gensym)))))
              (define rtd
                (begin
                  (write 'a)
                  (make-record-type-descriptor
                    'foo
                    #f
                    uid
                    #f
                    #f
                    '#((immutable x)))))
              (define make
                (begin
                  (write 'b)
                  (record-constructor (begin (write 'c) rtd))))
              (define a
                (begin
                  (write 'd)
                  (record-accessor (begin (write 'e) rtd) 0)))
              (define x
                (make (let ((f (begin (write 'f) (lambda (x) x))))
                        (let ([g (begin (write 'g) (lambda (x) (or x f)))])
                          (g 3)
                          (g 17)))))
              (write (a x)))))
       '(lambda ()
          (#3%write 'a)
          (#3%write 'b)
          (#3%write 'c)
          (#3%write 'd)
          (#3%write 'e)
          (#3%write 'f)
          (#3%write 'g)
          (#3%write 17)))

     (equal? (with-output-to-string
               (lambda ()
                 (define-syntax uid
                   (lambda (x)
                     #`(quote #,(datum->syntax #'* (gensym)))))
                 (define rtd
                   (begin
                     (write 'a)
                     (make-record-type-descriptor
                       'foo
                       #f
                       uid
                       #f
                       #f
                       '#((immutable x)))))
                 (define rcd
                   (begin
                     (write 'b)
                     (make-record-constructor-descriptor rtd #f #f)))
                 (define a
                   (begin
                     (write 'c)
                     (record-accessor (begin (write 'd) rtd) 0)))
                 (write (a ((begin
                              (write 'e)
                              (record-constructor (begin (write 'f) rcd))) 17)))))
             "abcdef17")
     (equivalent-expansion?
       (parameterize
         ([optimize-level 2]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(lambda ()
              (define-syntax uid
                (lambda (x)
                  #`(quote #,(datum->syntax #'* (gensym)))))
              (define rtd
                (begin
                  (write 'a)
                  (make-record-type-descriptor
                    'foo
                    #f
                    uid
                    #f
                    #f
                    '#((immutable x)))))
              (define rcd
                (begin
                  (write 'b)
                  (make-record-constructor-descriptor rtd #f #f)))
              (define a
                (begin
                  (write 'c)
                  (record-accessor (begin (write 'd) rtd) 0)))
              (write (a ((begin
                           (write 'e)
                           (record-constructor (begin (write 'f) rcd))) 17))))))
       '(lambda ()
          (#2%write 'a)
          (#2%write 'b)
          (#2%write 'c)
          (#2%write 'd)
          (#2%write (begin (#2%write 'e) (#2%write 'f) 17))))
     (equivalent-expansion?
       (parameterize
         ([optimize-level 3]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(lambda ()
              (define-syntax uid
                (lambda (x)
                  #`(quote #,(datum->syntax #'* (gensym)))))
              (define rtd
                (begin
                  (write 'a)
                  (make-record-type-descriptor
                    'foo
                    #f
                    uid
                    #f
                    #f
                    '#((immutable x)))))
              (define rcd
                (begin
                  (write 'b)
                  (make-record-constructor-descriptor rtd #f #f)))
              (define a
                (begin
                  (write 'c)
                  (record-accessor (begin (write 'd) rtd) 0)))
              (write (a ((begin
                           (write 'e)
                           (record-constructor (begin (write 'f) rcd))) 17))))))
       '(lambda ()
          (#3%write 'a)
          (#3%write 'b)
          (#3%write 'c)
          (#3%write 'd)
          (#3%write (begin (#3%write 'e) (#3%write 'f) 17))))

     (equal? (with-output-to-string
               (lambda ()
                 (define-syntax uid
                   (lambda (x)
                     #`(quote #,(datum->syntax #'* (gensym)))))
                 (define rtd1
                   (begin
                     (write 'a)
                     (make-record-type-descriptor
                       'foo
                       #f
                       uid
                       #f
                       #f
                       '#((immutable x)))))
                 (define rcd1
                   (begin
                     (write 'b)
                     (make-record-constructor-descriptor rtd1 #f #f)))
                 (define rtd2
                   (begin
                     (write 'a)
                     (make-record-type-descriptor
                       'foo
                       rtd1
                       uid
                       #f
                       #f
                       '#((immutable x)))))
                 (define rcd2
                   (begin
                     (write 'b)
                     (make-record-constructor-descriptor rtd2 rcd1 #f)))
                 (write (list rcd1 rcd2))))
             "abab(#<record constructor descriptor> #<record constructor descriptor>)")
     (equivalent-expansion?
       (parameterize
         ([optimize-level 2]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(lambda ()
              (define-syntax uid
                (lambda (x)
                  #`(quote #,(datum->syntax #'* (gensym)))))
              (define rtd1
                (begin
                  (write 'a)
                  (make-record-type-descriptor
                    'foo
                    #f
                    uid
                    #f
                    #f
                    '#((immutable x)))))
              (define rcd1
                (begin
                  (write 'b)
                  (make-record-constructor-descriptor rtd1 #f #f)))
              (define rtd2
                (begin
                  (write 'a)
                  (make-record-type-descriptor
                    'foo
                    rtd1
                    uid
                    #f
                    #f
                    '#((immutable x)))))
              (define rcd2
                (begin
                  (write 'b)
                  (make-record-constructor-descriptor rtd2 rcd1 #f)))
              (write (list rcd1 rcd2)))))
       `(lambda ()
          (#2%write 'a)
          (#2%write 'b)
          (#2%write 'a)
          (#2%write 'b)
          (#2%write (#2%list ',record-constructor-descriptor?
                             ',record-constructor-descriptor?))))
     (equivalent-expansion?
       (parameterize
         ([optimize-level 3]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(lambda ()
              (define-syntax uid
                (lambda (x)
                  #`(quote #,(datum->syntax #'* (gensym)))))
              (define rtd1
                (begin
                  (write 'a)
                  (make-record-type-descriptor
                    'foo
                    #f
                    uid
                    #f
                    #f
                    '#((immutable x)))))
              (define rcd1
                (begin
                  (write 'b)
                  (make-record-constructor-descriptor rtd1 #f #f)))
              (define rtd2
                (begin
                  (write 'a)
                  (make-record-type-descriptor
                    'foo
                    rtd1
                    uid
                    #f
                    #f
                    '#((immutable x)))))
              (define rcd2
                (begin
                  (write 'b)
                  (make-record-constructor-descriptor rtd2 rcd1 #f)))
              (write (list rcd1 rcd2)))))
       `(lambda ()
          (#3%write 'a)
          (#3%write 'b)
          (#3%write 'a)
          (#3%write 'b)
          (#3%write (#3%list ',record-constructor-descriptor?
                             ',record-constructor-descriptor?))))

     ; test cross-library optimization of record definitions
     (begin
       (with-output-to-file "testfile-rrp1.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-rrp1)
                (export make-bar
                        bar?
                        bar-x
                        make-foo
                        foo?
                        foo-x
                        foo-y
                        foo-x-set!
                        bar-inst
                        foo-inst)
                (import (chezscheme))
                (define-record-type bar (fields x))
                (define-record-type foo
                  (parent bar)
                  (fields (mutable x) y)
                  (protocol (lambda (pargs->new)
                              (lambda (y z)
                                ((pargs->new z) 17 y)))))
                (define bar-inst (make-bar 7))
                (define foo-inst (make-foo 13 11)))))
         'replace)
       #t)
     ; first, the control, with cp0 disabled
     (begin
       (load-library "testfile-rrp1.ss"
         (lambda (x)
           (parameterize ([enable-cp0 #f]) (eval x))))
       #t)
     (equal? (let ()
               (define ugh
                 (lambda (x)
                   (import (testfile-rrp1))
                   (let ([b (make-bar 23)] [f (make-foo 31 41)])
                     (foo-x-set! f 37)
                     (list (foo? x)
                           (foo? b)
                           (foo? f)
                           (foo? bar-inst)
                           (foo? foo-inst)
                           (bar? x)
                           (bar? b)
                           (bar? f)
                           (bar? bar-inst)
                           (bar? foo-inst)
                           (bar-x b)
                           (bar-x f)
                           (bar-x foo-inst)
                           (bar-x bar-inst)
                           (foo-x f)
                           (foo-x foo-inst)
                           (foo-y f)
                           (foo-y foo-inst)))))
               (ugh 19))
             '(#f #f #t #f #t #f #t #t #t #t 23 41 11 7 37 17 31 13))
     (equivalent-expansion?
       (parameterize
         ([optimize-level 2]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(lambda (x)
              (import (testfile-rrp1))
              (let ([b (make-bar 23)] [f (make-foo 31 41)])
                (foo-x-set! f 37)
                (list (foo? x)
                      (foo? b)
                      (foo? f)
                      (foo? bar-inst)
                      (foo? foo-inst)
                      (bar? x)
                      (bar? b)
                      (bar? f)
                      (bar? bar-inst)
                      (bar? foo-inst)
                      (bar-x b)
                      (bar-x f)
                      (bar-x foo-inst)
                      (bar-x bar-inst)
                      (foo-x f)
                      (foo-x foo-inst)
                      (foo-y f)
                      (foo-y foo-inst))))))
       '(begin
          (#3%$invoke-library '(testfile-rrp1) '() 'testfile-rrp1)
          (lambda (x)
            (let ([b ((#3%$top-level-value 'make-bar) 23)]
                  [f ((#3%$top-level-value 'make-foo) 31 41)])
              ((#3%$top-level-value 'foo-x-set!) f 37)
              (#2%list ((#3%$top-level-value 'foo?) x)
                ((#3%$top-level-value 'foo?) b)
                ((#3%$top-level-value 'foo?) f)
                ((#3%$top-level-value 'foo?)
                 (#3%$top-level-value 'bar-inst))
                ((#3%$top-level-value 'foo?)
                 (#3%$top-level-value 'foo-inst))
                ((#3%$top-level-value 'bar?) x)
                ((#3%$top-level-value 'bar?) b)
                ((#3%$top-level-value 'bar?) f)
                ((#3%$top-level-value 'bar?)
                 (#3%$top-level-value 'bar-inst))
                ((#3%$top-level-value 'bar?)
                 (#3%$top-level-value 'foo-inst))
                ((#3%$top-level-value 'bar-x) b)
                ((#3%$top-level-value 'bar-x) f)
                ((#3%$top-level-value 'bar-x)
                 (#3%$top-level-value 'foo-inst))
                ((#3%$top-level-value 'bar-x)
                 (#3%$top-level-value 'bar-inst))
                ((#3%$top-level-value 'foo-x) f)
                ((#3%$top-level-value 'foo-x)
                 (#3%$top-level-value 'foo-inst))
                ((#3%$top-level-value 'foo-y) f)
                ((#3%$top-level-value 'foo-y)
                 (#3%$top-level-value 'foo-inst)))))))
     ; now with cp0 enabled and optimize-level 2...also need compiler or cross-library optimization won't occur
     (begin
       (load-library "testfile-rrp1.ss"
         (lambda (x)
           (parameterize
             ([optimize-level 2]
              [enable-cp0 #t]
              [#%$suppress-primitive-inlining #f]
              [current-eval compile])
             (eval x))))
       #t)
     (equal? (let ()
               (define ugh
                 (lambda (x)
                   (import (testfile-rrp1))
                   (let ([b (make-bar 23)] [f (make-foo 31 41)])
                     (foo-x-set! f 37)
                     (list (foo? x)
                           (foo? b)
                           (foo? f)
                           (foo? bar-inst)
                           (foo? foo-inst)
                           (bar? x)
                           (bar? b)
                           (bar? f)
                           (bar? bar-inst)
                           (bar? foo-inst)
                           (bar-x b)
                           (bar-x f)
                           (bar-x foo-inst)
                           (bar-x bar-inst)
                           (foo-x f)
                           (foo-x foo-inst)
                           (foo-y f)
                           (foo-y foo-inst)))))
               (ugh 19))
             '(#f #f #t #f #t #f #t #t #t #t 23 41 11 7 37 17 31 13))
     (equivalent-expansion?
       (parameterize
         ([optimize-level 2]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(lambda (x)
              (import (testfile-rrp1))
              (let ([b (make-bar 23)] [f (make-foo 31 41)])
                (foo-x-set! f 37)
                (list (foo? x)
                      (foo? b)
                      (foo? f)
                      (foo? bar-inst)
                      (foo? foo-inst)
                      (bar? x)
                      (bar? b)
                      (bar? f)
                      (bar? bar-inst)
                      (bar? foo-inst)
                      (bar-x b)
                      (bar-x f)
                      (bar-x foo-inst)
                      (bar-x bar-inst)
                      (foo-x f)
                      (foo-x foo-inst)
                      (foo-y f)
                      (foo-y foo-inst))))))
       `(begin
          (#3%$invoke-library '(testfile-rrp1) '() 'testfile-rrp1)
          (lambda (x)
            (let ([f (#3%$record ',record-type-descriptor? 41 17 31)])
              (#3%$object-set! 'scheme-object f ,fixnum? 37)
              (#2%list (#3%record? x ',record-type-descriptor?)
                       #f
                       #t
                       (#3%record?
                         (#3%$top-level-value 'bar-inst)
                         ',record-type-descriptor?)
                       (#3%record?
                         (#3%$top-level-value 'foo-inst)
                         ',record-type-descriptor?)
                       (#3%record? x ',record-type-descriptor?)
                       #t
                       #t
                       (#3%record?
                         (#3%$top-level-value 'bar-inst)
                         ',record-type-descriptor?)
                       (#3%record?
                         (#3%$top-level-value 'foo-inst)
                         ',record-type-descriptor?)
                       23
                       41
                       (let ([g4 (#3%$top-level-value 'foo-inst)])
                         (if (#3%record? g4 ',record-type-descriptor?)
                             (#2%void)
                             (#3%$record-oops
                               'bar-x
                               g4
                               ',record-type-descriptor?))
                         (#3%$object-ref 'scheme-object g4 ,fixnum?))
                       (let ([g4 (#3%$top-level-value 'bar-inst)])
                         (if (#3%record? g4 ',record-type-descriptor?)
                             (#2%void)
                             (#3%$record-oops
                               'bar-x
                               g4
                               ',record-type-descriptor?))
                         (#3%$object-ref 'scheme-object g4 ,fixnum?))
                       (#3%$object-ref 'scheme-object f ,fixnum?)
                       (let ([g3 (#3%$top-level-value 'foo-inst)])
                         (if (#3%record? g3 ',record-type-descriptor?)
                             (#2%void)
                             (#3%$record-oops
                               'foo-x
                               g3
                               ',record-type-descriptor?))
                         (#3%$object-ref 'scheme-object g3 ,fixnum?))
                       31
                       (let ([g2 (#3%$top-level-value 'foo-inst)])
                         (if (#3%record? g2 ',record-type-descriptor?)
                             (#2%void)
                             (#3%$record-oops
                               'foo-y
                               g2
                               ',record-type-descriptor?))
                         (#3%$object-ref 'scheme-object g2 ,fixnum?)))))))
     (equivalent-expansion?
       (parameterize
         ([optimize-level 3]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(lambda (x)
              (import (testfile-rrp1))
              (let ([b (make-bar 23)] [f (make-foo 31 41)])
                (foo-x-set! f 37)
                (list (foo? x)
                      (foo? b)
                      (foo? f)
                      (foo? bar-inst)
                      (foo? foo-inst)
                      (bar? x)
                      (bar? b)
                      (bar? f)
                      (bar? bar-inst)
                      (bar? foo-inst)
                      (bar-x b)
                      (bar-x f)
                      (bar-x foo-inst)
                      (bar-x bar-inst)
                      (foo-x f)
                      (foo-x foo-inst)
                      (foo-y f)
                      (foo-y foo-inst))))))
       `(begin
          (#3%$invoke-library '(testfile-rrp1) '() 'testfile-rrp1)
          (lambda (x)
            (let ([f (#3%$record ',record-type-descriptor? 41 17 31)])
              (#3%$object-set! 'scheme-object f ,fixnum? 37)
              (#3%list (#3%record? x ',record-type-descriptor?)
                       #f
                       #t
                       (#3%record?
                         (#3%$top-level-value 'bar-inst)
                         ',record-type-descriptor?)
                       (#3%record?
                         (#3%$top-level-value 'foo-inst)
                         ',record-type-descriptor?)
                       (#3%record? x ',record-type-descriptor?)
                       #t
                       #t
                       (#3%record?
                         (#3%$top-level-value 'bar-inst)
                         ',record-type-descriptor?)
                       (#3%record?
                         (#3%$top-level-value 'foo-inst)
                         ',record-type-descriptor?)
                       23
                       41
                       (let ([g4 (#3%$top-level-value 'foo-inst)])
                         (if (#3%record? g4 ',record-type-descriptor?)
                             (#2%void)
                             (#3%$record-oops
                               'bar-x
                               g4
                               ',record-type-descriptor?))
                         (#3%$object-ref 'scheme-object g4 ,fixnum?))
                       (let ([g4 (#3%$top-level-value 'bar-inst)])
                         (if (#3%record? g4 ',record-type-descriptor?)
                             (#2%void)
                             (#3%$record-oops
                               'bar-x
                               g4
                               ',record-type-descriptor?))
                         (#3%$object-ref 'scheme-object g4 ,fixnum?))
                       (#3%$object-ref 'scheme-object f ,fixnum?)
                       (let ([g3 (#3%$top-level-value 'foo-inst)])
                         (if (#3%record? g3 ',record-type-descriptor?)
                             (#2%void)
                             (#3%$record-oops
                               'foo-x
                               g3
                               ',record-type-descriptor?))
                         (#3%$object-ref 'scheme-object g3 ,fixnum?))
                       31
                       (let ([g2 (#3%$top-level-value 'foo-inst)])
                         (if (#3%record? g2 ',record-type-descriptor?)
                             (#2%void)
                             (#3%$record-oops
                               'foo-y
                               g2
                               ',record-type-descriptor?))
                         (#3%$object-ref 'scheme-object g2 ,fixnum?)))))))
     ; now with cp0 enabled and optimize-level 3...also need compiler or cross-library optimization won't occur
     (begin
       (load-library "testfile-rrp1.ss"
         (lambda (x)
           (parameterize
             ([optimize-level 3]
              [enable-cp0 #t]
              [#%$suppress-primitive-inlining #f]
              [current-eval compile])
             (eval x))))
       #t)
     (equivalent-expansion?
       (parameterize
         ([optimize-level 2]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(lambda (x)
              (import (testfile-rrp1))
              (let ([b (make-bar 23)] [f (make-foo 31 41)])
                (foo-x-set! f 37)
                (list (foo? x)
                      (foo? b)
                      (foo? f)
                      (foo? bar-inst)
                      (foo? foo-inst)
                      (bar? x)
                      (bar? b)
                      (bar? f)
                      (bar? bar-inst)
                      (bar? foo-inst)
                      (bar-x b)
                      (bar-x f)
                      (bar-x foo-inst)
                      (bar-x bar-inst)
                      (foo-x f)
                      (foo-x foo-inst)
                      (foo-y f)
                      (foo-y foo-inst))))))
       `(begin
          (#3%$invoke-library '(testfile-rrp1) '() 'testfile-rrp1)
          (lambda (x)
            (let ([f (#3%$record ',record-type-descriptor? 41 17 31)])
              (#3%$object-set! 'scheme-object f ,fixnum? 37)
              (#2%list (#3%record? x ',record-type-descriptor?)
                       #f
                       #t
                       (#3%record?
                         (#3%$top-level-value 'bar-inst)
                         ',record-type-descriptor?)
                       (#3%record?
                         (#3%$top-level-value 'foo-inst)
                         ',record-type-descriptor?)
                       (#3%record? x ',record-type-descriptor?)
                       #t
                       #t
                       (#3%record?
                         (#3%$top-level-value 'bar-inst)
                         ',record-type-descriptor?)
                       (#3%record?
                         (#3%$top-level-value 'foo-inst)
                         ',record-type-descriptor?)
                       23
                       41
                       (#3%$object-ref 'scheme-object
                         (#3%$top-level-value 'foo-inst)
                         ,fixnum?)
                       (#3%$object-ref 'scheme-object
                         (#3%$top-level-value 'bar-inst)
                         ,fixnum?)
                       (#3%$object-ref 'scheme-object f ,fixnum?)
                       (#3%$object-ref 'scheme-object
                         (#3%$top-level-value 'foo-inst)
                         ,fixnum?)
                       31
                       (#3%$object-ref 'scheme-object
                         (#3%$top-level-value 'foo-inst)
                         ,fixnum?))))))
     (equivalent-expansion?
       (parameterize
         ([optimize-level 3]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(lambda (x)
              (import (testfile-rrp1))
              (let ([b (make-bar 23)] [f (make-foo 31 41)])
                (foo-x-set! f 37)
                (list (foo? x)
                      (foo? b)
                      (foo? f)
                      (foo? bar-inst)
                      (foo? foo-inst)
                      (bar? x)
                      (bar? b)
                      (bar? f)
                      (bar? bar-inst)
                      (bar? foo-inst)
                      (bar-x b)
                      (bar-x f)
                      (bar-x foo-inst)
                      (bar-x bar-inst)
                      (foo-x f)
                      (foo-x foo-inst)
                      (foo-y f)
                      (foo-y foo-inst))))))
       `(begin
          (#3%$invoke-library '(testfile-rrp1) '() 'testfile-rrp1)
          (lambda (x)
            (let ([f (#3%$record ',record-type-descriptor? 41 17 31)])
              (#3%$object-set! 'scheme-object f ,fixnum? 37)
              (#3%list (#3%record? x ',record-type-descriptor?)
                       #f
                       #t
                       (#3%record?
                         (#3%$top-level-value 'bar-inst)
                         ',record-type-descriptor?)
                       (#3%record?
                         (#3%$top-level-value 'foo-inst)
                         ',record-type-descriptor?)
                       (#3%record? x ',record-type-descriptor?)
                       #t
                       #t
                       (#3%record?
                         (#3%$top-level-value 'bar-inst)
                         ',record-type-descriptor?)
                       (#3%record?
                         (#3%$top-level-value 'foo-inst)
                         ',record-type-descriptor?)
                       23
                       41
                       (#3%$object-ref 'scheme-object
                         (#3%$top-level-value 'foo-inst)
                         ,fixnum?)
                       (#3%$object-ref 'scheme-object
                         (#3%$top-level-value 'bar-inst)
                         ,fixnum?)
                       (#3%$object-ref 'scheme-object f ,fixnum?)
                       (#3%$object-ref 'scheme-object
                         (#3%$top-level-value 'foo-inst)
                         ,fixnum?)
                       31
                       (#3%$object-ref 'scheme-object
                         (#3%$top-level-value 'foo-inst)
                         ,fixnum?))))))
     ; now compiling to / loading from a file with cp0 enabled and optimize-level 3
     (begin
       (parameterize
         ([optimize-level 3]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (compile-library "testfile-rrp1.ss"))
       (load-library "testfile-rrp1.so")
       #t)
     (equivalent-expansion?
       (parameterize
         ([optimize-level 2]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(lambda (x)
              (import (testfile-rrp1))
              (let ([b (make-bar 23)] [f (make-foo 31 41)])
                (foo-x-set! f 37)
                (list (foo? x)
                      (foo? b)
                      (foo? f)
                      (foo? bar-inst)
                      (foo? foo-inst)
                      (bar? x)
                      (bar? b)
                      (bar? f)
                      (bar? bar-inst)
                      (bar? foo-inst)
                      (bar-x b)
                      (bar-x f)
                      (bar-x foo-inst)
                      (bar-x bar-inst)
                      (foo-x f)
                      (foo-x foo-inst)
                      (foo-y f)
                      (foo-y foo-inst))))))
       `(begin
          (#3%$invoke-library '(testfile-rrp1) '() 'testfile-rrp1)
          (lambda (x)
            (let ([f (#3%$record ',record-type-descriptor? 41 17 31)])
              (#3%$object-set! 'scheme-object f ,fixnum? 37)
              (#2%list (#3%record? x ',record-type-descriptor?)
                       #f
                       #t
                       (#3%record?
                         (#3%$top-level-value 'bar-inst)
                         ',record-type-descriptor?)
                       (#3%record?
                         (#3%$top-level-value 'foo-inst)
                         ',record-type-descriptor?)
                       (#3%record? x ',record-type-descriptor?)
                       #t
                       #t
                       (#3%record?
                         (#3%$top-level-value 'bar-inst)
                         ',record-type-descriptor?)
                       (#3%record?
                         (#3%$top-level-value 'foo-inst)
                         ',record-type-descriptor?)
                       23
                       41
                       (#3%$object-ref 'scheme-object
                         (#3%$top-level-value 'foo-inst)
                         ,fixnum?)
                       (#3%$object-ref 'scheme-object
                         (#3%$top-level-value 'bar-inst)
                         ,fixnum?)
                       (#3%$object-ref 'scheme-object f ,fixnum?)
                       (#3%$object-ref 'scheme-object
                         (#3%$top-level-value 'foo-inst)
                         ,fixnum?)
                       31
                       (#3%$object-ref 'scheme-object
                         (#3%$top-level-value 'foo-inst)
                         ,fixnum?))))))
     (equivalent-expansion?
       (parameterize
         ([optimize-level 3]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(lambda (x)
              (import (testfile-rrp1))
              (let ([b (make-bar 23)] [f (make-foo 31 41)])
                (foo-x-set! f 37)
                (list (foo? x)
                      (foo? b)
                      (foo? f)
                      (foo? bar-inst)
                      (foo? foo-inst)
                      (bar? x)
                      (bar? b)
                      (bar? f)
                      (bar? bar-inst)
                      (bar? foo-inst)
                      (bar-x b)
                      (bar-x f)
                      (bar-x foo-inst)
                      (bar-x bar-inst)
                      (foo-x f)
                      (foo-x foo-inst)
                      (foo-y f)
                      (foo-y foo-inst))))))
       `(begin
          (#3%$invoke-library '(testfile-rrp1) '() 'testfile-rrp1)
          (lambda (x)
            (let ([f (#3%$record ',record-type-descriptor? 41 17 31)])
              (#3%$object-set! 'scheme-object f ,fixnum? 37)
              (#3%list (#3%record? x ',record-type-descriptor?)
                       #f
                       #t
                       (#3%record?
                         (#3%$top-level-value 'bar-inst)
                         ',record-type-descriptor?)
                       (#3%record?
                         (#3%$top-level-value 'foo-inst)
                         ',record-type-descriptor?)
                       (#3%record? x ',record-type-descriptor?)
                       #t
                       #t
                       (#3%record?
                         (#3%$top-level-value 'bar-inst)
                         ',record-type-descriptor?)
                       (#3%record?
                         (#3%$top-level-value 'foo-inst)
                         ',record-type-descriptor?)
                       23
                       41
                       (#3%$object-ref 'scheme-object
                         (#3%$top-level-value 'foo-inst)
                         ,fixnum?)
                       (#3%$object-ref 'scheme-object
                         (#3%$top-level-value 'bar-inst)
                         ,fixnum?)
                       (#3%$object-ref 'scheme-object f ,fixnum?)
                       (#3%$object-ref 'scheme-object
                         (#3%$top-level-value 'foo-inst)
                         ,fixnum?)
                       31
                       (#3%$object-ref 'scheme-object
                         (#3%$top-level-value 'foo-inst)
                         ,fixnum?))))))
     ;; regression tests for cp0 handling of record-mutator when handed a
     ;; (record-rtd rtd expr) directly.
     (equivalent-expansion?
       (parameterize
         ([optimize-level 2]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(let ()
              (define build-box
                (lambda (name k)
                  (let ([gs (gensym (symbol->string name))])
                    (define-syntax mrtd
                      (identifier-syntax
                        (make-record-type-descriptor
                          name
                          #f
                          gs
                          #f
                          #f
                          '#((mutable x)))))
                    (k (record-constructor
                         (make-record-constructor-descriptor mrtd #f #f))
                       (record-predicate mrtd)
                       (record-accessor mrtd 0)
                       (record-mutator mrtd 0)))))
              (build-box 'record-box
                (lambda (box box? unbox set-box!)
                  (let ([b (box 4)])
                    (set-box! b (* 3 (unbox b)))
                    (list (box? b) (unbox b))))))))
       `(let ([gs (#2%gensym "record-box")])
          (let ([g5 (#2%make-record-type-descriptor
                      'record-box
                      #f
                      gs
                      #f
                      #f
                      '#((mutable x)))]
                [g6 (#2%make-record-type-descriptor
                      'record-box
                      #f
                      gs
                      #f
                      #f
                      '#((mutable x)))]
                [g4 (#2%make-record-type-descriptor
                      'record-box
                      #f
                      gs
                      #f
                      #f
                      '#((mutable x)))])
            (let ([b ((#2%record-constructor
                        (#2%make-record-constructor-descriptor
                          (#2%make-record-type-descriptor
                            'record-box
                            #f
                            gs
                            #f
                            #f
                            '#((mutable x)))
                          #f
                          #f)) 4)])
              (let ([g7 (#2%* 3
                              (begin
                                (if (#3%record? b g6)
                                    (#2%void)
                                    (#3%$record-oops 'unbox b g6))
                                (#3%$object-ref 'scheme-object b ,fixnum?)))])
                (if (#3%record? b g4)
                    (#2%void)
                    (#3%$record-oops 'set-box! b g4))
                (#3%$object-set! 'scheme-object b ,fixnum? g7))
              (#2%list (#3%record? b g5)
                (begin
                  (if (#3%record? b g6)
                      (#2%void)
                      (#3%$record-oops 'unbox b g6))
                  (#3%$object-ref 'scheme-object b ,fixnum?)))))))
     (equal? (let ()
               (define build-box
                 (lambda (name k)
                   (let ([gs (gensym (symbol->string name))])
                     (define-syntax mrtd
                       (identifier-syntax
                         (make-record-type-descriptor
                           name
                           #f
                           gs
                           #f
                           #f
                           '#((mutable x)))))
                     (k (record-constructor
                          (make-record-constructor-descriptor mrtd #f #f))
                        (record-predicate mrtd)
                        (record-accessor mrtd 0)
                        (record-mutator mrtd 0)))))
               (build-box 'record-box
                 (lambda (box box? unbox set-box!)
                   (let ([b (box 4)])
                     (set-box! b (* 3 (unbox b)))
                     (list (box? b) (unbox b))))))
             '(#t 12))
     (equivalent-expansion?
       (parameterize
         ([optimize-level 2]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(let ()
              (define useless
                (lambda (name)
                  (record-mutator
                    (make-record-type-descriptor
                      name
                      #f
                      #f
                      #f
                      #f
                      '#((mutable x)))
                    0)))
              (procedure? (useless 'useless-box-setter)))))
       `(#2%procedure?
          (let ([g0 (#2%make-record-type-descriptor
                      'useless-box-setter
                      #f
                      #f
                      #f
                      #f
                      '#((mutable x)))])
            (lambda (g1 g2)
              (if (#3%record? g1 g0)
                  (#2%void)
                  (#3%$record-oops 'moi g1 g0))
              (#3%$object-set! 'scheme-object g1 ,fixnum? g2)))))
     (let ()
       (define useless
         (lambda (name)
           (record-mutator
             (make-record-type-descriptor name #f #f #f #f '#((mutable x)))
             0)))
       (procedure? (useless 'useless-box-setter))))

(mat r6rs-records-syntactic
     ; adapted from r6rs
     (begin (define-record-type point (fields x y)) #t)
     (error? ; invalid syntax
             point)
     (error? ; wrong number of arguments
             (make-point))
     (error? ; wrong number of arguments
             (make-point 3))
     (error? ; wrong number of arguments
             (make-point 3 4 5))
     (begin (define p (make-point 3 4)) #t)
     (error? ; wrong number of arguments
             (point?))
     (error? ; wrong number of arguments
             (point? p p))
     (point? p)
     (not (point? '(3 . 4)))
     (not (point? (let ()
                    (define-record-type point (fields x y))
                    (make-point 3 4))))
     (error? ; unbound
             (point-x-set! p 17))
     (error? ; unbound
             (point-y-set! p 17))
     (eqv? (point-x p) 3)
     (eqv? (point-y p) 4)
     (error? ; wrong number of arguments
             (point-x))
     (error? ; wrong number of arguments
             (point-y p p))
     (not (eq? p (make-point 3 4)))
     (not (record-field-mutable? (record-type-descriptor point) 0))
     (not (record-field-mutable? (record-type-descriptor point) 1))
     (error? (record-mutator (record-type-descriptor point) 0))
     (error? (record-mutator (record-type-descriptor point) 1))

     (let ()
       (define-record-type point (fields x y))
       (define p (make-point 3 4))
       (and (point? p)
            (not (point? '(3 . 4)))
            (not (point? (let ()
                           (define-record-type point
                             (fields x y))
                           (make-point 3 4))))
            (eqv? (point-x p) 3)
            (eqv? (point-y p) 4)
            (not (eq? p (make-point 3 4)))))

     (begin (set! make-point values) #t)
     (begin
       (define-record-type (point make-point point?)
         (fields (immutable x point-x)
                 (immutable y point-y)))
       #t)
     (error? ; invalid syntax
             point)
     (error? ; wrong number of arguments
             (make-point))
     (error? ; wrong number of arguments
             (make-point 3))
     (error? ; wrong number of arguments
             (make-point 3 4 5))
     (begin (define p (make-point 3 4)) #t)
     (error? ; wrong number of arguments
             (point?))
     (error? ; wrong number of arguments
             (point? p p))
     (point? p)
     (not (point? '(3 . 4)))
     (not (point? (let ()
                    (define-record-type point (fields x y))
                    (make-point 3 4))))
     (error? ; unbound
             (point-x-set! p 17))
     (error? ; unbound
             (point-y-set! p 17))
     (eqv? (point-x p) 3)
     (eqv? (point-y p) 4)
     (error? ; wrong number of arguments
             (point-x))
     (error? ; wrong number of arguments
             (point-y p p))
     (not (eq? p (make-point 3 4)))

     (begin (define-record-type widget (fields x)) #t)
     (begin
       (define-record-type frob
         (fields (mutable widget))
         (protocol (lambda (p) (lambda (n) (p (make-widget n))))))
       #t)
     (begin (define f (make-frob 17)) #t)
     (frob? f)
     (widget? (frob-widget f))
     (error? ; wrong number of arguments
             (frob-widget-set!))
     (error? ; wrong number of arguments
             (frob-widget-set! f))
     (error? ; wrong number of arguments
             (frob-widget-set! f f f))
     (eqv? (frob-widget-set! f (list (frob-widget f))) (void))
     (pair? (frob-widget f))
     (not (widget? (frob-widget f)))

     (begin (set! make-frob values) #t)
     (begin
       (define-record-type (frob make-frob frob?)
         (fields (mutable widget frob-widget frob-widget-set!))
         (protocol (lambda (p) (lambda (n) (p (make-widget n))))))
       #t)
     (begin (define f (make-frob 17)) #t)
     (frob? f)
     (widget? (frob-widget f))
     (error? ; wrong number of arguments
             (frob-widget-set!))
     (error? ; wrong number of arguments
             (frob-widget-set! f))
     (error? ; wrong number of arguments
             (frob-widget-set! f f f))
     (eqv? (frob-widget-set! f (list (frob-widget f))) (void))
     (pair? (frob-widget f))
     (not (widget? (frob-widget f)))

     (begin (set! make-frob values) #t)
     (begin
       (define-record-type frob
         (fields (mutable widget getwid setwid!))
         (protocol (lambda (p) (lambda (n) (p (make-widget n))))))
       #t)
     (begin (define f (make-frob 17)) #t)
     (frob? f)
     (widget? (getwid f))
     (error? ; wrong number of arguments
             (setwid!))
     (error? ; wrong number of arguments
             (setwid! f))
     (error? ; wrong number of arguments
             (setwid! f f f))
     (eqv? (setwid! f (list (getwid f))) (void))
     (pair? (getwid f))
     (not (widget? (getwid f)))

     (begin
       (define-record-type (point make-point point?)
         (fields (immutable x point-x)
                 (mutable y point-y set-point-y!))
         (nongenerative point-4893d957-e00b-11d9-817f-00111175eb9e))
       (define-record-type (cpoint make-cpoint cpoint?)
         (parent point)
         (protocol (lambda (n) (lambda (x y c) ((n x y) (color->rgb c)))))
         (fields (mutable rgb cpoint-rgb cpoint-rgb-set!)))
       (define (color->rgb c) (cons 'rgb c))
       (define p1 (make-point 1 2))
       (define p2 (make-cpoint 3 4 'red))
       #t)
     (point? p1)
     (point? p2)
     (not (point? (vector)))
     (not (point? (cons 'a 'b)))
     (not (cpoint? p1))
     (cpoint? p2)
     (eqv? (point-x p1) 1)
     (eqv? (point-y p1) 2)
     (eqv? (point-x p2) 3)
     (eqv? (point-y p2) 4)
     (equal? (cpoint-rgb p2) '(rgb . red))
     (eqv? (set-point-y! p1 17) (void))
     (eqv? (point-y p1) 17)
     (record-type-descriptor? (record-rtd p1))

     (begin
       (define-record-type (ex1 make-ex1 ex1?)
         (protocol (lambda (p) (lambda a (p a))))
         (fields (immutable f ex1-f)))
       (define ex1-i1 (make-ex1 1 2 3))
       #t)
     (equal? (ex1-f ex1-i1) '(1 2 3))

     (begin
       (define-record-type (ex2 make-ex2 ex2?)
         (protocol (lambda (p) (lambda (a . b) (p a b))))
         (fields (immutable a ex2-a) (immutable b ex2-b)))
       (define ex2-i1 (make-ex2 1 2 3))
       #t)

     (eqv? (ex2-a ex2-i1) 1)
     (equal? (ex2-b ex2-i1) '(2 3))

     (not (record-type-opaque? (record-type-descriptor ex2)))
     (not (record-type-sealed? (record-type-descriptor ex2)))
     (record? ex2-i1)
     (r6rs:record? ex2-i1)

     (begin
       (define *ex3-instance* #f)
       (define-record-type ex3
         (parent cpoint)
         (protocol (lambda (n)
                     (lambda (x y t)
                       (let ((r ((n x y 'red) t)))
                         (set! *ex3-instance* r)
                         r))))
         (fields (mutable thickness))
         (sealed #t)
         (opaque #t))
       (define ex3-i1 (make-ex3 1 2 17))
       #t)
     (ex3? ex3-i1)
     (equal? (cpoint-rgb ex3-i1) '(rgb . red))
     (eqv? (ex3-thickness ex3-i1) 17)
     (begin (ex3-thickness-set! ex3-i1 18) #t)
     (eqv? (ex3-thickness ex3-i1) 18)
     (eqv? *ex3-instance* ex3-i1)

     (record-type-opaque? (record-type-descriptor ex3))
     (record-type-sealed? (record-type-descriptor ex3))
     (not (r6rs:record? ex3-i1))
     (not (record? ex3-i1))
     (error? ; not a record
             (record-rtd ex3-i1))
     (error? ; not a record
             (record-rtd ex3-i1))
     (error? ; parent record type is sealed
             (define-record-type ex3xxx (parent ex3)))
     (record-type-descriptor? (record-type-descriptor ex3))
     (record-constructor-descriptor? (record-constructor-descriptor ex3))
     (equal? (parameterize ([print-gensym 'pretty])
               (with-output-to-string
                 (lambda ()
                   (define-record-type f (fields x))
                   (define-record-type g
                     (fields y)
                     (parent f)
                     (opaque #t))
                   (define-record-type h
                     (fields z)
                     (parent g)
                     (opaque #t))
                   (let ([fx (make-f 'a)]
                         [gx (make-g 'a 'b)]
                         [hx (make-h 'a 'b 'c)])
                     (write fx)
                     (write gx)
                     (write hx)
                     (record-writer (record-type-descriptor f)
                       (lambda (x p wr)
                         (display "#<an f>" p)))
                     (record-writer (record-type-descriptor g)
                       (lambda (x p wr)
                         (display "#<a g>" p)))
                     (record-writer (record-type-descriptor h)
                       (lambda (x p wr)
                         (display "#<an h x=" p)
                         (wr (f-x x) p)
                         (display " y=" p)
                         (wr (g-y x) p)
                         (display " z=" p)
                         (wr (h-z x) p)
                         (display ">" p)))
                     (write fx)
                     (write gx)
                     (write hx)))))
             "#[#:f a]#<g>#<h>#<an f>#<a g>#<an h x=a y=b z=c>")
     (equal? (let ()
               (define-record-type f (fields x))
               (define-record-type g
                 (fields y)
                 (parent f)
                 (opaque #t))
               (define-record-type h
                 (fields z)
                 (parent g)
                 (opaque #t))
               (list ($record->vector
                       (with-input-from-string
                         (with-output-to-string
                           (lambda ()
                             (write (make-f "hello"))))
                         read))
                     ($record->vector
                       (with-input-from-string
                         (format "#[~s k]"
                           (record-type-uid (record-type-descriptor f)))
                         read))
                     ($record->vector
                       (with-input-from-string
                         (format "#[~s k 9]"
                           (record-type-uid (record-type-descriptor g)))
                         read))
                     ($record->vector
                       (with-input-from-string
                         (format "#[~s opaque? no problem]"
                                 (record-type-uid (record-type-descriptor h)))
                         read))))
             '(#(f "hello") #(f k) #(g k 9) #(h opaque? no problem)))

     (begin
       (define-record-type (unit-vector make-unit-vector unit-vector?)
         (protocol (lambda (p)
                     (lambda (x y z)
                       (let ((length (sqrt (+ (* x x) (* y y) (* z z)))))
                         (p (/ x length) (/ y length) (/ z length))))))
         (fields (immutable x unit-vector-x)
                 (immutable y unit-vector-y)
                 (immutable z unit-vector-z)))
       (define uv (make-unit-vector 3 4 0))
       #t)
     (unit-vector? uv)
     (eqv? (unit-vector-x uv) 3/5)
     (eqv? (unit-vector-y uv) 4/5)
     (eqv? (unit-vector-z uv) 0)

     ; to avoid gensyms in error messages, hence problems diffing mat output
     (begin (print-record #f) #t)

     ; test generativity
     (error? ; not a point
       (let f ([x #f])
         (define-record-type point (fields x y))
         (if x (point-x x) (f (make-point 3 4)))))

     (not (let f ([x #f])
            (define-record-type point (fields x y))
            (if x (point? x) (f (make-point 3 4)))))

     (begin
       (define ($f p)
         (define-record-type point (fields x y))
         (if (eq? p 'make) (make-point 3 4) (point? p)))
       (not ($f ($f 'make))))

     (eqv? (let f ([x #f])
             (define-record-type point
               (fields x y)
               (nongenerative))
             (if x (point-x x) (f (make-point 3 4))))
           3)

     (let f ([x #f])
       (define-record-type point
         (fields x y)
         (nongenerative))
       (if x (point? x) (f (make-point 3 4))))

     (begin
       (define ($f p)
         (define-record-type point
           (fields x y)
           (nongenerative))
         (if (eq? p 'make) (make-point 3 4) (point? p)))
       ($f ($f 'make)))

     (eqv? (let f ([x #f])
             (define-record-type point
               (fields x y)
               (nongenerative spam))
             (if x (point-x x) (f (make-point 3 4))))
           3)

     (error? ; not a point
       (let f ([x #f])
         (define (color->rgb c) (cons 'rgb c))
         (define-record-type point (fields x y))
         (define-record-type cpoint
           (parent point)
           (fields (mutable rgb))
           (protocol (lambda (n) (lambda (x y c) ((n x y) (color->rgb c))))))
         (if x (point-x x) (f (make-cpoint 3 4 'red)))))

     (error? ; not a cpoint
       (let f ([x #f])
         (define (color->rgb c) (cons 'rgb c))
         (define-record-type point (fields x y))
         (define-record-type cpoint
           (parent point)
           (fields (mutable rgb))
           (protocol (lambda (n) (lambda (x y c) ((n x y) (color->rgb c))))))
         (if x (cpoint-rgb x) (f (make-cpoint 3 4 'red)))))

     (eqv? (let f ([x #f])
             (define (color->rgb c) (cons 'rgb c))
             (define-record-type point
               (fields x y)
               (nongenerative))
             (define-record-type cpoint
               (parent point)
               (fields (mutable rgb))
               (protocol (lambda (n)
                           (lambda (x y c)
                             ((n x y) (color->rgb c))))))
             (if x (point-x x) (f (make-cpoint 3 4 'red))))
           3)

     (error? ; not a cpoint
       (let f ([x #f])
         (define (color->rgb c) (cons 'rgb c))
         (define-record-type point
           (fields x y)
           (nongenerative))
         (define-record-type cpoint
           (parent point)
           (fields (mutable rgb))
           (protocol (lambda (n) (lambda (x y c) ((n x y) (color->rgb c))))))
         (if x (cpoint-rgb x) (f (make-cpoint 3 4 'red)))))

     (error? ; incompatible record type
       (let f ([x #f])
         (define (color->rgb c) (cons 'rgb c))
         (define-record-type point (fields x y))
         (define-record-type cpoint
           (nongenerative)
           (parent point)
           (fields (mutable rgb))
           (protocol (lambda (n) (lambda (x y c) ((n x y) (color->rgb c))))))
         (if x (point-x x) (f (make-cpoint 3 4 'red)))))

     (error? ; incompatible record type
       (let f ([x #f])
         (define (color->rgb c) (cons 'rgb c))
         (define-record-type point (fields x y))
         (define-record-type cpoint
           (nongenerative)
           (parent point)
           (fields (mutable rgb))
           (protocol (lambda (n) (lambda (x y c) ((n x y) (color->rgb c))))))
         (if x (cpoint-rgb x) (f (make-cpoint 3 4 'red)))))

     (eqv? (let ()
             (define-record-type point (fields x y))
             (let f ([x #f])
               (define (color->rgb c) (cons 'rgb c))
               (define-record-type cpoint
                 (nongenerative)
                 (parent point)
                 (fields (mutable rgb))
                 (protocol (lambda (n)
                             (lambda (x y c)
                               ((n x y) (color->rgb c))))))
               (if x (point-x x) (f (make-cpoint 3 4 'red)))))
           3)

     (equal? (let ()
               (define-record-type point (fields x y))
               (let f ([x #f])
                 (define (color->rgb c) (cons 'rgb c))
                 (define-record-type cpoint
                   (nongenerative)
                   (parent point)
                   (fields (mutable rgb))
                   (protocol (lambda (n)
                               (lambda (x y c)
                                 ((n x y) (color->rgb c))))))
                 (if x
                     (cpoint-rgb x)
                     (f (make-cpoint 3 4 'red)))))
             '(rgb . red))

     (eqv? (let f ([x #f])
             (define (color->rgb c) (cons 'rgb c))
             (define-record-type point
               (fields x y)
               (nongenerative))
             (define-record-type cpoint
               (nongenerative)
               (parent point)
               (fields (mutable rgb))
               (protocol (lambda (n)
                           (lambda (x y c)
                             ((n x y) (color->rgb c))))))
             (if x (point-x x) (f (make-cpoint 3 4 'red))))
           3)

     (equal? (let f ([x #f])
               (define (color->rgb c) (cons 'rgb c))
               (define-record-type point
                 (fields x y)
                 (nongenerative))
               (define-record-type cpoint
                 (nongenerative)
                 (parent point)
                 (fields (mutable rgb))
                 (protocol (lambda (n)
                             (lambda (x y c)
                               ((n x y) (color->rgb c))))))
               (if x
                   (cpoint-rgb x)
                   (f (make-cpoint 3 4 'red))))
             '(rgb . red))

     (eqv? (let f ([x #f])
             (define (color->rgb c) (cons 'rgb c))
             (define-record-type point
               (fields x y)
               (nongenerative point0001))
             (define-record-type cpoint
               (parent point)
               (fields (mutable rgb))
               (protocol (lambda (n)
                           (lambda (x y c)
                             ((n x y) (color->rgb c))))))
             (if x (point-x x) (f (make-cpoint 3 4 'red))))
           3)

     (error? ; not a cpoint
       (let f ([x #f])
         (define (color->rgb c) (cons 'rgb c))
         (define-record-type point
           (fields x y)
           (nongenerative point0002))
         (define-record-type cpoint
           (parent point)
           (fields (mutable rgb))
           (protocol (lambda (n) (lambda (x y c) ((n x y) (color->rgb c))))))
         (if x (cpoint-rgb x) (f (make-cpoint 3 4 'red)))))

     (error? ; incompatible record type
       (let f ([x #f])
         (define (color->rgb c) (cons 'rgb c))
         (define-record-type point (fields x y))
         (define-record-type cpoint
           (nongenerative cpoint0003)
           (parent point)
           (fields (mutable rgb))
           (protocol (lambda (n) (lambda (x y c) ((n x y) (color->rgb c))))))
         (if x (point-x x) (f (make-cpoint 3 4 'red)))))

     (error? ; incompatible record type
       (let f ([x #f])
         (define (color->rgb c) (cons 'rgb c))
         (define-record-type point (fields x y))
         (define-record-type cpoint
           (nongenerative cpoint0004)
           (parent point)
           (fields (mutable rgb))
           (protocol (lambda (n) (lambda (x y c) ((n x y) (color->rgb c))))))
         (if x (cpoint-rgb x) (f (make-cpoint 3 4 'red)))))

     (eqv? (let ()
             (define-record-type point (fields x y))
             (let f ([x #f])
               (define (color->rgb c) (cons 'rgb c))
               (define-record-type cpoint
                 (nongenerative cpoint0005)
                 (parent point)
                 (fields (mutable rgb))
                 (protocol (lambda (n)
                             (lambda (x y c)
                               ((n x y) (color->rgb c))))))
               (if x (point-x x) (f (make-cpoint 3 4 'red)))))
           3)

     (equal? (let ()
               (define-record-type point (fields x y))
               (let f ([x #f])
                 (define (color->rgb c) (cons 'rgb c))
                 (define-record-type cpoint
                   (nongenerative cpoint0006)
                   (parent point)
                   (fields (mutable rgb))
                   (protocol (lambda (n)
                               (lambda (x y c)
                                 ((n x y) (color->rgb c))))))
                 (if x
                     (cpoint-rgb x)
                     (f (make-cpoint 3 4 'red)))))
             '(rgb . red))

     (eqv? (let f ([x #f])
             (define (color->rgb c) (cons 'rgb c))
             (define-record-type point
               (fields x y)
               (nongenerative point0007))
             (define-record-type cpoint
               (nongenerative cpoint0008)
               (parent point)
               (fields (mutable rgb))
               (protocol (lambda (n)
                           (lambda (x y c)
                             ((n x y) (color->rgb c))))))
             (if x (point-x x) (f (make-cpoint 3 4 'red))))
           3)

     (equal? (let f ([x #f])
               (define (color->rgb c) (cons 'rgb c))
               (define-record-type point
                 (fields x y)
                 (nongenerative point0009))
               (define-record-type cpoint
                 (nongenerative cpoint0010)
                 (parent point)
                 (fields (mutable rgb))
                 (protocol (lambda (n)
                             (lambda (x y c)
                               ((n x y) (color->rgb c))))))
               (if x
                   (cpoint-rgb x)
                   (f (make-cpoint 3 4 'red))))
             '(rgb . red))

     ; make sure we can use arbitrary symbols as uids w/o destroying bindings
     (equal? ($record->vector
               (let ()
                 (define-record-type foo
                   (fields x)
                   (nongenerative cons))
                 (make-foo (cons 17 3))))
             '#(foo (17 . 3)))
     (equal? (cons 17 3) '(17 . 3))

     ; make sure we can use modifiers and types as field names
     (equal? (let ()
               (define-record-type foo
                 (fields (mutable mutable)
                         (immutable int)
                         (immutable char)
                         (mutable integer-32)))
               (let ([x (make-foo 3 4 5 6)])
                 (foo-mutable-set! x 75)
                 (list ($record->vector x)
                       (foo-mutable x)
                       (foo-int x)
                       (foo-char x)
                       (foo-integer-32 x))))
             '(#(foo 75 4 5 6) 75 4 5 6))

     (begin (print-record #t) (print-record))

     ; optimization tests---observe with expand/optimize
     (equal? (map (lambda (x) (if (#%$record? x) ($record->vector x) x))
                  ; try define-record-type
                  (let f ([x #f])
                    (define (color->rgb c) (cons 'rgb c))
                    (define-record-type point (fields x y))
                    (define-record-type cpoint
                      (parent point)
                      (fields (mutable rgb)))
                    (if x
                        (list x (cpoint? x) (make-point -8 -15))
                        (f (make-cpoint 3 4 (color->rgb 'red))))))
             '(#(cpoint 3 4 (rgb . red)) #f #(point -8 -15)))
     (equivalent-expansion? ; optimize-level 2 expansion of above
       (parameterize
         ([optimize-level 2]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(lambda ()
              (define (color->rgb c) (cons 'rgb c))
              (define-record-type point (fields x y))
              (define-record-type cpoint
                (parent point)
                (fields (mutable rgb)))
              (if x
                  (list x (cpoint? x) (make-point -8 -15))
                  (f (make-cpoint 3 4 (color->rgb 'red)))))))
       '(lambda ()
          (let ([rtd (#2%$make-record-type-descriptor
                       #!base-rtd
                       'point
                       #f
                       #f
                       #f
                       #f
                       '#2((immutable x) (immutable y))
                       'define-record-type)])
            (let ([rtd (#2%$make-record-type-descriptor
                         #!base-rtd
                         'cpoint
                         rtd
                         #f
                         #f
                         #f
                         '#1((mutable rgb))
                         'define-record-type)])
              (if x
                  (#2%list x (#3%record? x rtd) (#3%$record rtd -8 -15))
                  (f (#3%$record rtd 3 4 (#2%cons 'rgb 'red))))))))
     (equivalent-expansion? ; optimize-level 3 expansion of above
       (parameterize
         ([optimize-level 3]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(lambda ()
              (define (color->rgb c) (cons 'rgb c))
              (define-record-type point (fields x y))
              (define-record-type cpoint
                (parent point)
                (fields (mutable rgb)))
              (if x
                  (list x (cpoint? x) (make-point -8 -15))
                  (f (make-cpoint 3 4 (color->rgb 'red)))))))
       '(lambda ()
          (let ([rtd (#3%$make-record-type-descriptor
                       #!base-rtd
                       'point
                       #f
                       #f
                       #f
                       #f
                       '#2((immutable x) (immutable y))
                       'define-record-type)])
            (let ([rtd (#3%$make-record-type-descriptor
                         #!base-rtd
                         'cpoint
                         rtd
                         #f
                         #f
                         #f
                         '#1((mutable rgb))
                         'define-record-type)])
              (if x
                  (#3%list x (#3%record? x rtd) (#3%$record rtd -8 -15))
                  (f (#3%$record rtd 3 4 (#3%cons 'rgb 'red))))))))
     (equal? (map (lambda (x) (if (#%$record? x) ($record->vector x) x))
                  ; same but nongenerative w/accessor call
                  (let f ([x #f])
                    (define (color->rgb c) (cons 'rgb c))
                    (define-record-type point
                      (fields x y)
                      (nongenerative))
                    (define-record-type cpoint
                      (nongenerative)
                      (parent point)
                      (fields (mutable rgb)))
                    (if x
                        (list x (cpoint-rgb x) (make-point -8 -15))
                        (f (make-cpoint 3 4 (color->rgb 'red))))))
             '(#(cpoint 3 4 (rgb . red)) (rgb . red) #(point -8 -15)))
     (equivalent-expansion? ; optimize-level 2 expansion of above
       (parameterize
         ([optimize-level 2]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(lambda ()
              (define (color->rgb c) (cons 'rgb c))
              (define-record-type point
                (fields x y)
                (nongenerative))
              (define-record-type cpoint
                (nongenerative)
                (parent point)
                (fields (mutable rgb)))
              (if x
                  (list x (cpoint-rgb x) (make-point -8 -15))
                  (f (make-cpoint 3 4 (color->rgb 'red)))))))
       `(lambda ()
          (if x
              (#2%list x
                (let ([g12 x])
                  (if (#3%record? g12 ',record-type-descriptor?)
                      (#2%void)
                      (#3%$record-oops
                        'cpoint-rgb
                        g12
                        ',record-type-descriptor?))
                  (#3%$object-ref 'scheme-object g12 ,fixnum?))
                ',record?)
              (f (#3%$record
                   ',record-type-descriptor?
                   3
                   4
                   (#2%cons 'rgb 'red))))))
     (equivalent-expansion? ; optimize-level 3 expansion of above
       (parameterize
         ([optimize-level 3]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(lambda ()
              (define (color->rgb c) (cons 'rgb c))
              (define-record-type point
                (fields x y)
                (nongenerative))
              (define-record-type cpoint
                (nongenerative)
                (parent point)
                (fields (mutable rgb)))
              (if x
                  (list x (cpoint-rgb x) (make-point -8 -15))
                  (f (make-cpoint 3 4 (color->rgb 'red)))))))
       `(lambda ()
          (if x
              (#3%list x
                (#3%$object-ref 'scheme-object x ,fixnum?)
                ',record?)
              (f (#3%$record
                   ',record-type-descriptor?
                   3
                   4
                   (#3%cons 'rgb 'red))))))
     (equal? (map (lambda (x) (if (#%$record? x) ($record->vector x) x))
                  ; same but with child protocol
                  (let f ([x #f])
                    (define (color->rgb c) (cons 'rgb c))
                    (define-record-type point (fields x y))
                    (define-record-type cpoint
                      (parent point)
                      (fields (mutable rgb))
                      (protocol (lambda (n)
                                  (lambda (x y c)
                                    ((n x y) (color->rgb c))))))
                    (if x
                        (list x (cpoint? x) (make-point -8 -15))
                        (f (make-cpoint 3 4 'red)))))
             '(#(cpoint 3 4 (rgb . red)) #f #(point -8 -15)))
     (equivalent-expansion? ; optimize-level 2 expansion of above
       (parameterize
         ([optimize-level 2]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(lambda ()
              (define (color->rgb c) (cons 'rgb c))
              (define-record-type point (fields x y))
              (define-record-type cpoint
                (parent point)
                (fields (mutable rgb))
                (protocol (lambda (n)
                            (lambda (x y c)
                              ((n x y) (color->rgb c))))))
              (if x
                  (list x (cpoint? x) (make-point -8 -15))
                  (f (make-cpoint 3 4 'red))))))
       '(lambda ()
          (let ([rtd (#2%$make-record-type-descriptor
                       #!base-rtd
                       'point
                       #f
                       #f
                       #f
                       #f
                       '#2((immutable x) (immutable y))
                       'define-record-type)])
            (let ([rtd (#2%$make-record-type-descriptor
                         #!base-rtd
                         'cpoint
                         rtd
                         #f
                         #f
                         #f
                         '#1((mutable rgb))
                         'define-record-type)])
              (if x
                  (#2%list x (#3%record? x rtd) (#3%$record rtd -8 -15))
                  (f (#3%$record rtd 3 4 (#2%cons 'rgb 'red))))))))
     (equivalent-expansion? ; optimize-level 3 expansion of above
       (parameterize
         ([optimize-level 3]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(lambda ()
              (define (color->rgb c) (cons 'rgb c))
              (define-record-type point (fields x y))
              (define-record-type cpoint
                (parent point)
                (fields (mutable rgb))
                (protocol (lambda (n)
                            (lambda (x y c)
                              ((n x y) (color->rgb c))))))
              (if x
                  (list x (cpoint? x) (make-point -8 -15))
                  (f (make-cpoint 3 4 'red))))))
       '(lambda ()
          (let ([rtd (#3%$make-record-type-descriptor
                       #!base-rtd
                       'point
                       #f
                       #f
                       #f
                       #f
                       '#2((immutable x) (immutable y))
                       'define-record-type)])
            (let ([rtd (#3%$make-record-type-descriptor
                         #!base-rtd
                         'cpoint
                         rtd
                         #f
                         #f
                         #f
                         '#1((mutable rgb))
                         'define-record-type)])
              (if x
                  (#3%list x (#3%record? x rtd) (#3%$record rtd -8 -15))
                  (f (#3%$record rtd 3 4 (#3%cons 'rgb 'red))))))))
     (equal? (map (lambda (x) (if (#%$record? x) ($record->vector x) x))
                  ; same but nongenerative w/accessor call
                  (let f ([x #f])
                    (define (color->rgb c) (cons 'rgb c))
                    (define-record-type point
                      (fields x y)
                      (nongenerative point0009))
                    (define-record-type cpoint
                      (nongenerative cpoint0010)
                      (parent point)
                      (fields (mutable rgb))
                      (protocol (lambda (n)
                                  (lambda (x y c)
                                    ((n x y) (color->rgb c))))))
                    (if x
                        (list x (cpoint-rgb x) (make-point -8 -15))
                        (f (make-cpoint 3 4 'red)))))
             '(#(cpoint 3 4 (rgb . red)) (rgb . red) #(point -8 -15)))
     (equivalent-expansion? ; optimize-level 2 expansion of above
       (parameterize
         ([optimize-level 2]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(lambda ()
              (define (color->rgb c) (cons 'rgb c))
              (define-record-type point
                (fields x y)
                (nongenerative point0009))
              (define-record-type cpoint
                (nongenerative cpoint0010)
                (parent point)
                (fields (mutable rgb))
                (protocol (lambda (n)
                            (lambda (x y c)
                              ((n x y) (color->rgb c))))))
              (if x
                  (list x (cpoint-rgb x) (make-point -8 -15))
                  (f (make-cpoint 3 4 'red))))))
       `(lambda ()
          (if x
              (#2%list x
                (let ([g35 x])
                  (if (#3%record? g35 ',record-type-descriptor?)
                      (#2%void)
                      (#3%$record-oops
                        'cpoint-rgb
                        g35
                        ',record-type-descriptor?))
                  (#3%$object-ref 'scheme-object g35 ,fixnum?))
                ',record?)
              (f (#3%$record
                   ',record-type-descriptor?
                   3
                   4
                   (#2%cons 'rgb 'red))))))
     (equivalent-expansion? ; optimize-level 3 expansion of above
       (parameterize
         ([optimize-level 3]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(lambda ()
              (define (color->rgb c) (cons 'rgb c))
              (define-record-type point
                (fields x y)
                (nongenerative point0009))
              (define-record-type cpoint
                (nongenerative cpoint0010)
                (parent point)
                (fields (mutable rgb))
                (protocol (lambda (n)
                            (lambda (x y c)
                              ((n x y) (color->rgb c))))))
              (if x
                  (list x (cpoint-rgb x) (make-point -8 -15))
                  (f (make-cpoint 3 4 'red))))))
       `(lambda ()
          (if x
              (#3%list x
                (#3%$object-ref 'scheme-object x ,fixnum?)
                ',record?)
              (f (#3%$record
                   ',record-type-descriptor?
                   3
                   4
                   (#3%cons 'rgb 'red))))))
     (equal? (map (lambda (x) (if (#%$record? x) ($record->vector x) x))
                  ; same as two above but with trivial parent protocol
                  (let f ([x #f])
                    (define (color->rgb c) (cons 'rgb c))
                    (define-record-type point
                      (fields x y)
                      (protocol (lambda (n) n)))
                    (define-record-type cpoint
                      (parent point)
                      (fields (mutable rgb))
                      (protocol (lambda (n)
                                  (lambda (x y c)
                                    ((n x y) (color->rgb c))))))
                    (if x
                        (list x (cpoint? x) (make-point -8 -15))
                        (f (make-cpoint 3 4 'red)))))
             '(#(cpoint 3 4 (rgb . red)) #f #(point -8 -15)))
     (equivalent-expansion? ; optimize-level 2 expansion of above
       (parameterize
         ([optimize-level 2]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(lambda ()
              (define (color->rgb c) (cons 'rgb c))
              (define-record-type point
                (fields x y)
                (protocol (lambda (n) n)))
              (define-record-type cpoint
                (parent point)
                (fields (mutable rgb))
                (protocol (lambda (n)
                            (lambda (x y c)
                              ((n x y) (color->rgb c))))))
              (if x
                  (list x (cpoint? x) (make-point -8 -15))
                  (f (make-cpoint 3 4 'red))))))
       '(lambda ()
          (let ([rtd (#2%$make-record-type-descriptor
                       #!base-rtd
                       'point
                       #f
                       #f
                       #f
                       #f
                       '#2((immutable x) (immutable y))
                       'define-record-type)])
            (let ([rtd (#2%$make-record-type-descriptor
                         #!base-rtd
                         'cpoint
                         rtd
                         #f
                         #f
                         #f
                         '#1((mutable rgb))
                         'define-record-type)])
              (if x
                  (#2%list x (#3%record? x rtd) (#3%$record rtd -8 -15))
                  (f (#3%$record rtd 3 4 (#2%cons 'rgb 'red))))))))
     (equivalent-expansion? ; optimize-level 3 expansion of above
       (parameterize
         ([optimize-level 3]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(lambda ()
              (define (color->rgb c) (cons 'rgb c))
              (define-record-type point
                (fields x y)
                (protocol (lambda (n) n)))
              (define-record-type cpoint
                (parent point)
                (fields (mutable rgb))
                (protocol (lambda (n)
                            (lambda (x y c)
                              ((n x y) (color->rgb c))))))
              (if x
                  (list x (cpoint? x) (make-point -8 -15))
                  (f (make-cpoint 3 4 'red))))))
       '(lambda ()
          (let ([rtd (#3%$make-record-type-descriptor
                       #!base-rtd
                       'point
                       #f
                       #f
                       #f
                       #f
                       '#2((immutable x) (immutable y))
                       'define-record-type)])
            (let ([rtd (#3%$make-record-type-descriptor
                         #!base-rtd
                         'cpoint
                         rtd
                         #f
                         #f
                         #f
                         '#1((mutable rgb))
                         'define-record-type)])
              (if x
                  (#3%list x (#3%record? x rtd) (#3%$record rtd -8 -15))
                  (f (#3%$record rtd 3 4 (#3%cons 'rgb 'red))))))))
     (equal? (map (lambda (x) (if (#%$record? x) ($record->vector x) x))
                  ; same but nongenerative w/accessor call
                  (let f ([x #f])
                    (define (color->rgb c) (cons 'rgb c))
                    (define-record-type point
                      (fields x y)
                      (nongenerative point0009)
                      (protocol (lambda (n) n)))
                    (define-record-type cpoint
                      (nongenerative cpoint0010)
                      (parent point)
                      (fields (mutable rgb))
                      (protocol (lambda (n)
                                  (lambda (x y c)
                                    ((n x y) (color->rgb c))))))
                    (if x
                        (list x (cpoint-rgb x) (make-point -8 -15))
                        (f (make-cpoint 3 4 'red)))))
             '(#(cpoint 3 4 (rgb . red)) (rgb . red) #(point -8 -15)))
     (equivalent-expansion? ; optimize-level 2 expansion of above
       (parameterize
         ([optimize-level 2]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(lambda ()
              (define (color->rgb c) (cons 'rgb c))
              (define-record-type point
                (fields x y)
                (nongenerative point0009)
                (protocol (lambda (n) n)))
              (define-record-type cpoint
                (nongenerative cpoint0010)
                (parent point)
                (fields (mutable rgb))
                (protocol (lambda (n)
                            (lambda (x y c)
                              ((n x y) (color->rgb c))))))
              (if x
                  (list x (cpoint-rgb x) (make-point -8 -15))
                  (f (make-cpoint 3 4 'red))))))
       `(lambda ()
          (if x
              (#2%list x
                (let ([g57 x])
                  (if (#3%record? g57 ',record-type-descriptor?)
                      (#2%void)
                      (#3%$record-oops
                        'cpoint-rgb
                        g57
                        ',record-type-descriptor?))
                  (#3%$object-ref 'scheme-object g57 ,fixnum?))
                ',record?)
              (f (#3%$record
                   ',record-type-descriptor?
                   3
                   4
                   (#2%cons 'rgb 'red))))))
     (equivalent-expansion? ; optimize-level 3 expansion of above
       (parameterize
         ([optimize-level 3]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(lambda ()
              (define (color->rgb c) (cons 'rgb c))
              (define-record-type point
                (fields x y)
                (nongenerative point0009)
                (protocol (lambda (n) n)))
              (define-record-type cpoint
                (nongenerative cpoint0010)
                (parent point)
                (fields (mutable rgb))
                (protocol (lambda (n)
                            (lambda (x y c)
                              ((n x y) (color->rgb c))))))
              (if x
                  (list x (cpoint-rgb x) (make-point -8 -15))
                  (f (make-cpoint 3 4 'red))))))
       `(lambda ()
          (if x
              (#3%list x
                (#3%$object-ref 'scheme-object x ,fixnum?)
                ',record?)
              (f (#3%$record
                   ',record-type-descriptor?
                   3
                   4
                   (#3%cons 'rgb 'red))))))
     (begin
       ; test global define-record-type
       (define ($color->rgb c) (cons 'rgb c))
       (define-record-type ($point $make-point $point?)
         (fields x y))
       (define-record-type ($cpoint $make-cpoint $cpoint?)
         (parent $point)
         (fields (mutable rgb)))
       (equal? (map (lambda (x) (if (#%$record? x) ($record->vector x) x))
                    (let ([x ($make-cpoint 3 4 ($color->rgb 'red))])
                      (list x ($cpoint-rgb x) ($make-point -8 -15))))
               '(#($cpoint 3 4 (rgb . red)) (rgb . red) #($point -8 -15))))
     (equivalent-expansion? ; optimize-level 2 expansion of above
       (parameterize
         ([optimize-level 2]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(begin
              ; test global define-record-type
              (define ($color->rgb c) (cons 'rgb c))
              (define-record-type ($point $make-point $point?)
                (fields x y))
              (define-record-type ($cpoint $make-cpoint $cpoint?)
                (parent $point)
                (fields (mutable rgb)))
              (equal? (map (lambda (x)
                             (if (#%$record? x)
                                 ($record->vector x)
                                 x))
                           (let ([x ($make-cpoint 3 4 ($color->rgb 'red))])
                             (list x ($cpoint-rgb x) ($make-point -8 -15))))
                      '(#($cpoint 3 4 (rgb . red))
                        (rgb . red)
                        #($point -8 -15))))))
       `(begin
          (set! $color->rgb (lambda (c) (#2%cons 'rgb c)))
          (set! $make-point
            (lambda (g73 g74)
              (#3%$record ',record-type-descriptor? g73 g74)))
          (set! $point?
            (lambda (g72)
              (#3%record? g72 ',record-type-descriptor?)))
          (set! $point-x
            (lambda (g71)
              (if (#3%record? g71 ',record-type-descriptor?)
                  (#2%void)
                  (#3%$record-oops 'moi g71 ',record-type-descriptor?))
              (#3%$object-ref 'scheme-object g71 ,fixnum?)))
          (set! $point-y
            (lambda (g70)
              (if (#3%record? g70 ',record-type-descriptor?)
                  (#2%void)
                  (#3%$record-oops 'moi g70 ',record-type-descriptor?))
              (#3%$object-ref 'scheme-object g70 ,fixnum?)))
          (set! $make-cpoint
            (lambda (g67 g68 g69)
              (#3%$record ',record-type-descriptor? g67 g68 g69)))
          (set! $cpoint?
            (lambda (g66)
              (#3%record? g66 ',record-type-descriptor?)))
          (set! $cpoint-rgb
            (lambda (g65)
              (if (#3%record? g65 ',record-type-descriptor?)
                  (#2%void)
                  (#3%$record-oops 'moi g65 ',record-type-descriptor?))
              (#3%$object-ref 'scheme-object g65 ,fixnum?)))
          (set! $cpoint-rgb-set!
            (lambda (g63 g64)
              (if (#3%record? g63 ',record-type-descriptor?)
                  (#2%void)
                  (#3%$record-oops 'moi g63 ',record-type-descriptor?))
              (#3%$object-set! 'scheme-object g63 ,fixnum? g64)))
          (#2%equal?
            (#2%map (lambda (x) (if (#2%$record? x) ($record->vector x) x))
                    (let ([x ($make-cpoint 3 4 ($color->rgb 'red))])
                      (#2%list x ($cpoint-rgb x) ($make-point -8 -15))))
            '(#4($cpoint 3 4 (rgb . red)) (rgb . red) #3($point -8 -15)))))
     (equivalent-expansion? ; optimize-level 3 expansion of above
       (parameterize
         ([optimize-level 3]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(begin
              ; test global define-record-type
              (define ($color->rgb c) (cons 'rgb c))
              (define-record-type ($point $make-point $point?)
                (fields x y))
              (define-record-type ($cpoint $make-cpoint $cpoint?)
                (parent $point)
                (fields (mutable rgb)))
              (equal? (map (lambda (x)
                             (if (#%$record? x)
                                 ($record->vector x)
                                 x))
                           (let ([x ($make-cpoint 3 4 ($color->rgb 'red))])
                             (list x ($cpoint-rgb x) ($make-point -8 -15))))
                      '(#($cpoint 3 4 (rgb . red))
                        (rgb . red)
                        #($point -8 -15))))))
       `(begin
          (set! $color->rgb (lambda (c) (#3%cons 'rgb c)))
          (set! $make-point
            (lambda (g109 g110)
              (#3%$record ',record-type-descriptor? g109 g110)))
          (set! $point?
            (lambda (g108)
              (#3%record? g108 ',record-type-descriptor?)))
          (set! $point-x
            (lambda (g107)
              (#3%$object-ref 'scheme-object g107 ,fixnum?)))
          (set! $point-y
            (lambda (g106)
              (#3%$object-ref 'scheme-object g106 ,fixnum?)))
          (set! $make-cpoint
            (lambda (g103 g104 g105)
              (#3%$record ',record-type-descriptor? g103 g104 g105)))
          (set! $cpoint?
            (lambda (g102)
              (#3%record? g102 ',record-type-descriptor?)))
          (set! $cpoint-rgb
            (lambda (g101)
              (#3%$object-ref 'scheme-object g101 ,fixnum?)))
          (set! $cpoint-rgb-set!
            (lambda (g99 g100)
              (#3%$object-set! 'scheme-object g99 ,fixnum? g100)))
          (#3%equal?
            (#3%map (lambda (x) (if (#3%$record? x) ($record->vector x) x))
                    (let ([x ($make-cpoint 3 4 ($color->rgb 'red))])
                      (#3%list x ($cpoint-rgb x) ($make-point -8 -15))))
            '(#4($cpoint 3 4 (rgb . red)) (rgb . red) #3($point -8 -15)))))
     (begin
       ; test global define-record-type
       (define ($color->rgb c) (cons 'rgb c))
       (define-record-type ($point $make-point $point?)
         (fields x y)
         (protocol (lambda (n) n)))
       (define-record-type ($cpoint $make-cpoint $cpoint?)
         (parent $point)
         (fields (mutable rgb))
         (protocol (lambda (n) (lambda (x y c) ((n x y) ($color->rgb c))))))
       (equal? (map (lambda (x) (if (#%$record? x) ($record->vector x) x))
                    (let ([x ($make-cpoint 3 4 'red)])
                      (list x ($cpoint-rgb x) ($make-point -8 -15))))
               '(#($cpoint 3 4 (rgb . red)) (rgb . red) #($point -8 -15))))
     (equivalent-expansion? ; optimize-level 2 expansion of above
       (parameterize
         ([optimize-level 2]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(begin
              ; test global define-record-type
              (define ($color->rgb c) (cons 'rgb c))
              (define-record-type ($point $make-point $point?)
                (fields x y)
                (protocol (lambda (n) n)))
              (define-record-type ($cpoint $make-cpoint $cpoint?)
                (parent $point)
                (fields (mutable rgb))
                (protocol (lambda (n)
                            (lambda (x y c)
                              ((n x y) ($color->rgb c))))))
              (equal? (map (lambda (x)
                             (if (#%$record? x)
                                 ($record->vector x)
                                 x))
                           (let ([x ($make-cpoint 3 4 'red)])
                             (list x ($cpoint-rgb x) ($make-point -8 -15))))
                      '(#($cpoint 3 4 (rgb . red))
                        (rgb . red)
                        #($point -8 -15))))))
       `(begin
          (set! $color->rgb (lambda (c) (#2%cons 'rgb c)))
          (letrec ([g7 (lambda (n) n)])
            (#3%$set-top-level-value! 'rcd1
              (#3%$make-record-constructor-descriptor
                ',record-type-descriptor?
                #f
                g7
                'define-record-type)))
          (set! $make-point
            (#2%r6rs:record-constructor (#2%$top-level-value 'rcd1)))
          (set! $point?
            (lambda (g153)
              (#3%record? g153 ',record-type-descriptor?)))
          (set! $point-x
            (lambda (g152)
              (if (#3%record? g152 ',record-type-descriptor?)
                  (#2%void)
                  (#3%$record-oops 'moi g152 ',record-type-descriptor?))
              (#3%$object-ref 'scheme-object g152 ,fixnum?)))
          (set! $point-y
            (lambda (g151)
              (if (#3%record? g151 ',record-type-descriptor?)
                  (#2%void)
                  (#3%$record-oops 'moi g151 ',record-type-descriptor?))
              (#3%$object-ref 'scheme-object g151 ,fixnum?)))
          (#3%$set-top-level-value! 'rcd2
            (#2%$make-record-constructor-descriptor
              ',record-type-descriptor?
              (#2%$top-level-value 'rcd1)
              (lambda (n)
                (lambda (x y c) ((n x y) ($color->rgb c))))
              'define-record-type))
          (set! $make-cpoint
            (#2%r6rs:record-constructor (#2%$top-level-value 'rcd2)))
          (set! $cpoint?
            (lambda (g150)
              (#3%record? g150 ',record-type-descriptor?)))
          (set! $cpoint-rgb
            (lambda (g149)
              (if (#3%record? g149 ',record-type-descriptor?)
                  (#2%void)
                  (#3%$record-oops 'moi g149 ',record-type-descriptor?))
              (#3%$object-ref 'scheme-object g149 ,fixnum?)))
          (set! $cpoint-rgb-set!
            (lambda (g147 g148)
              (if (#3%record? g147 ',record-type-descriptor?)
                  (#2%void)
                  (#3%$record-oops 'moi g147 ',record-type-descriptor?))
              (#3%$object-set! 'scheme-object g147 ,fixnum? g148)))
          (#2%equal?
            (#2%map (lambda (x) (if (#2%$record? x) ($record->vector x) x))
                    (let ([x ($make-cpoint 3 4 'red)])
                      (#2%list x ($cpoint-rgb x) ($make-point -8 -15))))
            '(#4($cpoint 3 4 (rgb . red)) (rgb . red) #3($point -8 -15)))))
     (equivalent-expansion? ; optimize-level 3 expansion of above
       (parameterize
         ([optimize-level 3]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(begin
              ; test global define-record-type
              (define ($color->rgb c) (cons 'rgb c))
              (define-record-type ($point $make-point $point?)
                (fields x y)
                (protocol (lambda (n) n)))
              (define-record-type ($cpoint $make-cpoint $cpoint?)
                (parent $point)
                (fields (mutable rgb))
                (protocol (lambda (n)
                            (lambda (x y c)
                              ((n x y) ($color->rgb c))))))
              (equal? (map (lambda (x)
                             (if (#%$record? x)
                                 ($record->vector x)
                                 x))
                           (let ([x ($make-cpoint 3 4 'red)])
                             (list x ($cpoint-rgb x) ($make-point -8 -15))))
                      '(#($cpoint 3 4 (rgb . red))
                        (rgb . red)
                        #($point -8 -15))))))
       `(begin
          (set! $color->rgb (lambda (c) (#3%cons 'rgb c)))
          (letrec ([g7 (lambda (n) n)])
            (#3%$set-top-level-value! 'rcd1
              (#3%$make-record-constructor-descriptor
                ',record-type-descriptor?
                #f
                g7
                'define-record-type)))
          (set! $make-point
            (#3%r6rs:record-constructor (#3%$top-level-value 'rcd1)))
          (set! $point?
            (lambda (g129)
              (#3%record? g129 ',record-type-descriptor?)))
          (set! $point-x
            (lambda (g128)
              (#3%$object-ref 'scheme-object g128 ,fixnum?)))
          (set! $point-y
            (lambda (g127)
              (#3%$object-ref 'scheme-object g127 ,fixnum?)))
          (#3%$set-top-level-value! 'rcd2
            (#3%$make-record-constructor-descriptor
              ',record-type-descriptor?
              (#3%$top-level-value 'rcd1)
              (lambda (n)
                (lambda (x y c) ((n x y) ($color->rgb c))))
              'define-record-type))
          (set! $make-cpoint
            (#3%r6rs:record-constructor (#3%$top-level-value 'rcd2)))
          (set! $cpoint?
            (lambda (g126)
              (#3%record? g126 ',record-type-descriptor?)))
          (set! $cpoint-rgb
            (lambda (g125)
              (#3%$object-ref 'scheme-object g125 ,fixnum?)))
          (set! $cpoint-rgb-set!
            (lambda (g123 g124)
              (#3%$object-set! 'scheme-object g123 ,fixnum? g124)))
          (#3%equal?
            (#3%map (lambda (x) (if (#3%$record? x) ($record->vector x) x))
                    (let ([x ($make-cpoint 3 4 'red)])
                      (#3%list x ($cpoint-rgb x) ($make-point -8 -15))))
            '(#4($cpoint 3 4 (rgb . red)) (rgb . red) #3($point -8 -15)))))
     (error? ; can't handle define-record-type parent
             (let ()
               (define-record-type fratrat)
               (define-record dormy fratrat ())))
     (error? ; can't handle define-record parent
             (let ()
               (define-record fratrat ())
               (define-record-type dormy (parent fratrat))))
     (equal? (let ()
               (define-record fratrat ())
               (define-record-type dormy
                 (parent-rtd (type-descriptor fratrat)
                   (make-record-constructor-descriptor
                     (type-descriptor fratrat)
                     #f
                     #f)))
               (let ([x (make-fratrat)] [y (make-dormy)])
                 (list (fratrat? x) (dormy? x) (fratrat? y) (dormy? y))))
             '(#t #f #t #t))
     (equivalent-expansion? ; optimize-level 2 expansion of above
       (parameterize
         ([optimize-level 2]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(let ()
              (define-record fratrat ())
              (define-record-type dormy
                (parent-rtd (type-descriptor fratrat)
                  (make-record-constructor-descriptor
                    (type-descriptor fratrat)
                    #f
                    #f)))
              (let ([x (make-fratrat)] [y (make-dormy)])
                (list (fratrat? x) (dormy? x) (fratrat? y) (dormy? y))))))
       `(begin
          (#2%$make-record-type-descriptor
            #!base-rtd
            'dormy
            ',record-type-descriptor?
            #f
            #f
            #f
            '#0()
            'define-record-type)
          (#2%list #t #f #t #t)))
     (equivalent-expansion? ; optimize-level 3 expansion of above
       (parameterize
         ([optimize-level 3]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(let ()
              (define-record fratrat ())
              (define-record-type dormy
                (parent-rtd (type-descriptor fratrat)
                  (make-record-constructor-descriptor
                    (type-descriptor fratrat)
                    #f
                    #f)))
              (let ([x (make-fratrat)] [y (make-dormy)])
                (list (fratrat? x) (dormy? x) (fratrat? y) (dormy? y))))))
       `(#3%list #t #f #t #t))
     (equal? (let ()
               (define-record fratrat (x))
               (define-record-type dormy
                 (parent-rtd (type-descriptor fratrat)
                   (make-record-constructor-descriptor
                     (type-descriptor fratrat)
                     #f
                     #f))
                 (fields (immutable y)))
               (let ([x (make-fratrat 17)] [y (make-dormy 23 'creepy)])
                 (list (fratrat? x)
                       (dormy? x)
                       (fratrat? y)
                       (dormy? y)
                       (fratrat-x x)
                       (fratrat-x y)
                       (dormy-y y))))
             '(#t #f #t #t 17 23 creepy))
     (equivalent-expansion? ; optimize-level 2 expansion of above
       (parameterize
         ([optimize-level 2]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(let ()
              (define-record fratrat (x))
              (define-record-type dormy
                (parent-rtd (type-descriptor fratrat)
                  (make-record-constructor-descriptor
                    (type-descriptor fratrat)
                    #f
                    #f))
                (fields (immutable y)))
              (let ([x (make-fratrat 17)] [y (make-dormy 23 'creepy)])
                (list (fratrat? x)
                      (dormy? x)
                      (fratrat? y)
                      (dormy? y)
                      (fratrat-x x)
                      (fratrat-x y)
                      (dormy-y y))))))
       `(let ([rtd (#2%$make-record-type-descriptor
                     #!base-rtd
                     'dormy
                     ',record-type-descriptor?
                     #f
                     #f
                     #f
                     '#1((immutable y))
                     'define-record-type)])
          (let ([x (#3%$record ',record-type-descriptor? 17)]
                [y (#3%$record rtd 23 'creepy)])
            (#2%list #t
                     #f
                     #t
                     #t
                     (#3%$object-ref 'scheme-object x ,fixnum?)
                     (#3%$object-ref 'scheme-object y ,fixnum?)
                     'creepy))))
     (equivalent-expansion? ; optimize-level 3 expansion of above
       (parameterize
         ([optimize-level 3]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(let ()
              (define-record fratrat (x))
              (define-record-type dormy
                (parent-rtd (type-descriptor fratrat)
                  (make-record-constructor-descriptor
                    (type-descriptor fratrat)
                    #f
                    #f))
                (fields (immutable y)))
              (let ([x (make-fratrat 17)] [y (make-dormy 23 'creepy)])
                (list (fratrat? x)
                      (dormy? x)
                      (fratrat? y)
                      (dormy? y)
                      (fratrat-x x)
                      (fratrat-x y)
                      (dormy-y y))))))
       `(let ([rtd (#3%$make-record-type-descriptor
                     #!base-rtd
                     'dormy
                     ',record-type-descriptor?
                     #f
                     #f
                     #f
                     '#1((immutable y))
                     'define-record-type)])
          (let ([x (#3%$record ',record-type-descriptor? 17)]
                [y (#3%$record rtd 23 'creepy)])
            (#3%list #t
                     #f
                     #t
                     #t
                     (#3%$object-ref 'scheme-object x ,fixnum?)
                     (#3%$object-ref 'scheme-object y ,fixnum?)
                     'creepy))))
     (equal? (let ()
               ; add a protocol
               (define-record fratrat (x))
               (define-record-type dormy
                 (parent-rtd (type-descriptor fratrat)
                   (make-record-constructor-descriptor
                     (type-descriptor fratrat)
                     #f
                     #f))
                 (fields (immutable y))
                 (protocol (lambda (p) (lambda (q) ((p (car q)) q)))))
               (let ([x (make-fratrat 17)] [y (make-dormy '(23 creepy))])
                 (list (fratrat? x)
                       (dormy? x)
                       (fratrat? y)
                       (dormy? y)
                       (fratrat-x x)
                       (fratrat-x y)
                       (dormy-y y))))
             '(#t #f #t #t 17 23 (23 creepy)))
     (equivalent-expansion? ; optimize-level 2 expansion of above
       (parameterize
         ([optimize-level 2]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(let ()
              (define-record fratrat (x))
              (define-record-type dormy
                (parent-rtd (type-descriptor fratrat)
                  (make-record-constructor-descriptor
                    (type-descriptor fratrat)
                    #f
                    #f))
                (fields (immutable y))
                (protocol (lambda (p) (lambda (q) ((p (car q)) q)))))
              (let ([x (make-fratrat 17)] [y (make-dormy '(23 creepy))])
                (list (fratrat? x)
                      (dormy? x)
                      (fratrat? y)
                      (dormy? y)
                      (fratrat-x x)
                      (fratrat-x y)
                      (dormy-y y))))))
       `(let ([rtd (#2%$make-record-type-descriptor
                     #!base-rtd
                     'dormy
                     ',record-type-descriptor?
                     #f
                     #f
                     #f
                     '#1((immutable y))
                     'define-record-type)])
          (let ([x (#3%$record ',record-type-descriptor? 17)]
                [y (#3%$record rtd 23 '(23 creepy))])
            (#2%list #t
                     #f
                     #t
                     #t
                     (#3%$object-ref 'scheme-object x ,fixnum?)
                     (#3%$object-ref 'scheme-object y ,fixnum?)
                     '(23 creepy)))))
     (equivalent-expansion? ; optimize-level 3 expansion of above
       (parameterize
         ([optimize-level 3]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(let ()
              (define-record fratrat (x))
              (define-record-type dormy
                (parent-rtd (type-descriptor fratrat)
                  (make-record-constructor-descriptor
                    (type-descriptor fratrat)
                    #f
                    #f))
                (fields (immutable y))
                (protocol (lambda (p) (lambda (q) ((p (car q)) q)))))
              (let ([x (make-fratrat 17)] [y (make-dormy '(23 creepy))])
                (list (fratrat? x)
                      (dormy? x)
                      (fratrat? y)
                      (dormy? y)
                      (fratrat-x x)
                      (fratrat-x y)
                      (dormy-y y))))))
       `(let ([rtd (#3%$make-record-type-descriptor
                     #!base-rtd
                     'dormy
                     ',record-type-descriptor?
                     #f
                     #f
                     #f
                     '#1((immutable y))
                     'define-record-type)])
          (let ([x (#3%$record ',record-type-descriptor? 17)]
                [y (#3%$record rtd 23 '(23 creepy))])
            (#3%list #t
                     #f
                     #t
                     #t
                     (#3%$object-ref 'scheme-object x ,fixnum?)
                     (#3%$object-ref 'scheme-object y ,fixnum?)
                     '(23 creepy)))))
     (error? ; m-r-c-d can't handle non-scheme-object fields
       (let ()
         (define-record fratrat ((immutable integer-32 x)))
         (define-record-type dormy
           (parent-rtd (type-descriptor fratrat)
             (make-record-constructor-descriptor
               (type-descriptor fratrat)
               #f
               #f))
           (fields (immutable y)))
         (let ([x (make-fratrat 17)] [y (make-dormy 23 'creepy)])
           (list (fratrat? x)
                 (dormy? x)
                 (fratrat? y)
                 (dormy? y)
                 (fratrat-x x)
                 (fratrat-x y)
                 (dormy-y y)))))
     (equal? (let ()
               (define-record fratrat ((immutable x)))
               (define-record-type dormy
                 (nongenerative)
                 (parent-rtd (type-descriptor fratrat)
                   (make-record-constructor-descriptor
                     (type-descriptor fratrat)
                     #f
                     #f))
                 (fields (immutable y)))
               (let ([x (make-fratrat 17)] [y (make-dormy 23 'creepy)])
                 (list (fratrat? x)
                       (dormy? x)
                       (fratrat? y)
                       (dormy? y)
                       (fratrat-x x)
                       (fratrat-x y)
                       (dormy-y y))))
             '(#t #f #t #t 17 23 creepy))
     (equivalent-expansion? ; optimize-level 2 expansion of above
       (parameterize
         ([optimize-level 2]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(let ()
              (define-record fratrat ((immutable x)))
              (define-record-type dormy
                (nongenerative)
                (parent-rtd (type-descriptor fratrat)
                  (make-record-constructor-descriptor
                    (type-descriptor fratrat)
                    #f
                    #f))
                (fields (immutable y)))
              (let ([x (make-fratrat 17)] [y (make-dormy 23 'creepy)])
                (list (fratrat? x)
                      (dormy? x)
                      (fratrat? y)
                      (dormy? y)
                      (fratrat-x x)
                      (fratrat-x y)
                      (dormy-y y))))))
       `(#2%list #t #f #t #t 17 23 'creepy))
     (equivalent-expansion? ; optimize-level 3 expansion of above
       (parameterize
         ([optimize-level 3]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(let ()
              (define-record fratrat ((immutable x)))
              (define-record-type dormy
                (nongenerative)
                (parent-rtd (type-descriptor fratrat)
                  (make-record-constructor-descriptor
                    (type-descriptor fratrat)
                    #f
                    #f))
                (fields (immutable y)))
              (let ([x (make-fratrat 17)] [y (make-dormy 23 'creepy)])
                (list (fratrat? x)
                      (dormy? x)
                      (fratrat? y)
                      (dormy? y)
                      (fratrat-x x)
                      (fratrat-x y)
                      (dormy-y y))))))
       `(#3%list #t #f #t #t 17 23 'creepy))
     (equal? (let ()
               (define-record fratrat ((immutable x)))
               (define dormy
                 (make-record-type
                   (type-descriptor fratrat)
                   '#{dormy a3utgl1aoz8jzrg1-0}
                   '((immutable y))))
               (define make-dormy
                 (record-constructor dormy))
               (define dormy? (record-predicate dormy))
               (define dormy-y (record-accessor dormy 0))
               (let ([x (make-fratrat 17)] [y (make-dormy 23 'creepy)])
                 (list (fratrat? x)
                       (dormy? x)
                       (fratrat? y)
                       (dormy? y)
                       (fratrat-x x)
                       (fratrat-x y)
                       (dormy-y y))))
             '(#t #f #t #t 17 23 creepy))
     (equivalent-expansion?
       ; optimize-level 2 expansion of above (note dormy gensym must be different)
       (parameterize
         ([optimize-level 2]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(let ()
              (define-record fratrat ((immutable x)))
              (define dormy
                (make-record-type
                  (type-descriptor fratrat)
                  '#{dormy a3utgl1aoz8jzrg1-1}
                  '((immutable y))))
              (define make-dormy (record-constructor dormy))
              (define dormy? (record-predicate dormy))
              (define dormy-y (record-accessor dormy 0))
              (let ([x (make-fratrat 17)] [y (make-dormy 23 'creepy)])
                (list (fratrat? x)
                      (dormy? x)
                      (fratrat? y)
                      (dormy? y)
                      (fratrat-x x)
                      (fratrat-x y)
                      (dormy-y y))))))
       `(#2%list #t #f #t #t 17 23 'creepy))
     (equivalent-expansion?
       ; optimize-level 2 expansion of above (note dormy gensym must be different)
       (parameterize
         ([optimize-level 3]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(let ()
              (define-record fratrat ((immutable x)))
              (define dormy
                (make-record-type
                  (type-descriptor fratrat)
                  '#{dormy a3utgl1aoz8jzrg1-2}
                  '((immutable y))))
              (define make-dormy (record-constructor dormy))
              (define dormy? (record-predicate dormy))
              (define dormy-y (record-accessor dormy 0))
              (let ([x (make-fratrat 17)] [y (make-dormy 23 'creepy)])
                (list (fratrat? x)
                      (dormy? x)
                      (fratrat? y)
                      (dormy? y)
                      (fratrat-x x)
                      (fratrat-x y)
                      (dormy-y y))))))
       `(#3%list #t #f #t #t 17 23 'creepy))
     (error? ; can't have both parent and parent-rtd
       (let ()
         (define-record fratrat ((immutable x)))
         (define-record-type fratrat2
           (fields (immutable x)))
         (define-record-type dormy
           (parent fratrat2)
           (parent-rtd (type-descriptor fratrat)
             (make-record-constructor-descriptor
               (type-descriptor fratrat)
               #f
               #f))
           (fields (immutable y)))
         (let ([x (make-fratrat 17)] [y (make-dormy 23 'creepy)])
           (list (fratrat? x)
                 (dormy? x)
                 (fratrat? y)
                 (dormy? y)
                 (fratrat-x x)
                 (fratrat-x y)
                 (dormy-y y)))))
     (error? ; can't have both parent and parent-rtd
       (let ()
         (define-record fratrat ((immutable x)))
         (define-record-type fratrat2
           (fields (immutable x)))
         (define-record-type dormy
           (parent-rtd (type-descriptor fratrat)
             (make-record-constructor-descriptor
               (type-descriptor fratrat)
               #f
               #f))
           (parent fratrat2)
           (fields (immutable y)))
         (let ([x (make-fratrat 17)] [y (make-dormy 23 'creepy)])
           (list (fratrat? x)
                 (dormy? x)
                 (fratrat? y)
                 (dormy? y)
                 (fratrat-x x)
                 (fratrat-x y)
                 (dormy-y y)))))
     (error? ; can't have two parent-rtd clauses
       (let ()
         (define-record fratrat ((immutable x)))
         (define-record-type dormy
           (parent-rtd (type-descriptor fratrat)
             (make-record-constructor-descriptor
               (type-descriptor fratrat)
               #f
               #f))
           (parent-rtd (type-descriptor fratrat)
             (make-record-constructor-descriptor
               (type-descriptor fratrat)
               #f
               #f))
           (fields (immutable y)))
         (let ([x (make-fratrat 17)] [y (make-dormy 23 'creepy)])
           (list (fratrat? x)
                 (dormy? x)
                 (fratrat? y)
                 (dormy? y)
                 (fratrat-x x)
                 (fratrat-x y)
                 (dormy-y y)))))
     (error? ; can't have two parent clauses
       (let ()
         (define-record-type fratrat2
           (fields (immutable x)))
         (define-record-type dormy
           (parent fratrat2)
           (parent fratrat2)
           (fields (immutable y)))
         (let ([x (make-fratrat 17)] [y (make-dormy 23 'creepy)])
           (list (fratrat? x)
                 (dormy? x)
                 (fratrat? y)
                 (dormy? y)
                 (fratrat-x x)
                 (fratrat-x y)
                 (dormy-y y)))))
     (error? ; can't have two fields clauses
       (let ()
         (define-record-type fratrat2
           (fields (immutable x)))
         (define-record-type dormy
           (parent fratrat2)
           (fields z)
           (fields (immutable y)))
         (let ([x (make-fratrat 17)] [y (make-dormy 23 'creepy)])
           (list (fratrat? x)
                 (dormy? x)
                 (fratrat? y)
                 (dormy? y)
                 (fratrat-x x)
                 (fratrat-x y)
                 (dormy-y y)))))
     (error? ; can't have two nongenerative clauses
       (let ()
         (define-record-type fratrat2
           (fields (immutable x)))
         (define-record-type dormy
           (parent fratrat2)
           (nongenerative)
           (nongenerative spam-for-dinner)
           (fields (immutable y)))
         (let ([x (make-fratrat 17)] [y (make-dormy 23 'creepy)])
           (list (fratrat? x)
                 (dormy? x)
                 (fratrat? y)
                 (dormy? y)
                 (fratrat-x x)
                 (fratrat-x y)
                 (dormy-y y)))))
     (error? ; can't have two sealed? clauses
       (let ()
         (define-record-type fratrat2
           (fields (immutable x)))
         (define-record-type dormy
           (parent fratrat2)
           (sealed #t)
           (sealed #t)
           (fields (immutable y)))
         (let ([x (make-fratrat 17)] [y (make-dormy 23 'creepy)])
           (list (fratrat? x)
                 (dormy? x)
                 (fratrat? y)
                 (dormy? y)
                 (fratrat-x x)
                 (fratrat-x y)
                 (dormy-y y)))))
     (error? ; can't have two opaque? clauses
       (let ()
         (define-record-type fratrat2
           (fields (immutable x)))
         (define-record-type dormy
           (parent fratrat2)
           (opaque #t)
           (opaque #t)
           (fields (immutable y)))
         (let ([x (make-fratrat 17)] [y (make-dormy 23 'creepy)])
           (list (fratrat? x)
                 (dormy? x)
                 (fratrat? y)
                 (dormy? y)
                 (fratrat-x x)
                 (fratrat-x y)
                 (dormy-y y)))))
     (error? ; can't have two protocol clauses
       (let ()
         (define-record-type fratrat2
           (fields (immutable x)))
         (define-record-type dormy
           (parent fratrat2)
           (protocol values)
           (protocol (lambda (x) x))
           (fields (immutable y)))
         (let ([x (make-fratrat 17)] [y (make-dormy 23 'creepy)])
           (list (fratrat? x)
                 (dormy? x)
                 (fratrat? y)
                 (dormy? y)
                 (fratrat-x x)
                 (fratrat-x y)
                 (dormy-y y)))))
     (error? ; protocol expression doesn't evaluate to a procedure
       (let ()
         (define-record-type fratrat2
           (fields (immutable x)))
         (define-record-type dormy
           (parent fratrat2)
           (protocol 'whoops!)
           (fields (immutable y)))
         (let ([x (make-fratrat 17)] [y (make-dormy 23 'creepy)])
           (list (fratrat? x)
                 (dormy? x)
                 (fratrat? y)
                 (dormy? y)
                 (fratrat-x x)
                 (fratrat-x y)
                 (dormy-y y)))))
     (error? ; not an rcd
       (let ()
         (define-record fratrat ((immutable x)))
         (define-record-type dormy
           (parent-rtd (type-descriptor fratrat) 'rats)
           (fields (immutable y)))
         (let ([x (make-fratrat 17)] [y (make-dormy 23 'creepy)])
           (list (fratrat? x)
                 (dormy? x)
                 (fratrat? y)
                 (dormy? y)
                 (fratrat-x x)
                 (fratrat-x y)
                 (dormy-y y)))))
     (error? ; not an rtd
       (let ()
         (define-record fratrat ((immutable x)))
         (define-record-type dormy
           (parent-rtd 'rats
             (make-record-constructor-descriptor
               (type-descriptor fratrat)
               #f
               #f))
           (fields (immutable y)))
         (let ([x (make-fratrat 17)] [y (make-dormy 23 'creepy)])
           (list (fratrat? x)
                 (dormy? x)
                 (fratrat? y)
                 (dormy? y)
                 (fratrat-x x)
                 (fratrat-x y)
                 (dormy-y y)))))
     (equal? (let ()
               (define-record fratrat ((immutable x)))
               (define-record-type dormy
                 (parent-rtd #f #f)
                 (fields (immutable y)))
               (let ([x (make-fratrat 17)] [y (make-dormy 'creepy)])
                 (list (fratrat? x)
                       (dormy? x)
                       (fratrat? y)
                       (dormy? y)
                       (fratrat-x x)
                       (dormy-y y))))
             '(#t #f #f #t 17 creepy))
     (equal? (let ()
               (define-record fratrat ((immutable x)))
               (define-record-type dormy
                 (parent-rtd (record-type-descriptor fratrat) #f)
                 (fields (immutable y)))
               (let ([x (make-fratrat 17)] [y (make-dormy 23 'creepy)])
                 (list (fratrat? x)
                       (dormy? x)
                       (fratrat? y)
                       (dormy? y)
                       (fratrat-x x)
                       (dormy-y y))))
             '(#t #f #t #t 17 creepy))
     (error? ; "can't specify rcd w/o rtd"
       (let ()
         (define-record fratrat ((immutable x)))
         (define-record-type dormy
           (parent-rtd #f
             (make-record-constructor-descriptor
               (type-descriptor fratrat)
               #f
               #f))
           (fields (immutable y)))
         (let ([x (make-fratrat 17)] [y (make-dormy 'creepy)])
           (list (fratrat? x)
                 (dormy? x)
                 (fratrat? y)
                 (dormy? y)
                 (fratrat-x x)
                 (dormy-y y)))))
     (error? ; invalid syntax
             (define-record-type (fields x)))
     (error? ; invalid clause
             (define-record-type foo (x)))
     (error? ; invalid clause
             (define-record-type foo (fields . x)))
     (error? ; invalid field
       (define-record-type foo
         (fields (mutable flyboy flyboy))))
     (error? ; invalid field
       (define-record-type foo
         (fields (immutable flyboy flyboy flyboy!))))
     (error? ; invalid field
       (define-record-type foo (fields (ugly flyboy))))
     (error? ; invalid clause
       (define-record-type foo (nongenerative 'spam)))
     (error? ; cannot handle record name defined by define-record
             (let ()
               (define-record frob ())
               (record-constructor-descriptor frob)))
     (error? ; invalid protocol value
             (define-record-type frob (protocol 'oops)))
     (let ()
       (define-record-type foo
         (nongenerative #{rats c9zu8koxo8gppgp-a}))
       (define-record-type bar
         (nongenerative #{rats c9zu8koxo8gppgp-a}))
       (and (eqv? (type-descriptor foo) (type-descriptor bar))
            (foo? (make-bar))
            (bar? (make-foo))))

     ; test for appropriate choice of pretty names for uids
     ((lambda (x y) (and (gensym? x) (equal? (symbol->string x) y)))
      (let ()
        (define-record-type foo)
        (record-type-uid (record-type-descriptor foo)))
      "foo")

     ; test for appropriate choice of pretty names for uids
     ((lambda (x y) (and (gensym? x) (equal? (symbol->string x) y)))
      (let ()
        (define-record-type (foo xfoo yfoo))
        (record-type-uid (record-type-descriptor foo)))
      "foo")

     ; test for appropriate choice of pretty names for uids
     ((lambda (x y) (and (gensym? x) (equal? (symbol->string x) y)))
      (let ()
        (define-record-type foo (nongenerative))
        (record-type-uid (record-type-descriptor foo)))
      "foo")

     ; test for appropriate choice of pretty names for uids
     ((lambda (x y) (and (gensym? x) (equal? (symbol->string x) y)))
      (let ()
        (define-record-type (foo xfoo yfoo) (nongenerative))
        (record-type-uid (record-type-descriptor foo)))
      "foo")

     (eqv? (let ()
             (define-record-type bar)
             (record-type-sealed? (record-type-descriptor bar)))
           #f)
     (eqv? (let ()
             (define-record-type bar (sealed #t))
             (record-type-sealed? (record-type-descriptor bar)))
           #t)
     (equivalent-expansion? ; optimize-level 2 expansion of above
       (parameterize
         ([optimize-level 2]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(let ()
              (define-record-type bar (sealed #t))
              (record-type-sealed? (record-type-descriptor bar)))))
       '(begin
          (#2%$make-record-type-descriptor
            #!base-rtd
            'bar
            #f
            #f
            #t
            #f
            '#()
            'define-record-type)
          #t))
     (equivalent-expansion? ; optimize-level 3 expansion of above
       (parameterize
         ([optimize-level 3]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(let ()
              (define-record-type bar (sealed #t))
              (record-type-sealed? (record-type-descriptor bar)))))
       '#t)
     (eqv? (let ()
             (define-record-type bar (sealed #t))
             (record? (make-bar)))
           #t)
     (eqv? (let ()
             (define-record-type bar (sealed #t))
             (r6rs:record? (make-bar)))
           #t)
     (eqv? (let ()
             (define-record-type bar (sealed #t))
             (record? (make-bar) (record-type-descriptor bar)))
           #t)
     (eqv? (let ()
             (define-record-type prnt)
             (define-record-type chld (parent prnt))
             (record? (make-chld) (record-type-descriptor prnt)))
           #t)
     (error? ; parent sealed
       (let ()
         (define-record-type prnt (sealed #t))
         (define-record-type chld (parent prnt))
         (record? (make-chld) (record-type-descriptor prnt))))
     (eqv? (let ()
             (define-record-type prnt)
             (define-record-type chld (parent prnt))
             (define-record-type xftr)
             (record? (make-xftr) (record-type-descriptor prnt)))
           #f)
     (equivalent-expansion?
       (parameterize
         ([optimize-level 2]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(lambda (x)
              (define-record-type bar)
              (record? x (record-type-descriptor bar)))))
       '(lambda (x)
          (#3%record? x
            (#2%$make-record-type-descriptor
              #!base-rtd
              'bar
              #f
              #f
              #f
              #f
              '#()
              'define-record-type))))

     (equivalent-expansion?
       (parameterize
         ([optimize-level 2]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(lambda (x)
              (define-record-type bar (sealed #t))
              (record? x (record-type-descriptor bar)))))
       '(lambda (x)
          (#3%$sealed-record? x
            (#2%$make-record-type-descriptor
              #!base-rtd
              'bar
              #f
              #f
              #t
              #f
              '#()
              'define-record-type))))

     (equal? ($record->vector
               (let ()
                 (define-record-type A
                   (nongenerative)
                   (fields))
                 (define-record-type B
                   (nongenerative)
                   (parent A)
                   (fields z)
                   (protocol (lambda (make) (lambda (z) ((make) z)))))
                 (define-record-type C
                   (nongenerative)
                   (parent B)
                   (fields)
                   (protocol (lambda (make) (lambda (z) ((make z))))))
                 (make-C 4)))
             '#(C 4))
     (equivalent-expansion?
       (parameterize
         ([optimize-level 2]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(let ()
              (define-record-type A
                (nongenerative)
                (fields))
              (define-record-type B
                (nongenerative)
                (parent A)
                (fields z)
                (protocol (lambda (make) (lambda (z) ((make) z)))))
              (define-record-type C
                (nongenerative)
                (parent B)
                (fields)
                (protocol (lambda (make) (lambda (z) ((make z))))))
              (make-C 4))))
       `',record?)

     (equal? ($record->vector
               (let ()
                 (define-record-type A
                   (nongenerative)
                   (fields))
                 (define-record-type B
                   (nongenerative)
                   (parent A)
                   (fields z)
                   (protocol (lambda (make) (lambda () ((make) 0)))))
                 (define-record-type C
                   (nongenerative)
                   (parent B)
                   (fields)
                   (protocol (lambda (make) (lambda () ((make))))))
                 (make-C)))
             '#(C 0))
     (equivalent-expansion?
       (parameterize
         ([optimize-level 2]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(let ()
              (define-record-type A
                (nongenerative)
                (fields))
              (define-record-type B
                (nongenerative)
                (parent A)
                (fields z)
                (protocol (lambda (make) (lambda () ((make) 0)))))
              (define-record-type C
                (nongenerative)
                (parent B)
                (fields)
                (protocol (lambda (make) (lambda () ((make))))))
              (make-C))))
       `',record?)

     (equal? ($record->vector
               (let ()
                 (define-record-type A
                   (nongenerative)
                   (fields))
                 (define-record-type B
                   (nongenerative)
                   (parent A)
                   (fields z)
                   (protocol (lambda (make) (lambda (z) ((make) z)))))
                 (define-record-type C
                   (nongenerative)
                   (parent B)
                   (fields w)
                   (protocol (lambda (make) (lambda (z) ((make z) 0)))))
                 (make-C 4)))
             '#(C 4 0))
     (equivalent-expansion?
       (parameterize
         ([optimize-level 2]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(let ()
              (define-record-type A
                (nongenerative)
                (fields))
              (define-record-type B
                (nongenerative)
                (parent A)
                (fields z)
                (protocol (lambda (make) (lambda (z) ((make) z)))))
              (define-record-type C
                (nongenerative)
                (parent B)
                (fields w)
                (protocol (lambda (make) (lambda (z) ((make z) 0)))))
              (make-C 4))))
       `',record?)

     (equal? ($record->vector
               (let ()
                 (define-record-type A
                   (nongenerative)
                   (fields))
                 (define-record-type B
                   (nongenerative)
                   (parent A)
                   (fields z)
                   (protocol (lambda (make) (lambda (z) ((make) z)))))
                 (define-record-type C
                   (nongenerative)
                   (parent B)
                   (fields w q1 q2 q3)
                   (protocol (lambda (make)
                               (lambda (z)
                                 ((make z) 0 1 2 3)))))
                 (make-C 4)))
             '#(C 4 0 1 2 3))
     (equivalent-expansion?
       (parameterize
         ([optimize-level 2]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(let ()
              (define-record-type A
                (nongenerative)
                (fields))
              (define-record-type B
                (nongenerative)
                (parent A)
                (fields z)
                (protocol (lambda (make) (lambda (z) ((make) z)))))
              (define-record-type C
                (nongenerative)
                (parent B)
                (fields w q1 q2 q3)
                (protocol (lambda (make) (lambda (z) ((make z) 0 1 2 3)))))
              (make-C 4))))
       `',record?)

     ; try hierarchy of five levels
     (equal? ($record->vector
               (let ()
                 (define-record-type A
                   (nongenerative)
                   (fields))
                 (define-record-type B
                   (nongenerative)
                   (parent A)
                   (fields z)
                   (protocol (lambda (make) (lambda (z) ((make) z)))))
                 (define-record-type C
                   (nongenerative)
                   (parent B)
                   (fields w q1 q2 q3)
                   (protocol (lambda (make)
                               (lambda (z)
                                 ((make z) 0 1 2 3)))))
                 (define-record-type D
                   (nongenerative)
                   (parent C)
                   (fields w)
                   (protocol (lambda (make)
                               (lambda (z w/2)
                                 ((make z) (* w/2 2))))))
                 (define-record-type E
                   (nongenerative)
                   (parent D)
                   (fields w)
                   (protocol (lambda (make)
                               (lambda (z a b)
                                 ((make z (/ a 5)) (+ a b))))))
                 (make-E 3 7 11)))
             '#(E 3 0 1 2 3 14/5 18))
     (equivalent-expansion?
       (parameterize
         ([optimize-level 2]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(let ()
              (define-record-type A
                (nongenerative)
                (fields))
              (define-record-type B
                (nongenerative)
                (parent A)
                (fields z)
                (protocol (lambda (make) (lambda (z) ((make) z)))))
              (define-record-type C
                (nongenerative)
                (parent B)
                (fields w q1 q2 q3)
                (protocol (lambda (make) (lambda (z) ((make z) 0 1 2 3)))))
              (define-record-type D
                (nongenerative)
                (parent C)
                (fields w)
                (protocol (lambda (make)
                            (lambda (z w/2)
                              ((make z) (* w/2 2))))))
              (define-record-type E
                (nongenerative)
                (parent D)
                (fields w)
                (protocol (lambda (make)
                            (lambda (z a b)
                              ((make z (/ a 5)) (+ a b))))))
              (make-E 3 7 11))))
       `',record?)

     (begin
       (module ($drt-foo1)
         (define-record-type $drt-foo1
           (protocol (lambda (new) (lambda () (new))))))
       (define-record-type $drt-bar1
         (parent $drt-foo1)
         (protocol (lambda (make-new) (lambda () ((make-new))))))
       ($drt-bar1? (make-$drt-bar1)))
     ($drt-bar1? (make-$drt-bar1))

     (begin
       (define $drt-false #f)
       (module ($drt-foo2)
         (define-record-type $drt-foo2
           (parent-rtd $drt-false $drt-false)
           (protocol (lambda (new) (lambda () (new))))))
       (define-record-type $drt-bar2
         (parent $drt-foo2)
         (protocol (lambda (make-new) (lambda () ((make-new))))))
       ($drt-bar2? (make-$drt-bar2)))
     ($drt-bar2? (make-$drt-bar2))

     ; make sure record accessor isn't folded when applied to
     ; the wrong type of constant argument
     (equivalent-expansion?
       (parameterize
         ([optimize-level 2]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(lambda (b)
              (let ([x 'x])
                (define-record-type frob
                  (nongenerative)
                  (fields x))
                (if b (frob-x x) 72)))))
       `(lambda (b)
          (if b
              (begin
                (#3%$record-oops 'frob-x 'x ',record-type-descriptor?)
                (#3%$object-ref 'scheme-object 'x ,fixnum?))
              72)))
     (equivalent-expansion?
       (parameterize
         ([optimize-level 3]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(lambda (b)
              (let ([x 'x])
                (define-record-type frob
                  (nongenerative)
                  (fields x))
                (if b (frob-x x) 72)))))
       `(lambda (b)
          (if b
              (#3%$object-ref 'scheme-object 'x ,fixnum?)
              72)))
     ; ensure we're checking to make sure field names, accessors, and
     ; mutators are identifiers
     (error? ; invalid field spec
             (define-record-type foo (fields 876)))
     (error? ; invalid field spec
             (define-record-type foo (fields (mutable (x)))))
     (error? ; invalid field spec
       (define-record-type foo (fields (immutable "spam"))))
     (error? ; invalid field spec
       (define-record-type foo
         (fields (immutable (x) foo-x))))
     (error? ; invalid accessor name
       (define-record-type foo
         (fields (immutable x (foo-x)))))
     (error? ; invalid field spec
       (define-record-type foo
         (fields (mutable (x) foo-x foo-x!))))
     (error? ; invalid accessor name
       (define-record-type foo
         (fields (mutable x (foo-x) foo-x!))))
     (error? ; invalid accessor name
       (define-record-type foo
         (fields (mutable x foo-x (foo-x!))))))

(mat define-record-type-extensions
     (error? ; nongenerative clause missing
       (parameterize ([require-nongenerative-clause #t])
         (eval '(let () (define-record-type foo) make-foo))))
     (procedure?
       (parameterize ([require-nongenerative-clause #t])
         (eval '(let ()
                  (define-record-type foo
                    (nongenerative #f))
                  make-foo))))
     (procedure?
       (parameterize ([require-nongenerative-clause #t])
         (eval '(let () (define-record-type foo (nongenerative)) make-foo))))
     (procedure?
       (parameterize ([require-nongenerative-clause #t])
         (eval '(let ()
                  (define-record-type foo
                    (nongenerative #{foo e7akngbfn4x0395fvq3uor-0}))
                  make-foo))))
     ((lambda (ls) (not (apply eq? ls)))
      (let ()
        (define f
          (lambda ()
            (define-record-type foo (nongenerative #f))
            (record-type-descriptor foo)))
        (list (f) (f))))
     ((lambda (ls) (apply eq? ls))
      (let ()
        (define f
          (lambda ()
            (define-record-type foo (nongenerative))
            (record-type-descriptor foo)))
        (list (f) (f)))))

(mat cp0-record-ref-optimizations
     (eqv? (let ()
             (define-record-type foo (fields x))
             (let ([x 17])
               (let ([q (make-foo x)])
                 (set! x 43)
                 (foo-x q))))
           17)
     (eqv? (let ()
             (define-record-type foo (fields x))
             (let ([x 17])
               (let ([q (make-foo x)])
                 #;
                 (set! x 43)
                 (foo-x q))))
           17)
     (equivalent-expansion?
       (parameterize
         ([optimize-level 3]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(let ()
              (define-record-type foo (fields x))
              (let ([x 17])
                (let ([q (make-foo x)])
                  #;
                  (set! x 43)
                  (foo-x q))))))
       17)
     (equivalent-expansion?
       (parameterize
         ([optimize-level 3]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(let ()
              (define-record-type foo (fields x))
              (let ([x 17])
                (let ([q (make-foo x)])
                  (set! x 43)
                  (foo-x q))))))
       `(let ([rtd (#3%$make-record-type-descriptor
                     #!base-rtd
                     'foo
                     #f
                     #f
                     #f
                     #f
                     '#((immutable x))
                     'define-record-type)])
          (let ([x 17])
            (let ([q (#3%$record rtd x)])
              (set! x 43)
              (#3%$object-ref 'scheme-object q ,fixnum?)))))
     (equivalent-expansion?
       (parameterize
         ([optimize-level 2]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(lambda (a)
              (define-record-type foo (fields x y))
              (let ([q (make-foo a 3)])
                (list (foo-x q) (foo-y q))))))
       '(lambda (a)
          (#2%$make-record-type-descriptor
            #!base-rtd
            'foo
            #f
            #f
            #f
            #f
            '#((immutable x) (immutable y))
            'define-record-type)
          (#2%list a 3)))
     (equivalent-expansion?
       (parameterize
         ([optimize-level 3]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(lambda (a)
              (define-record-type foo (fields x y))
              (let ([q (make-foo a 3)])
                (list (foo-x q) (foo-y q))))))
       '(lambda (a) (#3%list a 3)))
     (equivalent-expansion?
       (parameterize
         ([optimize-level 2]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(lambda (a)
              (define-record-type foo
                (nongenerative)
                (fields x y))
              (let ([q (make-foo a 3)])
                (list (foo-x q) (foo-y q))))))
       '(lambda (a) (#2%list a 3)))
     (equivalent-expansion?
       (parameterize
         ([optimize-level 3]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(lambda (a)
              (define-record-type foo
                (nongenerative)
                (fields x y))
              (let ([q (make-foo a 3)])
                (list (foo-x q) (foo-y q))))))
       '(lambda (a) (#3%list a 3)))
     (equivalent-expansion?
       (parameterize
         ([optimize-level 2]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(lambda (a)
              (define-record-type foo (fields x y))
              (let ([q (make-foo (cons a a) (lambda () a))])
                (list (foo-x q) ((foo-y q)))))))
       '(lambda (a)
          (#2%$make-record-type-descriptor
            #!base-rtd
            'foo
            #f
            #f
            #f
            #f
            '#((immutable x) (immutable y))
            'define-record-type)
          (#2%list (#2%cons a a) a)))
     (equivalent-expansion?
       (parameterize
         ([optimize-level 3]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(lambda (a)
              (define-record-type foo (fields x y))
              (let ([q (make-foo (cons a a) (lambda () a))])
                (list (foo-x q) ((foo-y q)))))))
       '(lambda (a) (#3%list (#3%cons a a) a)))
     (equivalent-expansion?
       (parameterize
         ([optimize-level 2]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(lambda (a)
              (define-record-type foo
                (nongenerative)
                (fields x y))
              (let ([q (make-foo (cons a a) (lambda () a))])
                (list (foo-x q) ((foo-y q)))))))
       '(lambda (a) (#2%list (#2%cons a a) a)))
     (equivalent-expansion?
       (parameterize
         ([optimize-level 3]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(lambda (a)
              (define-record-type foo
                (nongenerative)
                (fields x y))
              (let ([q (make-foo (cons a a) (lambda () a))])
                (list (foo-x q) ((foo-y q)))))))
       '(lambda (a) (#3%list (#3%cons a a) a)))
     ; oscar's example
     (equivalent-expansion?
       (parameterize
         ([optimize-level 2]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(let ()
              (import scheme)
              (define-record foo ([immutable ptr a] [immutable ptr b]))
              (define (inc r)
                (make-foo (foo-a r) (+ (foo-b r) 1)))
              (lambda (x)
                (let* ([r (make-foo 37 x)] [r (inc r)] [r (inc r)])
                  r)))))
       `(lambda (x)
          (#3%$record ',record-type-descriptor? 37 (#2%+ 1 (#2%+ 1 x)))))
     (equivalent-expansion?
       (parameterize
         ([optimize-level 3]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(let ()
              (import scheme)
              (define-record foo ([immutable ptr a] [immutable ptr b]))
              (define (inc r)
                (make-foo (foo-a r) (+ (foo-b r) 1)))
              (lambda (x)
                (let* ([r (make-foo 37 x)] [r (inc r)] [r (inc r)])
                  r)))))
       `(lambda (x)
          (#3%$record ',record-type-descriptor? 37 (#3%+ 1 (#3%+ 1 x)))))
     (equivalent-expansion?
       (parameterize
         ([optimize-level 2]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(let ()
              (import scheme)
              (define-record-type foo (fields a b))
              (define (inc r)
                (make-foo (foo-a r) (+ (foo-b r) 1)))
              (lambda (x)
                (let* ([r (make-foo 37 x)] [r (inc r)] [r (inc r)])
                  r)))))
       '(let ([rtd (#2%$make-record-type-descriptor
                     #!base-rtd
                     'foo
                     #f
                     #f
                     #f
                     #f
                     '#((immutable a) (immutable b))
                     'define-record-type)])
          (lambda (x)
            (#3%$record rtd 37 (#2%+ 1 (#2%+ 1 x))))))
     (equivalent-expansion?
       (parameterize
         ([optimize-level 3]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(let ()
              (import scheme)
              (define-record-type foo (fields a b))
              (define (inc r)
                (make-foo (foo-a r) (+ (foo-b r) 1)))
              (lambda (x)
                (let* ([r (make-foo 37 x)] [r (inc r)] [r (inc r)])
                  r)))))
       '(let ([rtd (#3%$make-record-type-descriptor
                     #!base-rtd
                     'foo
                     #f
                     #f
                     #f
                     #f
                     '#((immutable a) (immutable b))
                     'define-record-type)])
          (lambda (x)
            (#3%$record rtd 37 (#3%+ 1 (#3%+ 1 x))))))
     (equivalent-expansion?
       (parameterize
         ([optimize-level 2]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(let ()
              (import scheme)
              (define-record-type foo
                (nongenerative)
                (fields a b)
                (protocol (let ([ctr 0])
                            (lambda (new)
                              (lambda (q)
                                (let ([x (begin (set! ctr (+ xtr 1)) ctr)])
                                  (new q x)))))))
              (make-foo 3))))
       `(let ([ctr 0])
          (letrec ([g0 (lambda (new)
                         (lambda (q)
                           (new q (begin (set! ctr (#2%+ 1 xtr)) ctr))))])
            (#3%$make-record-constructor-descriptor
              ',record-type-descriptor?
              #f
              g0
              'define-record-type)
            (#3%$record ',record-type-descriptor? 3
              (begin (set! ctr (#2%+ 1 xtr)) ctr)))))
     (equivalent-expansion?
       (parameterize
         ([optimize-level 3]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(let ()
              (import scheme)
              (define-record-type foo
                (nongenerative)
                (fields a b)
                (protocol (let ([ctr 0])
                            (lambda (new)
                              (lambda (q)
                                (let ([x (begin (set! ctr (+ xtr 1)) ctr)])
                                  (new q x)))))))
              (make-foo 3))))
       `(let ([ctr 0])
          (letrec ([g0 (lambda (new)
                         (lambda (q)
                           (new q (begin (set! ctr (#3%+ 1 xtr)) ctr))))])
            (#3%$make-record-constructor-descriptor
              ',record-type-descriptor?
              #f
              g0
              'define-record-type)
            (#3%$record ',record-type-descriptor? 3
              (begin (set! ctr (#3%+ 1 xtr)) ctr)))))
     (error? ; invalid uid
       (let ()
         (define useless
           (lambda (name)
             (record-mutator
               (make-record-type-descriptor
                 name
                 #f
                 5
                 #f
                 #f
                 '#((mutable x)))
               0)))
         (procedure? (useless 'useless-box-setter))))
     (equal? (let ()
               (define-record foo ((immutable double x)))
               (foo-x (make-foo 3.0)))
             3.0)
     (begin
       (define $foo
         (lambda (y)
           (define-record foo ((immutable double x) (immutable int y)))
           (foo-x (make-foo 3.0 y))))
       #t)
     (equal? ($foo 17) 3.0))

(mat cp0-rtd-inspection-optimizations
     (equivalent-expansion?
       (parameterize
         ([optimize-level 2]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(let ()
              (define prtd
                (make-record-type-descriptor
                  'foo
                  #f
                  #f
                  #f
                  #f
                  '#((mutable x))))
              (define rtd
                (make-record-type-descriptor
                  'bar
                  prtd
                  'pluto
                  #t
                  #f
                  '#((mutable y) (immutable z))))
              (define rcd
                (make-record-constructor-descriptor rtd #f #f))
              (list (record-type-descriptor? rtd)
                    (record-constructor-descriptor? rcd)
                    (record-type-descriptor? rcd)
                    (record-constructor-descriptor? rtd)
                    (record-field-mutable? prtd 0)
                    (record-field-mutable? rtd 0)
                    (record-field-mutable? rtd 1)
                    (record-type-field-names prtd)
                    (record-type-field-names rtd)
                    (list (record-type-generative? prtd)
                          (record-type-generative? rtd))
                    (list (record-type-opaque? prtd)
                          (record-type-opaque? rtd))
                    (list (record-type-sealed? prtd)
                          (record-type-sealed? rtd))))))
       '(let ([prtd (#2%make-record-type-descriptor
                      'foo
                      #f
                      #f
                      #f
                      #f
                      '#((mutable x)))])
          (let ([rtd (#2%make-record-type-descriptor
                       'bar
                       prtd
                       'pluto
                       #t
                       #f
                       '#((mutable y) (immutable z)))])
            (let ([rcd (#3%make-record-constructor-descriptor rtd #f #f)])
              (#2%list #t
                       #t
                       (#2%record-type-descriptor? rcd)
                       (#2%record-constructor-descriptor? rtd)
                       #t
                       #t
                       #f
                       '#(x)
                       '#(y z)
                       (#2%list (#2%record-type-generative? prtd)
                                (#2%record-type-generative? rtd))
                       (#2%list #f #f)
                       (#2%list #f #t))))))
     (equivalent-expansion?
       (parameterize
         ([optimize-level 2]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(let ()
              (define prtd
                (make-record-type-descriptor 'foo #f #f #f #f '#()))
              (define rtd
                (make-record-type-descriptor 'bar prtd #f #f #f '#()))
              (list (list (record-type-opaque? prtd)
                          (record-type-opaque? rtd))
                    (list (record-type-sealed? prtd)
                          (record-type-sealed? rtd))))))
       '(let ([prtd (#2%make-record-type-descriptor 'foo #f #f #f #f '#())])
          (#2%make-record-type-descriptor 'bar prtd #f #f #f '#())
          (#2%list (#2%list #f #f) (#2%list #f #f))))
     (equivalent-expansion?
       (parameterize
         ([optimize-level 2]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(let ()
              (define prtd
                (make-record-type-descriptor 'foo #f #f #f #t '#()))
              (define rtd
                (make-record-type-descriptor 'bar prtd #f #f #f '#()))
              (list (list (record-type-opaque? prtd)
                          (record-type-opaque? rtd))
                    (list (record-type-sealed? prtd)
                          (record-type-sealed? rtd))))))
       '(let ([prtd (#2%make-record-type-descriptor 'foo #f #f #f #t '#())])
          (#2%make-record-type-descriptor 'bar prtd #f #f #f '#())
          (#2%list (#2%list #t #t) (#2%list #f #f))))
     (equivalent-expansion?
       (parameterize
         ([optimize-level 2]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(let ()
              (define prtd
                (make-record-type-descriptor 'foo #f #f #f #f '#()))
              (define rtd
                (make-record-type-descriptor 'bar prtd #f #t #t '#()))
              (list (list (record-type-opaque? prtd)
                          (record-type-opaque? rtd))
                    (list (record-type-sealed? prtd)
                          (record-type-sealed? rtd))))))
       '(let ([prtd (#2%make-record-type-descriptor 'foo #f #f #f #f '#())])
          (#2%make-record-type-descriptor 'bar prtd #f #t #t '#())
          (#2%list (#2%list #f #t) (#2%list #f #t))))
     (equivalent-expansion?
       (parameterize
         ([optimize-level 2]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(let ()
              (define prtd
                (make-record-type-descriptor 'foo #f #f #f #t '#()))
              (define rtd
                (make-record-type-descriptor 'bar prtd #f #t #t '#()))
              (list (list (record-type-opaque? prtd)
                          (record-type-opaque? rtd))
                    (list (record-type-sealed? prtd)
                          (record-type-sealed? rtd))))))
       '(let ([prtd (#2%make-record-type-descriptor 'foo #f #f #f #t '#())])
          (#2%make-record-type-descriptor 'bar prtd #f #t #t '#())
          (#2%list (#2%list #t #t) (#2%list #f #t))))
     (equivalent-expansion?
       (parameterize
         ([optimize-level 2]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(lambda (sealed? opaque?)
              (define prtd
                (make-record-type-descriptor
                  'foo
                  #f
                  #f
                  sealed?
                  opaque?
                  '#()))
              (define rtd
                (make-record-type-descriptor 'bar prtd #f #f #f '#()))
              (list (list (record-type-opaque? prtd)
                          (record-type-opaque? rtd))
                    (list (record-type-sealed? prtd)
                          (record-type-sealed? rtd))))))
       '(lambda (sealed? opaque?)
          (let ([prtd (#2%make-record-type-descriptor
                        'foo
                        #f
                        #f
                        sealed?
                        opaque?
                        '#())])
            (let ([rtd (#2%make-record-type-descriptor
                         'bar
                         prtd
                         #f
                         #f
                         #f
                         '#())])
              (#2%list (#2%list (#2%record-type-opaque? prtd)
                                (#2%record-type-opaque? rtd))
                       (#2%list (#2%record-type-sealed? prtd) #f))))))
     (equivalent-expansion?
       (parameterize
         ([optimize-level 2]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(lambda (sealed? opaque?)
              (define prtd
                (make-record-type-descriptor
                  'foo
                  #f
                  #f
                  sealed?
                  opaque?
                  '#()))
              (define rtd
                (make-record-type-descriptor 'bar prtd #f #t #t '#()))
              (list (list (record-type-opaque? prtd)
                          (record-type-opaque? rtd))
                    (list (record-type-sealed? prtd)
                          (record-type-sealed? rtd))))))
       '(lambda (sealed? opaque?)
          (let ([prtd (#2%make-record-type-descriptor
                        'foo
                        #f
                        #f
                        sealed?
                        opaque?
                        '#())])
            (#2%make-record-type-descriptor 'bar prtd #f #t #t '#())
            (#2%list (#2%list (#2%record-type-opaque? prtd) #t)
                     (#2%list (#2%record-type-sealed? prtd) #t)))))
     (equivalent-expansion?
       (parameterize
         ([optimize-level 2]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(lambda (sealed? opaque?)
              (define prtd
                (make-record-type-descriptor 'foo #f #f #f #f '#()))
              (define rtd
                (make-record-type-descriptor
                  'bar
                  prtd
                  #f
                  sealed?
                  opaque?
                  '#()))
              (list (list (record-type-opaque? prtd)
                          (record-type-opaque? rtd))
                    (list (record-type-sealed? prtd)
                          (record-type-sealed? rtd))))))
       '(lambda (sealed? opaque?)
          (let ([rtd (#2%make-record-type-descriptor 'bar
                       (#2%make-record-type-descriptor
                         'foo
                         #f
                         #f
                         #f
                         #f
                         '#())
                       #f
                       sealed?
                       opaque?
                       '#())])
            (#2%list (#2%list #f (#2%record-type-opaque? rtd))
                     (#2%list #f (#2%record-type-sealed? rtd))))))
     (equivalent-expansion?
       (parameterize
         ([optimize-level 2]
          [enable-cp0 #t]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(lambda (sealed? opaque?)
              (define prtd
                (make-record-type-descriptor 'foo #f #f #f #t '#()))
              (define rtd
                (make-record-type-descriptor
                  'bar
                  prtd
                  #f
                  sealed?
                  opaque?
                  '#()))
              (list (list (record-type-opaque? prtd)
                          (record-type-opaque? rtd))
                    (list (record-type-sealed? prtd)
                          (record-type-sealed? rtd))))))
       '(lambda (sealed? opaque?)
          (let ([rtd (#2%make-record-type-descriptor 'bar
                       (#2%make-record-type-descriptor
                         'foo
                         #f
                         #f
                         #f
                         #t
                         '#())
                       #f
                       sealed?
                       opaque?
                       '#())])
            (#2%list (#2%list #t #t)
              (#2%list #f (#2%record-type-sealed? rtd)))))))

(define (cp0x3 cp0 x) (cp0 (cp0 (cp0 x))))

(define (member? o l) (and (member o l) #t))
(mat cp0-kar-kons-optimizations
     ; for now, it's necesary to run cp0 three times to complete the reduction
     (equal? (with-output-to-string
               (lambda ()
                 (define-record mybox (val))
                 (display (mybox-val (begin (display 1) (make-mybox 2))))))
             "12")
     (equivalent-expansion?
       (parameterize
         ([optimize-level 2]
          [enable-cp0 #t]
          [run-cp0 cp0x3]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(let ()
              (define-record mybox (val))
              (display (mybox-val (begin (display 1) (make-mybox 2)))))))
       '(#2%display (begin (#2%display 1) 2)))
     (eq? (let ()
            (define-record kons (kar kdr))
            (kons-kar (make-kons 'a 'b)))
          'a)
     (equivalent-expansion?
       (parameterize
         ([optimize-level 2]
          [enable-cp0 #t]
          [run-cp0 cp0x3]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(let ()
              (define-record kons (kar kdr))
              (kons-kar (make-kons 'a 'b)))))
       ''a)
     (eq? (let ()
            (define-record kons (kar kdr))
            (kons-kdr (make-kons 'a 'b)))
          'b)
     (equivalent-expansion?
       (parameterize
         ([optimize-level 2]
          [enable-cp0 #t]
          [run-cp0 cp0x3]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(let ()
              (define-record kons (kar kdr))
              (kons-kdr (make-kons 'a 'b)))))
       ''b)
     (member? (with-output-to-string
                (lambda ()
                  (define-record kons (kar kdr))
                  (display (kons-kar (make-kons
                                       (begin (display 1) (display 2) 3)
                                       (begin (display 4) (display 5) 6))))))
              '("45123" "12453"))
     (equivalent-expansion?
       (parameterize
         ([optimize-level 2]
          [enable-cp0 #t]
          [run-cp0 cp0x3]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(let ()
              (define-record kons (kar kdr))
              (display (kons-kar (make-kons
                                   (begin (display 1) (display 2) 3)
                                   (begin (display 4) (display 5) 6)))))))
       '(#2%display
          (begin
            (#2%display 4)
            (#2%display 5)
            (#2%display 1)
            (#2%display 2)
            3)))
     (member? (with-output-to-string
                (lambda ()
                  (define-record kons (kar kdr))
                  (display (kons-kdr (make-kons
                                       (begin (display 1) (display 2) 3)
                                       (begin (display 4) (display 5) 6))))))
              '("45126" "12456"))
     (equivalent-expansion?
       (parameterize
         ([optimize-level 2]
          [enable-cp0 #t]
          [run-cp0 cp0x3]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(let ()
              (define-record kons (kar kdr))
              (display (kons-kdr (make-kons
                                   (begin (display 1) (display 2) 3)
                                   (begin (display 4) (display 5) 6)))))))
       '(#2%display
          (begin
            (#2%display 4)
            (#2%display 5)
            (#2%display 1)
            (#2%display 2)
            6)))
     (equal? (with-output-to-string
               (lambda ()
                 (define-record ktail (kar (immutable kdr)))
                 (define x (make-ktail 1 2))
                 (display 3)
                 (display (ktail-kdr (begin (display 4) x)))))
             "342")
     (equivalent-expansion?
       (parameterize
         ([optimize-level 2]
          [enable-cp0 #t]
          [run-cp0 cp0x3]
          [#%$suppress-primitive-inlining #f])
         (expand/optimize
           '(let ()
              (define-record ktail (kar (immutable kdr)))
              (define x (make-ktail 1 2))
              (display 3)
              (display (ktail-kdr (begin (display 4) x))))))
       '(begin
          (#2%display 3)
          (#2%display (begin (#2%display 4) 2))))
     (equal? (with-output-to-string
               (lambda ()
                 (define-record ktail (kar (immutable kdr)))
                 (define x (make-ktail 1 2))
                 (display 3)
                 (display (ktail-kar (begin (display 4) x)))))
             "341")
     (not (equivalent-expansion?
            (parameterize
              ([optimize-level 2]
               [enable-cp0 #t]
               [run-cp0 cp0x3]
               [#%$suppress-primitive-inlining #f])
              (expand/optimize
                '(let ()
                   (define-record ktail (kar (immutable kdr)))
                   (define x (make-ktail 1 2))
                   (display 3)
                   (display (ktail-kar (begin (display 4) x))))))
            '(begin
               (#2%display 3)
               (#2%display (begin (#2%display 4) 1))))))
;;; enum.ms
;;; Copyright 1984-2017 Cisco Systems, Inc.
;;; 
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;; 
;;; http://www.apache.org/licenses/LICENSE-2.0
;;; 
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

(mat enumeration
     (equal? '(a b c) (enum-set->list (make-enumeration '(a b c))))
     (equal? '(a b c) (enum-set->list (make-enumeration '(a b a c))))
     (equal? '(a b c)
       (enum-set->list
         ((enum-set-constructor (make-enumeration '(a a b b c d))) '(a b c))))
     (equal? '(a b
                 c
                 d
                 e
                 f
                 g
                 h
                 i
                 j
                 k
                 l
                 m
                 n
                 o
                 p
                 q
                 r
                 s
                 t
                 u
                 v
                 w
                 x
                 y
                 z
                 aa
                 bb
                 cc
                 dd
                 ee
                 ff
                 gg
                 hh
                 ii
                 jj
                 kk
                 ll
                 mm
                 nn
                 oo
                 pp
                 qq
                 rr
                 ss
                 tt
                 uu
                 vv
                 ww
                 xx
                 yy
                 zz)
             (enum-set->list
               (make-enumeration
                 '(a b
                     c
                     d
                     e
                     f
                     g
                     h
                     i
                     j
                     k
                     l
                     m
                     n
                     o
                     p
                     q
                     r
                     s
                     t
                     u
                     v
                     w
                     x
                     y
                     z
                     aa
                     bb
                     cc
                     dd
                     ee
                     ff
                     gg
                     hh
                     ii
                     jj
                     kk
                     ll
                     mm
                     nn
                     oo
                     pp
                     qq
                     rr
                     ss
                     tt
                     uu
                     vv
                     ww
                     xx
                     yy
                     zz))))
     (equal? '(d)
       (let ([c (enum-set-constructor (make-enumeration '(a b c d e f)))])
         (enum-set->list
           (enum-set-intersection (c '(a c d e)) (c '(b d f))))))
     (equal? '(a b c d e f)
       (let ([c (enum-set-constructor (make-enumeration '(a b c d e f)))])
         (enum-set->list (enum-set-union (c '(a c d e)) (c '(b d f))))))
     (equal? '(a c e)
       (let ([c (enum-set-constructor (make-enumeration '(a b c d e f)))])
         (enum-set->list (enum-set-difference (c '(a c d e)) (c '(b d f))))))
     (equal? '(b f)
       (let ([c (enum-set-constructor (make-enumeration '(a b c d e f)))])
         (enum-set->list (enum-set-complement (c '(a c d e))))))
     (equal? '(a b c d e f)
       (let ([c (enum-set-constructor (make-enumeration '(a b c d e f)))])
         (enum-set->list (enum-set-universe (c '(a c d e))))))
     (equal? '(a c d e)
       (let ([c (enum-set-constructor (make-enumeration '(a b c d e f)))])
         (enum-set->list (enum-set-projection (c '(a c d e)) (c '(b d f))))))
     (equal? '(0 1 #f 5 #f)
       (let ([e (make-enumeration '(a b c d e f))])
         (map (enum-set-indexer e) '(a b g f h))))
     (error? (enum-set-intersection (make-enumeration '(a b c d e f g))
               (make-enumeration '(a b c d e f g))))
     (error? (enum-set-intersection 1 1))
     (equal? '(#f #t #f #t #t #t #f #f #f #f)
       (let ([x ((enum-set-constructor (make-enumeration '(a b c d e f g))) '(b d e f))])
         (map (lambda (y) (enum-set-member? y x))
              '(a b c d e f g h i j))))
     (equal? '(#t #f #t #f)
       (let ([e1 (make-enumeration '(a b c d))]
             [e2 (make-enumeration '(c d e f))])
         (list (enum-set-subset? e1 e1)
               (enum-set-subset? e1 e2)
               (enum-set-subset? e2 e2)
               (enum-set-subset? e2 e1))))
     (equal? '(#f #f #f #f #f)
       (let ([c1 (enum-set-constructor (make-enumeration '(a b c d)))]
             [c2 (enum-set-constructor (make-enumeration '(c d e f)))])
         (list (enum-set-subset? (c1 '(c)) (c2 '(c d)))
               (enum-set-subset? (c1 '(a c)) (c2 '(c d)))
               (enum-set-subset? (c1 '(c d)) (c2 '(c d)))
               (enum-set=? (c1 '(c d)) (c2 '(c d)))
               (enum-set=? (c1 '(c)) (c2 '(c d))))))
     (equal? '(#t #f #t #t #f)
       (let ([c1 (enum-set-constructor (make-enumeration '(a b c d e f)))]
             [c2 (enum-set-constructor (make-enumeration '(f e d c b a)))])
         (list (enum-set-subset? (c1 '(c)) (c2 '(c d)))
               (enum-set-subset? (c1 '(a c)) (c2 '(c d)))
               (enum-set-subset? (c1 '(c d)) (c2 '(c d)))
               (enum-set=? (c1 '(c d)) (c2 '(c d)))
               (enum-set=? (c1 '(c)) (c2 '(c d))))))
     (equal? 'a (let () (define-enumeration foo (a b c) make-foo) (foo a)))
     (error? (let () (define-enumeration foo (a b c) make-foo) (foo d)))
     (equal? '(a b)
       (let ()
         (define-enumeration foo (a b c) make-foo)
         (enum-set->list (make-foo a b))))
     (error? (let ()
               (define-enumeration foo (a b c) make-foo)
               (make-foo a d)))
     (error? (make-enumeration 3))
     (error? (enum-set-universe 3))
     (error? (enum-set-indexer 3))
     (error? (let ([e (make-enumeration '(a b c))])
               ((enum-set-indexer e) 1)))
     (error? (enum-set->list 3))
     (equal? '(a b)
       (let ()
         (define-enumeration foo (a b c) f)
         (enum-set->list (enum-set-union (f a) (f b)))))
     (error? (let ()
               (define-enumeration foo (a b c) f)
               (enum-set->list (enum-set-union (f a) 3))))
     (error? (enum-set-union 4 (make-enumeration '(a b c))))
     (error? (let ()
               (define-enumeration foo (a b c) f)
               (define-enumeration bar (a b c) g)
               (enum-set-union (f a) (g b))))
     (error? (enum-set-complement 3))
     (error? (enum-set-projection 3 (make-enumeration '(a b))))
     (error? (enum-set-projection (make-enumeration '(a b)) 4))
     (equal? '(a b)
       (enum-set->list
         (enum-set-projection (make-enumeration '(a b))
           (make-enumeration '(a b)))))
     (equal? '(a b)
       (enum-set->list
         (enum-set-projection (make-enumeration '(a b c))
           (make-enumeration '(a b)))))
     (equal? '(a b)
       (enum-set->list
         (enum-set-projection (make-enumeration '(a b))
           (make-enumeration '(a b c)))))
     (equal? #t (let () (define-enumeration foo () bar) #t))
     (error? (let () (define-enumeration 3 () bar) #t))
     (error? (let () (define-enumeration foo baz bar) #t))
     (error? (let () (define-enumeration foo () 3) #t))
     (error? (let () (define-enumeration foo (a 3) bar) #t))
     (error? (let () (define-enumeration foo (a b) bar) (foo 3)))
     (error? (let () (define-enumeration foo (a b) bar) (bar 3)))
     (error? ; cannot extend sealed record
       (make-record-type (record-rtd (make-enumeration '(a b c))) "foo" '()))

     (equal? #t (enum-set? (make-enumeration '(a b c))))
     (equal? #f (enum-set? 1)))
;;; 8.ms
;;; Copyright 1984-2017 Cisco Systems, Inc.
;;; 
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;; 
;;; http://www.apache.org/licenses/LICENSE-2.0
;;; 
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

(mat define-syntax
     (begin
       (define-syntax foo
         (syntax-rules () [(foo a b) (list a b)]))
       #t)
     (error? (expand '(foo)))
     (error? (expand '(foo . a)))
     (error? (expand '(foo a)))
     (error? (expand '(foo a . b)))
     (equal? (foo 3 4) '(3 4))
     ;;   (equal? (expand-once '(foo 3 4)) '(list 3 4))
     (equal? (foo 3 4) '(3 4))
     (error? (expand '(foo a b . c)))
     (error? (expand '(foo a b c)))
     (begin
       (define-syntax foo
         (syntax-rules (bar)
           [(foo) '()]
           [(foo (bar x)) x]
           [(foo x) (cons x '())]
           [(foo x y ...) (cons x (foo y ...))]))
       #t)
     (equivalent-expansion? (expand '(foo)) ''())
     (equivalent-expansion? (expand '(foo (bar a))) 'a)
     (equal? (foo 'a) '(a))
     ;;   (equal? (expand-once '(foo a b c)) '(cons a (foo b c)))
     (equal? (foo 'a 'b 'c) '(a b c))
     (equal? (foo 'a 'b (bar 'c)) '(a b . c))
     (equal? (foo 'a 'b 'c 'd) '(a b c d))
     (equal? (foo 'a 'b 'c (bar 'd)) '(a b c . d))
     (begin
       (define-syntax foo
         (lambda (x)
           (syntax-case x ()
             [(_ ((x v) ...) e1 e2 ...)
              (andmap symbol? '(x ...))
              (syntax ((lambda (x ...) e1 e2 ...) v ...))]
             [(_ ((lambda (x ...) e1 e2 ...) v ...))
              (= (length '(x ...)) (length '(v ...)))
              (syntax (foo ((x v) ...) e1 e2 ...))])))
       #t)
     (equal? (foo ((a 3) (b 4)) (cons a b)) '(3 . 4))
     (error? (expand '(foo ((1 b) (c d)) e f g)))
     (error? (expand '(foo ((lambda (a c) e f g) b))))
     (error? (define-syntax foo (syntax-rules (...) [(foo ...) 0])))
     ; no longer an error:
     #;
     (error? (define-syntax foo (syntax-rules () [(foo x ... y) 0])))
     (error? (define-syntax foo (syntax-rules () [(foo x . ...) 0])))
     (error? (define-syntax foo (syntax-rules () [(foo (...)) 0])))
     (error? (define-syntax foo (syntax-rules () [(foo x x) 0])))
     (begin
       (define-syntax foo (syntax-rules () [(foo foo) 0]))
       #t)
     (begin
       (define-syntax foo
         (lambda (x)
           (syntax-case x ()
             [(_ keys) (with-syntax ([x `,(syntax keys)]) (syntax x))])))
       (equivalent-expansion? (expand '(foo (a b c))) '(a b c)))
     (begin
       (define-syntax foo
         ; test exponential "with" time problem
         (lambda (x)
           (syntax-case x ()
             [(_)
              (with-syntax
                ([a1 1]
                 [b1 2]
                 [c1 3]
                 [d1 4]
                 [e1 5]
                 [f1 6]
                 [g1 7]
                 [h1 8]
                 [a2 1]
                 [b2 2]
                 [c2 3]
                 [d2 4]
                 [e2 5]
                 [f2 6]
                 [g2 7]
                 [h2 8]
                 [a3 1]
                 [b3 2]
                 [c3 3]
                 [d3 4]
                 [e3 5]
                 [f3 6]
                 [g3 7]
                 [h3 8]
                 [a4 1]
                 [b4 2]
                 [c4 3]
                 [d4 4]
                 [e4 5]
                 [f4 6]
                 [g4 7]
                 [h4 8]
                 [a5 1]
                 [b5 2]
                 [c5 3]
                 [d5 4]
                 [e5 5]
                 [f5 6]
                 [g5 7]
                 [h5 8]
                 [a6 1]
                 [b6 2]
                 [c6 3]
                 [d6 4]
                 [e6 5]
                 [f6 6]
                 [g6 7]
                 [h6 8]
                 [a7 1]
                 [b7 2]
                 [c7 3]
                 [d7 4]
                 [e7 5]
                 [f7 6]
                 [g7 7]
                 [h7 8]
                 [a8 1]
                 [b8 2]
                 [c8 3]
                 [d8 4]
                 [e8 5]
                 [f8 6]
                 [g8 7]
                 [h8 8])
                (syntax (list a1 b2 c3 d4 e5 f6 g7 h8)))])))
       (equal? (foo) '(1 2 3 4 5 6 7 8)))
     (eqv? (let ()
             (let-syntax () (define x 3) (define y 4))
             (define z (lambda () (+ x y)))
             (z))
           7)
     (eqv? (let ()
             (let-syntax
               ((a (syntax-rules () ((_ x v) (define x v))))
                (b (syntax-rules ()
                     ((_ x v) (define-syntax x (syntax-rules () ((_) v)))))))
               (a x 3)
               (b y 4))
             (define z (lambda () (+ x (y))))
             (z))
           7)
     (eqv? (let-syntax ((a (eval '(lambda (x) (let ((x x)) (syntax 3))))))
             (a))
           3)
     (error? (begin
               (define-syntax x
                 (let ((a 3))
                   (identifier-syntax (define a 4))))
               x))
     (error? (begin
               (define-syntax x
                 (let ((a 3))
                   (identifier-syntax (set! a 4))))
               x))
     (error? (begin
               (define-syntax x
                 (let ((a 3))
                   (identifier-syntax
                     (fluid-let-syntax ((a (identifier-syntax 4))) 3))))
               x))
     ;; transformers expressions can reference local keywords
     (eqv? (let-syntax ((a (lambda (x) (syntax (lambda (y) (syntax 3))))))
             (let-syntax ((b a)) b))
           3)
     (eqv? (let-syntax ((a (lambda (x) (syntax (lambda (y) (syntax 3))))))
             (letrec-syntax ((b a)) b))
           3)
     (eqv? (let-syntax ((a (lambda (x) (syntax (lambda (y) (syntax 3))))))
             (fluid-let-syntax ((b a)) b))
           3)
     (eqv? (let-syntax ((a (lambda (x) (syntax (lambda (y) (syntax 3))))))
             (let () (define-syntax b a) b))
           3)
     (let-syntax ((a (lambda (x) #'(lambda (x) #'3))))
       (define-syntax top-level-b a)
       (eqv? top-level-b 3))
     ;; transformers expressions cannot reference local variables
     (error? (let ((a (lambda (x) x))) (let-syntax ((b a)) b)))
     (error? (let ((a (lambda (x) x))) (letrec-syntax ((b a)) b)))
     (error? (let ((a (lambda (x) x))) (fluid-let-syntax ((b a)) b)))
     (error? (let ((a (lambda (x) x))) (let () (define-syntax b a) b)))
     ;; transformers expressions cannot reference pattern variables
     (error? (let-syntax
               ([foo (lambda (x)
                       (syntax-case x ()
                         [(_ z ...)
                          (let-syntax ([bar (lambda (y) #'(z ...))])
                            (bar))]))])
               (foo + 8 9 10)))
     ;; but can expand into syntax forms containing pattern variable references
     (equal? (let-syntax
               ([foo (lambda (x)
                       (syntax-case x ()
                         [(_ z ...)
                          (let-syntax
                            ([bar (lambda (y) #'#'(z (... ...)))])
                            (bar))]))])
               (foo + 8 9 10))
             27)

     (procedure? (eval (expand '(rec f (lambda (x) x)))))
     ; make sure we're using the right environment for evaluating transformers
     (eq? (let ()
            (define x 3)
            (let-syntax ((x (identifier-syntax (identifier-syntax 4))))
              (define-syntax a x))
            a)
          4)
     ; make sure local-syntax bindings aren't visible outside their scope
     (equal? (let ([a 14])
               (module (x y)
                 (let-syntax ((a (identifier-syntax 3)))
                   (define x a))
                 (define y a))
               (cons x y))
             '(3 . 14))
     (begin
       (define $ds-a 14)
       (module ($ds-x $ds-y)
         (letrec-syntax ((a (identifier-syntax 3))) (define $ds-x a))
         (define $ds-y $ds-a))
       (equal? (cons $ds-x $ds-y) '(3 . 14)))
     ; make sure both introduced references and defines are scoped the same
     (eq? (let ()
            (define-syntax a
              (identifier-syntax (begin (define x 3) x)))
            (let () a))
          3)

     (begin
       (define $a 'aaa)
       (define $x 'xxx)
       (define-syntax $introduce-module
         (identifier-syntax
           (begin
             (module $a ($x) (define $x 73))
             (import $a)
             (eq? $x 73))))
       $introduce-module)
     (eq? $a 'aaa)
     ; make sure introduced module binding isn't visible
     (eq? $x 'xxx)
     ; make sure introduced and imported variable isn't visible
     (eq? (top-level-value '$a) 'aaa)
     (eq? (top-level-value '$x) 'xxx)
     (begin
       (define-syntax $dsmat-foo1
         (lambda (x)
           (syntax-case x ()
             ((_ name arg ...)
              (with-syntax (($... (syntax (... ...))))
                (syntax (begin
                          (define $dsmat-y 10)
                          (define-syntax name
                            (lambda (z)
                              (syntax-case z ()
                                ((_ a $...) (syntax (list $dsmat-y a $...)))))))))))))
       #t)
     (begin ($dsmat-foo1 $dsmat-bar) #t)
     (error? ($dsmat-bar $dsmat-y))
     (begin (define $dsmat-y 77) #t)
     (equal? ($dsmat-bar $dsmat-y) '(10 77))
     (error? ; misplaced ellipsis
             (with-syntax ([x 3]) #'#(... (x))))
     (equal? (let ()
               (define b)
               (define d)
               (define-syntax a
                 (lambda (x)
                   (syntax-case x (b c)
                     [(_ b) "b"]
                     [(_ c) "c"]
                     [(_ bar) (free-identifier=? #'bar #'d) "d"]
                     [(_ bar) (free-identifier=? #'bar #'e) "e"]
                     [(_ bar bee)
                      (bound-identifier=? #'bar #'bee)
                      (symbol->string (datum bar))]
                     [_ "nope"])))
               (list (a b) (a c) (a d) (a e) (a b b) (a c c) (a f)))
             '("b" "c" "d" "e" "b" "c" "nope"))
     (equal? (let ()
               (define-syntax letrec
                 (lambda (x)
                   (syntax-case x ()
                     [(_ ((i v) ...) e1 e2 ...)
                      (with-syntax ([(t ...) (generate-temporaries #'(i ...))])
                        #'(let ([i #f] ...)
                            (let ([t v] ...)
                              (set! i t)
                              ...
                              (let () e1 e2 ...))))])))
               (list (letrec ([f (lambda (x)
                                   (if (zero? x)
                                       'odd
                                       (g (- x 1))))]
                              [g (lambda (x)
                                   (if (zero? x)
                                       'even
                                       (f (- x 1))))])
                       (and (eq? (g 10) 'even)
                            (eq? (g 13) 'odd)
                            (eq? (f 13) 'even)))
                     (letrec ([v 0] [k (call/cc (lambda (x) x))])
                       (set! v (+ v 1))
                       (k (lambda (x) v)))))
             '(#t 1))
     (equal? (let ()
               (define-syntax main
                 ; Anton's example
                 (lambda (stx)
                   (let ((make-swap
                           (lambda (x y)
                             (with-syntax ((x x) (y y) ((t) (generate-temporaries '(*))))
                               (syntax (let ((t1 x))
                                         (set! x y)
                                         (set! y t1)))))))
                     (syntax-case stx ()
                       ((_)
                        (with-syntax ((swap (make-swap (syntax s) (syntax t))))
                          (syntax (let ((s 1) (t 2)) swap (list s t)))))))))
               (main))
             '(2 1))
     ; make sure second definition of marked id works like set!
     (begin
       (define $ds-b '())
       (define-syntax $ds-a
         (lambda (x)
           #'(begin
               (define q 33)
               (define (f) q)
               (set! $ds-b (cons (f) $ds-b))
               (define q 55)
               (set! $ds-b (cons (f) $ds-b))
               (set! $ds-b (cons q $ds-b))
               #t)))
       #t)
     $ds-a
     (equal? $ds-b '(55 55 33))

     ; check underscore as wildcard
     (equal? (let ()
               (define-syntax a
                 (lambda (x)
                   (syntax-case x ()
                     [(_ id e)
                      #'(let ()
                          (define-syntax id
                            (lambda (x)
                              (syntax-case x ()
                                [(_ q _) #'(list q '_)])))
                          e)])))
               (a xxx (xxx (cons (xxx 3 (/ 1 0)) 4) (/ 1 0))))
             '(((3 _) . 4) _))

     (equal? (let ([b 1] [c 2] [d 3] [e 4] [f 5] [g 6])
               (define-syntax a
                 (syntax-rules ()
                   [(_ x _ y _ z _) (list x y 'z '_)]))
               (a b c d e f g))
             '(1 3 f _))
     ; test syntax-rules fender
     (eqv? (let ()
             (define-syntax k
               (syntax-rules ()
                 [(_ a b) (identifier? #'a) (let ((a (+ b 1))) (* a b))]))
             (let ([x 4]) (k x (+ x 3))))
           88)
     ; test for mishandling of underscore introduced by syntax-rules
     (equal? (let ([_ 3])
               (define-syntax a
                 (lambda (x)
                   (syntax-case x (_)
                     [(k _) 4]
                     [(k x) #'(* x x)])))
               (list (a _)))
             '(4))
     (equal? (let ([_ 3])
               (define-syntax a
                 (syntax-rules (_)
                   [(k _) 4]
                   [(k x) (* x x)]))
               (list (a _)))
             '(4)))

(mat r6rs:syntax-rules
     (equal? (let ([b 1] [c 2] [d 3] [e 4] [f 5] [g 6])
               (import (rnrs))
               (define-syntax a
                 (syntax-rules ()
                   [(_ x _ y _ z _) (list x y 'z '_)]))
               (a b c d e f g))
             '(1 3 f _))
     (equal? (let ()
               (import (rnrs))
               (define-syntax a
                 (syntax-rules (b)
                   [(_ b) "yup"]
                   [(_ c) (list c)]))
               (list (a b) (a 3)))
             '("yup" (3)))
     ; test syntax-rules fender
     (error? (let ()
               (import (rnrs))
               (define-syntax k
                 (syntax-rules ()
                   [(_ a b) (identifier? #'a) (let ((a (+ b 1))) (* a b))]))
               (let ([x 4]) (k x (+ x 3)))))
     (error? (let () (import (rnrs)) (syntax-rules (_))))
     (error? (syntax-rules (_)))
     (error? (let () (import (rnrs)) (syntax-rules (...))))
     (error? (syntax-rules (...)))
     ; test for mishandling of underscore introduced by syntax-rules
     (equal? (let ()
               (import (rnrs))
               (let ([_ 3])
                 (define-syntax a
                   (syntax-rules (_)
                     [(k _) 4]
                     [(k x) (* x x)]))
                 (list (a _))))
             '(4)))

(mat definition-not-permitted
     ; top level
     (error? ; definition not permitted
             (let-syntax ((frob (lambda (x) #'(void))))
               (define frob 15)))
     (error? ; definition not permitted
       (let-syntax ((frob (lambda (x) #'(void))))
         (define-syntax frob (identifier-syntax 15))))
     (error? ; definition not permitted
       (let-syntax ((frob (lambda (x) #'(void))))
         (module frob (x) (define x 15))))
     (error? ; definition not permitted
       (let-syntax ((frob (lambda (x) #'(void))))
         (alias frob cons)))
     ; top level module body
     (error? ; definition not permitted
       (module (frob)
         (let-syntax ((frob (lambda (x) #'(void))))
           (define frob -15))))
     (error? ; definition not permitted
       (module (frob)
         (let-syntax ((frob (lambda (x) #'(void))))
           (define-syntax frob (identifier-syntax -15)))))
     (error? ; definition not permitted
       (module (frob)
         (let-syntax ((frob (lambda (x) #'(void))))
           (module frob (x) (define x -15)))))
     (error? ; definition not permitted
       (module (frob)
         (let-syntax ((frob (lambda (x) #'(void))))
           (alias frob cons))))
     ; body
     (error? ; definition not permitted
       (let ()
         (let-syntax ((frob (lambda (x) #'(void))))
           (define frob 'xxx))
         frob))
     (error? ; definition not permitted
       (let ()
         (let-syntax ((frob (lambda (x) #'(void))))
           (define-syntax frob (identifier-syntax 'xxx)))
         frob))
     (error? ; definition not permitted
       (let ()
         (let-syntax ((frob (lambda (x) #'(void))))
           (module frob (x) (define x 'xxx)))
         (import frob)
         x))
     (error? ; definition not permitted
       (let ()
         (let-syntax ((frob (lambda (x) #'(void))))
           (alias frob cons))
         (cons 3 4))))

(mat invalid-bindings
     (error? (let-syntax ([x '(global)]) x))
     (error? (letrec-syntax ([x '(global)]) x))
     (error? (fluid-let-syntax ([x '(global)]) x))
     (error? (begin (define-syntax x '(global)) x))
     (error? (let () (define-syntax x '(global)) x))
     (error? (let () (let-syntax ([x '(global)]) x)))
     (error? (let () (letrec-syntax ([x '(global)]) x)))
     (error? (let-syntax ([x '(lexical . #\a)]) x))
     (error? (letrec-syntax ([x '(lexical . #\a)]) x))
     (error? (fluid-let-syntax ([x '(lexical . #\a)]) x))
     (error? (begin (define-syntax x '(lexical . #\a)) x))
     (error? (let () (define-syntax x '(lexical . #\a)) x))
     (error? (let () (let-syntax ([x '(lexical . #\a)]) x)))
     (error? (let () (letrec-syntax ([x '(lexical . #\a)]) x)))
     (error? (let-syntax ([x '(macro . cond)]) x))
     (error? (letrec-syntax ([x '(macro . cond)]) x))
     (error? (fluid-let-syntax ([x '(macro . cond)]) x))
     (error? (begin (define-syntax x '(macro . cond)) x))
     (error? (let () (define-syntax x '(macro . cond)) x))
     (error? (let () (let-syntax ([x '(macro . cond)]) x)))
     (error? (let () (letrec-syntax ([x '(macro . cond)]) x))))

(mat generalized-pattern
     (begin
       (define-syntax gp$a
         (syntax-rules () [(_ x ... y) (list y x ...)]))
       #t)
     (error? gp$a)
     (error? (gp$a))
     (error? (gp$a . b))
     (equal? (gp$a 1 2 3 4 5) '(5 1 2 3 4))
     (equal? (gp$a 1) '(1))
     (equal? (gp$a 1 2) '(2 1))
     (begin
       (define-syntax gp$b
         (lambda (x)
           (syntax-case x () [(_ x ... y) #'(list y x ...)])))
       #t)
     (error? gp$b)
     (error? (gp$b))
     (error? (gp$b . b))
     (equal? (gp$b 1 2 3 4 5) '(5 1 2 3 4))
     (equal? (gp$b 1) '(1))
     (equal? (gp$b 1 2) '(2 1))
     (begin
       (define-syntax gp$c
         (syntax-rules ()
           [(_ x ... y z . w) '((x ...) y z w)]))
       #t)
     (error? (gp$c))
     (error? (gp$c 1))
     (equal? (gp$c 1 2) '(() 1 2 ()))
     (equal? (gp$c 1 2 3 4 5) '((1 2 3) 4 5 ()))
     (equal? (gp$c 1 2 . 3) '(() 1 2 3))
     (equal? (gp$c 1 2 3 4 5 . 6) '((1 2 3) 4 5 6))
     (begin
       (define-syntax gp$d
         (syntax-rules (foo)
           [(_ x ... (y z) . #(foo w1 w2)) '((x ...) y z w1 w2)]))
       #t)
     (error? (gp$d 1 2 . #(foo 6 7)))
     (error? (gp$d 1 2))
     (error? (gp$d 1 2 (3 4)))
     (equal? (gp$d (4 5) . #(foo 6 7)) '(() 4 5 6 7))
     (equal? (gp$d 1 (4 5) . #(foo 6 7)) '((1) 4 5 6 7))
     (equal? (gp$d 1 2 3 (4 5) . #(foo 6 7)) '((1 2 3) 4 5 6 7))
     (begin
       (define-syntax gp$e
         (syntax-rules (rats) [(_ x ... . rats) '(x ...)]))
       #t)
     (error? (gp$e))
     (error? (gp$e 1))
     (error? (gp$e 1 2))
     (error? (gp$e rats))
     (equal? (gp$e . rats) '())
     (equal? (gp$e 1 . rats) '(1))
     (equal? (gp$e 1 2 3 4 5 . rats) '(1 2 3 4 5))
     (begin
       (define-syntax gp$f
         (syntax-rules (rats)
           [(_ (x ... y) ...) '(x ... ... y ...)]))
       #t)
     (equal? (gp$f) '())
     (equal? (gp$f (1 2 3 4 5) (6 7 8)) '(1 2 3 4 6 7 5 8))
     (error? (define-syntax gp$g
               (syntax-rules ()
                 [(_ x ... y ...) '(x ... y ...)])))
     (begin
       (define-syntax gp$h
         (syntax-rules (rats)
           [(_ #(x ... y) ...) '(x ... ... y ...)]))
       #t)
     (error? (gp$h (1 2 3)))
     (error? (gp$h . 4))
     (equal? (gp$h) '())
     (equal? (gp$h #(1 2 3 4 5) #(6 7 8)) '(1 2 3 4 6 7 5 8)))

(mat define-integrable
     (begin
       (define-syntax define-integrable
         (lambda (x)
           (define make-residual-name
             (lambda (name)
               (datum->syntax name
                 (string->symbol
                   (string-append "residual-"
                     (symbol->string (syntax->datum name)))))))
           (syntax-case x (lambda)
             ((_ name (lambda formals form1 form2 ...))
              (identifier? (syntax name))
              (with-syntax ((xname (make-residual-name (syntax name))))
                (syntax (begin
                          (define-syntax name
                            (lambda (x)
                              (syntax-case x ()
                                (_ (identifier? x) (syntax xname))
                                ((_ arg (... ...))
                                 (syntax ((fluid-let-syntax
                                            ((name (identifier-syntax xname)))
                                            (lambda formals
                                              form1
                                              form2
                                              ...)) arg (... ...)))))))
                          (define xname
                            (fluid-let-syntax
                              ((name (identifier-syntax xname)))
                              (lambda formals
                                form1
                                form2
                                ...))))))))))
       #t)
     (let ()
       (define-integrable even?
         (lambda (x) (if (= x 0) #t (odd? (- x 1)))))
       (define-integrable odd?
         (lambda (x) (if (= x 0) #f (even? (- x 1)))))
       (and (even? 20) (not (odd? 20))))
     (begin
       (define-syntax define-integrable
         (lambda (x)
           (syntax-case x (lambda)
             [(_ name (lambda formals form1 form2 ...))
              (identifier? #'name)
              #'(begin
                  (define-syntax name
                    (lambda (x)
                      (syntax-case x ()
                        [_ (identifier? x) #'xname]
                        [(_ arg (... ...))
                         #'((fluid-let-syntax
                              ([name (identifier-syntax xname)])
                              (lambda formals
                                form1
                                form2
                                ...)) arg (... ...))])))
                  (define xname
                    (fluid-let-syntax ([name (identifier-syntax xname)])
                      (lambda formals form1 form2 ...))))])))
       #t)
     (let ()
       (define-integrable even?
         (lambda (x) (if (= x 0) #t (odd? (- x 1)))))
       (define-integrable odd?
         (lambda (x) (if (= x 0) #f (even? (- x 1)))))
       (and (even? 20) (not (odd? 20))))
     (begin
       (define-integrable $di-foo
         (lambda (x)
           (if (list? x) (map $di-foo x) (list x))))
       (define-integrable $di-bar
         (lambda (x)
           (if (vector? x)
               (vector-map $di-bar x)
               (vector ($di-foo x)))))
       (equal? (list ($di-bar '#(a b c)) ($di-bar '(1 2 3)))
               '(#(#((a)) #((b)) #((c))) #(((1) (2) (3)))))))

(mat identifier-syntax
     (eqv? (let ([x 0])
             (define-syntax frob
               (identifier-syntax [id (begin (set! x (+ x 1)) x)]
                 [(set! id v) (set! x v)]))
             (let ([n (+ frob frob frob)])
               (set! frob 15)
               (+ n frob)))
           22)
     (begin
       (module (($is-frob x))
         (define x 'initial-x)
         (define-syntax $is-frob
           (make-variable-transformer
             (lambda (z)
               (syntax-case z (set!)
                 [(set! id e) (identifier? #'id) #'(set! x e)]
                 [id (identifier? #'id) #'(vector x)]
                 [(_ a b c ...) #'(set! x (list (cons a b) c ...))])))))
       (equal? $is-frob '#(initial-x)))
     (error? ; invalid syntax
             ($is-frob))
     (error? ; invalid syntax
             ($is-frob 3))
     (error? ; invalid syntax
             (set! $is-frob))
     (error? ; invalid syntax
             (set! $is-frob 3 4))
     (equal? (begin ($is-frob 3 4) $is-frob) '#(((3 . 4))))
     (equal? (begin ($is-frob 3 4 5 6 7) $is-frob) '#(((3 . 4) 5 6 7)))
     (equal? (let () (set! $is-frob 55) $is-frob) '#(55))
     (equal? (let () ($is-frob 'q 'p 'doll) $is-frob) '#(((q . p) doll)))
     (equal? (let ([z (void)])
               (set! $is-frob 44)
               (let ([set! (lambda args (set! z args))])
                 (set! $is-frob 15)
                 (list z $is-frob)))
             '((#(44) 15) #(44))))

(mat with-syntax
     (begin
       (define-syntax foo
         (lambda (x)
           (syntax-case x ()
             [(_ x ...)
              (with-syntax ([n (length (syntax (x ...)))])
                (syntax (list n 'x ...)))])))
       #t)
     (equal? (foo 3 2 1) '(3 3 2 1))
     (equal? (foo 3 2 1) '(3 3 2 1))
     (begin
       (define-syntax foo
         (lambda (x)
           (syntax-case x ()
             [(_ (x ...) ...)
              (with-syntax
                (((len ...) (map length (syntax ((x ...) ...))))
                 (((z ...) ...) (map reverse (syntax ((x ...) ...)))))
                (syntax '((len z ...) ...)))])))
       #t)
     (equal? (foo) '())
     (equal? (foo (a b) (c d e)) '((2 b a) (3 e d c)))
     (error? (expand '(foo . a)))
     (error? (expand '(foo a)))
     (error? (expand '(foo (a b . c) (d e f))))
     (error? (expand '(foo (a b c) . d)))
     (begin
       (define-syntax foo
         (lambda (x)
           (syntax-case x ()
             [(_ x ...)
              (with-syntax ([(y1 y2 ...) (syntax (x ...))])
                (with-syntax ([(z1 z2) (syntax y1)])
                  (syntax '(z2 z1))))])))
       #t)
     (equal? (foo (a b) (c d) (e f)) '(b a))
     (error? (expand '(foo)))
     ;oops: "car: incorrect list structure"
     (error? (expand '(foo a b c)))
     ;oops: "cadr: incorrect list structure"
     (error? (define-syntax foo
               (lambda (x)
                 (syntax-case x ()
                   [(_) (with-syntax ([(x x) '(1 2)]) 0)]))))
     (error? (define-syntax foo
               (lambda (x)
                 (syntax-case x ()
                   [(_) (with-syntax ([x 1] [x 2]) 0)]))))
     (equal? (with-syntax ((x 3)) #'#&x) '#&3)
     (equal? (with-syntax ((x 3)) #'#(x)) '#(3))
     (equal? (list (with-syntax () (define x 3) x) 4) '(3 4))
     (equal? (list (with-syntax ([q 3]) (define x #'q) x) 4) '(3 4))
     (equal? (list (with-syntax ([q 3] [r 5]) (define x #'q) (cons x #'r))
                   4)
             '((3 . 5) 4)))

(mat generate-temporaries
     (error? (generate-temporaries))
     (error? (generate-temporaries '(a b c) '(d e f)))
     (error? (generate-temporaries '(a b . c)))
     (error? (generate-temporaries
               (let ([x (list 'a 'b 'c)])
                 (set-cdr! (cddr x) (cdr x))
                 x)))
     (andmap identifier? (generate-temporaries '(a b c)))
     (= (length (generate-temporaries '(a b c))) 3)
     (andmap identifier? (generate-temporaries #'(a b c)))
     (= (length (generate-temporaries #'(a b c))) 3)
     (andmap identifier? (generate-temporaries (cons 'q #'(1 2 3))))
     (= (length (generate-temporaries (cons 'q #'(1 2 3)))) 4)
     ; make sure generate-temporaries isn't confused by annotations
     (begin
       (let ((op (open-output-file "testfile.ss" 'replace)))
         (pretty-print
           '(begin
              (define-syntax $gt-a
                (lambda (x)
                  (syntax-case x ()
                    [(_ x)
                     (with-syntax ([(t1 t2 t3) (generate-temporaries #'(1 1 1))])
                       #'(define x
                           (let ([t1 17] [t2 53] [t3 -10])
                             (cons* t2 t3 t1))))])))
              ($gt-a $gt-x))
           op)
         (close-output-port op)
         (compile-file "testfile.ss"))
       #t)
     (begin (load "testfile.so") #t)
     (equal? $gt-x '(53 -10 . 17)))

(mat syntax->list
     (error? (syntax->list #'a))
     (error? (syntax->list #'(a b . e)))
     (eq? (syntax->list #'()) '())
     (andmap bound-identifier=?
             (syntax->list #'(a b c))
             (list #'a #'b #'c))
     (not (pair? (car (syntax->list #'((a . b))))))
     ; just for comparison
     (pair? (car (syntax->datum #'((a . b))))))

(mat syntax->vector
     (error? (syntax->vector #'a))
     (error? (syntax->vector #'(a b . e)))
     (eq? (syntax->vector #'#()) '#())
     (andmap bound-identifier=?
       (vector->list (syntax->vector #'#(a b c)))
       (list #'a #'b #'c))
     (not (pair? (vector-ref (syntax->vector #'#((a . b))) 0)))
     ; just for comparison
     (pair? (vector-ref (syntax->datum #'#((a . b))) 0)))

(mat syntax-errors
     (begin
       (define $do-one
         (lambda (x)
           (collect (collect-maximum-generation))
           ; close ports left open by load/compile-file w/mat's error handler
           (let ((op (open-output-file "testfile.ss" 'replace)))
             (fprintf op "   ~%     ")
             (if (string? x)
                 (fprintf op "~a~%" x)
                 (parameterize ((pretty-initial-indent 5))
                   (pretty-print x op)))
             (close-output-port op))
           (load "testfile.ss")))
       #t)

     ; fix "missing definition for exports" error to be like duplicate-id-error
     ; as is, no character position information is given
     (error? ($do-one '(module (y) (define x 3))))

     ; get no character position information for this
     (error? ($do-one '(let ()
                         (define x 3)
                         (define-syntax x
                           (identifier-syntax 4))
                         x)))

     ; these should possibly give position of invalid/duplicate id, not whole form
     (error? ($do-one '(let ()
                         (module (x)
                           (define x 3)
                           (define-syntax x
                             (identifier-syntax 4)))
                         x)))

     (error? ($do-one '(module (x)
                         (define x 3)
                         (define-syntax x
                           (identifier-syntax 4)))))

     (error? ($do-one '(letrec ((3 4)) 5)))

     (error? ($do-one '(letrec-syntax ((3 4)) 5)))

     ; these should be okay:
     (error? ($do-one '(module (x)
                         (module (x)
                           (define a 1)
                           (define a 2)
                           (define x 3)
                           (define x 4)))))

     (error? ($do-one '(a . b)))

     (error? ($do-one '(module (x) (define x 3) (define x 4))))

     (error? ($do-one '(module (x) (module (x) (define x 3) (define x 4)))))

     (error? ($do-one '(letrec ((x 3) (x 4)) x)))

     (error? ($do-one '(letrec-syntax ((x 3) (x 4)) x)))

     (error? ($do-one '(let () (module (x) (define x 3) (define x 4)) x)))

     (error? ($do-one '(let () (define x 3) (define x 4) x)))

     (error? ($do-one '(cond (a . b))))

     (error? ($do-one '(syntax-case (list 'a 'b) (a) ((_ b b) (syntax b)))))

     (error? ($do-one '(syntax-case (list 'a 'b) (a) ((_ a ...) 3 4 5))))

     (error? ($do-one '(syntax-case (list 'a 'b) (a ...) ((_ a ...) 3))))

     (error? ($do-one '(syntax a b)))

     (error? ($do-one '(if a b c d)))

     (error? ($do-one '(letrec ((x 3) (y 4) . (z 5)) (list x y z))))

     (error? ($do-one '(let () ($primitive 4 car))))

     (error? ($do-one '(syntax-case x)))

     (error? ($do-one '(quote a b)))

     (error? ($do-one '(fluid-let-syntax)))

     (error? ($do-one '(letrec-syntax () . 3)))

     (error? ($do-one '(lambda (x x) x)))

     (error? ($do-one '(lambda (x y) . z)))

     (error? ($do-one '(lambda (3) 3)))

     (error? ($do-one '(let ((x 4)) (set! x 3 5) x)))

     (error? ($do-one '(set! x 3 5)))

     (error? ($do-one '(let () (import . x) 3)))

     (error? ($do-one '(import . x)))

     (error? ($do-one '(let () (import (just scheme cons)))))

     (error? ($do-one '(import (just scheme cons))))

     (error? ($do-one '(module ((a . b)) c)))

     (error? ($do-one '(module (a . b) c)))

     (error? ($do-one '(define x y z)))

     (error? ($do-one '(define-syntax x y z)))

     (error? ($do-one '(case-lambda (()))))

     (error? ($do-one '(import m-not-defined)))

     (error? ($do-one '(let () (import m-not-defined) 3)))

     (error? ($do-one '(module () (import m-not-defined))))

     (error? ($do-one '(lambda (x) (define x 3))))

     (begin (define-syntax muck (lambda (x) 'x)) #t)

     (error? ($do-one '(muck)))

     (error? ($do-one '(eval-when (compile load foo) bar)))

     (error? ($do-one '(let ((x 3) (y . 4)) (+ x y))))

     (error? ($do-one '(begin
                         (define-syntax $a
                           (lambda (x)
                             (syntax-case x ()
                               ((_ a b c)
                                (syntax-case #'(a b c) ()
                                  [(_ x y z) (quote (x y z))])))))
                         ($a 1 2 3))))
     ; [
     (error? ($do-one "'(a b (c d])"))
     ; )

     (error? ($do-one '(let ()
                         (define-syntax a
                           (lambda (x)
                             (syntax-case x ()
                               [a (datum->syntax #'a '(if 1))])))
                         a)))

     (error? ($do-one '(let ()
                         (define-syntax a
                           (syntax-rules ()
                             [(_ m i) (module m (i) (import m1))]))
                         (module m1 (xxx) (define xxx 155))
                         (a m2 xxx)
                         (let () (import m2) xxx))))

     (error? ($do-one '(let ()
                         (define-syntax a
                           (lambda (q)
                             #'(let ()
                                 (define x 5)
                                 (define-syntax x
                                   (identifier-syntax 5))
                                 x)))
                         a)))

     (error? ; attempt to assign immutable variable cons
             ($do-one '(begin (set! cons list) (cons 1 2 3))))

     (error? ; attempt to assign immutable variable x
       ($do-one '(begin
                   (library ($selib1)
                     (export (rename (a $selib1-a)))
                     (import (rnrs))
                     (define x 0)
                     (define-syntax a
                       (syntax-rules ()
                         [(_ n) (begin (set! x (+ x n)) x)])))
                   (import ($selib1))
                   ($selib1-a 17))))

     (error? ; attempt to assign immutable variable x
       ($do-one '(begin
                   (library ($selib1)
                     (export (rename (a $selib1-a)))
                     (import (rnrs))
                     (define x 0)
                     (define-syntax a
                       (syntax-rules ()
                         [(_) (begin (set! x (+ x 1)) x)])))
                   (import ($selib1))
                   ($selib1-a))))

     (error? (mat/cf (begin
                       (define-syntax err-test
                         (syntax-rules ()
                           [(_ a b c) (list 'a 'b 'c)]))
                       (err-test "wrong # args"))))

     (error? ($do-one '(let () 3 (module foo ()) 4)))
     (error? ($do-one '(let () 3 (module ()) 4)))
     (error? ($do-one '(let () 3 (import scheme) 4)))
     (error? ($do-one '(let () 3 (import-only scheme) 4)))
     (error? ($do-one '(let () 3 (module . foo) 4)))
     (error? ($do-one '(let () 3 (module) 4)))
     (error? ($do-one '(let () 3 (import . scheme) 4)))
     (error? ($do-one '(let () 3 (import-only . scheme) 4)))

     (error? ($do-one '(let ()
                         (define-syntax foo
                           (syntax-rules () [(_ e) (if e)]))
                         (foo 17))))

     (error? ($do-one `(let ()
                         (define-syntax spam
                           (lambda (x)
                             #`(assert (let-syntax ([q '#,(lambda (x) #f)])
                                         q))))
                         spam)))
     (error? ($do-one '(let ()
                         (define-syntax spam
                           (lambda (x)
                             #`(let-values
                                 ([(a b) (let-syntax ([q '#,(lambda (x) 3)]) q)])
                                 (list a b))))
                         spam)))
     (error? ($do-one '(let ()
                         (define-syntax spam
                           (lambda (x)
                             #'(let ()
                                 (define x 0)
                                 (define y 1)
                                 (define-property x y sort)
                                 (let-values ([(a b c) (values x y)])
                                   (list a b)))))
                         spam))))

; this is identical to the preceding except that $do-one calls compile-file instead
; of load.
(mat syntax-errors2
     (begin
       (define $do-one
         (lambda (x)
           (collect (collect-maximum-generation))
           ; close ports left open by load/compile-file w/mat's error handler
           (let ((op (open-output-file "testfile.ss" 'replace)))
             (fprintf op "   ~%     ")
             (if (string? x)
                 (fprintf op "~a~%" x)
                 (parameterize ((pretty-initial-indent 5))
                   (pretty-print x op)))
             (close-output-port op))
           (compile-file "testfile.ss")
           (load "testfile.so")))
       #t)

     ; fix "missing definition for exports" error to be like duplicate-id-error
     ; as is, no character position information is given
     (error? ($do-one '(module (y) (define x 3))))

     ; get no character position information for this
     (error? ($do-one '(let ()
                         (define x 3)
                         (define-syntax x
                           (identifier-syntax 4))
                         x)))

     ; these should possibly give position of invalid/duplicate id, not whole form
     (error? ($do-one '(let ()
                         (module (x)
                           (define x 3)
                           (define-syntax x
                             (identifier-syntax 4)))
                         x)))

     (error? ($do-one '(module (x)
                         (define x 3)
                         (define-syntax x
                           (identifier-syntax 4)))))

     (error? ($do-one '(letrec ((3 4)) 5)))

     (error? ($do-one '(letrec-syntax ((3 4)) 5)))

     ; these should be okay:
     (error? ($do-one '(module (x)
                         (module (x)
                           (define a 1)
                           (define a 2)
                           (define x 3)
                           (define x 4)))))

     (error? ($do-one '(a . b)))

     (error? ($do-one '(module (x) (define x 3) (define x 4))))

     (error? ($do-one '(module (x) (module (x) (define x 3) (define x 4)))))

     (error? ($do-one '(letrec ((x 3) (x 4)) x)))

     (error? ($do-one '(letrec-syntax ((x 3) (x 4)) x)))

     (error? ($do-one '(let () (module (x) (define x 3) (define x 4)) x)))

     (error? ($do-one '(let () (define x 3) (define x 4) x)))

     (error? ($do-one '(cond (a . b))))

     (error? ($do-one '(syntax-case (list 'a 'b) (a) ((_ b b) (syntax b)))))

     (error? ($do-one '(syntax-case (list 'a 'b) (a) ((_ a ...) 3 4 5))))

     (error? ($do-one '(syntax-case (list 'a 'b) (a ...) ((_ a ...) 3))))

     (error? ($do-one '(syntax a b)))

     (error? ($do-one '(if a b c d)))

     (error? ($do-one '(letrec ((x 3) (y 4) . (z 5)) (list x y z))))

     (error? ($do-one '(let () ($primitive 4 car))))

     (error? ($do-one '(syntax-case x)))

     (error? ($do-one '(quote a b)))

     (error? ($do-one '(fluid-let-syntax)))

     (error? ($do-one '(letrec-syntax () . 3)))

     (error? ($do-one '(lambda (x x) x)))

     (error? ($do-one '(lambda (x y) . z)))

     (error? ($do-one '(lambda (3) 3)))

     (error? ($do-one '(let ((x 4)) (set! x 3 5) x)))

     (error? ($do-one '(set! x 3 5)))

     (error? ($do-one '(let () (import . x) 3)))

     (error? ($do-one '(import . x)))

     (error? ($do-one '(let () (import (just scheme cons)))))

     (error? ($do-one '(import (just scheme cons))))

     (error? ($do-one '(module ((a . b)) c)))

     (error? ($do-one '(module (a . b) c)))

     (error? ($do-one '(define x y z)))

     (error? ($do-one '(define-syntax x y z)))

     (error? ($do-one '(case-lambda (()))))

     (error? ($do-one '(import m-not-defined)))

     (error? ($do-one '(let () (import m-not-defined) 3)))

     (error? ($do-one '(module () (import m-not-defined))))

     (error? ($do-one '(lambda (x) (define x 3))))

     (begin (define-syntax muck (lambda (x) 'x)) #t)

     (error? ($do-one '(muck)))

     (error? ($do-one '(eval-when (compile load foo) bar)))

     (error? ($do-one '(let ((x 3) (y . 4)) (+ x y))))

     (error? ($do-one '(begin
                         (define-syntax $a
                           (lambda (x)
                             (syntax-case x ()
                               ((_ a b c)
                                (syntax-case #'(a b c) ()
                                  [(_ x y z) (quote (x y z))])))))
                         ($a 1 2 3))))
     ; [
     (error? ($do-one "'(a b (c d])"))
     ; )

     (error? ($do-one '(let ()
                         (define-syntax a
                           (lambda (x)
                             (syntax-case x ()
                               [a (datum->syntax #'a '(if 1))])))
                         a)))

     (error? ($do-one '(let ()
                         (define-syntax a
                           (syntax-rules ()
                             [(_ m i) (module m (i) (import m1))]))
                         (module m1 (xxx) (define xxx 155))
                         (a m2 xxx)
                         (let () (import m2) xxx))))

     (error? ($do-one '(let ()
                         (define-syntax a
                           (lambda (q)
                             #'(let ()
                                 (define x 5)
                                 (define-syntax x
                                   (identifier-syntax 5))
                                 x)))
                         a)))

     (error? ; ris #f: attempt to assign immutable variable cons
       ; ris #t: incorrect number of arguments to cons
       ($do-one '(begin (set! cons list) (set! cons #%cons) (cons 1 2 3))))

     (error? ; attempt to assign immutable variable x
       ($do-one '(begin
                   (library ($selib1)
                     (export (rename (a $selib1-a)))
                     (import (rnrs))
                     (define x 0)
                     (define-syntax a
                       (syntax-rules ()
                         [(_ n) (begin (set! x (+ x n)) x)])))
                   (import ($selib1))
                   ($selib1-a 17))))

     (error? ; attempt to assign immutable variable x
       ($do-one '(begin
                   (library ($selib1)
                     (export (rename (a $selib1-a)))
                     (import (rnrs))
                     (define x 0)
                     (define-syntax a
                       (syntax-rules ()
                         [(_) (begin (set! x (+ x 1)) x)])))
                   (import ($selib1))
                   ($selib1-a))))

     (error? (mat/cf (begin
                       (define-syntax err-test
                         (syntax-rules ()
                           [(_ a b c) (list 'a 'b 'c)]))
                       (err-test "wrong # args"))))

     (error? ($do-one '(let () 3 (module foo ()) 4)))
     (error? ($do-one '(let () 3 (module ()) 4)))
     (error? ($do-one '(let () 3 (import scheme) 4)))
     (error? ($do-one '(let () 3 (import-only scheme) 4)))
     (error? ($do-one '(let () 3 (module . foo) 4)))
     (error? ($do-one '(let () 3 (module) 4)))
     (error? ($do-one '(let () 3 (import . scheme) 4)))
     (error? ($do-one '(let () 3 (import-only . scheme) 4)))

     (error? ($do-one '(let ()
                         (define-syntax foo
                           (syntax-rules () [(_ e) (if e)]))
                         (foo 17))))

     ; make sure we don't get complaints from fasl writer due to procedures in the source
     ; information residualzied for the production of errors
     (error? ($do-one `(let ()
                         (define-syntax spam
                           (lambda (x)
                             #`(assert (let-syntax ([q '#,(lambda (x) #f)])
                                         q))))
                         spam)))
     (error? ($do-one '(let ()
                         (define-syntax spam
                           (lambda (x)
                             #`(let-values
                                 ([(a b) (let-syntax ([q '#,(lambda (x) 3)]) q)])
                                 (list a b))))
                         spam)))
     (error? ($do-one '(let ()
                         (define-syntax spam
                           (lambda (x)
                             #'(let ()
                                 (define x 0)
                                 (define y 1)
                                 (define-property x y sort)
                                 (let-values ([(a b c) (values x y)])
                                   (list a b)))))
                         spam))))

(mat define-structure
     (begin (define-structure ($tree left node right)) #t)
     ($tree? (make-$tree 3 4 5))
     (let ((tr (make-$tree 'a 'b 'c)))
       (and (eq? ($tree-left tr) 'a)
            (eq? ($tree-node tr) 'b)
            (eq? ($tree-right tr) 'c)))
     (begin
       (define-structure (pare kar kdr)
         ((original-kar kar) (original-kdr kdr)))
       #t)
     (andmap procedure?
       (list make-pare
             pare?
             pare-kar
             pare-kdr
             pare-original-kar
             pare-original-kdr
             set-pare-kar!
             set-pare-kdr!
             set-pare-original-kar!
             set-pare-original-kdr!))
     (pare? (make-pare 3 4))
     (eq? (pare-kar (make-pare 'a 'b)) 'a)
     (eq? (pare-kdr (make-pare 'a 'b)) 'b)
     (eq? (pare-original-kar (make-pare 'a 'b)) 'a)
     (eq? (pare-original-kdr (make-pare 'a 'b)) 'b)
     (let ((p (make-pare 'a 'b)))
       (set-pare-kar! p 'c)
       (set-pare-kdr! p 'd)
       (and (eq? (pare-kar p) 'c)
            (eq? (pare-kdr p) 'd)
            (eq? (pare-original-kar p) 'a)
            (eq? (pare-original-kdr p) 'b))))

(mat module1
     (begin
       (module $foo ($a) (define $a 4) (define $b 5))
       (import $foo)
       (eq? $a 4))
     (error? (begin
               (module $foo ($a) (define $a 4) (define $b 5))
               (import $foo)
               $b))
     (eq? (let ()
            (module $foo ($a) (define $a 4) (define $b 5))
            (import $foo)
            $a)
          4)
     (error? (let ()
               (module $foo ($a) (define $a 4) (define $b 5))
               (import $foo)
               $b))
     (begin
       (module $foo
         ($a)
         (define-syntax $a (identifier-syntax 4))
         (define-syntax $b (identifier-syntax 5)))
       (import $foo)
       (eq? $a 4))
     (error? (begin
               (module $foo
                 ($a)
                 (define-syntax $a (identifier-syntax 4))
                 (define-syntax $b (identifier-syntax 5)))
               (import $foo)
               $b))
     (eq? (let ()
            (module $foo
              ($a)
              (define-syntax $a (identifier-syntax 4))
              (define-syntax $b (identifier-syntax 5)))
            (import $foo)
            $a)
          4)
     (error? (let ()
               (module $foo
                 ($a)
                 (define-syntax $a (identifier-syntax 4))
                 (define-syntax $b (identifier-syntax 5)))
               (import $foo)
               $b))
     (begin
       (module $foo
         (($a $b))
         (define-syntax $a (identifier-syntax $b))
         (define $b 400))
       (import $foo)
       (eq? $a 400))
     (error? (begin
               (module $foo
                 ($a)
                 (define-syntax $a (identifier-syntax $b))
                 (define $b 400))
               (import $foo)
               $a))
     (eq? (let ()
            (module $foo
              (($a $b))
              (define-syntax $a (identifier-syntax $b))
              (define $b 400))
            (import $foo)
            $a)
          400)
     (eq? (let ()
            (module $foo
              ($a)
              (define-syntax $a (identifier-syntax $b))
              (define $b 400))
            (import $foo)
            $a)
          400)
     (begin
       (define-syntax anonymous-module
         (syntax-rules ()
           ((_ (exp ...) def ...)
            (begin
              (module $tmp (exp ...) def ...)
              (import $tmp)))))
       (anonymous-module ($x) (define $x 3))
       (eq? $x 3))
     (eq? (let () (anonymous-module ($x) (define $x 3)) $x) 3)
     (begin
       (define $y (lambda () $x))
       (anonymous-module ($x) (define $x 3))
       (eq? ($y) 3))
     (eq? (let ()
            (define $y (lambda () $x))
            (anonymous-module ($x) (define $x 3))
            ($y))
          3)
     (begin
       (anonymous-module (ok) (define $y 4) (define ok (lambda () $y)))
       (define $y (lambda () (ok)))
       (eq? ($y) 4))
     ; was an error before change to treat top-level begin like a <body>
     (begin
       (define $y (lambda () (rats)))
       (anonymous-module (rats) (define $y 4) (define rats (lambda () $y)))
       (eqv? ($y) 4))
     (eq? (let ()
            (define $y (lambda () ($x)))
            (anonymous-module ($x) (define $y 4) (define $x (lambda () $y)))
            ($y))
          4)
     (begin
       (anonymous-module ($a) (anonymous-module ($a) (define $a 3)))
       (eq? $a 3))
     (begin
       (anonymous-module ($a)
         (anonymous-module (($a $b))
           (define-syntax $a (identifier-syntax $b))
           (define $b 77)))
       (eq? $a 77))
     (begin
       (define-syntax defconst
         (syntax-rules ()
           ((_ $x e)
            (anonymous-module (($x t))
              (define-syntax $x (identifier-syntax t))
              (define t e)))))
       (defconst $a 3)
       (eq? $a 3))
     (error? (set! $a 4))
     (begin
       (module $qq ($q) (defconst $q 53))
       (eq? (let () (import $qq) $q) 53))
     (error? (let () (import $qq) (set! $q 4)))
     (begin (import $qq) (eq? $q 53))
     (error? (set! $q 4))
     ; repeat last set of tests for built-in anonymous modules
     (begin (module ($x) (define $x 3)) (eq? $x 3))
     (eq? (let () (module ($x) (define $x 3)) $x) 3)
     (begin
       (define $y (lambda () $x))
       (module ($x) (define $x 3))
       (eq? ($y) 3))
     (eq? (let ()
            (define $y (lambda () $x))
            (module ($x) (define $x 3))
            ($y))
          3)
     (begin
       (module (ok) (define $y 4) (define ok (lambda () $y)))
       (define $y (lambda () (ok)))
       (eq? ($y) 4))
     ; was an error before change to treat top-level begin like a <body>
     (begin
       (define $y (lambda () (mice)))
       (module (mice) (define $y 4) (define mice (lambda () $y)))
       (eqv? ($y) 4))
     (eq? (let ()
            (define $y (lambda () ($x)))
            (module ($x) (define $y 4) (define $x (lambda () $y)))
            ($y))
          4)
     (begin
       (module ($a) (module ($a) (define $a 3)))
       (eq? $a 3))
     (begin
       (module ($a)
         (module (($a $b))
           (define-syntax $a (identifier-syntax $b))
           (define $b 77)))
       (eq? $a 77))
     (begin
       (define-syntax defconst
         (syntax-rules ()
           ((_ $x e)
            (module (($x t))
              (define-syntax $x (identifier-syntax t))
              (define t e)))))
       (defconst $a 3)
       (eq? $a 3))
     (error? (set! $a 4))
     (begin
       (module $qq ($q) (defconst $q 53))
       (eq? (let () (import $qq) $q) 53))
     (error? (let () (import $qq) (set! $q 4)))
     (begin (import $qq) (eq? $q 53))
     (error? (set! $q 4))
     (begin
       (module $prom
         ((del make-$prom) frc)
         (define-syntax del
           (syntax-rules ()
             ((_ exp) (make-$prom (lambda () exp)))))
         (define frc (lambda ($prom) ($prom)))
         (define make-$prom
           (lambda (th)
             (let ([val #f] [forced? #f])
               (lambda ()
                 (if forced?
                     val
                     (let ([e (th)])
                       (set! forced? #t)
                       (set! val e)
                       e)))))))
       (module $tofu
         ($lazy-let)
         (import $prom)
         (define-syntax $lazy-let
           (lambda (form)
             (syntax-case form ()
               [(_ ((v e) ...) e1 e2 ...)
                #'(let ([v (del e)] ...)
                    (let-syntax ((v (identifier-syntax (frc v))) ...)
                      e1
                      e2
                      ...))]))))
       (module $test
         ($a)
         (import $tofu)
         (define-syntax push!
           (syntax-rules ()
             ((_ $x ls) (set! ls (cons $x ls)))))
         (define $a
           (lambda ()
             (let ((ls '()))
               (let ((w ($lazy-let
                          (($x (begin (push! '$x ls) '$x))
                           ($y (begin (push! '$y ls) '$y))
                           ($z (begin (push! '$z ls) '$z)))
                          (if $x (list $x $y) $z))))
                 (append w ls))))))
       (equal? (let () (import $test) ($a)) '($x $y $y $x)))
     (begin (import $test) (equal? ($a) '($x $y $y $x)))
     (error? (let () (module () (define $a 3) (define-syntax $a list)) 5))
     (eqv? (let ()
             (module $a ($x) (define $x 3) (set! $x (+ $x 1)))
             (import $a)
             $x)
           4)
     (eq? (let ()
            (module $foo
              ($a)
              (module $a
                ($b)
                (define-syntax $a (identifier-syntax $b))
                (define-syntax $b (identifier-syntax $c))
                (define $c 7)))
            (import $foo)
            (import $a)
            $b)
          7)
     (eq? (let ()
            (module $foo ($a) (module $a ($x) (define $x 3)))
            (import $foo)
            (import $a)
            $x)
          3)
     (begin
       (module $foo ($a) (module $a ($x) (define $x 3)))
       (import $foo)
       (import $a)
       (eq? $x 3))
     (error? (begin
               (module $foo
                 ($a)
                 (module $a
                   ($b)
                   (define-syntax $a (identifier-syntax $b))
                   (define-syntax $b (identifier-syntax $c))
                   (define $c 7)))
               (import $foo)
               (import $a)
               $b))
     (begin
       (module $foo
         ($a)
         (module $a
           (($b $c))
           (define-syntax $a (identifier-syntax $b))
           (define-syntax $b (identifier-syntax $c))
           (define $c 7)))
       (import $foo)
       (import $a)
       (eq? $b 7))
     (error? (begin
               (module $foo
                 ($a)
                 (module $a
                   (($b $c))
                   (define-syntax $a (identifier-syntax $c))
                   (define-syntax $b (identifier-syntax $a))
                   (define $c 7)))
               (import $foo)
               (import $a)
               (eq? $b 7)))
     (error? (begin
               (module $foo
                 ($a)
                 (module $a
                   (($b $a))
                   (define-syntax $a (identifier-syntax $c))
                   (define-syntax $b (identifier-syntax $a))
                   (define $c 7)))
               (import $foo)
               (import $a)
               (eq? $b 7)))
     (begin
       (module $foo
         ($a)
         (module $a
           (($b ($a $c)))
           (define-syntax $a (identifier-syntax $c))
           (define-syntax $b (identifier-syntax $a))
           (define $c 7)))
       (import $foo)
       (import $a)
       (eq? $b 7))
     (begin
       (module $foo
         ($a)
         (module $a
           (($b $a $c))
           (define-syntax $a (identifier-syntax $c))
           (define-syntax $b (identifier-syntax $a))
           (define $c 7)))
       (import $foo)
       (import $a)
       (eq? $b 7))
     (begin
       (module $foo
         ($a)
         (module $a
           (($b $a))
           (module (($a $c))
             (define-syntax $a (identifier-syntax $c))
             (define $c 7))
           (define-syntax $b (identifier-syntax $a))))
       (import $foo)
       (import $a)
       (eq? $b 7))
     (error? (begin
               (module $foo
                 ($a)
                 (define-syntax $a (identifier-syntax $b))
                 (define-syntax $b (identifier-syntax 4)))
               (import $foo)
               $a))
     (eq? (let ()
            (module $foo
              ($a)
              (define-syntax $a (identifier-syntax $b))
              (define-syntax $b (identifier-syntax $c))
              (define $c 7))
            (import $foo)
            $a)
          7)
     (eq? (let ()
            (module $foo
              ($y)
              (module $x
                ($y)
                (define-syntax $y (identifier-syntax $z))
                (define $z 4))
              (import $x))
            (import $foo)
            $y)
          4)
     (eq? (let ()
            (module $foo
              ($y)
              (module $x
                (($y $z))
                (define-syntax $y (identifier-syntax $z))
                (define $z 4))
              (import $x))
            (import $foo)
            $y)
          4)
     (error? (begin
               (module $foo
                 ($y)
                 (module $x
                   ($y)
                   (define-syntax $y (identifier-syntax $z))
                   (define $z 4))
                 (import $x))
               (import $foo)
               $y))
     (begin
       (module $foo
         ($y)
         (module $x
           (($y $z))
           (define-syntax $y (identifier-syntax $z))
           (define $z 4))
         (import $x))
       (import $foo)
       (eq? $y 4))
     (eq? (let ()
            (module $foo
              ($y)
              (module $x
                ($y $z)
                (define-syntax $y (identifier-syntax $z))
                (define $z 4))
              (import $x))
            (import $foo)
            $y)
          4)
     (error? (begin
               (module $foo
                 ($y)
                 (module $x
                   ($y $z)
                   (define-syntax $y (identifier-syntax $z))
                   (define $z 44))
                 (import $x))
               (import $foo)
               (eq? $y 44)))
     (begin
       (module $foo
         ($y)
         (module $x
           (($y $z) $z)
           (define-syntax $y (identifier-syntax $z))
           (define $z 44))
         (import $x))
       (import $foo)
       (eq? $y 44))
     (begin
       (module $foo
         (($y $z))
         (module $x
           ($y $z)
           (define-syntax $y (identifier-syntax $z))
           (define $z 44))
         (import $x))
       (import $foo)
       (eq? $y 44))
     (error? (let ()
               (module $foo
                 (($y $z))
                 (module (($y $z))
                   (define-syntax $y (identifier-syntax $z))
                   (define $z 4)))
               (import $foo)
               $y))
     (error? ; undefined export $y
       (let ()
         (module $foo
           (($y $z))
           (define-syntax $y (identifier-syntax $z))
           (module ($y))
           (define $z 4))
         (import $foo)
         $y))
     (error? ; undefined export $z
       (let ()
         (module $foo
           ($y)
           (module (($y $z)) (define-syntax $y (identifier-syntax $z)))
           (define $z 4))
         (import $foo)
         $y))
     ; following demonstrates "recursive" modules
     (equal? (let ()
               (module $one
                 ($e)
                 (define $e
                   (lambda ($x)
                     (or (zero? $x) ($o (- $x 1))))))
               (module $two ($o) (define $o (lambda ($x) (not ($e $x)))))
               (import $one)
               (import $two)
               (map (lambda ($x) (list ($o $x) ($e $x)))
                    '(0 1 2 3 4 5)))
             '((#f #t) (#t #f) (#f #t) (#t #f) (#f #t) (#t #f)))
     ; "recursive" modules don't work at top level ...
     (error? (begin
               (module $one
                 ($e)
                 (define $e
                   (lambda ($x)
                     (or (zero? $x) ($o (- $x 1))))))
               (module $two ($o) (define $o (lambda ($x) (not ($e $x)))))
               (import $one)
               (import $two)
               (map (lambda ($x) ($o $x)) '(0 1 2 3 4 5))))
     ; ... unless encapsulated within a top-level module
     (begin
       (module ($e $o)
         (module $one
           ($e)
           (define $e
             (lambda ($x) (or (zero? $x) ($o (- $x 1))))))
         (module $two ($o) (define $o (lambda ($x) (not ($e $x)))))
         (import $one)
         (import $two))
       (equal? (map (lambda ($x) (list ($o $x) ($e $x))) '(0 1 2 3 4 5))
               '((#f #t) (#t #f) (#f #t) (#t #f) (#f #t) (#t #f))))
     ; the following set of tests, as with many others above, highlights the
     ; difference between the flexibility of local and rigidness of global
     ; export rules.  for the global, we need to explicitly list the implicit
     ; exports; for the global, we do not.
     (eq? (let ()
            (module $a
              ($alpha)
              (define-syntax $alpha (identifier-syntax $x))
              (module $b ($x) (define $x 3))
              (import $b))
            (import $a)
            $alpha)
          3)
     (error? (begin
               (module $a
                 ($alpha)
                 (define-syntax $alpha
                   (identifier-syntax $x))
                 (module $b ($x) (define $x 3))
                 (import $b))
               (import $a)
               $alpha))
     (begin
       (module $a
         (($alpha $x))
         (define-syntax $alpha (identifier-syntax $x))
         (module $b ($x) (define $x 3))
         (import $b))
       (import $a)
       (eq? $alpha 3))
     (equal? (let ()
               (define $x "current outer value of $x")
               (let ()
                 (module $a
                   ($alpha)
                   (define-syntax $alpha
                     (identifier-syntax $x))
                   (module $b ($y) (define $y 445) (define $x 3))
                   (import $b))
                 (import $a)
                 $alpha))
             "current outer value of $x")
     (begin
       (define $x "current outer value of $x")
       (module $a
         ($alpha)
         (define-syntax $alpha (identifier-syntax $x))
         (module $b ($y) (define $y 445) (define $x 3))
         (import $b))
       (import $a)
       (equal? $alpha "current outer value of $x"))
     (begin
       (define-syntax $beta
         (syntax-rules ()
           ((_ x y)
            (begin
              (module x ($beta-a) (define $beta-a 666))
              (import x)
              (define-syntax y (identifier-syntax $beta-a))))))
       (eqv? (let () ($beta q t) t) 666))
     (error? (let () ($beta q t) $beta-a))
     (begin
       (define-syntax $gamma
         (syntax-rules ()
           ((_ x y)
            (begin
              (module x ($aaa) (define $aaa 666))
              (define y (lambda () (import x) $aaa))))))
       (eq? (let () ($gamma q t) (t)) 666))
     (error? (let () ($gamma q t) (import q) $aaa))
     (begin ($gamma $q $t) #t)
     (eqv? ($t) 666)
     (error? (let () (import $q) $aaa))
     (error? (begin (import $q) (eq? $aaa 666)))
     (error? (begin
               (define-syntax a
                 (lambda (x)
                   (syntax-case x () ((_ e) #'(define x e)))))
               (a 3)))
     (error? (begin
               (define-syntax a
                 (lambda (x)
                   (syntax-case x ()
                     ((_ e) #'(define-syntax x e)))))
               (a (identifier-syntax 4))))
     (error? (begin
               (define-syntax a
                 (lambda (x)
                   (syntax-case x ()
                     ((_ i e) #'(module x (i) (define i e))))))
               (a b 'c)))
     (error? ; defnie not defined
       (module (y) (import-only (rnrs)) (defnie x 3) (define y 4))))

(mat module2
     (begin
       (define-syntax $define-structure
         (lambda (x)
           (define construct-name
             (lambda (template-identifier . args)
               (datum->syntax template-identifier
                 (string->symbol
                   (apply string-append
                     (map (lambda (x)
                            (if (string? x)
                                x
                                (symbol->string (syntax->datum x))))
                          args))))))
           (syntax-case x ()
             ((_ (name id1 ...))
              (andmap identifier? (syntax (name id1 ...)))
              (with-syntax
                ((constructor
                   (construct-name (syntax name) "make-" (syntax name)))
                 (predicate
                   (construct-name (syntax name) (syntax name) "?"))
                 ((access ...)
                  (map (lambda (x) (construct-name x (syntax name) "-" x))
                       (syntax (id1 ...))))
                 ((assign ...)
                  (map (lambda (x)
                         (construct-name x "set-" (syntax name) "-" x "!"))
                       (syntax (id1 ...))))
                 (structure-length (+ (length (syntax (id1 ...))) 1))
                 ((index ...)
                  (let f ((i 1) (ids (syntax (id1 ...))))
                    (if (null? ids)
                        '()
                        (cons i (f (+ i 1) (cdr ids)))))))
                (syntax (begin
                          (module name
                            (constructor access ...)
                            (define constructor
                              (lambda (id1 ...)
                                (vector 'name id1 ...)))
                            (define access
                              (lambda (x)
                                (vector-ref x index)))
                            ...)
                          (import name))))))))
       (module $foo
         ($foos build-$foos)
         ($define-structure ($foos x))
         (define (build-$foos) (make-$foos 3)))
       (let ()
         (import $foo)
         (import $foos)
         (define x (build-$foos))
         (define y (make-$foos 4))
         (equal? (list ($foos-x x) ($foos-x y)) '(3 4))))
     (begin
       (import $foo)
       (import $foos)
       (define $x (build-$foos))
       (define $y (make-$foos 4))
       (equal? (list ($foos-x $x) ($foos-x $y)) '(3 4)))
     (let ()
       (define-syntax $define-structure
         (lambda (x)
           (define construct-name
             (lambda (template-identifier . args)
               (datum->syntax template-identifier
                 (string->symbol
                   (apply string-append
                     (map (lambda (x)
                            (if (string? x)
                                x
                                (symbol->string (syntax->datum x))))
                          args))))))
           (syntax-case x ()
             ((_ (name id1 ...))
              (andmap identifier? (syntax (name id1 ...)))
              (with-syntax
                ((constructor
                   (construct-name (syntax name) "make-" (syntax name)))
                 (predicate
                   (construct-name (syntax name) (syntax name) "?"))
                 ((access ...)
                  (map (lambda (x) (construct-name x (syntax name) "-" x))
                       (syntax (id1 ...))))
                 ((assign ...)
                  (map (lambda (x)
                         (construct-name x "set-" (syntax name) "-" x "!"))
                       (syntax (id1 ...))))
                 (structure-length (+ (length (syntax (id1 ...))) 1))
                 ((index ...)
                  (let f ((i 1) (ids (syntax (id1 ...))))
                    (if (null? ids)
                        '()
                        (cons i (f (+ i 1) (cdr ids)))))))
                (syntax (begin
                          (module name
                            (constructor access ...)
                            (define constructor
                              (lambda (id1 ...)
                                (vector 'name id1 ...)))
                            (define access
                              (lambda (x)
                                (vector-ref x index)))
                            ...)
                          (import name))))))))
       (module $foo
         ($foos build-$foos)
         ($define-structure ($foos x))
         (define (build-$foos) (make-$foos 3)))
       (import $foo)
       (import $foos)
       (let ()
         (define x (build-$foos))
         (define y (make-$foos 4))
         (equal? (list ($foos-x x) ($foos-x y)) '(3 4)))))

(mat module3
     (equal? (let ()
               (module foo (thing) (define thing #f))
               (define set
                 (lambda (x) (import foo) (set! thing x)))
               (define get (lambda () (import foo) thing))
               (let ([before (get)])
                 (set 37)
                 (list before (get))))
             '(#f 37))
     (eqv? (let ()
             (module foo (thing) (define thing #f))
             (define get (lambda () (import foo) thing))
             (import foo)
             (set! thing 37)
             (get))
           37)
     (eqv? (let ()
             (define x 45)
             (define-syntax def
               (identifier-syntax (define x 123)))
             (define-syntax fof
               (identifier-syntax (let () def x)))
             fof)
           45)
     (eqv? (let ()
             (define x 45)
             (define-syntax def
               (identifier-syntax (define x 123)))
             (define-syntax fof
               (identifier-syntax (let () def x)))
             (let () fof))
           45)
     (eqv? (let ()
             (define x 45)
             (define-syntax fof
               (identifier-syntax (let () (define x 123) x)))
             (let () fof))
           123)
     (eqv? (let ()
             (define x 45)
             (define-syntax def
               (identifier-syntax (begin (define x 123) (set! x (+ x x)))))
             (define-syntax fof
               (identifier-syntax (let () def x)))
             (let () fof))
           45)
     (eqv? (let ()
             (define x 45)
             (define-syntax def
               (syntax-rules () ((_ id) (define id 123))))
             (define-syntax fof
               (identifier-syntax (let () (def x) x)))
             (let () fof))
           123)
     (eqv? (let ()
             (define x 45)
             (define-syntax fof
               (identifier-syntax
                 (let ()
                   (define-syntax def
                     (identifier-syntax (define x 123)))
                   def
                   x)))
             (let () fof))
           45)
     (eqv? (let ()
             (define x 45)
             (define-syntax def
               (identifier-syntax (define x 123)))
             (define-syntax ref (identifier-syntax x))
             (let () def ref))
           45)
     (eqv? (let ()
             (define x 45)
             (define-syntax fof
               (identifier-syntax
                 (let ()
                   (define-syntax def
                     (lambda (x)
                       (syntax-case x ()
                         [id (identifier? #'id)
                             (with-syntax ([var (datum->syntax #'id 'x)])
                               #'(define var 123))])))
                   def
                   x)))
             (let () fof))
           123)
     (eqv? (let ()
             (define x 45)
             (define-syntax zorpon
               (identifier-syntax define))
             (define-syntax fof
               (identifier-syntax (let () (zorpon x 123) x)))
             (let () fof))
           123)
     (eqv? (let ()
             (define x 45)
             (define-syntax def
               (identifier-syntax (zorpon x 123)))
             (define-syntax fof
               (identifier-syntax (let () def x)))
             (let ()
               (fluid-let-syntax ((zorpon (identifier-syntax define))) fof)))
           45)
     (equal? (let ()
               (module foo (x) (define x 3))
               (define-syntax blah
                 (lambda (x)
                   (syntax-case x ()
                     [id (identifier? #'id)
                         (with-syntax
                           ([output (datum->syntax #'id '(let ()
                                                           (import foo)
                                                           x))])
                           #'output)])))
               (cons blah (let () blah)))
             '(3 . 3))
     (equal? (let ()
               (module foo (x) (define x 3))
               (module bar (x) (define x 5))
               (define-syntax get
                 (lambda (x)
                   (syntax-case x ()
                     [(_ mod)
                      (identifier? #'mod)
                      (with-syntax ([var (datum->syntax #'mod 'x)])
                        #'(let () (import mod) var))])))
               (cons (get bar) (let () (get foo))))
             '(5 . 3))
     (equal? (let ()
               (module foo (x) (define x 3))
               (module bar (x) (define x 5))
               (define-syntax get
                 (syntax-rules ()
                   ((_ mod id) (let () (import mod) id))))
               (cons (get bar x) (let () (get foo x))))
             '(5 . 3))
     (equal? (let ((x 1))
               (module foo (x) (define x 3))
               (module bar (x) (define x 5))
               (define-syntax get-x
                 (syntax-rules ()
                   ((_ mod) (let () (import mod) x))))
               (cons (get-x bar) (let () (get-x foo))))
             '(1 . 1)))

(mat module4
     (equal? (let ()
               (define-syntax import*
                 (lambda (x)
                   (syntax-case x ()
                     [(_ mid) #'(import mid)]
                     [(_ mid s1 s2 ...)
                      (with-syntax
                        ((((id ...) d ...)
                          (let f ((ls #'(s1 s2 ...)))
                            (if (null? ls)
                                '(())
                                (let ((rest (f (cdr ls))))
                                  (syntax-case (car ls) (as)
                                    [(as id1 id2)
                                     (cons (cons #'id2 (car rest))
                                           (cons #'(define-syntax id2
                                                     (identifier-syntax id1))
                                                 (cdr rest)))]
                                    [id (identifier? #'id)
                                        (cons (cons #'id (car rest))
                                              (cdr rest))]))))))
                        #'(module (id ...) (import mid) d ...))])))
               (module m1 (x y) (define x 'x) (define y 'y))
               (list (let () (import* m1) (cons x y))
                     (let () (import* m1 x y) (cons x y))
                     (let ()
                       (import* m1 x)
                       (define y 'yy)
                       (cons x y))
                     (let ((x 'outer))
                       (import* m1 (as x xx) y)
                       (list* x xx y))))
             '((x . y) (x . y) (x . yy) (outer x . y))))

(mat module5
     (begin
       (module $zip
         (a b c)
         (define a 1)
         (define b 123)
         (define-syntax c (identifier-syntax (list a b))))
       (equal? (let () (import $zip) (list a b c)) '(1 123 (1 123))))
     (eq? (let () (import-only $zip) a) 1)
     (error? (let () (import-only $zip) (list a b c)))
     (error? (let ((z list)) (import-only $zip) (z a b c)))
     (equal? (let ()
               (module bar
                 (q r s)
                 (import $zip)
                 (define q (lambda () a))
                 (define-syntax r (identifier-syntax b))
                 (define s (lambda () c)))
               (list (let () (import bar) (q))
                     (let () (import bar) r)
                     (let () (import bar) (s))
                     (let () (module (r) (import bar)) r)))
             '(1 123 (1 123) 123))
     (error? (let ()
               (module bar
                 (q r s)
                 (import $zip)
                 (define q (lambda () a))
                 (define-syntax r (identifier-syntax b))
                 (define s (lambda () c)))
               (let ((q "outer"))
                 (module (r) (import bar))
                 (q))))
     (begin
       (module $zoom
         (m1 x)
         (define x "this is x")
         (module m1
           (x (z y))
           (define x "this is m1's x")
           (define y "this is m1's y")
           (define-syntax z (identifier-syntax y))))
       (equal? (let ()
                 (import $zoom)
                 (let ((q x)) (import m1) (list q x z)))
               '("this is x" "this is m1's x" "this is m1's y")))
     (error? (let () (import $zoom) (define q x) (import m1) (list q x z)))
     ; check that we get the right x even though x (et al.) have
     ; multiple properties in the implementation.
     (begin
       (module $foo
         (x a b c)
         (define x "this is foo's X")
         (define a "this is foo's A")
         (define b "this is foo's B")
         (define c "this is foo's C"))
       (equal? (list (let () (import $foo) (list x a))
                     (let () (import $foo) (list b c)))
               '(("this is foo's X" "this is foo's A")
                 ("this is foo's B" "this is foo's C"))))
     (error? (let () (import $foo) (import $zip) #t)))

(mat module6
     (begin
       (define-syntax $from1
         (syntax-rules ()
           ((_ m id) (let () (import-only m) id))))
       (define-syntax $from2
         (syntax-rules ()
           ((_ m id) (let () (module (id) (import m)) id))))
       (define-syntax $from3
         (syntax-rules ()
           [(_ m id)
            (let ([z (cons 1 2)])
              (let ([id z])
                (import m)
                (let ([t id])
                  (if (eq? t z)
                      (errorf 'from "~s undefined" 'id)
                      t))))]))
       (module $frappe
         (wire (whip egg))
         (define wire 3)
         (define-syntax whip (identifier-syntax egg))
         (define egg 'whites))
       (equal? (list (cons ($from1 $frappe wire) ($from1 $frappe whip))
                     (cons ($from2 $frappe wire) ($from2 $frappe whip))
                     (cons ($from3 $frappe wire) ($from3 $frappe whip)))
               '((3 . whites) (3 . whites) (3 . whites))))
     (equal? (let ()
               (module q
                 (m from)
                 (module m (f) (define f "this is f"))
                 (define-syntax from
                   (syntax-rules ()
                     [(_ m id) (let () (import-only m) id)])))
               (let () (import-only q) (from m f)))
             "this is f")
     (begin
       (module $q
         (m from)
         (module m (f) (define f "this is f"))
         (define-syntax from
           (syntax-rules ()
             [(_ m id) (let () (import-only m) id)])))
       (equal? (let () (import-only $q) (from m f)) "this is f"))
     (eqv? (let ()
             (module p
               ((d m) f)
               (define-syntax d
                 (syntax-rules () ((_ e) (m (lambda () e)))))
               (define m (lambda (x) x))
               (define f (lambda (th) (th))))
             (let () (import-only p) (f (d 2))))
           2)
     (begin
       (module $p
         ((d m) f)
         (define-syntax d
           (syntax-rules () ((_ e) (m (lambda () e)))))
         (define m (lambda (x) x))
         (define f (lambda (th) (th))))
       (eqv? (let () (import-only $p) (f (d 2))) 2))
     (error? (let () (import-only $p) (f (d cons)))))

(mat module7
     (begin
       (module ($x) (define $x 3) (set! $x (+ $x $x)))
       (eq? $x 6))
     (eq? (let () (module ($x) (define $x 3) (set! $x (+ $x $x))) $x) 6))

(mat module8
     (begin
       (module $m
         ($a $b)
         (define-syntax $a (identifier-syntax 3))
         (define-syntax $b (identifier-syntax $a)))
       (eq? (let ()
              (import $m)
              (fluid-let-syntax (($a (identifier-syntax 4))) $b))
            4))
     (eq? (let ()
            (import $m)
            (fluid-let-syntax (($a (identifier-syntax 4))) $a))
          4)
     (begin
       (import $m)
       (eq? (fluid-let-syntax (($a (identifier-syntax 4))) $b) 4))
     (begin
       (define-syntax $a
         (syntax-rules ()
           ((_ m y z)
            (begin
              (module m ($crazy-x) (define $crazy-x 3731))
              (import m)
              (define y (lambda () $crazy-x))
              (define-syntax z (identifier-syntax $crazy-x))))))
       #t)
     (begin
       ($a $crazy-p $crazy-q $crazy-r)
       (eq? $crazy-r 3731))
     (error? $crazy-x)
     (eq? ($crazy-q) 3731)
     (eq? $crazy-r 3731)
     (begin
       (define-syntax $a1
         (syntax-rules ()
           ((_ m y)
            (module m
              ($flash-x y)
              (define $flash-x "flash")
              (define y (lambda () $flash-x))))))
       #t)
     (begin ($a1 $flash-p $flash-q) #t)
     (begin (import $flash-p) (procedure? $flash-q))
     (error? $flash-x)
     (equal? ($flash-q) "flash")
     (begin
       (define-syntax $c
         (syntax-rules ()
           ((_ y)
            (begin
              (define-syntax $blast-x (identifier-syntax "blast"))
              (define-syntax y (identifier-syntax $blast-x))))))
       #t)
     (begin ($c $blast-y) (equal? $blast-y "blast"))
     (equal? $blast-y "blast")
     (error? $blast-x)
     (begin
       (define-syntax $b
         (syntax-rules ()
           ((_ y)
            (begin
              (define $crud-x "crud")
              (define y (lambda () $crud-x))))))
       #t)
     (begin ($b $crud-y) (procedure? $crud-y))
     (equal? ($crud-y) "crud")
     (error? $crud-x)
     (begin
       (define-syntax $b2
         (syntax-rules ()
           ((_ x y)
            (begin
              (define-syntax x
                (identifier-syntax
                  (begin (define $idiot-x "idiot") $idiot-x)))
              (define y (lambda () $idiot-x))))))
       #t)
     (begin ($b2 $idiot-q $idiot-p) (procedure? $idiot-p))
     (equal? (let () $idiot-q) "idiot")
     (begin $idiot-q #t)
     (error? ($idiot-p))
     ; the following should probably generate an error, but doesn't due to
     ; our change in wraps (we apply only the most recent substitution)
     ; (error?
     ;   (begin
     ;     (define-syntax a
     ;       (lambda (?)
     ;         (with-syntax ((xx ((lambda (x) #'x) 4)))
     ;           #'(module (x) (define xx 3)))))
     ;     a))
     (eq? (let ((junk #f))
            (module (a)
              (import scheme)
              (define-syntax a
                (lambda (x)
                  (syntax-case x (foo car)
                    ((_ foo car bar-lit cons-lit)
                     (and (free-identifier=? #'bar-lit #'bar)
                          (free-identifier=? #'cons-lit #'cons))
                     #''yup)))))
            (module () (import scheme) (set! junk (a foo car bar cons)))
            junk)
          'yup)
     (error? (let ((junk #f))
               (module (a)
                 (import scheme)
                 (define-syntax a
                   (lambda (x)
                     (syntax-case x (foo car)
                       ((_ foo car bar-lit cons-lit)
                        (and (free-identifier=? #'bar-lit #'bar)
                             (free-identifier=? #'cons-lit #'cons))
                        #''yup)))))
               (module ()
                 (import scheme)
                 (define car 3)
                 (set! junk (a foo car bar cons)))
               junk)))

(mat module9
     (eq? (let () (import-only r5rs) (cond (else 0))) 0)
     (eq? (let () (import-only r5rs-syntax) (cond (else 0))) 0)
     (eq? (let () (import-only ieee) (cond (else 0))) 0)
     (eq? (let () (import-only scheme) (cond (else 0))) 0)
     (eq? (let () (import-only $system) (cond (else 0))) 0)
     (eq? (eval '(cond (else 0)) (scheme-report-environment 5)) 0)
     (eq? (eval '(cond (else 0)) (null-environment 5)) 0)
     (eq? (eval '(cond (else 0)) (interaction-environment)) 0)
     (eq? (eval '(cond (else 0)) (ieee-environment)) 0)
     (equal? (let ()
               (import-only scheme)
               (define-record foo ((immutable a)))
               (foo-a (make-foo 3)))
             3)
     (equal? (let ()
               (module foo
                 (a b)
                 (define-syntax a
                   (syntax-rules (b)
                     ((_ b) "yup")
                     ((_ c) (list c))))
                 (define-syntax b
                   (lambda (x)
                     (syntax-error x "misplaced aux keyword"))))
               (let () (import-only foo) (a (a b))))
             '("yup"))
     (equal? (let () (import-only scheme) `(a b ,(+ 3 4) ,@(list 'd 'e)))
             '(a b 7 d e))
     ; assuming internal-defines-as-letrec* defaults to #t
     (internal-defines-as-letrec*)
     ; following tests assume it's set to #f
     (begin
       (internal-defines-as-letrec* #f)
       (not (internal-defines-as-letrec*)))
     (error? ; cookie undefined
       (begin
         (module ($b)
           (module (($b getvar))
             (define getvar (lambda () "it worked"))
             (module (($b cookie tmp))
               (define cookie "secret")
               (define tmp cookie)
               (define-syntax $b
                 (identifier-syntax
                   (if (eq? tmp cookie)
                       (begin (set! tmp (getvar)) tmp)
                       tmp))))))
         (string=? $b "it worked")))
     (begin
       (internal-defines-as-letrec* #t)
       (internal-defines-as-letrec*))
     (begin
       (module ($b)
         (module (($b getvar))
           (define getvar (lambda () "it worked"))
           (module (($b cookie tmp))
             (define tmp)
             (define cookie "secret")
             (define-syntax $b
               (identifier-syntax
                 (if (eq? tmp cookie)
                     (begin (set! tmp (getvar)) tmp)
                     tmp)))
             (set! tmp cookie))))
       (string=? $b "it worked"))
     (begin
       (module $foo
         ($b)
         (module bar
           (($b getvar))
           (module baz
             (($b cookie tmp))
             (define cookie "secret")
             (define tmp)
             (define-syntax $b
               (identifier-syntax
                 (if (eq? tmp cookie)
                     (begin (set! tmp (getvar)) tmp)
                     tmp)))
             (set! tmp cookie))
           (define getvar (lambda () "this also worked"))
           (import baz))
         (import bar))
       (import $foo)
       (string=? $b "this also worked")))

(mat module10
     (begin
       ; make sure we the right binding is exported
       (module ($module10-foo)
         (define $module10-foo "okay")
         (module () (define $module10-foo 'oh-oh)))
       #t)
     (equal? $module10-foo "okay")
     (begin
       (module ($module10-bar)
         (module () (define $module10-bar 'oh-oh))
         (define $module10-bar "fine"))
       #t)
     (equal? $module10-bar "fine")
     (begin
       (module ($module10-qwerty)
         (module ($module10-qwerty) (define $module10-qwerty "dandy")))
       #t)
     (equal? $module10-qwerty "dandy")
     (let ()
       (module (foo) (define foo "okay") (module () (define foo 'oh-oh)))
       (equal? foo "okay"))
     (let ()
       (module (bar) (module () (define bar 'oh-oh)) (define bar "fine"))
       (equal? bar "fine"))
     (let ()
       (module (qwerty) (module (qwerty) (define qwerty "dandy")))
       (equal? qwerty "dandy")))

(mat module11
     (error? ; identifier out of context
             (module (x y) (define x 3) (define-syntax y (lambda (z) x))))
     (error? ; identifier out of context
       (let ()
         (module (x y) (define x 3) (define-syntax y (lambda (z) x)))
         y)))

(mat with-implicit
     (error? ; invalid syntax
             (with-implicit))
     (error? ; invalid syntax
             (with-implicit foo (bar ...) e1 e2))
     (error? ; invalid syntax
             (with-implicit (a b c)))
     (error? ; invalid syntax
             (with-implicit (a b c) . d))
     (error? ; invalid syntax
             (with-implicit (a b c) d . e))
     (error? ; invalid syntax
             (with-implicit (1 2 3) d e))
     (error? ; invalid syntax
             (with-implicit (a 2 c) d e))
     (error? ; 15 is not an identifier
             (with-syntax ([a 15])
               (with-implicit (a b c) d e)))
     (eqv? (let ((borf 'borf-outer))
             (define-syntax frob
               (lambda (x)
                 (syntax-case x ()
                   [k (with-implicit (k borf) #'borf)])))
             frob)
           'borf-outer)
     (equal? (let ([borf 'borf-outer])
               (define-syntax frob
                 (lambda (x)
                   (syntax-case x ()
                     [(k e)
                      (with-implicit (k borf)
                        #'(let ()
                            (define borf 'borf-inner)
                            e))])))
               (list borf (frob (list borf))))
             '(borf-outer (borf-inner)))
     (equal? (let ()
               (define-syntax for
                 (lambda (x)
                   (syntax-case x ()
                     [(k (e0 e1 e2) b1 b2 ...)
                      (with-implicit (k break continue)
                        #'(call/cc
                            (lambda (break)
                              e0
                              (let f ()
                                (when e1
                                      (call/cc
                                        (lambda (continue)
                                          b1
                                          b2
                                          ...))
                                      e2
                                      (f))))))])))
               (define ls-in)
               (define ls-out)
               (for ((begin
                       (set! ls-in '(a b c d e f g h i j))
                       (set! ls-out '()))
                     (not (null? ls-in))
                     (set! ls-in (cdr ls-in)))
                    (when (memq (car ls-in) '(c e))
                          (continue))
                    (set! ls-out (cons (car ls-in) ls-out))
                    (when (memq (car ls-in) '(g j)) (break)))
               ls-out)
             '(g f d b a)))

(mat datum
     (error? (datum))
     (error? (datum a b c))
     (error? (datum . b))
     (equal? (datum (a b c)) '(a b c))
     (equal? (let ()
               (define-syntax ralph
                 (lambda (x)
                   (syntax-case x ()
                     [(k a b)
                      (fixnum? (datum a))
                      (with-syntax
                        ([q (datum->syntax #'k (make-list (datum a) 15))])
                        #'(cons b 'q))]
                     [(_ a b) #'(cons 'a 'b)])))
               (list (ralph 3 4) (ralph 3.0 4.0)))
             '((4 15 15 15) (3.0 . 4.0))))

(mat alias
     (error? ; invalid syntax
             (alias x "y"))
     (error? ; invalid syntax
             (alias 3 x))
     (eq? (let ((x 2)) (alias y x) y) 2)
     (equal? (let ((x "x"))
               (define-syntax fool
                 (let () (alias y x) (lambda (z) #'y)))
               fool)
             "x")
     (equal? (let () (define x "x") (alias y x) y) "x")
     (begin
       (module (($alias-blue blue))
               (define blue "bleu")
               (alias $alias-blue blue))
       (equal? $alias-blue "bleu"))
     (begin
       (define $alias-blot "blot")
       (equal? (let () (alias y $alias-blot) y) "blot"))
     (begin
       (define $alias-f
         (let () (alias x $alias-blarg) (lambda () x)))
       (procedure? $alias-f))
     (error? ; $alias-blarg not bound
             ($alias-f))
     (begin
       (define $alias-blarg "blarg")
       (equal? ($alias-f) "blarg"))
     (begin
       (define-syntax $alias-blarg (lambda (x) "bloog"))
       (equal? ($alias-f) "blarg"))
     (begin
       (define $alias-g (let () (alias x lambda) (x () "g")))
       (equal? ($alias-g) "g"))
     (begin
       (define $alias-x 3)
       (alias $alias-y $alias-x)
       (eq? $alias-y 3))
     (eq? (let () (define $alias-x 4) (alias $alias-y $alias-x) $alias-y) 4)
     ; the following is no longer an error: binding for label is exported
     ; if the alias's identifier is exported
     (begin
       (module ($alias-y) (define $alias-x 5) (alias $alias-y $alias-x))
       (eq? $alias-y 5))
     (begin
       (module ($alias-y55)
         (define $alias-x55 5)
         (alias $alias-y55 $alias-x55)
         (alias $alias-z55 $alias-x55))
       (eq? $alias-y 5))
     (error? $alias-x55)
     (error? $alias-z55)
     (begin
       (module (($alias-y $alias-x))
               (define $alias-x 6)
               (alias $alias-y $alias-x))
       (eq? $alias-y 6))
     (begin
       (module ($alias-y)
         (module (($alias-y $alias-x))
                 (define $alias-x 66)
                 (alias $alias-y $alias-x)))
       (eq? $alias-y 66))
     (eq? (let ()
            (module (($alias-y $alias-x))
                    (define $alias-x 7)
                    (alias $alias-y $alias-x))
            $alias-y)
          7)
     (eq? (let ((x 8)) (module (y) (alias y x)) y) 8)
     (error? ; read-only environment
             (eval '(alias x cons) (scheme-environment)))
     (error? ; read-only environment
       (eval '(begin
                (import scheme)
                (alias $alias-cons cons)
                (set! $alias-cons 3))
             (copy-environment (interaction-environment))))
     (error? ; read-only environment
       (eval '(begin (import scheme) (set! cons 3))
             (copy-environment (interaction-environment))))
     (begin
       (module (($i-foo foo)) (define-record foo ()) (alias $i-foo foo))
       (define-record $i-bar $i-foo (x))
       ($i-bar? (make-$i-bar 3)))
     (begin
       (module ($i-foo)
         (module m (foo) (define-record foo ()))
         (module g2
           (($i-foo g3))
           (module g2 ((g3 foo)) (import m) (alias g3 foo))
           (import g2)
           (alias $i-foo g3))
         (import g2))
       (define-record $i-bar $i-foo (x))
       ($i-bar? (make-$i-bar 3)))
     (begin
       (module $alias-m
         ($alias:car)
         (import scheme)
         (alias $alias:car car))
       (import $alias-m)
       (eqv? ($alias:car '(2.3 4.5 6.7)) 2.3))
     (begin
       (library ($alias-a)
         (export x)
         (import (chezscheme))
         (define y 17)
         (alias x y))
       #t)
     (eqv? (let () (import ($alias-a)) x) 17)
     (error? ; attempt to create an alias to unbound identifier y
             (library ($alias-b)
               (export x)
               (import (chezscheme))
               (alias x y)))
     (error? ; attempt to create an alias to unbound identifier y
             (library ($alias-c)
               (export y)
               (import (chezscheme))
               (alias x y)
               (define y 17)))
     (begin
       (with-output-to-file "testfile-alias-d.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-alias-d)
                (export x)
                (import (chezscheme))
                (alias x y)
                (define y 17))))
         'replace)
       #t)
     (error? ; attempt to create an alias to unbound identifier y
             (compile-file "testfile-alias-d"))
     (error? ; attempt to create an alias to unbound identifier y
             (load "testfile-alias-d.ss"))
     (error? ; attempt to create an alias to unbound identifier y
             (library ($alias-b)
               (export x)
               (import (chezscheme))
               (let () (alias x y) 'hello)))
     (eqv? (let () (import-only (chezscheme)) (define y 17) (alias x y) x)
           17)
     (error? ; attempt to create an alias to unbound identifier y
             (let ()
               (import-only (chezscheme))
               (alias x y)
               7))
     (error? ; attempt to create an alias to unbound identifier y
             (let ()
               (import-only (chezscheme))
               (alias x y)
               (define y 3)
               7))
     (begin
       (with-output-to-file "testfile-alias-e.ss"
         (lambda ()
           (pretty-print
             '(let ()
                (import-only (chezscheme))
                (alias x y)
                (define y 3)
                7)))
         'replace)
       #t)
     (error? ; attempt to create an alias to unbound identifier y
             (compile-file "testfile-alias-e"))
     (error? ; attempt to create an alias to unbound identifier y
             (load "testfile-alias-e.ss")))

(mat extended-import
     (begin
       (module $notscheme
         (cons car cdr)
         (define cons)
         (define car)
         (define-syntax cdr (identifier-syntax $cdr)))
       #t)
     (equivalent-expansion?
       (parameterize ([#%$suppress-primitive-inlining #f])
         (expand '(let ()
                    (import $notscheme)
                    (let () (import scheme) (cons car cdr)))))
       (if (= (optimize-level) 3)
           '(#3%cons #3%car #3%cdr)
           '(#2%cons #2%car #2%cdr)))
     (equivalent-expansion?
       (parameterize ([#%$suppress-primitive-inlining #f])
         (expand '(let ()
                    (import $notscheme)
                    (let ()
                      (import (only scheme car cdr))
                      (cons car cdr)))))
       (if (= (optimize-level) 3)
           '((#3%$top-level-value 'cons) #3%car #3%cdr)
           '((#2%$top-level-value 'cons) #2%car #2%cdr)))
     (equivalent-expansion?
       (parameterize ([#%$suppress-primitive-inlining #f])
         (expand '(let ()
                    (import $notscheme)
                    (let ()
                      (import (except scheme car cdr))
                      (cons car cdr)))))
       (if (= (optimize-level) 3)
           '(#3%cons (#3%$top-level-value 'car) $cdr)
           '(#2%cons (#2%$top-level-value 'car) $cdr)))
     (equivalent-expansion?
       (parameterize ([#%$suppress-primitive-inlining #f])
         (expand '(let ()
                    (import $notscheme)
                    (let ()
                      (import (only (except scheme cdr) car))
                      (cons car cdr)))))
       (if (= (optimize-level) 3)
           '((#3%$top-level-value 'cons) #3%car $cdr)
           '((#2%$top-level-value 'cons) #2%car $cdr)))
     (equivalent-expansion?
       (parameterize ([#%$suppress-primitive-inlining #f])
         (expand '(let ()
                    (import $notscheme)
                    (let ()
                      (import (add-prefix (only scheme car cdr) scheme:))
                      (cons scheme:car cdr)))))
       (if (= (optimize-level) 3)
           '((#3%$top-level-value 'cons) #3%car $cdr)
           '((#2%$top-level-value 'cons) #2%car $cdr)))
     (equivalent-expansion?
       (parameterize ([#%$suppress-primitive-inlining #f])
         (expand '(let ()
                    (import $notscheme)
                    (let ()
                      (import (drop-prefix (only scheme car cdr cons) c))
                      (ons ar dr)))))
       (if (= (optimize-level) 3)
           '(#3%cons #3%car #3%cdr)
           '(#2%cons #2%car #2%cdr)))
     (equivalent-expansion?
       (parameterize ([#%$suppress-primitive-inlining #f])
         (expand '(let ()
                    (import $notscheme)
                    (let ()
                      (import (rename scheme [car xar] [cdr xdr]))
                      (cons xar cdr)))))
       (if (= (optimize-level) 3)
           '(#3%cons #3%car $cdr)
           '(#2%cons #2%car $cdr)))
     (equivalent-expansion?
       (parameterize ([#%$suppress-primitive-inlining #f])
         (expand '(let ()
                    (import $notscheme)
                    (let ()
                      (import (alias scheme [car xar] [cdr xdr]))
                      (cons xar cdr)))))
       (if (= (optimize-level) 3)
           '(#3%cons #3%car #3%cdr)
           '(#2%cons #2%car #2%cdr)))
     ; no glob support yet
     #;
     (equivalent-expansion?
       (parameterize ([#%$suppress-primitive-inlining #f])
         (expand '(let ()
                    (import $notscheme)
                    (let ()
                      (import (glob scheme c*r))
                      (cons car cdr)))))
       '(cons #2%car #2%cdr))
     (begin
       (module ($i-foo)
         (module m (foo) (define foo 45))
         (import (add-prefix m $i-)))
       (eq? $i-foo 45))
     (begin
       (library ($s)
         (export $spam)
         (import (scheme))
         (module m (spam) (define spam 3))
         (import (prefix m $)))
       (import ($s))
       (eqv? $spam 3))
     (begin
       (module ($i-foo)
         (module m (m:$i-foo) (define m:$i-foo 57))
         (import (drop-prefix m m:)))
       (eq? $i-foo 57))
     (begin
       (module ($i-foo)
         (module m (bar) (define bar 63))
         (import (rename m (bar $i-foo))))
       (eq? $i-foo 63))
     (begin
       (module ($i-foo)
         (module m (bar) (define bar 75))
         (import (alias m (bar $i-foo))))
       (eq? $i-foo 75))
     (begin
       (module ($i-x $i-y)
         (module m ($i-x $i-y) (define $i-x "x") (define $i-y "y"))
         (import (rename m ($i-y $i-x) ($i-x $i-y))))
       (equal? (list $i-x $i-y) '("y" "x")))
     (error? ; duplicate identifiers $i-x and $i-y
       (begin
         (module ($i-x $i-y)
           (module m ($i-x $i-y) (define $i-x "x") (define $i-y "y"))
           (import (alias m ($i-x $i-y) ($i-y $i-x))))
         (equal? (list $i-x $i-y) '("y" "x"))))
     (error? ; duplicate identifiers $i-x and $i-y
       (let ()
         (module ($i-x $i-y)
           (module m ($i-x $i-y) (define $i-x "x") (define $i-y "y"))
           (import (alias m ($i-x $i-y) ($i-y $i-x))))
         (equal? (list $i-x $i-y) '("y" "x"))))
     (begin
       (module ($i-foo)
         (module m (foo) (define-record foo ()))
         (import (rename m (foo $i-foo))))
       (define-record $i-bar $i-foo (x))
       ($i-bar? (make-$i-bar 3)))
     (let ()
       (module ($i-foo)
         (module m (foo) (define-record foo ()))
         (import (rename m (foo $i-foo))))
       (define-record $i-bar $i-foo (x))
       ($i-bar? (make-$i-bar 3)))
     (begin
       (module ($i-foo)
         (module m (foo) (module foo ($i-x) (define $i-x 14)))
         (import (rename m (foo $i-foo))))
       (import $i-foo)
       (eq? $i-x 14))
     (let ()
       (module ($i-foo)
         (module m (foo) (module foo ($i-x) (define $i-x 14)))
         (import (rename m (foo $i-foo))))
       (import $i-foo)
       (eq? $i-x 14))
     (error? ; y not visible
       (begin
         (module m (x y) (define x 3) (define y 4))
         (let ((x 5) (y 6)) (import-only (only m x)) y)))
     (error? ; y not visible
       (begin
         (module m (x y) (define x 3) (define y 4))
         (let ((x 5) (y 6))
           ; equivalent of (import-only (only m x)):
           (begin
             (module g0 (x) (import-only m))
             (import-only g0))
           y)))
     (begin
       ; keep with next
       (define $i-grotto-x 7)
       (define $i-grotto-y 8)
       (define $i-grotto-z 9)
       (equal? (list $i-grotto-x $i-grotto-y $i-grotto-z) '(7 8 9)))
     (begin
       ; keep with preceding
       (module $i-grotto
         ($i-grotto-x $i-grotto-y $i-grotto-z)
         (define $i-grotto-x 3)
         (define $i-grotto-y 4)
         (define $i-grotto-z 5))
       (import (only $i-grotto $i-grotto-x))
       (equal? (list $i-grotto-x $i-grotto-y $i-grotto-z) '(3 8 9)))
     (begin
       (import (rename (only scheme car) [car $i-car-from-scheme]))
       (eq? ($i-car-from-scheme '(a b c)) 'a))
     (begin
       (import (only (add-prefix scheme $i-scheme:) $i-scheme:list))
       (equal? ($i-scheme:list 3 4 5) '(3 4 5)))
     (begin
       (import (add-prefix (only scheme list) $i-scheme:))
       (equal? ($i-scheme:list 3 4 5) '(3 4 5))))

(mat import
     ; check import semantics changes May 05
     (begin
       (define $imp-x 0)
       (module $imp-m ($imp-x) (define $imp-x 3))
       (define-syntax $imp-from
         (syntax-rules ()
           [(_ $imp-m $imp-x) (let () (import $imp-m) $imp-x)]))
       (define-syntax $imp-from-m
         (syntax-rules ()
           [(_ $imp-x) (let () (import $imp-m) $imp-x)]))
       (define-syntax $imp-x-from
         (syntax-rules ()
           [(_ $imp-m) (let () (import $imp-m) $imp-x)]))
       (define-syntax $imp-x-from-m
         (syntax-rules ()
           [(_) (let () (import $imp-m) $imp-x)]))
       (define-syntax $imp-module*
         (syntax-rules ()
           [(_ (x ...) d ...) (begin (module t (x ...) d ...) (import t))]))
       (define-syntax $imp-import*
         (syntax-rules () [(_ m) (import m)]))
       #t)
     (eqv? ($imp-from $imp-m $imp-x) 3)
     (eqv? ($imp-from-m $imp-x) 0)
     (eqv? ($imp-x-from $imp-m) 0)
     (eqv? ($imp-x-from-m) 3)
     (eqv? (let () ($imp-from $imp-m $imp-x)) 3)
     (eqv? (let () ($imp-from-m $imp-x)) 0)
     (eqv? (let () ($imp-x-from $imp-m)) 0)
     (eqv? (let () ($imp-x-from-m)) 3)
     (eqv? (let ()
             (module $imp-m ($imp-x) (define $imp-x 4))
             ($imp-from $imp-m $imp-x))
           4)
     (eqv? (let ()
             (module $imp-m ($imp-x) (define $imp-x 4))
             ($imp-from-m $imp-x))
           0)
     (eqv? (let ()
             (module $imp-m ($imp-x) (define $imp-x 4))
             ($imp-x-from $imp-m))
           0)
     (eqv? (let ()
             (module $imp-m ($imp-x) (define $imp-x 4))
             ($imp-x-from-m))
           3)
     (eqv? (let () (module m (x) (define x 4)) ($imp-import* m) x) 4)
     (eqv? (let ()
             ($imp-module* (x) (define y 5) (define x (lambda () y)))
             (x))
           5)
     (equal? (let ()
               (define-syntax module*
                 (syntax-rules ()
                   [(_ (x ...) d ...)
                    (begin
                      (module t (x ...) d ...)
                      (import t))]))
               (define-syntax import*
                 (syntax-rules () [(_ m) (import m)]))
               (define x 0)
               (module m (x) (define x 3))
               (define-syntax from
                 (syntax-rules ()
                   [(_ m x) (let () (import m) x)]))
               (define-syntax from-m
                 (syntax-rules ()
                   [(_ x) (let () (import m) x)]))
               (define-syntax x-from
                 (syntax-rules ()
                   [(_ m) (let () (import m) x)]))
               (define-syntax x-from-m
                 (syntax-rules () [(_) (let () (import m) x)]))
               (module* (a) (define b 'bee) (define a (lambda () b)))
               (list (let () (module m (x) (define x 4)) (from m x))
                     (let ()
                       (module m (x) (define x 4))
                       (from-m x))
                     (let ()
                       (module m (x) (define x 4))
                       (x-from m))
                     (let ()
                       (module m (x) (define x 4))
                       (x-from-m))
                     (let () (import* m) x)
                     (a)))
             '(4 0 0 3 3 bee))
     (equal? (let ()
               (define-syntax alpha
                 (syntax-rules ()
                   [(_ m v e)
                    (let ()
                      (module m
                        (v x)
                        (define x 'introduced)
                        (define v 'supplied))
                      (list e (let () (import m) (list v x))))]))
               (let () (alpha q x (let () (import q) x))))
             '(supplied (supplied introduced)))
     (begin
       (module $imp-list
         ($imp-null? $imp-car $imp-cdr $imp-cons)
         (import (add-prefix (only scheme null? car cdr cons) $imp-)))
       (define-syntax $imp-a
         (syntax-rules ()
           ((_ x)
            (define-syntax x
              (lambda (q)
                (import (only $imp-list $imp-car))
                #'$imp-car)))))
       ($imp-a $imp-foo)
       (eqv? $imp-foo #%car))
     (eqv? (let ()
             (module rat
               (fink dog)
               (define fink 'lestein)
               (define dog 'cat))
             (define-syntax a
               (syntax-rules ()
                 ((_ x)
                  (define-syntax x
                    (lambda (q)
                      (import (only rat fink))
                      #'fink)))))
             (a foo)
             foo)
           'lestein)
     (eqv? (let ()
             (module rat
               (fink dog)
               (define fink 'lestein)
               (define dog 'cat))
             (define-syntax a
               (syntax-rules ()
                 ((_ x)
                  (define-syntax x
                    (lambda (q)
                      (import (add-prefix rat r:))
                      #'r:fink)))))
             (a foo)
             foo)
           'lestein)
     (eqv? (let ()
             (module rat
               (fink dog)
               (define fink 'lestein)
               (define dog 'cat))
             (define-syntax a
               (syntax-rules ()
                 ((_ x)
                  (define-syntax x
                    (lambda (q)
                      (import (except rat dog))
                      #'fink)))))
             (a foo)
             foo)
           'lestein)
     (eqv? (let ()
             (module m (x) (define x 'x1))
             (define-syntax a
               (lambda (q)
                 #'(let ([x 'x2])
                     (module n (x) (import m))
                     (let () (import n) x))))
             a)
           'x1)
     (eqv? (let ()
             (module m (x) (define x 'x1))
             (define-syntax a
               (lambda (q) #'(let ([x 'x2]) (import m) x)))
             a)
           'x1)
     (error? ; duplicate definition for x
       (let ()
         (module m (x) (define x 'x1))
         (define-syntax a
           (lambda (q)
             #'(let () (define x 'x2) (import m) x)))
         a))
     (error? ; duplicate definition for x
       (let ()
         (module m (x) (define x 'x1))
         (define-syntax a
           (lambda (q)
             #'(let () (import m) (define x 'x2) x)))
         a))
     (equal? (let () (import scheme) (import scheme) car) car)
     (error? ; "duplicate definition for car
             (let ()
               (import scheme)
               (import (rename scheme (cdr car)))
               car))
     (error? ; duplicate definition for car
             (let ()
               (module (car) (define car 'edsel))
               (import scheme)
               car))
     (error? ; duplicate definition for car
       (let ()
         (define-syntax a
           (lambda (q)
             #'(let ()
                 (module (car) (define car 'edsel))
                 (import scheme)
                 car)))
         a))
     (equal? (let ()
               (define-syntax a
                 (lambda (q)
                   #'(let ()
                       (import scheme)
                       (import scheme)
                       car)))
               a)
             car)
     (error? ; duplicate definition for x
       (let ()
         (define-syntax a
           (lambda (q)
             #'(let ()
                 (define x 5)
                 (define-syntax x (identifier-syntax 5))
                 x)))
         a))
     (error? ; missing definition for export(s) (xxx).
       (let ()
         (define-syntax a
           (syntax-rules ()
             [(_ m i) (module m (i) (import m1))]))
         (module m1 (xxx) (define xxx 155))
         (a m2 xxx)
         (let () (import m2) xxx)))
     (equal? (parameterize
               ([#%$suppress-primitive-inlining #f]
                [run-cp0 (lambda (cp0 x) (cp0 x))])
               (expand/optimize
                 '(let-syntax
                    ([a (lambda (x) #'(let () (import scheme) car))])
                    a)))
             (if (= (optimize-level) 3) '#3%car '#2%car))
     (equal? (parameterize
               ([#%$suppress-primitive-inlining #f]
                [run-cp0 (lambda (cp0 x) (cp0 x))])
               (expand/optimize
                 '(let-syntax
                    ([a (syntax-rules ()
                          [(_ x)
                           (define-syntax x
                             (lambda (q)
                               (import scheme)
                               #'car))])])
                    (a foo)
                    foo)))
             (if (= (optimize-level) 3) '#3%car '#2%car))
     (error? ; read-only environment
             (eval '(import (rnrs)) (scheme-environment)))
     (error? ; invalid context for import
             (let ([x (import)]) x))
     ; check 10/27/2010 change to make sense of multiple modules/libraries
     ; within the same import-only form
     (equal? (let ()
               (module m1 (x) (define x box))
               (module m2 (y) (define y 772))
               (let () (import-only m1 m2) (x y)))
             '#&772)
     (equal? (let ()
               (module m1 (x) (define x box))
               (module m2 (y) (define y 772))
               (let () (import m1 m2) (x y)))
             '#&772)
     (error? ; unbound identifier list
       (let ()
         (module m1 (x) (define x 29))
         (module m2 (y) (define y 772))
         (let () (import-only m1 m2) (list x y))))
     (equal? (let ()
               (module m1 (x) (define x 29))
               (module m2 (y) (define y 772))
               (let () (import m1 m2) (list x y)))
             '(29 772))
     (equal? (let ()
               (module m1 (x) (define x 29))
               (module m2 (y) (define y 772))
               (let () (import-only scheme m1 m2) (list x y)))
             '(29 772))
     (equal? (let ()
               (module m1 (x) (define x 29))
               (module m2 (y) (define y 772))
               (let () (import scheme m1 m2) (list x y)))
             '(29 772))
     (equal? (let ()
               (module m1 (x) (define x 29))
               (module m2 (y) (define y 772))
               (let ()
                 (import-only (scheme) m1 m2)
                 (list x y)))
             '(29 772))
     (equal? (let ()
               (module m1 (x) (define x 29))
               (module m2 (y) (define y 772))
               (let () (import (scheme) m1 m2) (list x y)))
             '(29 772))
     (equal? (let ()
               (module m1 (x) (define x 29))
               (module m2 (y) (define y 772))
               (let ()
                 (import-only m1 m2 (scheme))
                 (list x y)))
             '(29 772))
     (equal? (let ()
               (module m1 (x) (define x 29))
               (module m2 (y) (define y 772))
               (let () (import m1 m2 (scheme)) (list x y)))
             '(29 772))
     (begin
       (library ($io A) (export p) (import (rnrs)) (define p 17))
       (library ($io B)
         (export q)
         (import (rnrs))
         (define q (lambda (x) (cons 'q x))))
       (library ($io C)
         (export r)
         (import (chezscheme) ($io B))
         (import-only ($io A) (only (rnrs) define *))
         (define r (* p 2)))
       #t)
     (equal? (let () (import-only ($io B) ($io C)) (q r)) '(q . 34))
     (error? ; unbound identifier p
       (let ()
         (import ($io A))
         (import-only ($io B) ($io C))
         (q p)))
     (begin
       (library ($io A) (export p) (import (rnrs)) (define p 17))
       (library ($io B)
         (export q)
         (import (rnrs))
         (define q (lambda (x) (cons 'q x))))
       (library ($io C)
         (export r)
         (import (chezscheme) ($io B))
         (import ($io A) (only (rnrs) define *))
         (define r (* p 2)))
       #t)
     (equal? (let () (import ($io B) ($io C)) (q r)) '(q . 34))
     (equal? (let () (import ($io A)) (import ($io B) ($io C)) (q p))
             '(q . 17))
     (error? ; unbound identifier p
       (begin
         (library ($io A) (export p) (import (rnrs)) (define p 17))
         (library ($io B)
           (export q)
           (import (rnrs))
           (define q (lambda (x) (cons 'q x))))
         (library ($io C)
           (export r)
           (import (chezscheme) ($io A))
           (import-only ($io B) (only (rnrs) define *))
           (define r (* p 2)))))
     (begin
       (library ($io A) (export p) (import (rnrs)) (define p 17))
       (library ($io B)
         (export q)
         (import (rnrs))
         (define q (lambda (x) (cons 'q x))))
       (library ($io C)
         (export r)
         (import (chezscheme) ($io A))
         (import ($io B) (only (rnrs) define *))
         (define r (* p 2)))
       #t)
     (error? ; unbound identifier *
       (begin
         (library ($io A) (export p) (import (rnrs)) (define p 17))
         (library ($io B)
           (export q)
           (import (rnrs))
           (define q (lambda (x) (cons 'q x))))
         (library ($io C)
           (export r)
           (import (chezscheme) ($io A))
           (import-only ($io B) (only (rnrs) define))
           (define r (* p 2)))))
     (begin
       (library ($io A) (export p) (import (rnrs)) (define p 17))
       (library ($io B)
         (export q)
         (import (rnrs))
         (define q (lambda (x) (cons 'q x))))
       (library ($io C)
         (export r)
         (import (chezscheme) ($io A))
         (import ($io B) (only (rnrs) define))
         (define r (* p 2)))
       #t)
     ; check for let-like semantics for import w/multiple subforms
     (eq? (let ()
            (module A (B) (module B (x) (define x 'a-b)))
            (module B (x) (define x 'b))
            (let () (import A B) x))
          'b)
     (eq? (let ()
            (module A (B) (module B (x) (define x 'a-b)))
            (module B (x) (define x 'b))
            (let () (import-only A B) x))
          'b))

(mat export
     ; test stand-alone export form
     (error? ; export outside module or library
             (export))
     (error? ; export outside module or library
             (export cons))
     (error? ; export outside module or library
             (top-level-program (import (chezscheme)) (export)))
     (let () (export) #t)
     (error? ; nonempty export outside module or library
             (let () (export cons) #t))
     (begin
       (module ()
         (define $ex-x 3)
         (export (rename ($ex-x $ex-y) ($ex-y $ex-x)))
         (define $ex-y 4))
       #t)
     (equal? (cons $ex-x $ex-y) '(4 . 3))
     (begin
       (library ($ex-A)
         (export)
         (import (chezscheme))
         (define $ex-x 7)
         (export (rename ($ex-x $ex-y) ($ex-y $ex-x)))
         (define $ex-y 9))
       #t)
     (equal? (let () (import ($ex-A)) (cons $ex-x $ex-y)) '(9 . 7))
     (begin (import ($ex-A)) #t)
     (equal? (cons $ex-x $ex-y) '(9 . 7))
     (equal? (let ()
               (module ()
                 (define $ex-x 3)
                 (export (rename ($ex-x $ex-y) ($ex-y $ex-x)))
                 (define $ex-y 4))
               (cons $ex-x $ex-y))
             '(4 . 3))
     (begin (module $ex-m (x x) (define x 5) (export x)) #t)
     (eqv? (let () (import $ex-m) x) 5)
     (eqv? (let () (module (x x) (define x 5) (export x)) x) 5)
     (eqv? (let () (module (x) (define x 5) (export x)) x) 5)
     (error? ; duplicate export
       (module (x) (define x 15) (define y 117) (export (rename (y x)))))
     (begin
       ; okay to export id twice as long as it has the same binding
       (library ($ex-B)
         (export x x)
         (import (chezscheme))
         (define x 25)
         (export x))
       #t)
     (eqv? (let () (import ($ex-B)) x) 25)
     (begin
       ; okay to export id twice as long as it has the same binding
       (library ($ex-B)
         (export x (rename (x x)))
         (import (chezscheme))
         (define x 25)
         (export x))
       #t)
     (eqv? (let () (import ($ex-B)) x) 25)
     (begin
       ; okay to export id twice as long as it has the same binding
       (library ($ex-B)
         (export x (rename (y x)))
         (import (chezscheme))
         (define x 25)
         (alias y x)
         (export x))
       #t)
     (eqv? (let () (import ($ex-B)) x) 25)
     (begin
       (library ($ex-B)
         (export x)
         (import (chezscheme))
         (define x 35)
         (export x))
       #t)
     (eqv? (let () (import ($ex-B)) x) 35)
     (begin (import ($ex-B)) (eqv? x 35))
     (error? ; duplicate export
       (library ($ex-C)
         (export x)
         (import (chezscheme))
         (define x 5)
         (define y 17)
         (export (rename (y x)))))
     (equal? (let ()
               (module f
                 ((a x y))
                 (import (chezscheme))
                 (define x 3)
                 (define y 4)
                 (define-syntax a
                   (identifier-syntax (cons x y)))
                 (export a))
               (import f)
               a)
             '(3 . 4))
     (equal? (let ()
               (module m
                 ()
                 (define x 3)
                 (module m1
                   (x y)
                   (define x 4)
                   (define-syntax y (identifier-syntax x))
                   (indirect-export y x))
                 (export (import m1)))
               (let () (import m) (list x y)))
             '(4 4))
     (equal? (let ()
               (module m
                 ()
                 (define x 3)
                 (module m1
                   (x y)
                   (define x 4)
                   (define-syntax y (identifier-syntax x))
                   (indirect-export y x))
                 (export (import (only m1 y)) x))
               (let () (import m) (list x y)))
             '(3 4))
     (begin
       (define-syntax $ex-export1
         (syntax-rules ()
           [(_ (m id ...)) (export (import (only m id ...)))]
           [(_ id) (export id)]))
       (define-syntax $ex-export
         (syntax-rules ()
           [(_ frob ...) (begin ($ex-export1 frob) ...)]))
       #t)
     (begin
       (module $ex-mm
         ()
         ($ex-export)
         (define x 3)
         (module m1
           ()
           ($ex-export x y)
           (define x 4)
           (define-syntax y (identifier-syntax x))
           (indirect-export y x))
         ($ex-export (m1 y) x))
       #t)
     (equal? (let () (import $ex-mm) (list x y)) '(3 4))
     (equal? (let ()
               (module m
                 ()
                 ($ex-export)
                 (define x 3)
                 (module m1
                   ()
                   ($ex-export x y)
                   (define x 4)
                   (define-syntax y (identifier-syntax x))
                   (indirect-export y x))
                 ($ex-export (m1 y) x))
               (let () (import m) (list x y)))
             '(3 4))
     (begin
       (with-output-to-file "testfile-ex1a.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-ex1a)
                (export q)
                (import (chezscheme))
                (define-syntax q (identifier-syntax 17)))))
         'replace)
       (with-output-to-file "testfile-ex1b.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-ex1b)
                (export)
                (import (chezscheme))
                (define x 22)
                (export x (import (testfile-ex1a))))))
         'replace)
       (for-each separate-compile '(ex1a ex1b))
       #t)
     (equal? (let () (import (testfile-ex1b)) (list x q)) '(22 17))
     (begin
       (with-output-to-file "testfile-ex2a.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-ex2a)
                (export q)
                (import (chezscheme))
                (define-syntax q (identifier-syntax 17)))))
         'replace)
       (with-output-to-file "testfile-ex2b.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-ex2b)
                (export)
                (import (chezscheme))
                (define x 22)
                (export (rename (x q))
                  (import (prefix (rename (testfile-ex2a) (q que)) pi))))))
         'replace)
       (for-each separate-compile '(ex2a ex2b))
       #t)
     (equal? (let () (import (testfile-ex2b)) (list q pique)) '(22 17))
     (begin
       (with-output-to-file "testfile-ex3a.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-ex3a)
                (export q)
                (import (chezscheme))
                (implicit-exports #f)
                (indirect-export a x)
                (define x 17)
                (define-syntax a
                  (identifier-syntax (* x 2)))
                (indirect-export q a)
                (define-syntax q
                  (identifier-syntax (+ a 1))))))
         'replace)
       (with-output-to-file "testfile-ex3b.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-ex3b)
                (export)
                (import (chezscheme))
                (define x 22)
                (export (rename (x q))
                  (import (prefix (rename (testfile-ex3a) (q que)) pi))))))
         'replace)
       (for-each separate-compile '(ex3a ex3b))
       #t)
     (equal? (let () (import (testfile-ex3b)) (list q pique)) '(22 35))
     (begin
       (with-output-to-file "testfile-ex4a.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-ex4a)
                (export q)
                (import (chezscheme))
                (implicit-exports #f)
                (define x 17)
                (define-syntax a
                  (identifier-syntax (* x 2)))
                (define-syntax q
                  (identifier-syntax (+ a 1))))))
         'replace)
       (with-output-to-file "testfile-ex4b.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-ex4b)
                (export)
                (import (chezscheme))
                (define x 22)
                (export (rename (x q))
                  (import (prefix (rename (testfile-ex4a) (q que)) pi))))))
         'replace)
       (for-each separate-compile '(ex4a ex4b))
       #t)
     (error? ; attempt to reference unexported identifier a
             (let () (import (testfile-ex4b)) (list q pique))))

(define eval-test (lambda (expr) (eval expr) #t))
(define load-test
  (lambda (expr)
    (with-output-to-file "testfile.ss"
      (lambda () (pretty-print expr))
      'replace)
    (load "testfile.ss")
    #t))
(define compile-test
  (lambda (expr)
    (with-output-to-file "testfile.ss"
      (lambda () (pretty-print expr))
      'replace)
    (compile-file "testfile.ss")
    (load "testfile.so")
    #t))

(define-syntax errmat
  (lambda (x)
    (syntax-case x ()
      [(_ name expr ...)
       (let ([make-name
               (lambda (x)
                 (datum->syntax #'name
                   (string->symbol (format "~s-~s" x (datum name)))))])
         #`(begin
             (mat #,(make-name 'eval) (error? (eval-test 'expr)) ...)
             (mat #,(make-name 'load) (error? (load-test 'expr)) ...)
             (mat #,(make-name 'compile) (error? (compile-test 'expr)) ...)))])))

(errmat export-errors
  ; attempt to export multiple bindings for x
  (module A () (define x 5) (define y 6) (export (rename (y x)) x))
  ; attempt to export multiple bindings for x
  (module ()
    (module A () (define x 5) (define y 6) (export (rename (y x)) x)))
  ; attempt to export multiple bindings for x
  (let ()
    (module A () (define x 5) (define y 6) (export (rename (y x)) x))
    0)
  ; attempt to export multiple bindings for x
  (library (A)
    (export)
    (import (chezscheme))
    (define x 5)
    (define y 6)
    (export (rename (y x)) x))
  ; attempt to export multiple bindings for x
  (module A () (define x 5) (define y 6) (export x (rename (y x))))
  ; attempt to export multiple bindings for x
  (module ()
    (module A () (define x 5) (define y 6) (export x (rename (y x)))))
  ; attempt to export multiple bindings for x
  (let ()
    (module A () (define x 5) (define y 6) (export x (rename (y x))))
    0)
  ; attempt to export multiple bindings for x
  (library (A)
    (export)
    (import (chezscheme))
    (define x 5)
    (define y 6)
    (export x (rename (y x))))
  ; attempt to export multiple bindings for x
  (module A
    ()
    (define x 5)
    (module B (x) (define x 6))
    (export x (import B)))
  ; attempt to export multiple bindings for x
  (module ()
    (module A
      ()
      (define x 5)
      (module B (x) (define x 6))
      (export x (import B))))
  ; attempt to export multiple bindings for x
  (let ()
    (module A
      ()
      (define x 5)
      (module B (x) (define x 6))
      (export x (import B)))
    0)
  ; attempt to export multiple bindings for x
  (library (A)
    (export)
    (import (chezscheme))
    (define x 5)
    (module B (x) (define x 6))
    (export x (import B)))
  ; attempt to export multiple bindings for x
  (module A
    ()
    (define x 5)
    (module B (x) (define x 6))
    (export (import B) x))
  ; attempt to export multiple bindings for x
  (module ()
    (module A
      ()
      (define x 5)
      (module B (x) (define x 6))
      (export (import B) x)))
  ; attempt to export multiple bindings for x
  (let ()
    (module A
      ()
      (define x 5)
      (module B (x) (define x 6))
      (export (import B) x))
    0)
  ; attempt to export multiple bindings for x
  (library (A)
    (export)
    (import (chezscheme))
    (define x 5)
    (module B (x) (define x 6))
    (export (import B) x))
  ; attempt to export multiple bindings for x
  (module A
    ()
    (module B (x) (define x 6))
    (module C (x) (define x 7))
    (export (import C) (import B)))
  ; attempt to export multiple bindings for x
  (module ()
    (module A
      ()
      (module B (x) (define x 6))
      (module C (x) (define x 7))
      (export (import C) (import B))))
  ; attempt to export multiple bindings for x
  (let ()
    (module A
      ()
      (module B (x) (define x 6))
      (module C (x) (define x 7))
      (export (import C) (import B)))
    0)
  ; attempt to export multiple bindings for x
  (library (A)
    (export)
    (import (chezscheme))
    (module B (x) (define x 6))
    (module C (x) (define x 7))
    (export (import C) (import B)))
  ; missing import y
  (module A () (module B (x) (define x 6)) (export (import (only B y))))
  ; missing import y
  (module ()
    (module A () (module B (x) (define x 6)) (export (import (only B y)))))
  ; missing import y
  (let ()
    (module A () (module B (x) (define x 6)) (export (import (only B y))))
    0)
  ; missing import y
  (library (A)
    (export)
    (import (chezscheme))
    (module B (x) (define x 6))
    (export (import (only B y))))
  ; missing import y
  (module A
    ()
    (module B (x) (define x 6))
    (export (import (rename B (y z)))))
  ; missing import y
  (module ()
    (module A
      ()
      (module B (x) (define x 6))
      (export (import (rename B (y z))))))
  ; missing import y
  (let ()
    (module A
      ()
      (module B (x) (define x 6))
      (export (import (rename B (y z)))))
    0)
  ; missing import y
  (library (A)
    (export)
    (import (chezscheme))
    (module B (x) (define x 6))
    (export (import (rename B (y z)))))
  ; library (rename B y z) not found
  (module A () (module B (x) (define x 6)) (export (import (rename B y z))))
  ; library (rename B y z) not found
  (module ()
    (module A
      ()
      (module B (x) (define x 6))
      (export (import (rename B y z)))))
  ; library (rename B y z) not found
  (let ()
    (module A
      ()
      (module B (x) (define x 6))
      (export (import (rename B y z))))
    0)
  ; library (rename B y z) not found
  (library (A)
    (export)
    (import (chezscheme))
    (module B (x) (define x 6))
    (export (import (rename B y z))))
  ; missing expected prefix foo: x
  (module A
    ()
    (module B (x) (define foo:y 5) (define x 6))
    (export (import (drop-prefix B foo:))))
  ; missing expected prefix foo: x
  (module ()
    (module A
      ()
      (module B (x) (define foo:y 5) (define x 6))
      (export (import (drop-prefix B foo:)))))
  ; missing expected prefix foo: x
  (let ()
    (module A
      ()
      (module B (x) (define foo:y 5) (define x 6))
      (export (import (drop-prefix B foo:))))
    0)
  ; missing expected prefix foo: x
  (library (A)
    (export)
    (import (chezscheme))
    (module B (x) (define foo:y 5) (define x 6))
    (export (import (drop-prefix B foo:)))))

(mat indirect-export
     ; test stand-alone indirect-export form
     (error? ; invalid indirect-export syntax
       (module $ie-f
         (($ie-a x))
         (import (chezscheme))
         (define x '$ie-x)
         (indirect-export ($ie-a y z))
         (define y '$ie-y)
         (define-syntax $ie-a
           (identifier-syntax (list x y z)))
         (define z '$ie-z)))
     (error? ; export z undefined
       (module $ie-f
         (($ie-a x))
         (import (chezscheme))
         (define x '$ie-x)
         (indirect-export $ie-a y z)
         (define y '$ie-y)
         (define-syntax $ie-a
           (identifier-syntax (list x y z)))))
     (begin
       (module $ie-f
         ($ie-a)
         (import (chezscheme))
         (define-syntax $ie-a (identifier-syntax (list z)))
         (define z '$ie-z))
       #t)
     (error? ; attempt to reference unexported identifier z
             (let () (import $ie-f) $ie-a))
     (begin
       (module $ie-f
         (($ie-a z))
         (import (chezscheme))
         (define-syntax $ie-a (identifier-syntax (list z)))
         (define z '$ie-z))
       #t)
     (equal? (let () (import $ie-f) $ie-a) '($ie-z))
     (begin
       (module $ie-f
         ($ie-a)
         (import (chezscheme))
         (indirect-export $ie-a z)
         (define-syntax $ie-a (identifier-syntax (list z)))
         (define z '$ie-z))
       #t)
     (equal? (let () (import $ie-f) $ie-a) '($ie-z))
     (begin
       (module $ie-f
         ()
         (import (chezscheme))
         (export $ie-a)
         (indirect-export $ie-a z)
         (define-syntax $ie-a (identifier-syntax (list z)))
         (define z '$ie-z))
       #t)
     (equal? (let () (import $ie-f) $ie-a) '($ie-z))
     (begin
       (module $ie-f
         ()
         (import (chezscheme))
         (indirect-export $ie-a z)
         (export $ie-a)
         (define-syntax $ie-a (identifier-syntax (list z)))
         (define z '$ie-z))
       #t)
     (equal? (let () (import $ie-f) $ie-a) '($ie-z))
     (begin
       (module $ie-f
         (($ie-a x))
         (import (chezscheme))
         (define x '$ie-x)
         (indirect-export $ie-a z)
         (define y '$ie-y)
         (define-syntax $ie-a
           (identifier-syntax (list x y z)))
         (define z '$ie-z)
         (indirect-export $ie-a y))
       #t)
     (equal? (let () (import $ie-f) $ie-a) '($ie-x $ie-y $ie-z))
     (begin
       (module $ie-g
         ()
         (define x 3)
         (define y 4)
         (define-syntax a (identifier-syntax (list x y)))
         (alias b a)
         (export a b)
         (indirect-export a x)
         (indirect-export b y))
       #t)
     (equal? (let () (import $ie-g) a) '(3 4))
     (begin
       (module $ie-h
         ((cons x))
         (define-property cons car #'x)
         (define x 3))
       #t)
     (eqv? (let ()
             (define-syntax ref-prop
               (lambda (x)
                 (lambda (r)
                   (syntax-case x ()
                     [(_ id key) (r #'id #'key)]))))
             (import $ie-h)
             (ref-prop cons car))
           3)
     (begin
       (module $ie-h (cons) (define-property cons car #'x) (define x 3))
       #t)
     (error? ; unexported identifier x
       (let ()
         (define-syntax ref-prop
           (lambda (x)
             (lambda (r)
               (syntax-case x () [(_ id key) (r #'id #'key)]))))
         (import $ie-h)
         (ref-prop cons car)))
     (begin
       (module $ie-h
         (cons)
         (implicit-exports #t)
         (define-property cons car #'x)
         (define x 3))
       #t)
     (eqv? (let ()
             (define-syntax ref-prop
               (lambda (x)
                 (lambda (r)
                   (syntax-case x ()
                     [(_ id key) (r #'id #'key)]))))
             (import $ie-h)
             (ref-prop cons car))
           3)
     (error? ; undefine export x
       (library ($ie-i)
         (export a)
         (import (chezscheme))
         (define-syntax a (identifier-syntax x))
         (indirect-export a x))))

(mat implicit-exports
     ; test stand-alone implicit-exports form
     (error? ; invalid syntax
             (implicit-exports))
     (error? ; invalid syntax
             (+ (implicit-exports) 3))
     (error? ; invalid syntax
             (+ (implicit-exports yes!) 3))
     (error? ; invalid syntax
             (+ (implicit-exports no way!) 3))
     (error? ; outside of module or library
             (implicit-exports #t))
     (error? ; invalid context for definition
             (+ (implicit-exports #f) 3))
     (begin
       (module $ie-A
         (a)
         (import (chezscheme))
         (define-syntax a (identifier-syntax x))
         (define x 3))
       #t)
     (error? ; unexported identifier x
             (let () (import $ie-A) a))
     (begin
       (module $ie-A
         (a)
         (import (chezscheme))
         (implicit-exports #t)
         (define-syntax a (identifier-syntax x))
         (define x 3))
       #t)
     (eqv? (let () (import $ie-A) a) 3)
     (begin
       (module $ie-A
         (a)
         (import (chezscheme))
         (implicit-exports #f)
         (define-syntax a (identifier-syntax x))
         (define x 3))
       #t)
     (error? ; unexported identifier x
             (let () (import $ie-A) a))
     (begin
       (library ($ie-A)
         (export a)
         (import (chezscheme))
         (define-syntax a (identifier-syntax x))
         (define x 3))
       #t)
     (eqv? (let () (import ($ie-A)) a) 3)
     (begin
       (library ($ie-A)
         (export a)
         (import (chezscheme))
         (implicit-exports #f)
         (define-syntax a (identifier-syntax x))
         (define x 3))
       #t)
     (error? ; unexported identifier x
             (let () (import ($ie-A)) a))
     (begin
       (library ($ie-A)
         (export a)
         (import (chezscheme))
         (implicit-exports #t)
         (define-syntax a (identifier-syntax x))
         (define x 3))
       #t)
     (eqv? (let () (import ($ie-A)) a) 3)
     (begin
       (module $ie-A
         (a)
         (import (chezscheme))
         (module (a) (define-syntax a (identifier-syntax x)) (define x 3)))
       #t)
     (error? ; unexported identifier x
             (let () (import $ie-A) a))
     (begin
       (module $ie-A
         (a)
         (import (chezscheme))
         (module ((a x))
           (define-syntax a (identifier-syntax x))
           (define x 3)))
       #t)
     (eqv? (let () (import $ie-A) a) 3)
     (begin
       (module $ie-A
         (a)
         (import (chezscheme))
         (module (a)
           (implicit-exports #f)
           (define-syntax a (identifier-syntax x))
           (define x 3)))
       #t)
     (error? ; unexported identifier x
             (let () (import $ie-A) a))
     (begin
       (module $ie-A
         (a)
         (import (chezscheme))
         (module (a)
           (implicit-exports #t)
           (define-syntax a (identifier-syntax x))
           (define x 3)))
       #t)
     (eqv? (let () (import $ie-A) a) 3)
     (begin
       (module $ie-B
         (a)
         (import (chezscheme))
         (define-syntax a (identifier-syntax x))
         (module (x) (module (x (a x)) (define a 4) (define x 3))))
       #t)
     (error? ; unexported identifier x
             (let () (import $ie-B) a))
     (begin
       (module $ie-B
         (a)
         (import (chezscheme))
         (define-syntax a (identifier-syntax x))
         (indirect-export a x)
         (module (x) (module (x (a x)) (define a 4) (define x 3))))
       #t)
     (eqv? (let () (import $ie-B) a) 3)
     (begin
       (module $ie-C
         (a)
         (import (chezscheme))
         (module ((b x))
           (define-syntax b (identifier-syntax x))
           (define x 3))
         (alias a b))
       #t)
     (eqv? (let () (import $ie-C) a) 3)
     (begin
       (module $ie-C
         (a)
         (import (chezscheme))
         (module (b) (define-syntax b (identifier-syntax x)) (define x 3))
         (alias a b))
       #t)
     (error? ; unexported identifier x
             (let () (import $ie-C) a))
     (begin
       (module $ie-C
         (a)
         (import (chezscheme))
         (module (b)
           (indirect-export b x)
           (define-syntax b (identifier-syntax x))
           (define x 3))
         (alias a b))
       #t)
     (eqv? (let () (import $ie-C) a) 3)
     (begin
       (module $ie-D
         (a)
         (module (a (b x))
           (define-syntax b (identifier-syntax (list x)))
           (module (a x)
             (module (b x)
               (define-syntax b (identifier-syntax x))
               (define x 3))
             (alias a b))))
       #t)
     (error? ; unexported identifier x
             (let () (import $ie-D) a))
     (begin
       (module $ie-E
         (a)
         (import (chezscheme))
         (define-syntax a (identifier-syntax x))
         (alias b a)
         (indirect-export b x)
         (define x 77))
       #t)
     ; this works because the indirect export of x for b
     ; counts as an indrect export of x for a.  perhaps it
     ; shouldn't work.
     (eqv? (let () (import $ie-E) a) 77)
     ; perhaps this shouldn't work either:
     (eqv? (let ()
             (define b 3)
             (alias a b)
             (fluid-let-syntax ([b (identifier-syntax 4)]) a))
           4)
     (begin
       (module $ie-F
         (a)
         (import (chezscheme))
         (module (a)
           (implicit-exports #f)
           (define-syntax a (identifier-syntax x)))
         (implicit-exports #t)
         (define x 77))
       #t)
     (eqv? (let () (import $ie-F) a) 77)
     (begin
       (module $ie-G
         (a)
         (implicit-exports #t)
         (module M1 (x) (define x 5))
         (module M2
           ((a x))
           (implicit-exports #t)
           (import M1)
           (define-syntax a (identifier-syntax x)))
         (import M2))
       #t)
     (eqv? (let () (import $ie-G) a) 5)
     (begin
       (module $ie-H
         (a)
         (implicit-exports #t)
         (module M1 (x) (define x 5))
         (module M2
           (a)
           (implicit-exports #t)
           (define-syntax a
             (let () (import M1) (identifier-syntax x))))
         (import M2))
       #t)
     (eqv? (let () (import $ie-H) a) 5)
     (begin
       (module $ie-I
         (a)
         (define x 5)
         (indirect-export a x)
         (module M2 (a) (define-syntax a (identifier-syntax x)))
         (import M2))
       #t)
     (eqv? (let () (import $ie-I) a) 5)
     (begin
       (module $ie-J
         (m)
         (implicit-exports #t)
         (module m
           (e)
           (define f 44)
           (define-syntax e (identifier-syntax f))))
       #t)
     (error? ; unexported identifier f
             (let () (import $ie-J) (import m) e)))

(mat marked-top-level-ids
     (begin
       (define-syntax $a
         (syntax-rules ()
           ((_ x e)
            (begin
              (module ($y-marked) (define $y-marked e))
              (define x (lambda () $y-marked))))))
       ($a $one 1)
       ($a $two 2)
       (equal? (list ($one) ($two)) '(1 2)))
     (not (top-level-bound? '$y-marked))
     (begin
       (define-syntax $a
         (syntax-rules ()
           ((_ x e)
            (begin
              (define $y-marked e)
              (define x (lambda () $y-marked))))))
       ($a $one 1)
       ($a $two 2)
       ($a $three 3)
       (equal? (list ($one) ($two) ($three)) '(1 2 3)))
     (not (top-level-bound? '$y-marked))
     (not (top-level-bound? '$y-marked))
     (begin
       (define-syntax $a
         (syntax-rules ()
           ((_ x e)
            (begin
              (define $y-marked e)
              (define-syntax x
                (identifier-syntax $y-marked))))))
       ($a $one 1)
       ($a $two 2)
       ($a $three 3)
       ($a $four 4)
       (equal? (list $one $two $three $four) '(1 2 3 4)))
     (begin
       ; once more, with feeling
       (define-syntax $a
         (syntax-rules ()
           ((_ x e)
            (begin
              (define $y-marked e)
              (define-syntax x
                (identifier-syntax $y-marked))))))
       ($a $one 1)
       ($a $two 2)
       ($a $three 3)
       ($a $four 4)
       (equal? (list $one $two $three $four) '(1 2 3 4)))
     (begin
       (module $foo ($a) (define-syntax $a (identifier-syntax 3)))
       (import $foo)
       (eq? $a 3))
     (begin
       ; keep with preceding mat
       (define-syntax $a (identifier-syntax 4))
       (eq? $a 4)))

(mat top-level-begin
     ; mats to test change to body-like semantics for begin
     (begin
       (define ($foofrah expr ans)
         (with-output-to-file "testfile.ss"
           (lambda () (pretty-print expr))
           'replace)
         (let* ([ss.out (with-output-to-string
                          (lambda () (load "testfile.ss")))]
                [cf.out (with-output-to-string
                          (lambda ()
                            (compile-file "testfile.ss")))]
                [so.out (with-output-to-string
                          (lambda () (load "testfile.so")))])
           (let ([actual (list ss.out
                               (substring cf.out
                                 (string-length "compiling testfile.ss with output to testfile.so\n")
                                 (string-length cf.out))
                               so.out)])
             (unless (equal? actual ans)
                     (pretty-print actual)
                     (errorf #f
                             "unexpected actual value ~s instead of ~s"
                             actual
                             ans))))
         #t)
       #t)
     ($foofrah '(begin
                  (define-record-type (a make-a a?)
                    (fields type mapper))
                  (define-syntax define-descendant
                    (lambda (x)
                      (syntax-case x ()
                        [(_ parent-id maker type name pred arg ...)
                         (with-syntax ([(getter ...) (generate-temporaries #'(arg ...))])
                           #'(define-record-type (name maker pred)
                               (parent parent-id)
                               (fields (immutable arg getter)
                                       ...)
                               (protocol (lambda (n)
                                           (lambda (arg ...)
                                             (letrec ([rec ((n 'type
                                                               (lambda (receiver)
                                                                 (receiver (getter rec) ...))) arg ...)])
                                               rec))))))])))
                  (define-descendant a make-a subname x x? y z)
                  (write ((a-mapper (make-a 3 4)) list)))
               '("(3 4)" "" "(3 4)"))
     ($foofrah '(begin
                  (eval-when (compile load eval) (write 1))
                  (eval-when (compile load eval)
                    (write 2)
                    (write 3))
                  (newline))
               '("123\n" "123" "123\n"))
     ($foofrah '(begin
                  (define (f) (import foo) x1)
                  (module foo (x1) (define x1 'x1))
                  (pretty-print (f)))
               '("x1\n" "" "x1\n"))
     ($foofrah '(begin
                  (define x2 'x2)
                  (module (y2) (define y2 x2))
                  (pretty-print y2))
               ;=> x2
               '("x2\n" "" "x2\n"))
     ($foofrah '(begin
                  (define x3 'x3)
                  (module foo (y2) (define y2 x3))
                  (import foo)
                  (pretty-print y2))
               ;=> x3
               '("x3\n" "" "x3\n"))
     ($foofrah '(eval-when (compile load)
                  (eval-when (compile load eval)
                    (define x4 "x4"))
                  (define-syntax a4 (lambda (q) x4))
                  (display a4))
               '("" "x4" "x4"))
     ($foofrah '(eval-when (compile load eval)
                  (define x5 "x5")
                  (display x5))
               '("x5" "x5" "x5"))
     (begin
       (define x5 "x5")
       ($foofrah ; keep with preceding test
         '(begin
            (define x5 "x5new")
            (define-syntax a5 (lambda (q) x5))
            (printf "~a ~a\n" a5 x5))
         '("x5 x5new\n" "" "x5new x5new\n")))
     ($foofrah '(begin
                  (define x6 a6)
                  (define-syntax a6
                    (identifier-syntax 'cool))
                  (pretty-print x6))
               '("cool\n" "" "cool\n"))
     (error? ; variable a7 is not bound
       (eval '(begin
                (define x7 a7)
                (define-syntax a7 (identifier-syntax 'cool))
                (define a7 'the-real-deal))))
     ($foofrah '(begin
                  (define x8 'not-cool)
                  (define (f8) x8)
                  (define x8 'just-right)
                  (pretty-print (f8)))
               ;=> just-right
               '("just-right\n" "" "just-right\n"))
     ($foofrah '(begin
                  (define x9 'not-cool)
                  (define-syntax a9 (identifier-syntax x9))
                  (define x9 'just-right)
                  (pretty-print a9))
               ;=> just-right
               '("just-right\n" "" "just-right\n"))
     ($foofrah '(begin
                  (define x10 a10)
                  (module m10
                    (x y)
                    (define-syntax x
                      (identifier-syntax 'm10-x))
                    (define y a10)
                    (define-syntax a10
                      (identifier-syntax 'm10-y)))
                  (library (l10)
                    (export x y)
                    (import (rnrs))
                    (define-syntax x
                      (identifier-syntax 'l10-x))
                    (define y a10)
                    (define-syntax a10
                      (identifier-syntax 'l10-y)))
                  (define-syntax a10
                    (identifier-syntax 'outer-x10))
                  (import (rename m10 (y yy)) (rename (l10) (x xx)))
                  (pretty-print (list x y xx yy)))
               '("(m10-x l10-y l10-x m10-y)\n"
                  ""
                  "(m10-x l10-y l10-x m10-y)\n"))
     ($foofrah '(begin
                  (define-syntax a
                    (syntax-rules ()
                      [(a q) (begin (define (q) x) (define x 4))]))
                  (a zz)
                  (pretty-print (zz)))
               '("4\n" "" "4\n"))
     ($foofrah '(begin
                  (eval-when (compile load eval)
                    (module const
                      (get put)
                      (define ht (make-eq-hashtable))
                      (define get
                        (lambda (name)
                          (hashtable-ref ht name 0)))
                      (define put
                        (lambda (name value)
                          (hashtable-set! ht name value)))))
                  (define-syntax dc
                    (syntax-rules ()
                      [(_ id e) (let () (import const) (put 'id e))]))
                  (define-syntax con
                    (syntax-rules ()
                      [(_ id) (let () (import const) (get 'id))]))
                  (dc spam 13)
                  (dc b (list (con spam) 's))
                  (pretty-print (list (con spam) (con b) (con c))))
               '("(13 (13 s) 0)\n" "" "(13 (13 s) 0)\n"))
     (begin (define const) (define dc) (define con) #t)
     ($foofrah '(begin
                  (eval-when (compile load eval)
                    (module const
                      (get put)
                      (define ht (make-eq-hashtable))
                      (define get
                        (lambda (name)
                          (hashtable-ref ht name 0)))
                      (define put
                        (lambda (name value)
                          (hashtable-set! ht name value)))))
                  (define-syntax dc
                    (syntax-rules ()
                      [(_ id e) (let () (import const) (put 'id e))]))
                  (define-syntax con
                    (syntax-rules ()
                      [(_ id) (let () (import const) (get 'id))]))
                  (eval-when (compile load eval)
                    (dc spam 13)
                    (dc b (list (con spam) 's)))
                  (eval-when (compile load eval)
                    (pretty-print (list (con spam) (con b) (con c)))))
               '("(13 (13 s) 0)\n" "(13 (13 s) 0)\n" "(13 (13 s) 0)\n"))
     (begin (define const) (define dc) (define con) #t)
     ($foofrah '(begin
                  (eval-when (compile load eval)
                    (module const
                      (get put)
                      (define ht (make-eq-hashtable))
                      (define get
                        (lambda (name)
                          (hashtable-ref ht name 0)))
                      (define put
                        (lambda (name value)
                          (hashtable-set! ht name value)))))
                  (define-syntax dc
                    (syntax-rules ()
                      [(_ id e)
                       (eval-when (compile load eval)
                         (let () (import const) (put 'id e)))]))
                  (define-syntax con
                    (syntax-rules ()
                      [(_ id)
                       (eval-when (compile load eval)
                         (let () (import const) (get 'id)))]))
                  (dc spam 13)
                  (dc b (list (con spam) 's))
                  (eval-when (compile load eval)
                    (pretty-print (list (con spam) (con b) (con c)))))
               '("(13 (13 s) 0)\n" "(13 (13 s) 0)\n" "(13 (13 s) 0)\n"))
     (begin (define const) (define dc) (define con) #t)
     ($foofrah '(begin
                  (eval-when (compile eval)
                    (module const
                      (get put)
                      (define ht (make-eq-hashtable))
                      (define get
                        (lambda (name)
                          (hashtable-ref ht name 0)))
                      (define put
                        (lambda (name value)
                          (hashtable-set! ht name value)))))
                  (define-syntax dc
                    (syntax-rules ()
                      [(_ id e)
                       (eval-when (compile eval)
                         (let () (import const) (put 'id e)))]))
                  (define-syntax con
                    (syntax-rules ()
                      [(_ id)
                       (eval-when (compile eval)
                         (let () (import const) (get 'id)))]))
                  (dc spam 13)
                  (dc b (list (con spam) 's))
                  (eval-when (compile eval)
                    (pretty-print (list (con spam) (con b) (con c)))))
               '("(13 (13 s) 0)\n" "(13 (13 s) 0)\n" ""))
     (begin (define const) (define dc) (define con) #t)
     ($foofrah '(begin
                  (define-syntax a
                    (identifier-syntax
                      (begin
                        (eval-when (compile eval)
                          (module const
                            (get put)
                            (define ht (make-eq-hashtable))
                            (define get
                              (lambda (name)
                                (hashtable-ref ht name 0)))
                            (define put
                              (lambda (name value)
                                (hashtable-set! ht name value)))))
                        (define-syntax dc
                          (syntax-rules ()
                            [(_ id e)
                             (eval-when (compile eval)
                               (let ()
                                 (import const)
                                 (put 'id e)))]))
                        (define-syntax con
                          (syntax-rules ()
                            [(_ id)
                             (eval-when (compile eval)
                               (let ()
                                 (import const)
                                 (get 'id)))]))
                        (dc spam 13)
                        (dc b (list (con spam) 's))
                        (eval-when (compile eval)
                          (pretty-print (list (con spam) (con b) (con c)))))))
                  a)
               '("(13 (13 s) 0)\n" "(13 (13 s) 0)\n" ""))
     (begin (define const) (define dc) (define con) #t)
     (begin
       (with-output-to-file "testfile-lib-c.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-lib-c)
                (export y)
                (import (chezscheme) (testfile-lib-a))
                (define y (lambda () x))
                (printf "invoke c\n"))))
         'replace)
       (with-output-to-file "testfile-test-ac.ss"
         (lambda ()
           (pretty-print
             '(begin
                (library (testfile-lib-a)
                  (export x)
                  (import (chezscheme))
                  (define x (lambda () 1))
                  (printf "invoke a\n"))
                (import (testfile-lib-c) (chezscheme))
                (pretty-print (eq? (y) y)))))
         'replace)
       #t)
     (let ([cf '(lambda (x)
                  (parameterize ([compile-imported-libraries #t])
                    (compile-file x)))])
       (separate-compile cf 'test-ac)
       #t)
     (equal? (separate-eval '(load "testfile-test-ac.so"))
             "invoke a\ninvoke c\n#f\n")
     ; make sure no local-label bindings make it into compiled wraps
     (begin
       (with-output-to-file "testfile.ss"
         (lambda ()
           (pretty-print
             '(let-syntax ([a (lambda (x) 0)])
                (define-syntax $foo (lambda (x) #'cons)))))
         'replace)
       (compile-file "testfile")
       (load "testfile.so")
       #t)
     (equal? $foo cons)
     (begin
       (with-output-to-file "testfile.ss"
         (lambda ()
           (pretty-print
             '(begin
                (define-syntax $foo-a (lambda (x) 0))
                (define-syntax $foo (lambda (x) #'cons)))))
         'replace)
       (compile-file "testfile")
       (load "testfile.so")
       #t)
     (equal? $foo cons))

#;
(mat top-level-begin-NOT
     ; these mats test a behavior we have at this point decided against,
     ; in which a syntax object for an identifier imported from a library
     ; via an import is inserted outside the scope of the local import
     ; in a compiled file, thus forcing an implicit import of the library
     ; when the compiled file is loaded.  possibly, the library should be
     ; imported when a reference is actually attempted, but we shouldn't
     ; import eagerly on the off chance that a syntax object will be used
     ; in this manner, because the import will usually be unnecessary.
     (begin
       (with-output-to-file "testfile-tlb-a1.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-tlb-a1)
                (export tlb-a1-rats)
                (import (rnrs))
                (define-syntax tlb-a1-rats
                  (identifier-syntax 17)))))
         'replace)
       (with-output-to-file "testfile-tlb-a2.ss"
         (lambda ()
           (pretty-print
             '(define-syntax tlb-a2-foo
                (let ()
                  (import (testfile-tlb-a1))
                  (lambda (x) #'(cons tlb-a1-rats 2))))))
         'replace)
       (with-output-to-file "testfile-tlb-a3.ss"
         (lambda ()
           (pretty-print
             '(let-syntax
                ([silly (lambda (x)
                          (import (testfile-tlb-a1))
                          (syntax-case x ()
                            [(_ id)
                             #'(define-syntax id
                                 (identifier-syntax (cons tlb-a1-rats 3)))]))])
                (silly tlb-a3-fluffy))))
         'replace)
       (with-output-to-file "testfile-tlb-a4.ss"
         (lambda ()
           (pretty-print
             '(module (tlb-a4-pie)
                (import (testfile-tlb-a1))
                (define-syntax tlb-a4-pie
                  (lambda (x) #'(cons tlb-a1-rats 4))))))
         'replace)
       (with-output-to-file "testfile-tlb-a5.ss"
         (lambda ()
           (pretty-print
             '(meta define tlb-a5-spam
                    (let ()
                      (import (testfile-tlb-a1))
                      #'(cons tlb-a1-rats 5)))))
         'replace)
       (with-output-to-file "testfile-tlb-a6a.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-tlb-a6a)
                (export tlb-a6-fop)
                (import (rnrs) (testfile-tlb-a1))
                (define tlb-a6-fop #'(cons tlb-a1-rats 6)))))
         'replace)
       (with-output-to-file "testfile-tlb-a6b.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-tlb-a6b)
                (export tlb-a6-alpha)
                (import (rnrs) (testfile-tlb-a6a))
                (define-syntax tlb-a6-alpha
                  (lambda (x) tlb-a6-fop)))))
         'replace)
       (with-output-to-file "testfile-tlb-a6c.ss"
         (lambda ()
           (pretty-print '(import (rnrs) (testfile-tlb-a6b)))
           (pretty-print '(write tlb-a6-alpha)))
         'replace)
       (with-output-to-file "testfile-tlb-a7.ss"
         (lambda ()
           (pretty-print
             '(define-property spam spam
                (let ()
                  (import (testfile-tlb-a1))
                  #'(cons tlb-a1-rats 7)))))
         'replace)
       (with-output-to-file "testfile-tlb-a8.ss"
         (lambda ()
           (pretty-print
             '(define tlb-a8-spam
                (let ()
                  (import (testfile-tlb-a1))
                  #'(cons tlb-a1-rats 8)))))
         'replace)
       (with-output-to-file "testfile-tlb-a9.ss"
         (lambda ()
           (pretty-print
             '(let ()
                (import (testfile-tlb-a1))
                (set! tlb-a9-spam #'(cons tlb-a1-rats 9)))))
         'replace)
       (with-output-to-file "testfile-tlb-a10.ss"
         (lambda ()
           (pretty-print '(import (scheme) (testfile-tlb-a1)))
           (pretty-print
             '(define-top-level-value 'tlb-a10-spam
                #'(cons tlb-a1-rats 10))))
         'replace)
       (let ([cf (lambda (what)
                   `(lambda (x)
                      (parameterize ([compile-imported-libraries #t])
                        (,what x))))])
         (separate-compile (cf 'compile-file) 'tlb-a2)
         (separate-compile (cf 'compile-file) 'tlb-a3)
         (separate-compile (cf 'compile-file) 'tlb-a4)
         (separate-compile (cf 'compile-file) 'tlb-a5)
         (separate-compile (cf 'compile-library) 'tlb-a6b)
         (separate-compile (cf 'compile-program) 'tlb-a6c)
         (separate-compile (cf 'compile-file) 'tlb-a7)
         (separate-compile (cf 'compile-file) 'tlb-a8)
         (separate-compile (cf 'compile-file) 'tlb-a9)
         (separate-compile (cf 'compile-program) 'tlb-a10))
       #t)
     (equal? (separate-eval '(visit "testfile-tlb-a2.so")
               '(pretty-print tlb-a2-foo))
             "(17 . 2)\n")
     (equal? (separate-eval '(visit "testfile-tlb-a3.so")
               '(pretty-print tlb-a3-fluffy))
             "(17 . 3)\n")
     (equal? (separate-eval '(visit "testfile-tlb-a4.so")
               '(pretty-print tlb-a4-pie))
             "(17 . 4)\n")
     (equal? (separate-eval '(visit "testfile-tlb-a5.so")
               '(pretty-print
                  (let-syntax ([a (lambda (x) tlb-a5-spam)])
                    a)))
             "(17 . 5)\n")
     (equal? (separate-eval '(revisit "testfile-tlb-a6c.so")) "(17 . 6)")
     (equal? (separate-eval '(visit "testfile-tlb-a7.so")
               '(pretty-print
                  (let-syntax
                    ([a (lambda (x) (lambda (r) (r #'spam #'spam)))])
                    a)))
             "(17 . 7)\n")
     (equal? (separate-eval '(revisit "testfile-tlb-a8.so")
               '(pretty-print
                  (let-syntax ([a (lambda (x) tlb-a8-spam)])
                    a)))
             "(17 . 8)\n")
     (equal? (separate-eval '(revisit "testfile-tlb-a9.so")
               '(pretty-print
                  (let-syntax ([a (lambda (x) tlb-a9-spam)])
                    a)))
             "(17 . 9)\n")
     ; don't really want to fix this one:
     (equal? (separate-eval '(load-program "testfile-tlb-a10.so")
               '(pretty-print
                  (let-syntax ([a (lambda (x) tlb-a10-spam)])
                    a)))
             "(17 . 10)\n")
     (begin
       (with-output-to-file "testfile-tlb-bQ.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-tlb-bQ)
                (export tlb-bq)
                (import (rnrs))
                (define-syntax tlb-bq
                  (identifier-syntax 17)))))
         'replace)
       (with-output-to-file "testfile-tlb-bA.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-tlb-bA)
                (export tlb-bset-a! tlb-bget-a)
                (import (rnrs))
                (define a #f)
                (define tlb-bset-a! (lambda (x) (set! a x)))
                (define tlb-bget-a (lambda () a)))))
         'replace)
       (with-output-to-file "testfile-tlb-bP.ss"
         (lambda ()
           (pretty-print
             '(import (rnrs)
                (rnrs eval)
                (testfile-tlb-bQ)
                (testfile-tlb-bA)))
           (pretty-print '(tlb-bset-a! #'tlb-bq))
           (pretty-print
             '(eval '(let ()
                       (define-syntax alpha
                         (lambda (x) (tlb-bget-a)))
                       (write (cons alpha 'B)))
                    (environment '(rnrs)
                      '(testfile-tlb-bA)
                      '(testfile-tlb-bQ)))))
         'replace)
       (let ([cf (lambda (what)
                   `(lambda (x)
                      (parameterize ([compile-imported-libraries #t])
                        (,what x))))])
         (separate-compile (cf 'compile-program) 'tlb-bP))
       #t)
     (equal? (separate-eval '(load-program "testfile-tlb-bP.so"))
             "(17 . B)"))

(mat deferred-transformer
     ; don't get caught being lazy on transformer evaluation
     (begin
       (define $ratfink
         (let ([state 0])
           (lambda ()
             (set! state (+ state 1))
             (lambda (x) state))))
       (procedure? $ratfink))
     (eqv? (let-syntax ((f ($ratfink))) (let-syntax ((g ($ratfink))) g)) 2))

(mat copy-environment
     ; dummy test to set up nondescript record-writer for environments
     ; so that error messages involving environments don't include generated
     ; names that may change from run to run.  the record-writer is reset at
     ; end of this mat.
     (equal? (let ([env-rtd (record-rtd (scheme-environment))])
               (set! *saved-record-writer*
                 (record-writer env-rtd))
               (record-writer env-rtd
                 (lambda (x p wr)
                   (display "#<environment>" p)))
               (format "~s" (scheme-environment)))
             "#<environment>")
     (equal? (let ([e (copy-environment (scheme-environment))])
               (eval '(define x 17) e)
               (eval '(define-syntax a
                        (syntax-rules ()
                          [(_ b c)
                           (begin
                             (define x c)
                             (define-syntax b
                               (identifier-syntax x)))]))
                     e)
               (eval '(a foo 33) e)
               (list (eval 'foo e) (eval 'x e) (top-level-value 'x e)))
             '(33 17 17))
     (equal? (let ([e (copy-environment (scheme-environment) #t)])
               (eval '(define x 17) e)
               (eval '(define-syntax a
                        (syntax-rules ()
                          [(_ b c)
                           (begin
                             (define x c)
                             (define-syntax b
                               (identifier-syntax x)))]))
                     e)
               (eval '(a foo 33) e)
               (list (eval 'foo e) (eval 'x e) (top-level-value 'x e)))
             '(33 17 17))
     (error? (let ([e (copy-environment (scheme-environment) #f)])
               (eval '(define x 17) e)
               (eval '(define-syntax a
                        (syntax-rules ()
                          [(_ b c)
                           (begin
                             (define x c)
                             (define-syntax b
                               (identifier-syntax x)))]))
                     e)
               (eval '(a foo 33) e)
               (list (eval 'foo e) (eval 'x e) (top-level-value 'x e))))
     (equal? (let* ([e1 (copy-environment (scheme-environment))]
                    [e2 (copy-environment e1)])
               (define-top-level-value 'list list* e1)
               (list (parameterize ([optimize-level 0])
                       (eval '(list 1 2 3) e1))
                     (parameterize ([optimize-level 0])
                       (eval '(list 1 2 3) e2))))
             '((1 2 . 3) (1 2 3)))
     (equal? (let* ([e1 (copy-environment (scheme-environment))]
                    [e2 (copy-environment e1)])
               (define-top-level-value 'list list* e1)
               (list (parameterize ([optimize-level 0])
                       (eval '(list 1 2 3) e1))
                     (parameterize ([optimize-level 0])
                       (eval '(list 1 2 3) e2))))
             '((1 2 . 3) (1 2 3)))
     (error? (let* ([e1 (copy-environment (scheme-environment))]
                    [e2 (copy-environment e1)])
               (set-top-level-value! 'list list* e1)
               (list (parameterize ([optimize-level 0])
                       (eval '(list 1 2 3) e1))
                     (parameterize ([optimize-level 0])
                       (eval '(list 1 2 3) e2)))))
     (equal? (let ([e1 (copy-environment (scheme-environment))])
               (define-top-level-value 'curly (lambda (x) (+ x 15)) e1)
               (let ([e2 (copy-environment e1)])
                 (define-top-level-value 'curly (lambda (x) (- x 15)) e2)
                 (list (eval '(curly 5) e1) (eval '(curly 5) e2))))
             '(20 -10))
     (equal? (let ([e1 (copy-environment (scheme-environment))])
               (set-top-level-value! 'curly (lambda (x) (+ x 15)) e1)
               (let ([e2 (copy-environment e1)])
                 (set-top-level-value! 'curly (lambda (x) (- x 15)) e2)
                 (list (eval '(curly 5) e1) (eval '(curly 5) e2))))
             '(20 -10))
     (equal? (let ([e1 (copy-environment (scheme-environment))])
               (define-top-level-value 'curly (lambda (x) (+ x 15)) e1)
               (let ([e2 (copy-environment e1)])
                 (define-top-level-value 'curly (lambda (x) (- x 15)) e1)
                 (list (eval '(curly 5) e1) (eval '(curly 5) e2))))
             '(-10 20))
     (equal? (let ([e1 (copy-environment (scheme-environment))])
               (set-top-level-value! 'curly (lambda (x) (+ x 15)) e1)
               (let ([e2 (copy-environment e1)])
                 (set-top-level-value! 'curly (lambda (x) (- x 15)) e1)
                 (list (eval '(curly 5) e1) (eval '(curly 5) e2))))
             '(-10 20))
     (equal? (let ([e (copy-environment (scheme-environment))])
               (eval '(define let 4) e)
               (define-top-level-value 'let* 6 e)
               (list (top-level-value 'let e) (eval '(list let*) e)))
             '(4 (6)))
     (error? (let ([e (copy-environment (scheme-environment))])
               (set-top-level-value! letrec 3 e)))
     (error? (let ([e (copy-environment (scheme-environment))])
               (set-top-level-value! 'letrec 3 e)))
     (error? (let ([e (copy-environment (scheme-environment))])
               (eval '(set! lambda 55) e)))
     (error? (let ([e (copy-environment (scheme-environment) #f)])
               (eval '(define cons 55) e)))
     (error? (let ([e (copy-environment (scheme-environment) #f)])
               (eval '(set! cons 55) e)))
     (error? (let ([e (copy-environment (scheme-environment) #f)])
               (define-top-level-value 'cons 3 e)))
     (error? (let ([e (copy-environment (scheme-environment) #f)])
               (set-top-level-value! 'cons 3 e)))
     (error? (let ([e (copy-environment (scheme-environment) #f)])
               (define-top-level-value 'frappule 3 e)))
     (error? (let ([e (copy-environment (scheme-environment) #f)])
               (set-top-level-value! 'irascible 3 e)))
     (error? (let ([e (copy-environment (scheme-environment))])
               (eval 'nonstandard-identifier e)))
     (equal? (let ([env-rtd (record-rtd (scheme-environment))])
               (record-writer env-rtd *saved-record-writer*)
               (format "~s" (scheme-environment)))
             "#<environment *scheme*>")
     (equal? (let ([e (copy-environment (scheme-environment) #t '())])
               (define-top-level-value 'cons list e)
               (list (eval '(cons 3 4) e) (top-level-bound? 'list e)))
             '((3 4) #f))
     (error? (let ([e (copy-environment (scheme-environment) #t '())])
               (eval '(quote 3) e)))
     (error? (let ([e (copy-environment (scheme-environment) #t '(scheme))])
               (eval '(import scheme) e)
               (eval '(let ((x 3)) x) e)))
     (error? (let ([e (copy-environment (scheme-environment) #t '(import))])
               (eval '(import scheme) e)
               (eval '(let ((x 3)) x) e)))
     (eqv? (let ([e (copy-environment
                      (scheme-environment)
                      #t
                      '(import scheme))])
             (eval '(import scheme) e)
             (eval '(let ((x 3)) x) e))
           3)
     (error? (let ([e (copy-environment
                        (scheme-environment)
                        #t
                        '(import scheme))])
               (eval '(import scheme) e)
               (set-top-level-value! 'cons 72 e)))
     (begin
       (define $copy-env-tmp1 723)
       (define $copy-env-tmp2 -327)
       (define $copy-env-env
         (copy-environment
           (interaction-environment)
           #t
           (remq 'let*
                 (remq 'cons
                       (remq '$copy-env-tmp1
                             (environment-symbols (interaction-environment)))))))
       (environment? $copy-env-env))
     (equal? (eval '(let ((x (list 1 2))) (list x x $copy-env-tmp2))
                   $copy-env-env)
             '(#0= (1 2) #0# -327))
     (error? (eval 'cons $copy-env-env))
     (error? (eval 'let* $copy-env-env))
     (error? (eval '$copy-env-tmp1 $copy-env-env))
     (begin
       (eval '(define + -) $copy-env-env)
       (begin
         (equal? (top-level-value '+ $copy-env-env) -)
         (equal? (eval '+ $copy-env-env) -)
         (equal? (eval '#2%+ $copy-env-env) +)))
     (equal? (begin
               (eval '(set! cons 52) $copy-env-env)
               (top-level-value 'cons $copy-env-env))
             52)

     ; verify new (as of csv7.5) copy-environment semantics
     (begin
       (define $ce-e1
         (copy-environment (scheme-environment) #t))
       (eval '(module foo (eek) (define eek -7)) $ce-e1)
       (eval '(import foo) $ce-e1)
       (eval '(define-syntax ez (identifier-syntax 'tuary)) $ce-e1)
       (define-top-level-value 'whence 'now $ce-e1)
       #t)
     (equal? (eval '(list cons eek whence ez) $ce-e1)
             `(,cons -7 now tuary))
     (begin (define $ce-e2 (copy-environment $ce-e1 #t)) #t)
     (equal? (eval '(list cons eek whence ez) $ce-e2)
             `(,cons -7 now tuary))
     (equal? (begin
               (eval '(set! eek (* eek 3)) $ce-e1)
               (list (eval '(let () (import foo) eek) $ce-e1)
                     (eval '(let () (import foo) eek) $ce-e2)
                     (eval 'eek $ce-e1)
                     (top-level-value 'eek $ce-e2)))
             '(-21 -21 -21 -21))
     (equal? (begin
               (eval '(set! eek (* eek 3)) $ce-e2)
               (list (eval '(let () (import foo) eek) $ce-e1)
                     (eval '(let () (import foo) eek) $ce-e2)
                     (eval 'eek $ce-e1)
                     (top-level-value 'eek $ce-e2)))
             '(-63 -63 -63 -63))
     (equal? (begin
               (set-top-level-value! 'eek 99 $ce-e1)
               (list (eval '(let () (import foo) eek) $ce-e1)
                     (eval '(let () (import foo) eek) $ce-e2)
                     (eval 'eek $ce-e1)
                     (top-level-value 'eek $ce-e2)))
             '(99 99 99 99))
     (equal? (begin
               (set-top-level-value! 'eek 'ack $ce-e2)
               (list (eval '(let () (import foo) eek) $ce-e1)
                     (eval '(let () (import foo) eek) $ce-e2)
                     (eval 'eek $ce-e1)
                     (top-level-value 'eek $ce-e2)))
             '(ack ack ack ack))
     (equal? (begin
               (eval '(set! whence 'later) $ce-e1)
               (list (eval 'whence $ce-e1)
                     (top-level-value 'whence $ce-e2)))
             '(later now))
     (equal? (begin
               (set-top-level-value! 'whence 'never $ce-e2)
               (list (eval 'whence $ce-e1)
                     (top-level-value 'whence $ce-e2)))
             '(later never))
     (error? ; cannot assign immutable variable
             (eval '(set! cons 4) $ce-e1))
     (error? ; cannot assign immutable variable
             (eval '(set! cons 4) $ce-e2))
     (error? ; cannot assign immutable variable
             (set-top-level-value! 'cons 4 $ce-e1))
     (error? ; cannot assign immutable variable
             (set-top-level-value! 'cons 4 $ce-e2))
     (error? ; invalid syntax
             (eval '(set! foo 4) $ce-e1))
     (error? ; invalid syntax
             (eval '(set! foo 4) $ce-e2))
     (error? ; not a variable
             (set-top-level-value! 'foo 4 $ce-e1))
     (error? ; not a variable
             (set-top-level-value! 'foo 4 $ce-e2))
     (error? ; invalid syntax
             (eval '(set! ez 4) $ce-e1))
     (error? ; invalid syntax
             (eval '(set! ez 4) $ce-e2))
     (error? ; not a variable
             (set-top-level-value! 'ez 4 $ce-e1))
     (error? ; not a variable
             (set-top-level-value! 'ez 4 $ce-e2))
     (error? ; invalid syntax
       (eval '(begin (alias ard ez) (set! ard 45)) $ce-e1))
     (equal? (let ()
               (define $ce-f1
                 (eval '(lambda () (list cons eek whence ez)) $ce-e1))
               (define $ce-f2
                 (eval '(lambda () (list cons eek whence ez)) $ce-e2))
               (define $ce-f3
                 (eval '(lambda () (list cons (let () (import foo) eek)))
                       $ce-e1))
               (define $ce-f4
                 (eval '(lambda () (list cons (let () (import foo) eek)))
                       $ce-e2))
               (eval '(define cons 3) $ce-e1)
               (define-top-level-value 'eek 4 $ce-e1)
               (eval '(define whence 5) $ce-e1)
               (define-top-level-value 'ez 6 $ce-e1)
               (define-top-level-value 'cons 'a $ce-e2)
               (eval '(define eek 'b) $ce-e2)
               (define-top-level-value 'whence 'c $ce-e2)
               (eval '(define ez 'd) $ce-e2)
               (list ($ce-f1)
                     ($ce-f2)
                     ($ce-f3)
                     ($ce-f4)
                     (eval '(list cons eek whence ez) $ce-e1)
                     (eval '(list cons eek whence ez) $ce-e2)
                     (list cons (eval '(let () (import foo) eek) $ce-e1))
                     (list cons (eval '(let () (import foo) eek) $ce-e2))))
             `((,cons ack 5 tuary)
               (,cons ack c tuary)
               (,cons ack)
               (,cons ack)
               (3 4 5 6)
               (a b c d)
               (,cons ack)
               (,cons ack)))
     (equal? (let ()
               (eval '(define foo 'not-a-module) $ce-e1)
               (list (eval 'foo $ce-e1)
                     (eval '(let () (import foo) eek) $ce-e2)))
             '(not-a-module ack))
     (equal? (let ([e (copy-environment
                        (interaction-environment)
                        #f
                        '(cons $ce-e1))])
               (list (eval 'cons e) (eval '$ce-e1 e)))
             (list cons $ce-e1))
     (let ([e1 (copy-environment (scheme-environment) #t '())])
       (define-top-level-value 'darth 'vader e1)
       (let ([e2 (copy-environment e1 #f)])
         (let ([e3 (copy-environment e2 #t)])
           (define (f)
             (map (lambda (e) (top-level-value 'darth e))
                  (list e1 e2 e3)))
           (and (equal? (environment-symbols e1) '(darth))
                (equal? (environment-symbols e2) '(darth))
                (equal? (environment-symbols e3) '(darth))
                (equal? (f) '(vader vader vader))
                (eq? (set-top-level-value! 'darth 'maul e1) (void))
                (equal? (f) '(maul vader vader))
                (eq? (set-top-level-value! 'darth 'poodle e3) (void))
                (equal? (f) '(maul vader poodle)))))))

(mat environment-mutable?
     (not (environment-mutable? (scheme-environment)))
     (environment-mutable? (interaction-environment))
     (environment-mutable? (copy-environment (scheme-environment))))

(mat trace-define-syntax
     (equivalent-expansion?
       (parameterize
         ([trace-output-port (open-output-string)] [print-gensym #f])
         (let ([x (expand '(let ()
                             (trace-define-syntax frob
                               (syntax-rules ()
                                 [(_ rot gut) (gut rot)]))
                             (frob 17 $tds-foo)))])
           (list x (get-output-string (trace-output-port)))))
       '(($tds-foo 17) "|(frob (frob 17 $tds-foo))\n|($tds-foo 17)\n")))

(mat meta
     (error? ; x out of context
             (let () (meta define x 3) x))
     (error? ; x out of context
             (module () (meta define x 3) x))
     (begin
       (module ($meta-z)
         (meta define x #'"jolly")
         (define-syntax y (lambda (z) x))
         (define $meta-z y))
       (equal? $meta-z "jolly"))
     (begin
       (module (mat-meta-bar)
         (module foo
           (macro-helper a b)
           (meta define
                 table
                 ; pretend this is a "big computation":
                 (map cons '(#\a #\b #\c) '(1 2 3)))
           (meta define lookup
                 (lambda (c)
                   (cond [(assq c table) => cdr] [else #f])))
           (meta define macro-helper
                 (lambda (x)
                   (syntax-case x ()
                     [(k c)
                      (with-syntax ([n (lookup (datum c))])
                        #'(list '(k c) a n))])))
           (define a 'is)
           (define-syntax b (lambda (x) (macro-helper x))))
         (define mat-meta-bar
           (lambda ()
             (import foo)
             (define-syntax d (lambda (x) (macro-helper x)))
             (list a (b #\b) (d #\c)))))
       (equal? (mat-meta-bar) '(is ((b #\b) is 2) ((d #\c) is 3))))
     (error? ; lookup out-of-context (in definition of c)
       (begin
         (module (mat-meta-bar)
           (module foo
             (macro-helper a b c)
             (meta define
                   table
                   ; pretend this is a "big computation":
                   (map cons '(#\a #\b #\c) '(1 2 3)))
             (meta define lookup
                   (lambda (c)
                     (cond
                       [(assq c table) => cdr]
                       [else #f])))
             (meta define macro-helper
                   (lambda (x)
                     (syntax-case x ()
                       [(k c)
                        (with-syntax ([n (lookup (datum c))])
                          #'(list '(k c) a n))])))
             (define a 'is)
             (define-syntax b (lambda (x) (macro-helper x)))
             (define c
               (lambda (s) (map lookup (string->list s)))))
           (define mat-meta-bar
             (lambda ()
               (import foo)
               (define-syntax d
                 (lambda (x) (macro-helper x)))
               (list a (b #\b) (c "aq") (d #\c)))))
         (equal? (mat-meta-bar) '(is ((b #\b) is 2) (1 #f) ((d #\c) is 3)))))
     (begin
       (module mat-meta-foo
         (macro-helper a b)
         (meta define
               table
               ; pretend this is a "big computation":
               (map cons '(#\a #\b #\c) '(1 2 3)))
         (meta define lookup
               (lambda (c)
                 (cond [(assq c table) => cdr] [else #f])))
         (meta define macro-helper
               (lambda (x)
                 (syntax-case x ()
                   [(k c)
                    (with-syntax ([n (lookup (datum c))])
                      #'(list '(k c) a n))])))
         (define a 'is)
         (define-syntax b (lambda (x) (macro-helper x))))
       #t)
     (equal? (let ()
               (define mat-meta-bar1
                 (lambda ()
                   (import mat-meta-foo)
                   (define-syntax d
                     (lambda (x) (macro-helper x)))
                   (list a (b #\b) (d #\c))))
               (mat-meta-bar1))
             '(is ((b #\b) is 2) ((d #\c) is 3)))
     (begin
       (define mat-meta-bar2
         (lambda ()
           (import mat-meta-foo)
           (define-syntax d (lambda (x) (macro-helper x)))
           (list a (b #\b) (d #\c))))
       (procedure? mat-meta-bar2))
     (equal? (mat-meta-bar2) '(is ((b #\b) is 2) ((d #\c) is 3)))
     (error? ; out-of-context (run-time reference to meta variable)
       (let ()
         (module foo
           (macro-helper a b c)
           (meta define
                 table
                 ; pretend this is a "big computation":
                 (map cons '(#\a #\b #\c) '(1 2 3)))
           (meta define lookup
                 (lambda (c)
                   (cond [(assq c table) => cdr] [else #f])))
           (meta define macro-helper
                 (lambda (x)
                   (syntax-case x ()
                     [(k c)
                      (with-syntax ([n (lookup (datum c))])
                        #'(list '(k c) a n))])))
           (define a 'is)
           (define-syntax b (lambda (x) (macro-helper x)))
           (define c
             (lambda (s) (map lookup (string->list s)))))
         (define bar
           (lambda ()
             (import foo)
             (define-syntax d (lambda (x) (macro-helper x)))
             (list a (b #\b) (c "aq") (d #\c))))
         (bar)))
     (begin
       (module (mat-meta-q mat-meta-a)
         (meta define mat-meta-q 13)
         (define-syntax mat-meta-a
           (lambda (x)
             (set! mat-meta-q (* mat-meta-q 2))
             (with-syntax ((n mat-meta-q))
               #'(list n (- mat-meta-q 6))))))
       (meta define mat-meta-x
             (begin
               (set! mat-meta-q (+ mat-meta-q 4))
               mat-meta-q))
       (meta module () (set! mat-meta-q (+ mat-meta-q 10)))
       (define-syntax ans
         (lambda (x)
           (with-syntax
             ([d (cons (quotient (+ mat-meta-q mat-meta-x) 2) mat-meta-a)])
             #''d)))
       (equal? ans '(35 54 48)))
     (equal? (let ()
               (module (mat-meta-q mat-meta-a)
                 (meta define mat-meta-q 13)
                 (define-syntax mat-meta-a
                   (lambda (x)
                     (set! mat-meta-q (* mat-meta-q 2))
                     (with-syntax ((n mat-meta-q))
                       #'(list n (- mat-meta-q 6))))))
               (meta define mat-meta-x
                     (begin
                       (set! mat-meta-q (+ mat-meta-q 4))
                       mat-meta-q))
               (meta module () (set! mat-meta-q (+ mat-meta-q 10)))
               (define-syntax ans
                 (lambda (x)
                   (with-syntax
                     ([d (cons (quotient (+ mat-meta-q mat-meta-x) 2)
                               mat-meta-a)])
                     #''d)))
               ans)
             '(35 54 48))
     (begin
       (module (mat-meta-zeta)
         (meta module frobrat (boz) (define boz 3))
         (define-syntax rot
           (lambda (x) (import frobrat) boz))
         (define mat-meta-zeta rot))
       (eq? mat-meta-zeta 3))
     (begin
       (module (mat-meta-gorp)
         (meta define f (lambda (x) (if (= x 0) '() (cons x (f (- x 1))))))
         (define-syntax mat-meta-gorp
           (lambda (x)
             (syntax-case x ()
               [(_ n)
                (with-syntax ([(num ...) (f (datum n))])
                  #'(list num ...))]))))
       (equal? (mat-meta-gorp 5) '(5 4 3 2 1)))
     (error? ; f not bound (referenced in alpha before definition complete)
       (module (mat-meta-gorp)
         (meta define f
               (lambda (x)
                 (define-syntax alpha
                   (lambda (x)
                     (f x)
                     ; f not bound (yet)
                     #'()))
                 (if (= x 0) alpha (cons x (f (- x 1))))))
         (define-syntax mat-meta-gorp
           (lambda (x)
             (syntax-case x ()
               [(_ n)
                (with-syntax ([(num ...) (f (datum n))])
                  #'(list num ...))])))))
     (begin
       (define-syntax $cftest
         (syntax-rules ()
           [(_ e0 e1 e2)
            (begin
              (collect (collect-maximum-generation))
              ; close ports left open by load/compile-file w/mat's error handler
              (let ((op (open-output-file "testfile.ss" 'replace)))
                (pretty-print 'e0 op)
                (close-output-port op))
              (compile-file "testfile.ss")
              (and e1 (begin (load "testfile.ss") e2)))]))
       #t)
     ($cftest (begin (meta define meta-$bun 3) (define meta-$burger 4))
              (equal? meta-$bun 3)
              (equal? meta-$burger 4))
     (error? ($cftest (meta define meta-$lettuce 3)
                      (equal? meta-$bun 3)
                      (equal? meta-$burger 4)))
     ; check to make sure meta still works if we change interaction environment
     (eqv? (parameterize
             ([interaction-environment
                (copy-environment (interaction-environment))])
             (eval '(let ()
                      (meta define foo 3)
                      (meta define bar (* 3 7))
                      (define-syntax a
                        (lambda (x) (+ foo bar)))
                      a)))
           24))

(mat meta2
     (error? ; x out-of-context
             (begin (meta define x 3) x))
     (begin
       (meta define x 3)
       (define-syntax y (lambda (z) x))
       (eq? y 3))

     ; top-level module tests
     (error? ; x out-of-context
       (module m (x) (meta define x 3) (pretty-print x)))
     (error? ; x out-of-context
       (begin
         (module m (x) (meta define x 3))
         (let () (import m) x)))
     (begin
       (module m (x) (meta define x 3))
       (eq? (let () (import m) (define-syntax y (lambda (z) x)) y) 3))
     (error? ; x out-of-context
       (begin (module m (x) (meta define x 3)) (import m) x))
     (begin
       (module mm-m (mm-x) (meta define mm-x 3))
       (import mm-m)
       (define-syntax mm-y (lambda (z) mm-x))
       (eq? mm-y 3))
     (begin
       (module ($meta-z)
         (meta define x #'"jolly")
         (define-syntax y (lambda (z) x))
         (define $meta-z y))
       (equal? $meta-z "jolly"))
     ; local tests
     (error? ;=> out-of-context or unbound error
             (let ()
               (module m (x) (meta define x 3) (pretty-print x))
               4))
     (error? ;=> out-of-context or unbound error
             (let ()
               (module m (x) (meta define x 3))
               (let () (import m) x)))
     (eq? (let ()
            (module m (x) (meta define x 3))
            (let ()
              (import m)
              (define-syntax y (lambda (z) x))
              y))
          3)
     (let ()
       (module ($meta-z)
         (meta define x #'"jolly")
         (define-syntax y (lambda (z) x))
         (define $meta-z y))
       (equal? $meta-z "jolly"))
     (error? ;=> q out-of-context
       (let ()
         (meta define p 3)
         (define-syntax a
           (lambda (x)
             (meta define q 4)
             `(,#'quote (,p ,q))))
         a))
     (equal? (let ()
               (meta define p 3)
               (define-syntax a
                 (lambda (x)
                   (meta define q 4)
                   (define-syntax b (lambda (x) q))
                   `(,#'quote (,p ,b))))
               a)
             '(3 4))
     (begin
       (define $mm-p "p")
       (define $mm-q "q")
       (define $mm-r "r")
       (meta module
             ($mm-a $mm-b $mm-c)
             (define t '())
             (define $mm-a
               (lambda (k v)
                 (set! t (cons (cons k v) t))
                 #'(void)))
             (define $mm-b (lambda (k) (cdr (assq k t))))
             (define-syntax $mm-c
               (lambda (x)
                 (syntax-case x (get put)
                   [(_ get n) ($mm-b (datum n))]
                   [(_ put n v) ($mm-a (datum n) #'v)])))
             (set! t `((1 . ,#'$mm-q) (2 . ,#'$mm-r))))
       ($mm-c put 7 $mm-p)
       (equal? (list ($mm-c get 1) ($mm-c get 2) ($mm-c get 7))
               '("q" "r" "p")))
     (equal? (let ([p "p!"] [q "q!"] [r "r!"])
               (meta module
                     (a b c)
                     (define t '())
                     (define a
                       (lambda (k v)
                         (set! t (cons (cons k v) t))
                         #'(void)))
                     (define b
                       (lambda (k) (cdr (assq k t))))
                     (define-syntax c
                       (lambda (x)
                         (syntax-case x (get put)
                           [(_ get n) (b (datum n))]
                           [(_ put n v) (a (datum n) #'v)])))
                     (set! t `((1 . ,#'q) (2 . ,#'r))))
               (c put 7 p)
               (list (c get 1) (c get 2) (c get 7)))
             '("q!" "r!" "p!"))
     ; assuming internal-defines-as-letrec* defaults to #t
     (internal-defines-as-letrec*)
     ; following tests assume it's set to #f
     (begin
       (internal-defines-as-letrec* #f)
       (not (internal-defines-as-letrec*)))
     ; top-level module tests
     (error? ; undefined variable merry
       (module sam
         (frodo)
         (define merry 'merry)
         (define frodo (cons merry merry))))
     (error? ; undefined variable frodo
       (module sam
         (frodo)
         (define merry 'merry)
         (define frodo 'frodo)
         (define pippin (cons frodo frodo))))
     (begin
       (internal-defines-as-letrec* #t)
       (internal-defines-as-letrec*))
     (eq? (let ()
            (module (x !y ?y)
              (define x (call/cc values))
              (define y 0)
              (define !y (lambda (v) (set! y v)))
              (define ?y (lambda () y)))
            (!y (+ (?y) 1))
            (x values)
            (?y))
          1)
     (begin
       (module (x !y ?y)
         (define x (call/cc values))
         (define y 0)
         (define !y (lambda (v) (set! y v)))
         (define ?y (lambda () y)))
       (!y (+ (?y) 1))
       (x values)
       (eq? (?y) 1))
     (begin
       (meta define hobbits '())
       (module ()
         (meta module () (set! hobbits (cons 'merry hobbits)))
         (meta module
               ()
               (set! hobbits (cons 'lobelia hobbits))
               (set! hobbits (cons 'frodo hobbits))
               (set! hobbits (cons 'bilbo hobbits)))
         (meta begin (set! hobbits (cons 'pippin hobbits))))
       (define-syntax hobbit-report
         (lambda (x)
           `(,#'quote ,(datum->syntax #'* hobbits))))
       (equal? hobbit-report '(pippin bilbo frodo lobelia merry)))
     (let ()
       (meta define hobbits '())
       (module ()
         (meta module () (set! hobbits (cons 'merry hobbits)))
         (meta module
               ()
               (set! hobbits (cons 'lobelia hobbits))
               (set! hobbits (cons 'frodo hobbits))
               (set! hobbits (cons 'bilbo hobbits)))
         (meta begin (set! hobbits (cons 'pippin hobbits))))
       (define-syntax hobbit-report
         (lambda (x)
           `(,#'quote ,(datum->syntax #'* hobbits))))
       (equal? hobbit-report '(pippin bilbo frodo lobelia merry)))
     (begin
       (meta define $whatsit)
       (meta begin (set! $whatsit #xc7c7c7c7))
       (define-syntax $mm-a (lambda (x) $whatsit))
       (eqv? $mm-a #xc7c7c7c7))
     (error? ; no expr in body
             (let () (meta begin (void))))
     (error? ; invalid meta definition ((void))
             (meta (void)))
     (error? ; invalid meta definition ((void))
             (module () (meta (void))))
     (error? ; invalid meta definition ((void))
             (let () (meta (void))))
     (begin
       (define hobbits '())
       (module ()
         (module () (set! hobbits (cons 'merry hobbits)))
         (module ()
           (set! hobbits (cons 'lobelia hobbits))
           (set! hobbits (cons 'frodo hobbits))
           (set! hobbits (cons 'bilbo hobbits)))
         (set! hobbits (cons 'pippin hobbits)))
       (equal? hobbits '(pippin bilbo frodo lobelia merry)))
     (let ()
       (define hobbits '())
       (module ()
         (module () (set! hobbits (cons 'merry hobbits)))
         (module ()
           (set! hobbits (cons 'lobelia hobbits))
           (set! hobbits (cons 'frodo hobbits))
           (set! hobbits (cons 'bilbo hobbits)))
         (set! hobbits (cons 'pippin hobbits)))
       (equal? hobbits '(pippin bilbo frodo lobelia merry)))
     ; assuming internal-defines-as-letrec* true
     (internal-defines-as-letrec*)
     (begin
       (define hobbits '())
       (module sam
         (frodo)
         (define merry (set! hobbits (cons 'merry hobbits)))
         (define frodo (set! hobbits (cons 'frodo hobbits)))
         (define pippin
           (set! hobbits (cons 'pippin hobbits))))
       (equal? hobbits '(pippin frodo merry)))
     (let ()
       (define hobbits '())
       (module sam
         (frodo)
         (define merry (set! hobbits (cons 'merry hobbits)))
         (define frodo (set! hobbits (cons 'frodo hobbits)))
         (define pippin
           (set! hobbits (cons 'pippin hobbits))))
       (equal? hobbits '(pippin frodo merry)))
     (begin
       (define hobbits '())
       (module sam
         (frodo)
         (define merry (set! hobbits (cons 'merry hobbits)))
         (module (frodo)
           (define lobelia (set! hobbits (cons 'lobelia hobbits)))
           (define frodo (set! hobbits (cons 'frodo hobbits)))
           (define bilbo (set! hobbits (cons 'bilbo hobbits))))
         (define pippin
           (set! hobbits (cons 'pippin hobbits))))
       (equal? hobbits '(pippin bilbo frodo lobelia merry)))
     (let ()
       (define hobbits '())
       (module sam
         (frodo)
         (define merry (set! hobbits (cons 'merry hobbits)))
         (module (frodo)
           (define lobelia (set! hobbits (cons 'lobelia hobbits)))
           (define frodo (set! hobbits (cons 'frodo hobbits)))
           (define bilbo (set! hobbits (cons 'bilbo hobbits))))
         (define pippin
           (set! hobbits (cons 'pippin hobbits))))
       (equal? hobbits '(pippin bilbo frodo lobelia merry)))
     (begin
       (module sam
         (frodo)
         (define merry 'merry)
         (define frodo (cons merry merry)))
       (equal? (let () (import sam) frodo) '(merry . merry)))
     (error? ; undefined variable merry
       (module sam
         (frodo)
         (define frodo (cons merry merry))
         (define merry 'merry)))
     (error? ; undefined variable frodo
       (module sam
         (frodo)
         (define merry 'merry)
         (define pippin (cons frodo frodo))
         (define frodo 'frodo)))
     (begin
       (module sam
         (frodo)
         (define merry 'merry)
         (define frodo (lambda () pippin))
         (define pippin (cons frodo frodo)))
       (let () (import sam) (eq? (car (frodo)) frodo)))
     (let ()
       (module (x !y ?y)
         (define x (call/cc values))
         (define y 0)
         (define !y (lambda (v) (set! y v)))
         (define ?y (lambda () y)))
       (!y (+ (?y) 1))
       (x values)
       (eq? (?y) 1))
     (begin
       (module (x !y ?y)
         (define x (call/cc values))
         (define y 0)
         (define !y (lambda (v) (set! y v)))
         (define ?y (lambda () y)))
       (!y (+ (?y) 1))
       (x values)
       (eq? (?y) 1))
     ; test for proper evaluation of meta defines and inits at compile-file time,
     ; visit time, revisit time, and load time
     (begin
       (with-output-to-file "testfile.ss"
         (lambda ()
           (pretty-print
             '(meta module
                    $mm-m
                    (a)
                    (define q 3)
                    (define-syntax qinc!
                      (identifier-syntax (set! q (+ q 1))))
                    (define-syntax (a x) qinc! q)
                    qinc!
                    (set! q (* q q)))))
         'replace)
       (compile-file "testfile")
       #t)
     (eq? (let () (import $mm-m) a) 17)
     (eq? (let () (import $mm-m) a) 18)
     (begin (visit "testfile.so") #t)
     (eq? (let () (import $mm-m) a) 17)
     (eq? (let () (import $mm-m) a) 18)
     (begin (load "testfile.so") #t)
     (eq? (let () (import $mm-m) a) 17)
     (eq? (let () (import $mm-m) a) 18)
     (begin (revisit "testfile.so") #t)
     (eq? (let () (import $mm-m) a) 19))

(mat quasisyntax
     (error? ; invalid syntax
             quasisyntax)
     (error? ; invalid syntax
             (quasisyntax))
     (error? ; invalid syntax
             (quasisyntax . a))
     (error? ; invalid syntax
             (quasisyntax a b c))
     (error? ; misplaced
             (unsyntax x))
     (error? ; misplaced
             (unsyntax-splicing x))
     (error? ; misplaced
             (unsyntax x y))
     (error? ; misplaced
             (unsyntax-splicing x y))
     (error? ; misplaced
             (unsyntax))
     (error? ; misplaced
             (unsyntax-splicing))
     (error? ; misplaced
             unsyntax)
     (error? ; misplaced
             unsyntax-splicing)
     (begin
       (define-syntax qs-foo
         (lambda (x)
           (syntax-case x ()
             [(_ x ...) #`(list #,(length #'(x ...)) 'x ...)])))
       #t)
     (equal? (qs-foo 3 2 1) '(3 3 2 1))
     (equal? (qs-foo 3 2 1) '(3 3 2 1))
     (begin
       (define-syntax qs-foo
         (lambda (x)
           (syntax-case x ()
             [(_ x ...)
              (quasisyntax (list (unsyntax (length #'(x ...))) 'x ...))])))
       #t)
     (equal? (qs-foo 3 2 1) '(3 3 2 1))
     (equal? (qs-foo 3 2 1) '(3 3 2 1))
     (begin
       (define-syntax qs-foo
         (lambda (x)
           (syntax-case x ()
             [(_ x ...)
              #`'#`(a #,a b #,@b #,#(#,@#'(x ...)) #,@#(#,#'(x ...)))])))
       #t)
     (equal? (qs-foo 3 2 1)
       '(quasisyntax
          (a (unsyntax a)
             b
             (unsyntax-splicing b)
             (unsyntax #3(3 2 1))
             (unsyntax-splicing #1((3 2 1))))))
     (begin
       (define-syntax qs-foo
         (lambda (x)
           (syntax-case x ()
             [(_ x ...)
              #`'(a #(#,#'(x ...)
                      #,@#'(x ...)
                      unsyntax
                      unsyntax-splicing
                      ,a
                      ,@b)
                    (a . #,#'(x ...))
                    .
                    c)])))
       #t)
     (equal? (qs-foo 3 2 1)
       '(a #8((3 2 1) 3 2 1 unsyntax unsyntax-splicing ,a ,@b) (a 3 2 1) . c))
     (begin
       (define-syntax qs-foo
         (lambda (x)
           (syntax-case x ()
             [(_ x ...)
              #`'#(a (#,#'(x ...)
                      #,@#'(x ...)
                      unsyntax
                      unsyntax-splicing
                      ,a
                      ,@b)
                     (a . #,#'(x ...)))])))
       #t)
     (equal? (qs-foo 3 2 1)
       '#3(a ((3 2 1) 3 2 1 unsyntax unsyntax-splicing ,a ,@b) (a 3 2 1)))
     ; test zero and two+ unsyntax-splicing subforms
     (begin
       (define-syntax qs-foo
         (lambda (x)
           (syntax-case x ()
             [(_ x ...)
              #`'((unsyntax) 0 (unsyntax #'(a x ... b) #'(x ...)) c)])))
       #t)
     (equal? (qs-foo 3 2 1) '(0 (a 3 2 1 b) (3 2 1) c))
     (begin
       (define-syntax qs-foo
         (lambda (x)
           (syntax-case x ()
             [(_ x ...)
              #`'#((unsyntax) 0 (unsyntax #'(a x ... b) #'(x ...)) c)])))
       #t)
     (equal? (qs-foo 3 2 1) '#(0 (a 3 2 1 b) (3 2 1) c))
     ; test zero and two+ unsyntax-splicing subforms
     (begin
       (define-syntax qs-foo
         (lambda (x)
           (syntax-case x ()
             [(_ x ...)
              #`'((unsyntax-splicing)
                  0
                  (unsyntax-splicing #'(a x ... b) #'(x ...))
                  c)])))
       #t)
     (equal? (qs-foo 3 2 1) '(0 a 3 2 1 b 3 2 1 c))
     (begin
       (define-syntax qs-foo
         (lambda (x)
           (syntax-case x ()
             [(_ x ...)
              #`'#((unsyntax-splicing)
                   0
                   (unsyntax-splicing #'(a x ... b) #'(x ...))
                   c)])))
       #t)
     (equal? (qs-foo 3 2 1) '#(0 a 3 2 1 b 3 2 1 c))
     ; make sure out-of-place unsyntax/unsyntax-splicing keywords are left alone
     (begin
       (define-syntax qs-foo
         (lambda (x)
           (syntax-case x () [(_ x ...) #`'unsyntax])))
       #t)
     (equal? (qs-foo 3 2 1) 'unsyntax)
     (begin
       (define-syntax qs-foo
         (lambda (x)
           (syntax-case x ()
             [(_ x ...) #`'unsyntax-splicing])))
       #t)
     (equal? (qs-foo 3 2 1) 'unsyntax-splicing)
     (begin
       (define-syntax qs-foo
         (lambda (x)
           (syntax-case x ()
             [(_ x ...) #`'(a . (unsyntax #'(x ...) #'(x ...)))])))
       #t)
     (equal? (qs-foo 3 2 1)
       '(a . (unsyntax (syntax (3 2 1)) (syntax (3 2 1)))))
     (begin
       (define-syntax qs-foo
         (lambda (x)
           (syntax-case x ()
             [(_ x ...) #`'(a . (unsyntax-splicing #'(x ...)))])))
       #t)
     (equal? (qs-foo 3 2 1) '(a . (unsyntax-splicing (syntax (3 2 1)))))
     ; test noninterference with quasiquote
     (begin
       (define-syntax qs-foo
         (lambda (x)
           (syntax-case x ()
             [(_ x1 x2 ...)
              #``(a ,@(reverse (list #,@#'(x2 ...))) ,#,#'x1)])))
       #t)
     (equal? (qs-foo 3 2 1) '(a 1 2 3))
     ; tests adpated from Andre van Tonder posts to srfi 93 discussion
     (equal? (let ()
               (define-syntax swap!
                 (lambda (e)
                   (syntax-case e ()
                     [(_ a b)
                      (let ([a #'a] [b #'b])
                        (quasisyntax
                          (let ([temp (unsyntax a)])
                            (set! (unsyntax a) (unsyntax b))
                            (set! (unsyntax b) temp))))])))
               (let ([temp 1] [set! 2])
                 (swap! set! temp)
                 (cons temp set!)))
             '(2 . 1))
     (eq? (let ()
            (define-syntax case
              (lambda (x)
                (syntax-case x ()
                  [(_ e c1 c2 ...)
                   (quasisyntax
                     (let ([t e])
                       (unsyntax (let f ([c1 #'c1] [cmore #'(c2 ...)])
                                   (if (null? cmore)
                                       (syntax-case c1 (else)
                                         [(else e1 e2 ...) #'(begin e1 e2 ...)]
                                         [((k ...) e1 e2 ...)
                                          #'(if (memv t '(k ...))
                                                (begin
                                                  e1
                                                  e2
                                                  ...))])
                                       (syntax-case c1 ()
                                         [((k ...) e1 e2 ...)
                                          (quasisyntax
                                            (if (memv t '(k ...))
                                                (begin
                                                  e1
                                                  e2
                                                  ...)
                                                (unsyntax (f (car cmore) (cdr cmore)))))]))))))])))
            (case 'a [(b c) 'no] [(d a) 'yes]))
          'yes)
     (eqv? (let ()
             (define-syntax let-in-order
               (lambda (form)
                 (syntax-case form ()
                   [(_ ((i e) ...) e0 e1 ...)
                    (let f ([ies #'((i e) ...)] [its #'()])
                      (syntax-case ies ()
                        [() (quasisyntax (let (unsyntax its) e0 e1 ...))]
                        [((i e) . ies)
                         (with-syntax ([t (car (generate-temporaries '(t)))])
                           (quasisyntax
                             (let ([t e])
                               (unsyntax (f #'ies
                                            (quasisyntax ((i t) (unsyntax-splicing its))))))))]))])))
             (let-in-order ((x 1) (y 2)) (+ x y)))
           3)
     (equal? (let-syntax
               ([test-ellipses-over-unsyntax
                  (lambda (e)
                    (let ([a #'a])
                      (with-syntax ([(b ...) #'(1 2 3)])
                        (quasisyntax '((b #,a) ...)))))])
               (test-ellipses-over-unsyntax))
             '((1 a) (2 a) (3 a)))
     (equal? (let-syntax
               ([test (lambda (_) (quasisyntax '(list #,(+ 1 2) 4)))])
               (test))
             '(list 3 4))
     (equal? (let-syntax
               ([test (lambda (_)
                        (let ([name #'a])
                          (quasisyntax '(list #,name '#,name))))])
               (test))
             '(list a 'a))
     (equal? (let-syntax
               ([test (lambda (_)
                        (quasisyntax
                          '(a #,(+ 1 2) #,@(map abs '(4 -5 6)) b)))])
               (test))
             '(a 3 4 5 6 b))
     (equal? (let-syntax
               ([test (lambda (_)
                        (quasisyntax
                          '((foo #,(- 10 3)) #,@(cdr '(5)) . #,(car '(7)))))])
               (test))
             '((foo 7) . 7))
     (equal? (let-syntax
               ([test (lambda (_)
                        (quasisyntax
                          '#(10 5 #,(sqrt 4) #,@(map sqrt '(16 9)) 8)))])
               (test))
             '#(10 5 2 4 3 8))
     (eqv? (let-syntax ([test (lambda (_) (quasisyntax #,(+ 2 3)))])
             (test))
           5)
     (equal? (let-syntax
               ([test (lambda (_)
                        (quasisyntax
                          '(a (quasisyntax (b #,(+ 1 2) #,(foo #,(+ 1 3) d) e))
                              f)))])
               (test))
             '(a (quasisyntax (b #,(+ 1 2) #,(foo 4 d) e)) f))

     (equal? (let-syntax
               ([test (lambda (_)
                        (let ([name1 #'x] [name2 #'y])
                          (quasisyntax
                            '(a (quasisyntax (b #,#,name1 #,#'#,name2 d)) e))))])
               (test))
             '(a (quasisyntax (b #,x #,#'y d)) e))
     ; Bawden's extensions:
     (equal? (let-syntax
               ([test (lambda (_) (quasisyntax '(a (unsyntax 1 2) b)))])
               (test))
             '(a 1 2 b))
     (equal? (let-syntax
               ([test (lambda (_)
                        (quasisyntax
                          '(a (unsyntax-splicing '(1 2) '(3 4)) b)))])
               (test))
             '(a 1 2 3 4 b))
     (equal? (let-syntax
               ([test (lambda (_)
                        (let ([x #'(a b c)])
                          (quasisyntax
                            '(quasisyntax (#,#,x #,@#,x #,#,@x #,@#,@x)))))])
               (test))
             '(quasisyntax
                (#,(a b c)
                 #,@(a b c)
                 (unsyntax a b c)
                 (unsyntax-splicing a b c)))))

(mat meta-cond
     (begin
       (define $meta-cond-expr
         '(meta-cond
            [(= (optimize-level) 3) $mc-a $mc-b $mc-c]
            [(= (optimize-level) 2) $mc-d]
            [else $mc-e $mc-f]))
       #t)
     (equivalent-expansion?
       (parameterize ([optimize-level 3]) (expand $meta-cond-expr))
       '(begin $mc-a $mc-b $mc-c))
     (equivalent-expansion?
       (parameterize ([optimize-level 2]) (expand $meta-cond-expr))
       '$mc-d)
     (equivalent-expansion?
       (parameterize ([optimize-level 0]) (expand $meta-cond-expr))
       '(begin $mc-e $mc-f))
     (equal? (parameterize ([optimize-level 0])
               ; should have no effect
               (with-output-to-string
                 (lambda ()
                   (meta-cond
                     [(= (optimize-level) 3) (pretty-print 'level3)]
                     [(= (optimize-level) 2) (pretty-print 'level2)]))))
             (case (optimize-level)
               [(2) "level2\n"]
               [(3) "level3\n"]
               [else ""])))

(mat make-compile-time-value
     (error? ; incorrect number of arguments
             (let ()
               (define-syntax a
                 (lambda (x) (lambda (r) (r))))
               a))
     (error? ; not an identifier
       (let ()
         (define-syntax a
           (lambda (x) (lambda (r) (r #'(a)))))
         a))
     (error? ; not an identifier
       (let ()
         (define-syntax a
           (lambda (x) (lambda (r) (r #'(a) #'frip))))
         a))
     (error? ; not an identifier
       (let ()
         (define-syntax a
           (lambda (x) (lambda (r) (r #'a "frip"))))
         a))
     (error? ; incorrect number of arguments
       (let ()
         (define-syntax a
           (lambda (x)
             (lambda (r) (r #'a #'frip "extra stuff"))))
         a))
     (error? ; not a compile-time value
             (compile-time-value-value 17))
     (begin
       (with-output-to-file "testfile-mctv0.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-mctv0)
                (export get-ctv get-property)
                (import (chezscheme))
                (define-syntax get-ctv
                  (lambda (x)
                    (lambda (r)
                      (syntax-case x ()
                        [(_ q) #`'#,(datum->syntax #'* (r #'q))]))))
                (define-syntax get-property
                  (lambda (x)
                    (lambda (r)
                      (syntax-case x ()
                        [(_ q prop)
                         #`'#,(datum->syntax #'* (r #'q #'prop))])))))))
         'replace)
       (for-each separate-compile '(mctv0))
       #t)
     (begin (import (testfile-mctv0)) #t)
     (compile-time-value? (make-compile-time-value 'fred))
     (begin
       (define-syntax frob (make-compile-time-value 'rabf))
       #t)
     (eq? (get-ctv frob) 'rabf)
     (error? ; invalid syntax
             frob)
     (error? ; invalid syntax
             (frob kupe))
     (eq? (let ()
            (define-syntax frob
              (make-compile-time-value 'shuddle))
            (get-ctv frob))
          'shuddle)
     (eq? (let-syntax ([frob (make-compile-time-value 'skupo)])
            (get-ctv frob))
          'skupo)
     (equal? (let ([frob "not the global frob ..."])
               (list frob (get-ctv frob)))
             '("not the global frob ..." #f))
     (eq? (get-ctv frob) 'rabf)
     (error? ; invalid syntax
       (let ()
         (define-syntax frob
           (make-compile-time-value 'shuddle))
         frob))
     (error? ; invalid syntax
       (let ()
         (define-syntax frob
           (make-compile-time-value 'shuddle))
         (frob)))
     (error? ; duplicate definition
       (module mctv-m1
         (x)
         (define x 3)
         (define-syntax x (make-compile-time-value 'xxx))))
     (error? ; duplicate definition
       (module mctv-m1
         (x)
         (define-syntax x (make-compile-time-value 'xxx))
         (define-syntax x (make-compile-time-value 'xxx))))
     (begin
       (module mctv-m1
         (x)
         (define-syntax x (make-compile-time-value 'xxx)))
       #t)
     (eq? (let () (import mctv-m1) (get-ctv x)) 'xxx)
     (begin
       (library (mctv l1)
         (export x)
         (import (chezscheme) (testfile-mctv0))
         (define-syntax x (make-compile-time-value 'xow)))
       #t)
     (eq? (let () (import (mctv l1)) (get-ctv x)) 'xow)
     (eq? (compile-time-value-value
            (top-level-syntax 'x (environment '(mctv l1))))
          'xow)
     (begin
       (with-output-to-file "testfile-mctv1.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-mctv1)
                (export x)
                (import (chezscheme))
                (define-syntax x
                  (make-compile-time-value 'xuko1)))))
         'replace)
       (for-each separate-compile '(mctv1))
       #t)
     (eq? (let () (import (testfile-mctv1)) (get-ctv x)) 'xuko1)
     (compile-time-value?
       (top-level-syntax 'x (environment '(testfile-mctv1))))
     (eq? (compile-time-value-value
            (top-level-syntax 'x (environment '(testfile-mctv1))))
          'xuko1)
     (begin
       (with-output-to-file "testfile-mctv1a.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-mctv1a)
                (export x)
                (import (chezscheme))
                (define-syntax x
                  (make-compile-time-value 'xuko1)))))
         'replace)
       (for-each separate-compile '(mctv1a))
       #t)
     (eq? (compile-time-value-value
            (top-level-syntax 'x (environment '(testfile-mctv1a))))
          'xuko1)
     (eq? (let () (import (testfile-mctv1a)) (get-ctv x)) 'xuko1)
     (begin
       (with-output-to-file "testfile-mctv2.ss"
         (lambda ()
           (pretty-print
             '(module mctv-m2
                (x)
                (define-syntax x
                  (make-compile-time-value 'xuko2)))))
         'replace)
       (for-each separate-compile '(mctv2))
       (load "testfile-mctv2.so")
       #t)
     (eq? (let () (import mctv-m2) (get-ctv x)) 'xuko2)
     (begin
       (with-output-to-file "testfile-mctv3.ss"
         (lambda ()
           (pretty-print
             '(define-syntax mctv3-x
                (make-compile-time-value 'xuko3))))
         'replace)
       (for-each separate-compile '(mctv3))
       (load "testfile-mctv3.so")
       #t)
     (eq? (get-ctv mctv3-x) 'xuko3)
     (begin
       (with-output-to-file "testfile-mctv4.ss"
         (lambda ()
           (printf "#! /usr/bin/env scheme-script\n")
           (pretty-print '(import (chezscheme) (testfile-mctv0)))
           (pretty-print '(define spod))
           (pretty-print '(define qrtz))
           (pretty-print '(define xptz))
           (pretty-print
             '(define-syntax x
                (make-compile-time-value 'xuko4)))
           (pretty-print '(define-property x spod "shuff"))
           (pretty-print '(define-property x qrtz "dmnd"))
           (pretty-print
             '(printf "~s ~s ~s ~s ~s\n"
                (get-property get-property spod)
                (get-property x spod)
                (get-property x qrtz)
                (get-property x xptz)
                (get-ctv x))))
         'replace)
       (for-each
         (lambda (x) (separate-compile 'compile-program x))
         '(mctv4))
       #t)
     (equal? (with-output-to-string
               (lambda () (load-program "testfile-mctv4.ss")))
             "#f \"shuff\" \"dmnd\" #f xuko4\n")
     (equal? (with-output-to-string
               (lambda () (load-program "testfile-mctv4.so")))
             "#f \"shuff\" \"dmnd\" #f xuko4\n")
     (eqv? (let ()
             (define foo 3)
             (define-syntax alpha
               (make-compile-time-value #'foo))
             (define-syntax beta
               (lambda (x) (lambda (r) (r #'alpha))))
             (let () (define foo 4) beta))
           3)
     (eqv? (let ()
             (define foo 3)
             (define-syntax alpha
               (lambda (x)
                 (syntax-case x ()
                   [(_ id)
                    #'(define-syntax id
                        (make-compile-time-value #'foo))])))
             (let ()
               (define foo 4)
               (alpha beta)
               (define-syntax gamma
                 (lambda (x) (lambda (r) (r #'beta))))
               gamma))
           ;=> 3
           3)
     #;
     ; decided not to have rebuild-macro-output delve into records...
     (eqv? (let ()
             (meta define-record-type rats (fields cheese))
             (define foo 3)
             (define-syntax alpha
               (lambda (x)
                 (syntax-case x ()
                   [(_ id)
                    #`(define-syntax id
                        (make-compile-time-value '#,(make-rats #'foo)))])))
             (let ()
               (define foo 4)
               (alpha beta)
               (define-syntax gamma
                 (lambda (x)
                   (lambda (r)
                     #`(let ()
                         (define foo 5)
                         #,(rats-cheese (r #'beta))))))
               gamma))
           3)
     #;
     ; decided not to have rebuild-macro-output delve into records...
     (eqv? (let ()
             (meta define-record-type rats (fields cheese))
             (define foo 3)
             (define-syntax alpha
               (lambda (x)
                 (syntax-case x ()
                   [(_ id)
                    #`(module (id)
                        (define foo 3.5)
                        (define-syntax id
                          (make-compile-time-value '#,(make-rats #'foo))))])))
             (let ()
               (define foo 4)
               (alpha beta)
               (define-syntax gamma
                 (lambda (x)
                   (lambda (r)
                     #`(let ()
                         (define foo 5)
                         #,(rats-cheese (r #'beta))))))
               gamma))
           3.5)
     (eqv? (let ()
             (meta define make-rats list)
             (meta define rats-cheese car)
             (define foo 3)
             (define-syntax alpha
               (lambda (x)
                 (syntax-case x ()
                   [(_ id)
                    #`(module (id)
                        (define foo 3.5)
                        (define-syntax id
                          (make-compile-time-value #'#,(make-rats #'foo))))])))
             (let ()
               (define foo 4)
               (alpha beta)
               (define-syntax gamma
                 (lambda (x)
                   (lambda (r)
                     #`(let ()
                         (define foo 5)
                         #,(syntax-case (r #'beta) ()
                             [(foo) #'foo])))))
               gamma))
           3.5))

(mat define-property
     (begin
       (library (dp get-property)
         (export get-property)
         (import (scheme))
         (define-syntax get-property
           (lambda (x)
             (lambda (r)
               (syntax-case x ()
                 [(_ q prop) #`'#,(datum->syntax #'* (r #'q #'prop))])))))
       (import (dp get-property))
       #t)
     (begin
       (define-property cons frotz 'spamgle)
       (equal? (cons (get-property cons frotz) (get-property cons fratz))
               '(spamgle . #f)))
     (equal? (cons (get-property cons frotz) (get-property cons fratz))
             '(spamgle . #f))
     (equal? (let ()
               (import scheme)
               (cons (get-property cons frotz)
                     (get-property cons fratz)))
             (if (free-identifier=? #'cons (let () (import scheme) #'cons))
                 '(spamgle . #f)
                 '(#f . #f)))
     (equal? (let ()
               (define-property cons fratz 'yubah)
               (cons (get-property cons frotz)
                     (get-property cons fratz)))
             '(spamgle . yubah))
     (equal? (cons (get-property cons frotz) (get-property cons fratz))
             '(spamgle . #f))
     ; restore
     (begin
       (meta-cond
         [(free-identifier=? #'cons (let () (import scheme) #'cons))
          (import (only scheme cons))]
         [else (define cons (let () (import scheme) cons))])
       #t)
     (equal? (cons (get-property cons frotz) (get-property cons fratz))
             '(#f . #f))
     (equal? (let ()
               (import scheme)
               (cons (get-property cons frotz)
                     (get-property cons fratz)))
             '(#f . #f))
     (equal? (let ()
               (import scheme)
               (define-property list type "procedure")
               (list (get-property list type) (get-property car type)))
             '("procedure" #f))
     (equal? (let ()
               (define list (lambda x x))
               (define-property list type "procedure")
               (list (get-property list type) (get-property car type)))
             '("procedure" #f))
     (error? ; multiple definitions for list
       (let ()
         (define-property list type "procedure")
         (define list (lambda x x))
         (list (get-property list type) (get-property car type))))
     (error? ; multiple definitions for list
       (module m
         (list)
         (define-property list type "procedure")
         (define list (lambda x x))
         (list (get-property list type) (get-property car type))))
     (error? ; immutable environment
       (eval '(define-property frot rat 3) (scheme-environment)))
     (error? ; immutable environment
       (eval '(define-property cons rat 3) (scheme-environment)))
     (error? ; no visible binding
       (eval '(let () (define-property frot cons 3) 3) (scheme-environment)))
     (error? ; no visible binding
       (eval '(let () (define-property cons rat 3) 3) (scheme-environment)))
     (error? ; no visible binding
       (library (dp err1)
         (export x)
         (import (scheme))
         (define-property x cons "frap")))
     (error? ; no visible binding
       (library (dp err1)
         (export x)
         (import (scheme))
         (define-property cons frip "frap")))
     (error? ; no visible binding
       (module (x) (import-only (scheme)) (define-property x cons "frap")))
     (error? ; no visible binding
       (module (x)
         (import-only (scheme))
         (define-property cons frip "frap")))
     (not (get-property list type))
     (equal? (let ()
               (define type)
               (define-property list type "proc")
               (list (get-property list type)
                     (let ()
                       (define type)
                       (get-property list type))))
             '("proc" #f))
     (equal? (let ()
               (module (type iface list)
                 (define type)
                 (define iface)
                 (define-property list type "a proc")
                 (define-property list iface -1))
               (list (get-property list type) (get-property list iface)))
             '("a proc" -1))
     (equal? (let ()
               (module (type list)
                 (define type)
                 (define iface)
                 (define-property list type "a proc")
                 (define-property list iface -1))
               (list (get-property list type) (get-property list iface)))
             '("a proc" #f))
     (equal? (let ()
               (module (iface list)
                 (define type)
                 (define iface)
                 (define-property list type "a proc")
                 (define-property list iface -1))
               (list (get-property list type) (get-property list iface)))
             '(#f -1))
     (equal? (let ()
               (module (list)
                 (define type)
                 (define iface)
                 (define-property list type "a proc")
                 (define-property list iface -1))
               (list (get-property list type) (get-property list iface)))
             '(#f #f))
     (equal? (let ()
               (module (type iface)
                 (define type)
                 (define iface)
                 (define-property list type "a proc")
                 (define-property list iface -1))
               (list (get-property list type) (get-property list iface)))
             '(#f #f))
     (begin
       (define dp-out (open-output-string))
       (module dp-m1
         (x)
         (import (scheme) (dp get-property))
         (define x 444)
         (define-property x frob "x-frob")
         (define-property x spam "x-spam")
         (fprintf dp-out
                  "~s ~s ~s ~s\n"
                  (get-property x spam)
                  (get-property x frob)
                  (get-property x rats)
                  x))
       (equal? (get-output-string dp-out) "\"x-spam\" \"x-frob\" #f 444\n"))
     (equal? (let ()
               (import dp-m1)
               (list (get-property x spam)
                     (get-property x frob)
                     (get-property x rats)
                     x))
             '("x-spam" "x-frob" #f 444))
     (begin
       (define dp-out (open-output-string))
       (module dp-m1
         ()
         (import (scheme) (dp get-property))
         (define-property dp-out spam "dp-out-spam")
         (define-property dp-out frob "dp-out-frob")
         (fprintf dp-out
                  "~s ~s ~s\n"
                  (get-property dp-out spam)
                  (get-property dp-out frob)
                  (get-property dp-out rats)))
       (and (equal? (get-output-string dp-out)
                    "\"dp-out-spam\" \"dp-out-frob\" #f\n")
            (not (get-property dp-out spam))
            (not (get-property dp-out frob))))
     (equal? (let ()
               (import dp-m1)
               (list (get-property x spam)
                     (get-property x frob)
                     (get-property x rats)))
             '(#f #f #f))
     (begin
       (module dp-m1
         (m2 (f x y))
         (import (scheme) (dp get-property))
         (define y "yval")
         (define-property y a "y-a")
         (module m2
           (x)
           (define x "xval")
           (define-property x a "x-a")
           (define-property y b "y-b"))
         (import m2)
         (define-property x b "x-b")
         (define-syntax f
           (identifier-syntax
             (list (list x (get-property x a) (get-property x b))
                   (list y (get-property y a) (get-property y b))))))
       #t)
     (equal? (let () (import dp-m1) f)
             '(("xval" "x-a" "x-b") ("yval" "y-a" #f)))
     (equal? (let ()
               (import dp-m1)
               (import m2)
               (list (get-property x a)
                     (get-property x b)
                     (get-property x c)
                     x))
             '("x-a" #f #f "xval"))
     (begin
       (library (dp l1)
         (export x spam frob rats)
         (import (scheme) (dp get-property))
         (define spam)
         (define frob)
         (define rats)
         (define x (make-parameter 444))
         (define-property x spam "x-spam")
         (define-property x frob "x-frob")
         (printf "~s ~s ~s ~s\n"
           (get-property x spam)
           (get-property x frob)
           (get-property x rats)
           (x)))
       #t)
     (begin (define dp-f) #t)
     (equal? (with-output-to-string
               (lambda ()
                 (set! dp-f
                   (eval '(lambda ()
                            (import (dp l1))
                            (printf "~s ~s ~s ~s\n"
                              (get-property x spam)
                              (get-property x frob)
                              (get-property x rats)
                              (x)))))))
             "\"x-spam\" \"x-frob\" #f 444\n")
     (equal? (with-output-to-string (lambda () (dp-f)))
             "\"x-spam\" \"x-frob\" #f 444\n")
     (begin
       (library (dp l1)
         (export x spam frob rats)
         (import (scheme) (dp get-property))
         (define spam)
         (define frob)
         (define rats)
         (define-syntax x
           (identifier-syntax
             (list (get-property x spam)
                   (get-property x frob)
                   (get-property x rats))))
         (define-property x spam "x-spam")
         (define-property x frob "x-frob")
         (printf "~s ~s ~s ~s\n"
           (get-property x spam)
           (get-property x frob)
           (get-property x rats)
           x))
       #t)
     (begin (define dp-f) #t)
     (equal? (with-output-to-string
               (lambda ()
                 (set! dp-f
                   (eval '(lambda ()
                            (import (dp l1))
                            (printf "~s ~s ~s ~s\n"
                              (get-property x spam)
                              (get-property x frob)
                              (get-property x rats)
                              x))))))
             "")
     (equal? (with-output-to-string (lambda () (dp-f)))
             "\"x-spam\" \"x-frob\" #f (\"x-spam\" \"x-frob\" #f)\n")
     (begin
       (library (dp l1)
         (export x qq spam frob rats)
         (import (scheme) (dp get-property))
         (define spam)
         (define frob)
         (define rats)
         (define qq (make-parameter 33))
         (define-syntax x
           (identifier-syntax
             (list (get-property x spam)
                   (get-property x frob)
                   (get-property x rats))))
         (define-property x spam "x-spam")
         (define-property x frob "x-frob")
         (printf "~s ~s ~s ~s\n"
           (get-property x spam)
           (get-property x frob)
           (get-property x rats)
           x))
       #t)
     (begin (define dp-f) #t)
     (equal? (with-output-to-string
               (lambda ()
                 (set! dp-f
                   (eval '(lambda ()
                            (import (dp l1))
                            (printf "~s ~s ~s ~s ~s\n"
                              (get-property x spam)
                              (get-property x frob)
                              (get-property x rats)
                              x
                              (qq)))))))
             "\"x-spam\" \"x-frob\" #f (\"x-spam\" \"x-frob\" #f)\n")
     (equal? (with-output-to-string (lambda () (dp-f)))
             "\"x-spam\" \"x-frob\" #f (\"x-spam\" \"x-frob\" #f) 33\n")
     (begin
       (library (dp l1)
         (export qq spam frob rats)
         (import (scheme) (dp get-property))
         (define spam)
         (define frob)
         (define rats)
         (define qq (make-parameter 77))
         (define x (make-parameter 444))
         (define-property x spam "x-spam")
         (define-property x frob "x-frob")
         (printf "~s ~s ~s ~s\n"
           (get-property x spam)
           (get-property x frob)
           (get-property x rats)
           (x)))
       #t)
     (begin (define dp-f) #t)
     (equal? (with-output-to-string
               (lambda ()
                 (set! dp-f
                   (eval '(lambda (x)
                            (import (dp l1))
                            (printf "~s ~s ~s ~s\n"
                              (get-property x spam)
                              (get-property x frob)
                              (get-property x rats)
                              (qq)))))))
             "\"x-spam\" \"x-frob\" #f 444\n")
     (equal? (with-output-to-string (lambda () (dp-f 0))) "#f #f #f 77\n")
     (begin
       (module (dp-a)
         (module (dp-a) (define-syntax dp-a (identifier-syntax 3)))
         (define-property dp-a spam 55))
       (and (eqv? dp-a 3)
            (eqv? (get-property dp-a spam) 55)))
     (begin
       (module (dp-b)
         (module ((dp-b q))
           (define q 3)
           (define-syntax dp-b (identifier-syntax q)))
         (define-property dp-b spam 55))
       (and (eqv? dp-b 3)
            (eqv? (get-property dp-b spam) 55)))
     (let ()
       (module (dp-c)
         (module (dp-c) (define-syntax dp-c (identifier-syntax 3)))
         (define-property dp-c spam 55))
       (and (eqv? dp-c 3)
            (eqv? (get-property dp-c spam) 55)))
     (let ()
       (module (dp-c)
         (module ((dp-c q))
           (define q 3)
           (define-syntax dp-c (identifier-syntax q)))
         (define-property dp-c spam 55))
       (and (eqv? dp-c 3)
            (eqv? (get-property dp-c spam) 55)))
     (begin
       (library (dp l2)
         (export dp-d dp-e spam)
         (import (scheme))
         (define spam)
         (module (dp-d)
           (module (dp-d) (define-syntax dp-d (identifier-syntax 3)))
           (define-property dp-d spam 55))
         (module (dp-e)
           (module ((dp-e q))
             (define q 13)
             (define-syntax dp-e (identifier-syntax q)))
           (define-property dp-e spam 155)))
       (let ()
         (import (dp l2))
         (and (eqv? dp-d 3)
              (eqv? (get-property dp-d spam) 55)
              (eqv? dp-e 13)
              (eqv? (get-property dp-e spam) 155))))
     (begin
       (import (dp l2))
       (and (eqv? dp-d 3)
            (eqv? (get-property dp-d spam) 55)
            (eqv? dp-e 13)
            (eqv? (get-property dp-e spam) 155)))
     (begin
       (with-output-to-file "testfile-dp0.ss"
         (lambda ()
           (pretty-print '(define $dp0-x "dp0-x"))
           (pretty-print '(define-property $dp0-x dp0 17)))
         'replace)
       (with-output-to-file "testfile-dp1.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-dp1)
                (export cons a b spud)
                (import (scheme))
                (define spud)
                (define a "a")
                (define b "b")
                (define-property cons spud "spud-cons")
                (define-property a spud "spud-a")
                (define-property b spud "spud-b"))))
         'replace)
       (with-output-to-file "testfile-dp2.ss"
         (lambda ()
           (pretty-print
             '(module dp2
                (cons a b putz)
                (import (scheme))
                (define putz)
                (define a "a")
                (define b "b")
                (define-property cons putz "putz-cons")
                (define-property a putz "putz-a")
                (define-property b putz "putz-b"))))
         'replace)
       (for-each separate-compile '(dp0 dp1 dp2))
       #t)
     (begin (load "testfile-dp0.so") #t)
     (equal? $dp0-x "dp0-x")
     (equal? (get-property $dp0-x dp0) 17)
     (equal? (let ()
               (import (testfile-dp1))
               (list (cons a b)
                     (get-property cons spud)
                     (get-property a spud)
                     (get-property b spud)))
             '(("a" . "b") "spud-cons" "spud-a" "spud-b"))
     (begin (load "testfile-dp2.so") #t)
     (equal? (let ()
               (import dp2)
               (list (cons a b)
                     (get-property cons putz)
                     (get-property a putz)
                     (get-property b putz)))
             '(("a" . "b") "putz-cons" "putz-a" "putz-b"))
     ; illustrate use of define-property for storing parent record info,
     ; while still allowing the record name to be a variable whose value
     ; is the record type descriptor
     (equal? (let ()
               (module (drt)
                 (define drt-key)
                 (define-syntax drt
                   (lambda (x)
                     (define construct-name
                       (lambda (template-identifier . args)
                         (datum->syntax template-identifier
                           (string->symbol
                             (apply string-append
                               (map (lambda (x)
                                      (if (string? x)
                                          x
                                          (symbol->string (syntax->datum x))))
                                    args))))))
                     (define do-drt
                       (lambda (rname fname* prtd)
                         (with-syntax
                           ([rname rname]
                            [rtd (make-record-type-descriptor
                                   (syntax->datum rname)
                                   prtd
                                   #f
                                   #f
                                   #f
                                   (list->vector
                                     (map (lambda (fname)
                                            `(immutable ,(syntax->datum fname)))
                                          fname*)))]
                            [make-rname (construct-name rname "make-" rname)]
                            [rname? (construct-name rname rname "?")]
                            [(rname-fname ...)
                             (map (lambda (fname)
                                    (construct-name fname rname "-" fname))
                                  fname*)]
                            [(i ...) (enumerate fname*)])
                           #'(begin
                               (define rname 'rtd)
                               (define rcd
                                 (make-record-constructor-descriptor 'rtd #f #f))
                               (define-property rname drt-key 'rtd)
                               (define make-rname
                                 (record-constructor rcd))
                               (define rname?
                                 (record-predicate 'rtd))
                               (define rname-fname
                                 (record-accessor 'rtd i))
                               ...))))
                     (syntax-case x (parent)
                       [(_ rname fname ...)
                        (for-all identifier? #'(rname fname ...))
                        (do-drt #'rname #'(fname ...) #f)]
                       [(_ rname (parent pname) fname ...)
                        (for-all identifier? #'(rname pname fname ...))
                        (lambda (r)
                          (let ([prtd (r #'pname #'drt-key)])
                            (unless prtd
                                    (syntax-error
                                      #'pname
                                      "unrecognized parent record typd"))
                            (do-drt #'rname #'(fname ...) prtd)))]))))
               (drt foo x y)
               (drt bar (parent foo) z)
               (let ([b (make-bar 1 2 3)])
                 (list (record-type-descriptor? foo)
                       (record-type-descriptor? bar)
                       (foo? b)
                       (bar? b)
                       (foo-x b)
                       (foo-y b)
                       (bar-z b))))
             '(#t #t #t #t 1 2 3))
     ; on no!
     (equal? (let ()
               (define type-key)
               (define-syntax declare
                 (syntax-rules ()
                   [(_ type id)
                    (identifier? #'id)
                    (define-property id type-key #'type)]))
               (define-syntax type-of
                 (lambda (x)
                   (syntax-case x ()
                     [(_ id)
                      (identifier? #'id)
                      (lambda (r) #`'#,(r #'id #'type-key))])))
               (let ([x 3])
                 (define p (lambda (x) x))
                 (declare fixnum? x)
                 (declare procedure? p)
                 (list (type-of x) (type-of p))))
             '(fixnum? procedure?))
     ; make sure library is visited and invoked when needed by
     ; top-level-xxx procedures, even when properties are defined
     (begin
       (with-output-to-file "testfile-dp3.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-dp3)
                (export dp3-x frop)
                (import (chezscheme))
                (define frop)
                (define dp3-x 3)
                (define-property dp3-x frop "blob"))))
         'replace)
       (for-each separate-compile '(dp3))
       #t)
     (begin (import (testfile-dp3)) #t)
     (top-level-bound? 'dp3-x)
     (equal? (get-property dp3-x frop) "blob")
     (begin
       (with-output-to-file "testfile-dp4.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-dp4)
                (export dp4-x frop)
                (import (chezscheme))
                (define frop)
                (define dp4-x 3)
                (define-property dp4-x frop "blob"))))
         'replace)
       (for-each separate-compile '(dp4))
       #t)
     (begin (import (testfile-dp4)) #t)
     (eqv? (top-level-value 'dp4-x) 3)
     (equal? (get-property dp4-x frop) "blob")
     (begin
       (with-output-to-file "testfile-dp5.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-dp5)
                (export dp5-x frop)
                (import (chezscheme))
                (define frop)
                (define dp5-x 3)
                (define-property dp5-x frop "blob"))))
         'replace)
       (for-each separate-compile '(dp5))
       #t)
     (begin (import (testfile-dp5)) #t)
     ; same as last, but reverse order of checks
     (equal? (get-property dp5-x frop) "blob")
     (eqv? (top-level-value 'dp5-x) 3)
     (begin
       (with-output-to-file "testfile-dp6.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-dp6)
                (export dp6-x frop)
                (import (chezscheme))
                (define frop)
                (define-syntax dp6-x (identifier-syntax 3))
                (define-property dp6-x frop "blob"))))
         'replace)
       (for-each separate-compile '(dp6))
       #t)
     (begin (import (testfile-dp6)) #t)
     (top-level-syntax? 'dp6-x)
     (equal? (get-property dp6-x frop) "blob")
     (begin
       (with-output-to-file "testfile-dp7.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-dp7)
                (export dp7-x frop)
                (import (chezscheme))
                (define frop)
                (define-syntax dp7-x (identifier-syntax 3))
                (define-property dp7-x frop "blob"))))
         'replace)
       (for-each separate-compile '(dp7))
       #t)
     (begin (import (testfile-dp7)) #t)
     ; same as last, but reverse order of checks
     (equal? (get-property dp7-x frop) "blob")
     (top-level-syntax? 'dp7-x)
     (begin
       (with-output-to-file "testfile-dp8.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-dp8)
                (export dp8-x frop)
                (import (chezscheme))
                (define frop)
                (define-syntax dp8-x (identifier-syntax 3))
                (define-property dp8-x frop "blob"))))
         'replace)
       (for-each separate-compile '(dp8))
       #t)
     (begin (import (testfile-dp8)) #t)
     ; same as last, but reverse order of checks
     (procedure? (top-level-syntax 'dp8-x))
     (equal? (get-property dp8-x frop) "blob")
     (begin
       (with-output-to-file "testfile-dp9.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-dp9)
                (export dp9-x frop)
                (import (chezscheme))
                (define frop)
                (define-syntax dp9-x (identifier-syntax 3))
                (define-property dp9-x frop "blob"))))
         'replace)
       (for-each separate-compile '(dp9))
       #t)
     (begin (import (testfile-dp9)) #t)
     (error? ; not a variable
             (set-top-level-value! 'dp9-x 11))
     (equal? (get-property dp9-x frop) "blob")
     (begin
       (with-output-to-file "testfile-dp10.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-dp10)
                (export dp10-x frop)
                (import (chezscheme))
                (define frop)
                (define dp10-x 3)
                (define-property dp10-x frop "blob"))))
         'replace)
       (for-each separate-compile '(dp10))
       #t)
     (begin (import (testfile-dp10)) #t)
     (error? ; immutable
       (set-top-level-value! 'dp10-x 11))
     (equal? (get-property dp10-x frop) "blob")
     (begin
       (with-output-to-file "testfile-dp11.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-dp11)
                (export dp11-x frop)
                (import (chezscheme))
                (define frop)
                (define dp11-x 3)
                (define-property dp11-x frop "blob"))))
         'replace)
       (for-each separate-compile '(dp11))
       #t)
     (begin (import (testfile-dp11)) #t)
     (not (top-level-mutable? 'dp11-x))
     (equal? (get-property dp11-x frop) "blob")
     (equal? (syntax-case '(a b c) ()
               [(_ . x)
                (let ()
                  (define-property x goofy 'stuff)
                  (define-property x amazingly 'unlikely)
                  (list (get-property x goofy)
                        (get-property x amazingly)
                        #'x))])
             '(stuff unlikely (b c)))
     (begin
       (library (docstring)
         (export define-docstring get-docstring)
         (import (chezscheme))
         (define check-docstring
           (lambda (x s)
             (unless (string? s)
                     (syntax-error x "invalid docstring definition"))
             s))
         (define-syntax define-docstring
           (lambda (x)
             (syntax-case x ()
               [(_ id expr)
                #`(define-property id check-docstring
                    (check-docstring #'#,x expr))])))
         (define-syntax get-docstring
           (lambda (x)
             (lambda (r)
               (syntax-case x ()
                 [(_ id)
                  (or (r #'id #'check-docstring)
                      "no documentation available")])))))
       #t)
     (equal? (let ()
               (import (docstring))
               (define-docstring cons "cons takes three arguments")
               (get-docstring cons))
             "cons takes three arguments")
     (equal? (let ()
               (import (docstring))
               (define-docstring else "else is cool")
               (cond [else (get-docstring else)]))
             "else is cool")
     ((lambda (x ls) (and (member x ls) #t))
      (parameterize ([#%$suppress-primitive-inlining #f])
        (expand '(let () (import scheme) (define-property cons car 3) cons)))
      `(#%cons #2%cons #3%cons))
     (begin
       (define dp-x #f)
       (define dp-y #f)
       (define-property dp-x dp-y "xy")
       (define-syntax a
         (lambda (z)
           (define-property dp-x z "xz")
           #'(get-property dp-x dp-y)))
       (equal? a "xy"))
     (begin
       (define dp-x #f)
       (define dp-y #f)
       (define-property dp-x dp-y "outer")
       (define-syntax a
         (lambda (z)
           (define-property dp-x dp-y "inner")
           #'(get-property dp-x dp-y)))
       (not a))
     (equal? (let ([x #f] [y #f])
               (define-property x y "xy")
               (define-syntax a
                 (lambda (z)
                   (define-property x z "xz")
                   #'(get-property x y)))
               a)
             "xy")
     (eq? (let ([x #f] [y #f])
            (define-property x y "outer")
            (define-syntax a
              (lambda (z)
                (define-property x y "inner")
                #'(get-property x y)))
            a)
          #f)
     (eq? (let ([x #f])
            (define-syntax a
              (syntax-rules (x) [(_ x) 'yes] [(_ y) 'no]))
            (let () (define-property x q 0) (a x)))
          'yes)
     (begin
       (library (dp l3)
         (export x)
         (import (chezscheme))
         (define x 5)
         (define-property x car 17))
       (import (dp l3))
       (and (eqv? x 5)
            (eqv? (let () (import (chezscheme)) (get-property x car)) 17)))
     (begin
       (library (dp l4)
         (export sort)
         (import (chezscheme))
         (define-property sort car 53))
       (library (dp l5)
         (export sort)
         (import (chezscheme))
         (define-property sort cdr 87))
       (import (dp l4))
       (import (dp l5))
       (and (procedure? sort)
            (eq? sort #%sort)
            (eqv? (let ()
                    (import (only (chezscheme) car))
                    (get-property sort car))
                  53)
            (eqv? (let ()
                    (import (only (chezscheme) cdr))
                    (get-property sort cdr))
                  87)))
     (begin
       (with-output-to-file "testfile-dp12.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-dp12)
                (export dp12-dq)
                (import (chezscheme))
                (define-syntax dp12-dq
                  (identifier-syntax "dq"))
                (define-property dp12-dq car "dqp"))))
         'replace)
       (for-each separate-compile '(dp12))
       #t)
     (begin (import (testfile-dp12)) #t)
     (equal? (list dp12-dq
                   (let ()
                     (import (chezscheme))
                     (get-property dp12-dq car)))
             '("dq" "dqp"))
     (equal? (let ()
               (define x 0)
               (module m1 (x) (define-property x car "xcar"))
               (module m2 (x) (define-property x cdr "xcdr"))
               (let ([q1 (let ()
                           (import m1)
                           (list x (get-property x car) (get-property x cdr)))]
                     [q2 (let ()
                           (import m2)
                           (list x (get-property x car) (get-property x cdr)))]
                     [q3 (let ()
                           (import m1)
                           (import m2)
                           (list x (get-property x car) (get-property x cdr)))]
                     [q4 (let ()
                           (import m2)
                           (import m1)
                           (list x (get-property x car) (get-property x cdr)))])
                 (list x
                       q1
                       q2
                       q3
                       q4
                       (get-property x car)
                       (get-property x cdr))))
             '(0 (0 "xcar" #f)
                 (0 #f "xcdr")
                 (0 "xcar" "xcdr")
                 (0 "xcar" "xcdr")
                 #f
                 #f))
     (equal? (let ()
               (define x 0)
               (module m1 (x) (define-property x car "xcar"))
               (import m1)
               (module m2 (x) (define-property x cdr "xcdr"))
               (import m2)
               (list x (get-property x car) (get-property x cdr)))
             '(0 "xcar" "xcdr"))
     (begin
       (module $dp13
         (foo)
         (define foo 17)
         (module ((foo bar))
           (define-property foo cons #'bar)
           (define bar 35)))
       #t)
     (eqv? (let ()
             (import $dp13)
             (define-syntax a
               (lambda (x)
                 (lambda (r)
                   (syntax-case x ()
                     [(_ id) (r #'id #'cons)]))))
             (a foo))
           35)
     (eqv? (let ()
             (module m (x) (define x 3) (define-property x x 4))
             (import m)
             (get-property x x))
           4)
     (eqv? (let ()
             (module m (x) (define x 3) (define-property x x 4))
             (import (alias m (x y)))
             (get-property x x))
           4)
     (eqv? (let ()
             (module m (x) (define x 3) (define-property x x 4))
             (import (alias m (x y)))
             (get-property x y))
           4)
     (eqv? (let ()
             (module m (x) (define x 3) (define-property x x 4))
             (import (alias m (x y)))
             (get-property y x))
           4)
     (eqv? (let ()
             (module m (x) (define x 3) (define-property x x 4))
             (import (alias m (x y)))
             (get-property y y))
           4)
     (eqv? (let ()
             (module m (x) (define x 3) (define-property x x 4))
             (import (rename m (x y)))
             (get-property y y))
           4)
     (begin
       (module $dp14 (x) (define x 3) (define-property x x 4))
       #t)
     (eqv? (let () (import $dp14) (get-property x x)) 4)
     (eqv? (let () (import (alias $dp14 (x y))) (get-property x x)) 4)
     (eqv? (let () (import (alias $dp14 (x y))) (get-property x y)) 4)
     (eqv? (let () (import (alias $dp14 (x y))) (get-property y x)) 4)
     (eqv? (let () (import (alias $dp14 (x y))) (get-property y y)) 4)
     (eqv? (let () (import (rename $dp14 (x y))) (get-property y y)) 4)
     (equal? (let ([y 14])
               (define k1)
               (define k2)
               (module ()
                 (export x (rename (y x)))
                 (define x 3)
                 (define-property x k1 4)
                 (define-property x k2 5)
                 (alias y x))
               (list x
                     y
                     (get-property x k1)
                     (get-property x k2)
                     (get-property y k1)
                     (get-property y k2)))
             '(3 14 4 5 #f #f))
     (error? ; attempt to export different bindings for x
       (let ([y 14])
         (define k1)
         (define k2)
         (module ()
           (export x (rename (y x)))
           (define x 3)
           (define-property x k1 4)
           (alias y x)
           (define-property x k2 5))
         (list x y (get-property x k1) (get-property y k2))))
     (begin
       (with-output-to-file "testfile-A.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-A)
                (export $testfile-A-x $testfile-A-prop-id)
                (import (scheme))
                (define $testfile-A-x (cons 'a 'b))
                (define $testfile-A-prop-id)
                (define-property $testfile-A-x $testfile-A-prop-id
                  (cons 'c 'd)))))
         'replace)
       (with-output-to-file "testfile-B.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-B)
                (export)
                (import (scheme) (testfile-A))
                (export (import (testfile-A))))))
         'replace)
       (with-output-to-file "testfile-C.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-C)
                (export)
                (import (scheme) (testfile-A) (testfile-B))
                (export (import (testfile-A)) (import (testfile-B))))))
         'replace)
       (for-each separate-compile '(A B C))
       #t)
     (equal? (let ()
               (import (testfile-C))
               (list $testfile-A-x
                     (get-property $testfile-A-x $testfile-A-prop-id)))
             '((a . b) (c . d))))

(mat library1
     (error? (compile-library "/file/not/there"))
     (error? (load-library "/file/not/there"))
     (error? ; abc is not a string
             (load-library 'abc))
     (error? ; xxx is not a procedure
             (load-library "/file/not/there" 'xxx))
     (error? ; 3 is not a string
       (parameterize ([source-directories '("/tmp" ".")]) (load-library 3)))
     (error? ; 3 is not a string
       (parameterize ([source-directories '("/tmp" ".")])
         (load-library 3 values)))
     (begin
       (library ($l1-a)
         (export $l1-x)
         (import (scheme))
         (module $l1-x
           (($l1-a $l1-b) $l1-c $l1-e)
           (define $l1-d 4)
           (define-syntax $l1-a
             (identifier-syntax (cons $l1-b $l1-y)))
           (define $l1-b 55)
           (define $l1-c (lambda () (* $l1-d $l1-y)))
           (define $l1-f 44)
           (define-syntax $l1-e (identifier-syntax $l1-f)))
         (define $l1-y 14))
       #t)
     (equal? (let () (import ($l1-a)) (import $l1-x) (list $l1-a ($l1-c)))
             '((55 . 14) 56))
     (begin (import ($l1-a)) #t)
     (begin (import $l1-x) #t)
     (equal? $l1-a '(55 . 14))
     (equal? ($l1-c) 56)
     (error? ; unbound variable $l1-b
             $l1-b)
     (error? ; unbound variable $l1-d
             $l1-d)
     (error? ; unbound variable $l1-y
             $l1-y)
     (error? ; unexported identifier $l1-f
             $l1-e)
     (error? ; unbound variable $l1-f
             $l1-f)
     (equal? (let () (import ($l1-a)) (import $l1-x) (list $l1-a ($l1-c)))
             '((55 . 14) 56))
     (begin
       (library ($l1-b)
         (export $l1-x)
         (import (scheme))
         (module $l1-x
           ($l1-a $l1-c $l1-e)
           (define $l1-d 4)
           (define $l1-a (lambda () (cons $l1-b $l1-y)))
           (define $l1-b 55)
           (define $l1-c (lambda () (* $l1-d $l1-y)))
           (define $l1-f 44)
           (define $l1-e (lambda () $l1-f)))
         (define $l1-y 14))
       #t)
     (equal? (let ()
               (import ($l1-b))
               (import $l1-x)
               (vector ($l1-a) ($l1-c) ($l1-e)))
             '#((55 . 14) 56 44))
     (begin (import ($l1-b)) #t)
     (begin (import $l1-x) #t)
     (equal? ($l1-a) '(55 . 14))
     (equal? ($l1-c) 56)
     (equal? ($l1-e) 44)
     (error? ; unbound variable $l1-b
             $l1-b)
     (error? ; unbound variable $l1-d
             $l1-d)
     (error? ; unbound variable $l1-y
             $l1-y)
     (error? ; unbound variable $l1-f
             $l1-f)
     (equal? (let ()
               (import ($l1-b))
               (import $l1-x)
               (vector ($l1-a) ($l1-c) ($l1-e)))
             '#((55 . 14) 56 44))
     (begin
       (library ($l1-c)
         (export (rename (q $l1-q) (a:x $l1-x)) $l1-p)
         (import (scheme)
           (rename ($l1-a) ($l1-x a:x))
           (rename ($l1-b) ($l1-x b:x)))
         (import (drop-prefix a:x $l1-) (prefix (drop-prefix b:x $l1-) b:))
         (define-syntax q
           (identifier-syntax (list a (c) (b:a) (b:c) ($l1-p) (r))))
         (define $l1-p
           (lambda () (vector a (c) (b:a) (b:c))))
         (define r (lambda () (cons* a (c) (b:a) (b:c)))))
       #t)
     (equal? (let () (import ($l1-c)) $l1-q)
       '((55 . 14)
         56
         (55 . 14)
         56
         #4((55 . 14) 56 (55 . 14) 56)
         ((55 . 14) 56 (55 . 14) . 56)))
     (equal? (let ()
               (import ($l1-c) ($l1-a))
               (import $l1-x)
               (list $l1-a $l1-q))
             '((55 . 14)
               ((55 . 14)
                56
                (55 . 14)
                56
                #4((55 . 14) 56 (55 . 14) 56)
                ((55 . 14) 56 (55 . 14) . 56))))

     (begin
       (library ($l1-d)
         (export $l1-x $l1-getx $l1-setx!)
         (import (scheme))
         (define x 0)
         (define-syntax $l1-x (identifier-syntax x))
         (define $l1-getx (lambda () x))
         (define $l1-setx! (lambda (v) (set! x v))))
       #t)
     (eqv? (let () (import ($l1-d)) ($l1-setx! 'hello) ($l1-getx)) 'hello)
     (error? ; unexported identifier x
             (let () (import ($l1-d)) $l1-x))
     (error? ; unexported identifier x
             (expand '(let () (import ($l1-d)) $l1-x)))
     (error? ; immutable variable $l1-x
             (let () (import ($l1-d)) (set! $l1-getx void)))
     (error? ; immutable variable $l1-x
             (expand '(let () (import ($l1-d)) (set! $l1-getx void))))
     (begin (import ($l1-d)) #t)
     (eqv? (begin ($l1-setx! 'hello) ($l1-getx)) 'hello)
     (error? ; unexported identifier x
             $l1-x)
     (error? ; unexported identifier x
             (expand '$l1-x))
     (error? ; immutable variable $l1-x
             (set! $l1-getx void))
     (error? ; immutable variable $l1-x
             (expand '(set! $l1-getx void)))

     (error? (library ($l1-e)
               (export $l1-x)
               (import (scheme))
               (define $l1-x 0)
               (set! $l1-x 1)))
     (error? (expand '(library ($l1-e)
                        (export $l1-x)
                        (import (scheme))
                        (define $l1-x 0)
                        (set! $l1-x 1))))

     (begin
       (with-output-to-file "testfile.ss"
         (lambda ()
           (pretty-print
             '(library ($l1-f)
                (export $l1-x $l1-y)
                (import (scheme))
                (define-syntax $l1-x (identifier-syntax q))
                (define-syntax q
                  (begin
                    (printf "An expand-time greeting from $l1-f\n")
                    (lambda (x) 77)))
                (define $l1-y (lambda () (* q 2)))
                (printf "A run-time greeting from $l1-f\n")))
           (pretty-print
             '(library ($l1-g)
                (export $l1-x $l1-z $l1-w)
                (import (scheme) ($l1-f))
                (define-syntax $l1-z
                  (begin
                    (printf "An expand-time greeting from $l1-g\n")
                    (lambda (x) ($l1-y))))
                (define $l1-w
                  (begin
                    (printf "A run-time greeting from $l1-g\n")
                    (lambda (x) (cons* x $l1-x ($l1-y)))))))
           (pretty-print
             '(library ($l1-h)
                (export $l1-x $l1-y $l1-v)
                (import (scheme) ($l1-f) ($l1-g))
                (define $l1-v
                  (list $l1-x ($l1-y) $l1-z ($l1-w 13)))
                (printf "A run-time greeting from $l1-h\n"))))
         'replace)
       (compile-file "testfile")
       #t)
     ; look, ma, no need to load...
     (equal? (let () (import ($l1-h)) $l1-v) '(77 154 154 (13 77 . 154)))
     (begin
       (library ($l1-h)
         (export $l1-x $l1-y $l1-v)
         (import (scheme))
         (define $l1-x "these aren't")
         (define $l1-y "the exports")
         (define $l1-v "you're looking for"))
       #t)
     (begin (load "testfile.so") #t)
     (equal? (let () (import ($l1-h)) $l1-v) '(77 154 154 (13 77 . 154)))

     (begin
       (with-output-to-file "testfile.ss"
         (lambda ()
           (pretty-print
             '(library ($l1-f)
                (export $l1-x $l1-y)
                (import (scheme))
                (define-syntax $l1-x (identifier-syntax q))
                (define-syntax q
                  (begin
                    (printf "An expand-time greeting from $l1-f\n")
                    (lambda (x) 77)))
                (define $l1-y (lambda () (* q 2)))
                (printf "A run-time greeting from $l1-f\n")))
           (pretty-print
             '(library ($l1-g)
                (export $l1-x $l1-z $l1-w)
                (import (scheme) ($l1-f))
                (define-syntax $l1-z
                  (begin
                    (printf "An expand-time greeting from $l1-g\n")
                    (lambda (x) ($l1-y))))
                (define $l1-w
                  (begin
                    (printf "A run-time greeting from $l1-g\n")
                    (lambda (x)
                      (cons* x $l1-z $l1-x ($l1-y)))))))
           (pretty-print
             '(library ($l1-h)
                (export $l1-x $l1-y $l1-v)
                (import (scheme) ($l1-f) ($l1-g))
                (define $l1-v
                  (list $l1-x ($l1-y) $l1-z ($l1-w 13)))
                (printf "A run-time greeting from $l1-h\n"))))
         'replace)
       (compile-file "testfile")
       #t)
     ; look, ma, no need to load...
     (equal? (let () (import ($l1-h)) $l1-v)
             '(77 154 154 (13 154 77 . 154)))
     (begin
       (library ($l1-h)
         (export $l1-x $l1-y $l1-v)
         (import (scheme))
         (define $l1-x "these aren't")
         (define $l1-y "the exports")
         (define $l1-v "you're looking for"))
       #t)
     (begin (load "testfile.so") #t)
     (equal? (let () (import ($l1-h)) $l1-v)
             '(77 154 154 (13 154 77 . 154)))

     (error? ; unknown library ($l1-ham)
       (begin
         (library ($l1-spam) (export) (import ($l1-ham)))
         (library ($l1-ham) (export) (import ($l1-spam)))))

     (begin
       (with-output-to-file "testfile.ss"
         (lambda ()
           (pretty-print
             '(library ($l1-i)
                (export $l1-x $l1-y)
                (import (scheme))
                (define $l1-x 'i-am-x)
                (define-syntax $l1-y
                  (identifier-syntax 'i-am-y))))
           (pretty-print
             '(library ($l1-j)
                (export $l1-x $l1-y)
                (import ($l1-i) (only (scheme) errorf))
                (errorf #f "this error shouldn't happen")))
           (pretty-print
             '(library ($l1-k)
                (export $l1-z)
                (import (scheme) ($l1-j))
                (define $l1-z (list 'i-am-z $l1-x $l1-y)))))
         'replace)
       (compile-file "testfile")
       #t)
     (equal? (let () (import ($l1-k)) $l1-z) '(i-am-z i-am-x i-am-y))
     (begin (load "testfile.so") #t)
     (equal? (let () (import ($l1-k)) $l1-z) '(i-am-z i-am-x i-am-y))

     (begin
       (library ($l1-l)
         (export $l1-x)
         (import (scheme))
         (define $l1-x 'i-am-$l1-l.$l1-x))
       #t)
     (eq? (let ()
            (import ($l1-l))
            (define-syntax a
              (lambda (x) #`'#,(datum->syntax #'* $l1-x)))
            a)
          'i-am-$l1-l.$l1-x)

     (begin
       (with-output-to-file "testfile-a1.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-a1)
                (export $l1-a)
                (import (scheme))
                (define $l1-a 'a1))))
         'replace)
       (with-output-to-file "testfile-b1.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-b1)
                (export $l1-a $l1-b)
                (import (scheme) (testfile-a1))
                (define $l1-b 'b1))))
         'replace)
       (with-output-to-file "testfile-c1.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-c1)
                (export $l1-a $l1-b $l1-c)
                (import (scheme) (testfile-b1))
                (define ($l1-c) (list $l1-a $l1-b 'c1)))))
         'replace)
       (with-output-to-file "testfile-d1.ss"
         (lambda ()
           (pretty-print '(import (scheme) (testfile-b1)))
           (pretty-print '(define ($l1-d) (list $l1-a $l1-b 'd1))))
         'replace)
       (with-output-to-file "testfile-e1.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-e1)
                (export $l1-e)
                (import (scheme) (testfile-b1))
                (alias $l1-e $l1-a))))
         'replace)
       (with-output-to-file "testfile-f1.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-f1)
                (export $l1-f)
                (import (scheme))
                (define-syntax $l1-f
                  (identifier-syntax "macro-f")))))
         'replace)
       (with-output-to-file "testfile-g1.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-g1)
                (export $l1-f)
                (import (scheme) (testfile-f1)))))
         'replace)
       (with-output-to-file "testfile-h1.ss"
         (lambda ()
           (pretty-print '(import (scheme) (testfile-g1)))
           (pretty-print '(define ($l1-h) (list $l1-f))))
         'replace)
       (for-each
         separate-compile
         '(a1 b1 c1 d1 e1 f1 g1 h1))
       #t)
     (equal? (begin (load "testfile-d1.so") ($l1-d)) '(a1 b1 d1))
     (begin (import (testfile-c1)) #t)
     (equal? ($l1-c) '(a1 b1 c1))
     (begin (import (testfile-e1)) #t)
     (equal? $l1-e 'a1)
     (equal? (begin (load "testfile-h1.so") ($l1-h)) '("macro-f"))

     (begin
       (with-output-to-file "testfile-a2.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-a2)
                (export $l1-a)
                (import (scheme))
                (define $l1-a 'a2))))
         'replace)
       (with-output-to-file "testfile-b2.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-b2)
                (export $l1-a $l1-b)
                (import (scheme) (testfile-a2))
                (define $l1-b 'b2))))
         'replace)
       (with-output-to-file "testfile-c2.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-c2)
                (export $l1-a $l1-b $l1-c)
                (import (scheme) (testfile-b2))
                (define ($l1-c) (list $l1-a $l1-b 'c2)))))
         'replace)
       (with-output-to-file "testfile-d2.ss"
         (lambda ()
           (pretty-print '(import (scheme) (testfile-b2)))
           (pretty-print '(define ($l1-d) (list $l1-a $l1-b 'd2))))
         'replace)
       (for-each separate-compile '(a2 b2 c2 d2 a2))
       #t)
     (error? ; expected different compilation instance
       ; program complains about b2 rather than b2 about a2
       ;   now that load-library reloads source when dependency changes
       ;   would be nice if program were reloaded from source as well
       (load "testfile-d2.so"))
     ; no longer fails now that load-library reloads source when dependency changes
     #;
     (error? ; expected different compilation instance
             (import (testfile-c2)))
     (begin
       (library ($l1-m)
         (export $l1-x)
         (import (scheme))
         (define $l1-x 333))
       (library ($l1-n) (export $l1-x) (import (scheme)) (import ($l1-m)))
       #t)
     (eqv? (let () (import ($l1-n)) $l1-x) 333)
     (begin
       (define-syntax $from1
         (syntax-rules ()
           ((_ m id) (let () (import-only m) id))))
       (define-syntax $from2
         (syntax-rules ()
           ((_ m id) (let () (module (id) (import m)) id))))
       (define-syntax $from3
         (syntax-rules ()
           [(_ m id)
            (let ([z (cons 1 2)])
              (let ([id z])
                (import m)
                (let ([t id])
                  (if (eq? t z)
                      (errorf 'from "~s undefined" 'id)
                      t))))]))
       (library ($frappe)
         (export wire whip)
         (import (scheme))
         (define wire 3)
         (define-syntax whip (identifier-syntax egg))
         (define egg 'whites))
       (equal? (list (cons ($from1 ($frappe) wire) ($from1 ($frappe) whip))
                     (cons ($from2 ($frappe) wire) ($from2 ($frappe) whip))
                     (cons ($from3 ($frappe) wire) ($from3 ($frappe) whip)))
               '((3 . whites) (3 . whites) (3 . whites))))
     (begin
       (library ($q)
         (export m from)
         (import (scheme))
         (module m (f) (define f "this is f"))
         (define-syntax from
           (syntax-rules ()
             [(_ m id) (let () (import-only m) id)])))
       (equal? (let () (import-only ($q)) (from m f)) "this is f"))
     (begin
       (library ($p)
         (export d f)
         (import (scheme))
         (define-syntax d
           (syntax-rules () ((_ e) (m (lambda () e)))))
         (define m (lambda (x) x))
         (define f (lambda (th) (th))))
       (eqv? (let () (import-only ($p)) (f (d 2))) 2))
     ; this works for libraries because m is implicitly exported
     (eqv? (let () (import-only ($p)) (f (d 1/3))) 1/3)
     (error? ; cons undefined
             (let () (import-only ($p)) (f (d cons))))
     (error? ; invalid syntax
       (library (a) (export x:eval) (import (add-prefix (rnrs eval) x))))
     (error? ; invalid syntax
       (library (a) (export val) (import (drop-prefix (rnrs eval) x))))
     (error? ; invalid syntax
       (library (a)
         (export meaning)
         (import (alias (rnrs eval) [eval meaning]))))
     (begin
       (define $l1-q1)
       (define $l1-q2)
       (define-syntax $l1-qlib
         (syntax-rules ()
           [(_ name (export ex ...) (import im ...) body ...)
            (begin
              (library name
                (export ex ... q)
                (import im ... (rename (only (rnrs) cons) (cons list)))
                (define q list)
                body
                ...)
              (let () (import name) (set! $l1-q1 q)))]))
       ($l1-qlib ($l1-libfoo) (export q) (import (rnrs)) (define q list))
       (let () (import ($l1-libfoo)) (set! $l1-q2 q))
       (equal? (list $l1-q1 $l1-q2) (list cons list)))
     ; check for existence of chezscheme library
     (begin
       (library ($l1-r1)
         (export $l1-x)
         (import (chezscheme))
         (define $l1-x (sort < '(1 3 2 0 5))))
       (library ($l1-r2)
         (export $l1-y)
         (import (chezscheme) ($l1-r1))
         (define $l1-y (cons $l1-x (void))))
       (equal? (let () (import ($l1-r2)) $l1-y) `((0 1 2 3 5) . ,(void))))
     (error? ; invalid context for library form
             (module (a) (library (a) (export) (import))))
     (error? ; invalid syntax for library form
             (module (a)
               (library a (import) (export x) (define x 3))
               (import a)
               x))
     (error? ; invalid context for top-level-program form
             (module (a) (top-level-program (import))))
     (error? ; invalid syntax for top-level-program form
             (module (a) (top-level-program (display "hello"))))
     (error? ; invalid context for library form
             (lambda () (library (a) (export) (import))))
     (error? ; invalid syntax for library form
             (lambda ()
               (library a (import) (export x) (define x 3))
               (import a)
               x))
     (error? ; invalid context for top-level-program form
             (lambda () (top-level-program (import))))
     (error? ; invalid syntax for top-level-program form
             (lambda ()
               (top-level-program (display "hello"))))
     (error? ; defnie not defined
       (library ($l1-s)
         (export y)
         (import (rnrs))
         (defnie x 3)
         (define y 4)))

     (begin
       (library ($l1-s)
         (export m)
         (import (chezscheme))
         (module m
           (x set-x!)
           (define x 0)
           (define set-x! (lambda () (set! x 1)))))
       #t)
     (error? ; attempt to reference assigned hence unexported
             (let () (import ($l1-s)) (import m) x))
     (error? ; attempt to reference assigned hence unexported
             (let () (import ($l1-s)) (import m) (set! x 2)))
     (error? ; invalid version
       (let ()
         (import-only (chezscheme csv7 (6)))
         record-field-mutator))
     (equal? (let () (import-only (chezscheme csv7)) record-field-mutator)
             csv7:record-field-mutator)

     ; test macros generating libraries
     (begin
       (let-syntax
         ([make-A (syntax-rules ()
                    [(_)
                     (library (A)
                       (export $library-x)
                       (import (chezscheme))
                       (define $library-x 3))])])
         (make-A))
       #t)
     (error? ; out-of-context library reference (A)
             (equal? (let () (import (A)) $library-x) 3))
     (begin
       (let-syntax
         ([make-A (lambda (x)
                    (syntax-case x ()
                      [(k)
                       (with-implicit (k A)
                         #'(library (A)
                             (export $library-x)
                             (import (chezscheme))
                             (define $library-x 3)))]))])
         (make-A))
       #t)
     (error? ; unbound $library-x
             (equal? (let () (import (A)) $library-x) 3))
     (begin
       (let-syntax
         ([make-A (lambda (x)
                    (syntax-case x ()
                      [(k id ...)
                       (with-implicit (k A)
                         #'(library (A)
                             (export id ...)
                             (import (chezscheme))
                             (define id 3)
                             ...))]))])
         (make-A $library-x))
       #t)
     (eqv? (let () (import (A)) $library-x) 3)
     (let-syntax
       ([make-A (syntax-rules ()
                  [(_)
                   (begin
                     (library (A)
                       (export x)
                       (import (chezscheme))
                       (define x 3))
                     (let () (import (A)) (eqv? x 3)))])])
       (make-A))
     (let-syntax
       ([make-A (syntax-rules ()
                  [(_)
                   (begin
                     (library (A)
                       (export x)
                       (import (chezscheme))
                       (define x 3))
                     (define-syntax q
                       (syntax-rules ()
                         [(_) (let () (import (A)) x)]))
                     (eqv? (q) 3))])])
       (make-A))

     (begin
       (with-output-to-file "testfile-a14.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-a14)
                (export f)
                (import (chezscheme))
                (define f
                  (lambda (n)
                    (if (fx= n 0) 1 (fx* n (f (fx- n 1))))))
                (printf "invoked a\n"))))
         'replace)
       (with-output-to-file "testfile-b14.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-b14)
                (export g)
                (import (chezscheme) (testfile-a14))
                (define g (lambda (n) (f n)))
                (printf "invoked b\n"))))
         'replace)
       (with-output-to-file "testfile-c14.ss"
         (lambda ()
           (pretty-print '(import (chezscheme) (testfile-b14)))
           (pretty-print '(pretty-print (g 10))))
         'replace)
       #t)
     (equal? (with-output-to-string (lambda () (load "testfile-c14.ss")))
             "invoked a\ninvoked b\n3628800\n")
     ; test for proper propagation and non-propagation of constants across library boundaries
     (begin
       (with-output-to-file "testfile-a15.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-a15)
                (export a b c d e f g fa fb fc fd fe ff fg)
                (import (chezscheme))
                (define-record-type foo
                  (nongenerative)
                  (fields x))
                (define a '())
                (define b 'sym)
                (define c 3/4)
                (define d '(x . y))
                (define e (record-type-descriptor foo))
                (define f (make-foo 3))
                (define g "hello!")
                (define fa (lambda () a))
                (define fb (lambda () b))
                (define fc (lambda () c))
                (define fd (lambda () d))
                (define fe (lambda () e))
                (define ff (lambda () f))
                (define fg (lambda () g)))))
         'replace)
       (with-output-to-file "testfile-b15.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-b15)
                (export a b c d e f g fa fb fc fd fe ff fg)
                (import (chezscheme) (prefix (testfile-a15) %))
                (define a %a)
                (define b %b)
                (define c %c)
                (define d %d)
                (define e %e)
                (define f %f)
                (define g %g)
                (define fa (lambda () (%fa)))
                (define fb (lambda () (%fb)))
                (define fc (lambda () (%fc)))
                (define fd (lambda () (%fd)))
                (define fe (lambda () (%fe)))
                (define ff (lambda () (%ff)))
                (define fg (lambda () (%fg))))))
         'replace)
       (with-output-to-file "testfile-c15.ss"
         (lambda ()
           (pretty-print
             '(define $c15-ls1
                (let ()
                  (import (testfile-a15))
                  (list a b c d e f g (fa) (fb) (fc) (fd) (fe) (ff) (fg)))))
           (pretty-print
             '(define $c15-ls2
                (let ()
                  (import (testfile-b15))
                  (list a b c d e f g (fa) (fb) (fc) (fd) (fe) (ff) (fg)))))
           (pretty-print '(pretty-print (map eq? $c15-ls1 $c15-ls2)))
           (pretty-print '(pretty-print (map eqv? $c15-ls1 $c15-ls2)))
           (pretty-print '(pretty-print (map equal? $c15-ls1 $c15-ls2))))
         'replace)
       (for-each separate-compile '(a15 b15 c15))
       #t)
     ((lambda (x ls) (and (member x ls) #t))
      (with-output-to-string (lambda () (load "testfile-c15.so")))
      '("(#t #t #f #t #t #t #t #t #t #f #t #t #t #t)\n(#t #t #t #t #t #t #t #t #t #t #t #t #t #t)\n(#t #t #t #t #t #t #t #t #t #t #t #t #t #t)\n"
         "(#t #t #t #t #t #t #t #t #t #t #t #t #t #t)\n(#t #t #t #t #t #t #t #t #t #t #t #t #t #t)\n(#t #t #t #t #t #t #t #t #t #t #t #t #t #t)\n"))
     (begin
       (library ($l3) (export f) (import (chezscheme)) (define (f x) x))
       #t)
     (equal? (let () (import ($l3)) (f (f 3))) 3)
     (begin
       ;; (export import-spec ...) empty case
       (library ($empty) (export) (import (chezscheme)) (export (import)))
       #t)
     (begin
       (library ($l4-A) (export a) (import (chezscheme)) (define a 1))
       (library ($l4-B) (export b) (import (chezscheme)) (define b 2))
       #t)
     (equal? '(1 2) (let () (import ($l4-A) ($l4-B)) (list a b)))
     (begin
       ;; (export import-spec ...) multiple imports case
       (library ($l4-C)
         (export)
         (import (chezscheme))
         (export (import ($l4-A) ($l4-B))))
       (equal? '(1 2) (let () (import ($l4-C)) (list a b)))))

(mat library2
     ; test to make sure that libraries needed by the transformers of local
     ; macros are invoked immediately and not required as run-time requirements.
     (begin
       (with-output-to-file "testfile-a3.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-a3)
                (export q)
                (import (rnrs) (only (scheme) putprop))
                (define q 3)
                (putprop 'testfile-a3 'invoke #t))))
         'replace)
       (with-output-to-file "testfile-b3.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-b3)
                (export x)
                (import (testfile-a3) (rnrs) (only (scheme) putprop))
                (define x
                  (let ()
                    (define-syntax p
                      (lambda (x)
                        (putprop 'testfile-b3 'visit #t)
                        q))
                    p)))))
         'replace)
       (for-each separate-compile '(a3 b3))
       #t)
     (equal? (let ()
               (import (testfile-b3))
               (list x
                     (getprop 'testfile-a3 'invoke #f)
                     (getprop 'testfile-b3 'visit #f)))
             '(3 #f #f))
     (begin
       (with-output-to-file "testfile-a4.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-a4)
                (export q)
                (import (rnrs) (only (scheme) putprop))
                (define q
                  (lambda (x)
                    (if (= x 0) 1 (* x (q (- x 1))))))
                (putprop 'testfile-a4 'invoke #t))))
         'replace)
       (with-output-to-file "testfile-b4.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-b4)
                (export x)
                (import (testfile-a4) (rnrs) (only (scheme) putprop))
                (define x
                  (let ()
                    (define-syntax p
                      (lambda (x)
                        (putprop 'testfile-b4 'visit #t)
                        (q 3)))
                    (list p (q 4)))))))
         'replace)
       (for-each separate-compile '(a4 b4))
       #t)
     (equal? (let ()
               (import (testfile-b4))
               (list x
                     (getprop 'testfile-a4 'invoke #f)
                     (getprop 'testfile-b4 'visit #f)))
             '((6 24) #t #f))
     (begin
       (with-output-to-file "testfile-a5.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-a5)
                (export q)
                (import (rnrs) (only (scheme) putprop))
                (define q 3)
                (putprop 'testfile-a5 'invoke #t))))
         'replace)
       (with-output-to-file "testfile-b5.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-b5)
                (export x)
                (import (testfile-a5) (rnrs) (only (scheme) putprop))
                (define x
                  (let-syntax
                    ([p (lambda (x) (putprop 'testfile-b5 'visit #t) q)])
                    p)))))
         'replace)
       (for-each separate-compile '(a5 b5))
       #t)
     (equal? (let ()
               (import (testfile-b5))
               (list x
                     (getprop 'testfile-a5 'invoke #f)
                     (getprop 'testfile-b5 'visit #f)))
             '(3 #f #f))
     (begin
       (with-output-to-file "testfile-a6.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-a6)
                (export q)
                (import (rnrs) (only (scheme) putprop))
                (define q 3)
                (putprop 'testfile-a6 'invoke #t))))
         'replace)
       (with-output-to-file "testfile-b6.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-b6)
                (export x)
                (import (testfile-a6) (rnrs) (only (scheme) putprop))
                (let-syntax
                  ([p (lambda (x) (putprop 'testfile-b6 'visit #t) q)])
                  (define x p)))))
         'replace)
       (for-each separate-compile '(a6 b6))
       #t)
     (equal? (let ()
               (import (testfile-b6))
               (list x
                     (getprop 'testfile-a6 'invoke #f)
                     (getprop 'testfile-b6 'visit #f)))
             '(3 #f #f))

     ; test cyclic dependency check
     ; this mat and next four are connected
     (begin
       (with-output-to-file "testfile-a7.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-a7)
                (export x)
                (import (rnrs) (testfile-b7))
                (define x y))))
         'replace)
       (with-output-to-file "testfile-b7.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-b7)
                (export y)
                (import (rnrs) (testfile-a7))
                (define y x))))
         'replace)
       #t)
     (error? ; possible cyclic dependency
             (let ()
               (import (testfile-a7) (testfile-b7))
               (list x y)))
     (error? ; possible cyclic dependency
             (let ()
               (import (testfile-b7) (testfile-a7))
               (list x y)))
     ; make sure errors didn't leave libraries in a state where they can't be redefined
     (begin
       (with-output-to-file "testfile-a7.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-a7)
                (export x)
                (import (rnrs) (testfile-b7))
                (define x y))))
         'replace)
       (with-output-to-file "testfile-b7.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-b7)
                (export y)
                (import (rnrs))
                (define y 17))))
         'replace)
       #t)
     (equal? (let () (import (testfile-a7) (testfile-b7)) (list x y))
             '(17 17))

     ; import cycles
     (error? ; cyclic dependency on import
             (library ($l2-lib1) (export) (import ($l2-lib1))))
     (begin
       ; make sure we can redefine after cyclic import error
       (library ($l2-lib1) (export a) (import (rnrs)) (define a "a"))
       #t)
     (equal? (let () (import ($l2-lib1)) a) "a")

     (begin
       (delete-file "testfile-a8.so")
       (with-output-to-file "testfile-a8.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-a8) (export a) (import (testfile-a8)))))
         'replace)
       #t)
     (error? ; cyclic dependency on import
             (import (testfile-a8)))
     (begin
       ; make sure we can redefine after cyclic import error
       (with-output-to-file "testfile-a8.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-a8) (export cons) (import (rnrs)))))
         'replace)
       #t)
     (equal? (let () (import (testfile-a8)) cons)
             (let () (import (rnrs)) cons))

     (begin
       (delete-file "testfile.a9.so")
       (with-output-to-file "testfile-a9.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-a9) (export a) (import (testfile-a9)))))
         'replace)
       #t)
     (error? ; cyclic dependency on import
             (compile-file "testfile-a9"))
     (begin
       ; make sure we can redefine after cyclic import error
       (with-output-to-file "testfile-a9.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-a9) (export cons) (import (rnrs)))))
         'replace)
       (compile-file "testfile-a9")
       (load "testfile-a9.so")
       #t)
     (equal? (let () (import (testfile-a9)) cons)
             (let () (import (rnrs)) cons))

     (begin
       (delete-file "testfile-a10.so")
       (delete-file "testfile-b10.so")
       (with-output-to-file "testfile-a10.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-a10) (export a) (import (testfile-b10)))))
         'replace)
       (with-output-to-file "testfile-b10.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-b10) (export a) (import (testfile-a10)))))
         'replace)
       #t)
     (error? ; cyclic dependency on import (indirect)
             (import (testfile-a10)))
     (begin
       ; make sure we can redefine after cyclic import error
       (with-output-to-file "testfile-a10.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-a10) (export a) (import (testfile-b10)))))
         'replace)
       (with-output-to-file "testfile-b10.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-b10)
                (export a)
                (import (rnrs))
                (define a "eh?"))))
         'replace)
       #t)
     (equal? (let () (import (testfile-a10)) a) "eh?")

     ; invoke cycles
     (begin
       (library ($l2-lib2)
         (export a)
         (import (rnrs) (rnrs eval))
         (define a (eval 'a (environment '($l2-lib2)))))
       #t)
     (error? ; cyclic dependency on invoke
             (let () (import ($l2-lib2)) a))

     (begin
       (delete-file "testfile-a11.so")
       (delete-file "testfile-b11.so")
       (with-output-to-file "testfile-a11.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-a11) (export a) (import (testfile-b11)))))
         'replace)
       (with-output-to-file "testfile-b11.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-b11)
                (export a)
                (import (rnrs) (rnrs eval))
                (define a
                  (eval 'a (environment '(testfile-a11)))))))
         'replace)
       #t)
     (error? ; cyclic dependency on invoke (indirect)
             (let () (import (testfile-a11)) a))

     ; visit cycles
     (begin
       (delete-file "testfile-a12.so")
       (remprop 'chewie 'ratface)
       (with-output-to-file "testfile-a12.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-a12)
                (export a)
                (import (rnrs) (rnrs eval) (only (scheme) getprop))
                (define-syntax a
                  (if (getprop 'chewie 'ratface #f)
                      (eval 'a (environment '(testfile-a12)))
                      (lambda (x) 3))))))
         'replace)
       (separate-compile 'a12)
       (putprop 'chewie 'ratface #t)
       #t)
     (error? ; cyclic dependency on visit
             (let () (import (testfile-a12)) a))
     (begin
       (with-output-to-file "testfile-a13.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-a13)
                (export a)
                (import (rename (rnrs) (cons a))))))
         'replace)
       (separate-compile 'a13)
       #t)
     (equal? (let () (import (testfile-a13)) (a 3 4)) '(3 . 4))
     (error? (library (foo)
               (export a (rename b a))
               (import (rnrs))
               (define a 3)
               (define b 4)))
     (error? (library (foo)
               (export a (rename (b a)))
               (import (rnrs))
               (define a 3)
               (define b 4)))
     (error? (library (foo) (exports a) (import (rnrs)) (define a 3)))
     (error? (library (foo) (export a) (imports (rnrs)) (define a 3)))

     (error? ; misplaced library form
       (let ()
         (library (foo)
           (export)
           (import (scheme))
           (library (bar) (export) (import)))))
     (error? ; misplaced library form
             (let () (library (foo) (export) (import))))
     (error? ; misplaced library form
             (+ (library (bar) (export) (import)) 3))

     ; make sure library is visited when needed
     (begin
       (with-output-to-file "testfile-f2.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-f2)
                (export f2-x)
                (import (rnrs) (rnrs mutable-pairs))
                (define-syntax define-mutable
                  (syntax-rules ()
                    [(_ x e)
                     (begin
                       (define t (list e))
                       (define-syntax x
                         (identifier-syntax [_ (car t)]
                           [(set! _ new) (set-car! t new)])))]))
                (define-mutable f2-x 772))))
         'replace)
       (for-each separate-compile '(f2))
       #t)
     (begin
       (define (f2-x-whack! v)
         (import (testfile-f2))
         (set! f2-x v))
       (f2-x-whack! 29)
       #t)
     (eqv? (let () (import (testfile-f2)) f2-x) 29)
     (not (top-level-bound? 'f2-x))
     ; make sure #'x doesn't force library to be visited if x is an exported
     ; keyword or invoked if x is an exported variable
     (begin
       (with-output-to-file "testfile-g2.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-g2)
                (export hit-a hit-x)
                (import (chezscheme))
                (define hit-a (make-parameter #f))
                (define hit-x (make-parameter #f)))))
         'replace)
       (with-output-to-file "testfile-h2.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-h2)
                (export x a)
                (import (rnrs) (testfile-g2))
                (define-syntax a
                  (begin (hit-a #t) (lambda (x) 73)))
                (define x
                  (begin (hit-x #t) (list (hit-x) 97))))))
         'replace)
       (for-each separate-compile '(g2 h2))
       #t)
     (let ()
       (import (testfile-g2))
       (and (not (hit-a)) (not (hit-x))))
     (let ()
       (import (testfile-g2) (testfile-h2))
       (let ([q #'a])
         (and (identifier? q) (not (hit-a)) (not (hit-x)))))
     (let ()
       (import (testfile-g2) (testfile-h2))
       (let ([q #'x])
         (and (identifier? q) (not (hit-a)) (not (hit-x)))))
     (let ()
       (import (testfile-g2) (testfile-h2))
       (and (eqv? a 73) (hit-a) (not (hit-x))))
     (let ()
       (import (testfile-g2) (testfile-h2))
       (and (equal? x '(#t 97)) (hit-a) (hit-x))))

(mat library3
     ; test several-deep invoke-dependency chain
     (begin
       (with-output-to-file "testfile-a3-0.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-a3-0)
                (export x0)
                (import (rnrs))
                (define x0 7))))
         'replace)
       (with-output-to-file "testfile-a3-1.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-a3-1)
                (export x1)
                (import (rnrs) (testfile-a3-0))
                (define x1 (+ x0 1)))))
         'replace)
       (with-output-to-file "testfile-a3-2.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-a3-2)
                (export x2)
                (import (rnrs) (testfile-a3-1))
                (define x2 (+ x1 2)))))
         'replace)
       (with-output-to-file "testfile-a3-3.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-a3-3)
                (export x3)
                (import (rnrs) (testfile-a3-2))
                (define x3 (+ x2 3)))))
         'replace)
       (with-output-to-file "testfile-a3-4.ss"
         (lambda ()
           (pretty-print '(import (rnrs) (testfile-a3-3)))
           (pretty-print '(write (+ x3 4))))
         'replace)
       (separate-compile 'compile-library 'a3-0)
       (separate-compile 'compile-library 'a3-1)
       (separate-compile 'compile-library 'a3-2)
       (separate-compile 'compile-library 'a3-3)
       (separate-compile 'compile-program 'a3-4)
       #t)
     (equal? (with-output-to-string
               (lambda () (load-program "testfile-a3-4.so")))
             "17")
     (eqv? (let () (import (testfile-a3-3)) x3) 13)
     ; try begin containing library and top-level program
     (begin
       (with-output-to-file "testfile-a3-5.ss"
         (lambda ()
           (pretty-print
             '(begin
                (library (a3-5 foo)
                  (export x)
                  (import (rnrs))
                  (define x "hello"))
                (top-level-program (import (rnrs) (a3-5 foo)) (display x)))))
         'replace)
       (separate-compile 'a3-5)
       #t)
     (equal? (with-output-to-string (lambda () (load "testfile-a3-5.so")))
             "hello")
     (equal? (with-output-to-string (lambda () (load "testfile-a3-5.ss")))
             "hello")
     ; try begin containing two libraries
     (begin
       (with-output-to-file "testfile-a3-6.ss"
         (lambda ()
           (pretty-print
             '(begin
                (library (a3-6 foo)
                  (export a x)
                  (import (rnrs))
                  (define-syntax a
                    (identifier-syntax "boo"))
                  (define x "hello"))
                (library (a3-6 bar)
                  (export y)
                  (import (rnrs) (a3-6 foo))
                  (define y (cons a x)))
                (let () (import (a3-6 bar)) (write y)))))
         'replace)
       (separate-compile 'a3-6)
       #t)
     (equal? (with-output-to-string (lambda () (load "testfile-a3-6.so")))
             "(\"boo\" . \"hello\")")
     (equal? (let () (import (a3-6 bar)) y) '("boo" . "hello"))
     (equal? (let () (import (a3-6 foo)) (cons x a)) '("hello" . "boo"))
     ; import a library in subset-mode system, then outsied of subset-mode system
     (begin
       (with-output-to-file "testfile-a3-7.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-a3-7)
                (export x)
                (import (rnrs))
                (define x "hello"))))
         'replace)
       #t)
     (equal? (parameterize ([subset-mode 'system])
               (eval '(let () (import (testfile-a3-7)) x)))
             "hello")
     (equal? (let () (import (testfile-a3-7)) x) "hello")

     (begin
       (with-output-to-file "testfile-a3-8.ss"
         (lambda ()
           (pretty-print '(printf "outside (testfile-a3-8)\n"))
           (pretty-print
             '(library (testfile-a3-8)
                (export a3-8-x)
                (import (rnrs))
                (define a3-8-x 5)
                (error #f "library should not be invoked"))))
         'replace)
       (with-output-to-file "testfile-a3-9.ss"
         (lambda ()
           (pretty-print
             '(let ()
                (import (scheme) (testfile-a3-8))
                (printf "inside testfile-a3-9\n"))))
         'replace)
       (with-output-to-file "testfile-a3-10.ss"
         (lambda ()
           (pretty-print '(import (scheme) (testfile-a3-8)))
           (pretty-print '(printf "inside testfile-a3-10\n")))
         'replace)
       (separate-compile 'a3-8)
       (separate-compile 'a3-9)
       (separate-compile 'a3-10)
       #t)
     (equal? (with-output-to-string (lambda () (load "testfile-a3-9.so")))
             "inside testfile-a3-9\n")
     (equal? (with-output-to-string (lambda () (load "testfile-a3-10.so")))
             "outside (testfile-a3-8)\ninside testfile-a3-10\n"))

(mat library4
     ; test reloading of libraries if dependencies have changed
     ; when compile-imported-libraries is true.
     ; first test with compile-imported-libraries true:
     (begin
       (define ($reset-l4-1)
         (for-each
           delete-file
           '("testfile-l4-a1.so" "testfile-l4-b1.so" "testfile-l4-c1.so"))
         (with-output-to-file "testfile-l4-a1.ss"
           (lambda ()
             (pretty-print
               '(library (testfile-l4-a1)
                  (export x)
                  (import (chezscheme) (testfile-l4-b1) (testfile-l4-c1))
                  (include "testfile-l4-d1.ss")
                  (define a 'a-object)
                  (define x (list a b c d)))))
           'replace)
         (with-output-to-file "testfile-l4-b1.ss"
           (lambda ()
             (pretty-print
               '(library (testfile-l4-b1)
                  (export b)
                  (import (chezscheme))
                  (define b (list 'b-object)))))
           'replace)
         (with-output-to-file "testfile-l4-c1.ss"
           (lambda ()
             (pretty-print
               '(library (testfile-l4-c1)
                  (export c)
                  (import (chezscheme))
                  (define-syntax c (lambda (x) #''c-object)))))
           'replace)
         (with-output-to-file "testfile-l4-d1.ss"
           (lambda ()
             (pretty-print '(define-syntax d (lambda (x) #''d-object))))
           'replace)
         (with-output-to-file "testfile-l4-p1.ss"
           (lambda ()
             (pretty-print '(import (testfile-l4-a1) (chezscheme)))
             (pretty-print '(pretty-print x)))
           'replace)
         (let ([s (separate-eval '(compile-imported-libraries #t)
                    '(compile-file-message #f)
                    '(load-program "testfile-l4-p1.ss"))])
           (unless (equal? s "(a-object (b-object) c-object d-object)\n")
                   (errorf #f "unexpected separate-eval return value ~s" s)))
         ; ensure different file times for followup updates
         (sleep (make-time 'time-duration 0 (if (embedded?) 3 1)))
         #t)
       #t)
     ($reset-l4-1)
     (equal? (begin
               (with-output-to-file "testfile-l4-a1.ss"
                 (lambda ()
                   (pretty-print
                     '(library (testfile-l4-a1)
                        (export x)
                        (import (chezscheme)
                          (testfile-l4-b1)
                          (testfile-l4-c1))
                        (include "testfile-l4-d1.ss")
                        (define a 'newa-object)
                        (define x (list a b c d)))))
                 'replace)
               (separate-eval '(compile-imported-libraries #t)
                 '(compile-file-message #f)
                 '(load-program "testfile-l4-p1.ss")))
             "(newa-object (b-object) c-object d-object)\n")
     ($reset-l4-1)
     (equal? (begin
               (with-output-to-file "testfile-l4-b1.ss"
                 (lambda ()
                   (pretty-print
                     '(library (testfile-l4-b1)
                        (export b)
                        (import (chezscheme))
                        (define b (list 'newb-object)))))
                 'replace)
               (separate-eval '(compile-imported-libraries #t)
                 '(compile-file-message #f)
                 '(load-program "testfile-l4-p1.ss")))
             "(a-object (newb-object) c-object d-object)\n")
     ($reset-l4-1)
     (equal? (begin
               (with-output-to-file "testfile-l4-c1.ss"
                 (lambda ()
                   (pretty-print
                     '(library (testfile-l4-c1)
                        (export c)
                        (import (chezscheme))
                        (define-syntax c
                          (lambda (x) #''newc-object)))))
                 'replace)
               (separate-eval '(compile-imported-libraries #t)
                 '(compile-file-message #f)
                 '(load-program "testfile-l4-p1.ss")))
             "(a-object (b-object) newc-object d-object)\n")
     ($reset-l4-1)
     (equal? (begin
               (with-output-to-file "testfile-l4-d1.ss"
                 (lambda ()
                   (pretty-print
                     '(define-syntax d
                        (lambda (x) #''newd-object))))
                 'replace)
               (separate-eval '(compile-imported-libraries #t)
                 '(compile-file-message #f)
                 '(load-program "testfile-l4-p1.ss")))
             "(a-object (b-object) c-object newd-object)\n")
     ; now with compile-imported-libraries false
     ($reset-l4-1)
     (equal? (begin
               (with-output-to-file "testfile-l4-a1.ss"
                 (lambda ()
                   (pretty-print
                     '(library (testfile-l4-a1)
                        (export x)
                        (import (chezscheme)
                          (testfile-l4-b1)
                          (testfile-l4-c1))
                        (include "testfile-l4-d1.ss")
                        (define a 'newera-object)
                        (define x (list a b c d)))))
                 'replace)
               (separate-eval '(compile-imported-libraries #f)
                 '(compile-file-message #t)
                 '(load-program "testfile-l4-p1.ss")))
             "(newera-object (b-object) c-object d-object)\n")
     ($reset-l4-1)
     (equal? (begin
               (with-output-to-file "testfile-l4-b1.ss"
                 (lambda ()
                   (pretty-print
                     '(library (testfile-l4-b1)
                        (export b)
                        (import (chezscheme))
                        (define b (list 'newerb-object)))))
                 'replace)
               (separate-eval '(compile-imported-libraries #f)
                 '(compile-file-message #t)
                 '(load-program "testfile-l4-p1.ss")))
             "(a-object (newerb-object) c-object d-object)\n")
     ($reset-l4-1)
     (equal? (begin
               (with-output-to-file "testfile-l4-c1.ss"
                 (lambda ()
                   (pretty-print
                     '(library (testfile-l4-c1)
                        (export c)
                        (import (chezscheme))
                        (define-syntax c
                          (lambda (x) #''newerc-object)))))
                 'replace)
               (separate-eval '(compile-imported-libraries #f)
                 '(compile-file-message #t)
                 '(load-program "testfile-l4-p1.ss")))
             "(a-object (b-object) newerc-object d-object)\n")
     ($reset-l4-1)
     (equal? (begin
               (with-output-to-file "testfile-l4-d1.ss"
                 (lambda ()
                   (pretty-print
                     '(define-syntax d
                        (lambda (x) #''newerd-object))))
                 'replace)
               (separate-eval '(compile-imported-libraries #f)
                 '(compile-file-message #t)
                 '(load-program "testfile-l4-p1.ss")))
             "(a-object (b-object) c-object newerd-object)\n"))

(mat library5
     ; test for proper runtime library dependencies
     (begin
       (with-output-to-file "testfile-l5-a1.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-l5-a1)
                (export a)
                (import (chezscheme))
                (define a (cons 3 4)))))
         'replace)
       (with-output-to-file "testfile-l5-b1.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-l5-b1)
                (export a b c)
                (import (chezscheme) (testfile-l5-a1))
                (define-syntax b
                  (identifier-syntax (vector a)))
                (define c (cons 5 6)))))
         'replace)
       (with-output-to-file "testfile-l5-c1.ss"
         (lambda ()
           (for-each
             pretty-print
             `((import (chezscheme) (testfile-l5-b1))
               (set-car! a 55)
               (pretty-print (list a b)))))
         'replace)
       (equal? (parameterize ([compile-imported-libraries #t])
                 (compile-program "testfile-l5-c1"))
               '((testfile-l5-a1))))
     ; delete testfile-l5-b1.{ss,so} to make sure they aren't surreptitiously loaded
     (begin
       (delete-file "testfile-l5-b1.ss")
       (delete-file "testfile-l5-b1.so")
       (and (not (file-exists? "testfile-l5-b1.ss"))
            (not (file-exists? "testfile-l5-b1.so"))))
     (equal? (separate-eval '(load-program "testfile-l5-c1.so"))
             "((55 . 4) #((55 . 4)))\n"))

(mat library6
     ; test for proper handling of visit library dependencies
     (begin
       (with-output-to-file "testfile-l6-a1.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-l6-a1)
                (export a)
                (import (chezscheme))
                (define a (cons 3 4)))))
         'replace)
       (with-output-to-file "testfile-l6-b1.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-l6-b1)
                (export b-x b-y)
                (import (chezscheme) (testfile-l6-a1))
                (define-syntax b-x (lambda (x) (car a)))
                (define b-y (cons 5 6)))))
         'replace)
       (with-output-to-file "testfile-l6-c1.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-l6-c1)
                (export c)
                (import (chezscheme) (testfile-l6-b1))
                (meta define c
                      (lambda (x)
                        #`(cons (* #,x #,(car b-y))
                                (* #,x #,(cdr b-y))))))))
         'replace)
       (with-output-to-file "testfile-l6-prog1.ss"
         (lambda ()
           (pretty-print
             '(eval-when (visit)
                (printf "visiting testfile-l6-prog1\n")))
           (pretty-print
             '(define-syntax M
                (lambda (x)
                  (import (testfile-l6-c1))
                  (syntax-case x ()
                    [(_ f d) #`(f #,(c (datum d)))]))))
           (pretty-print
             '(eval-when (revisit)
                (printf "revisiting testfile-l6-prog1\n")))
           (pretty-print '(pretty-print (M vector 2))))
         'replace)
       (separate-compile
         '(lambda (x)
            (parameterize ([compile-imported-libraries #t])
              (compile-file x)))
         "testfile-l6-prog1")
       #t)

     (begin
       (delete-file "testfile-l6-a1.so")
       (delete-file "testfile-l6-a1.ss")
       (and (not (file-exists? "testfile-l6-a1.so"))
            (not (file-exists? "testfile-l6-a1.ss"))))

     (equal? (separate-eval '(revisit "testfile-l6-prog1.so"))
             "revisiting testfile-l6-prog1\n#((10 . 12))\n"))

(mat library-regression
     ; test that failing invoke code does not result in cyclic dependency problem on re-run
     (equal? (separate-eval
               '(begin
                  (library (invoke-fail)
                    (export x)
                    (import (chezscheme))
                    (define x #f)
                    (error #f "failed to load library (invoke-fail)"))
                  (guard (e [else
                             (guard (e2 [else
                                         (display-condition e)
                                         (newline)
                                         (display-condition e2)
                                         (newline)])
                                    (eval 'x
                                          (environment '(chezscheme) '(invoke-fail))))])
                         (eval 'x
                               (environment '(chezscheme) '(invoke-fail))))))
             "Exception: failed to load library (invoke-fail)\nException: failed to load library (invoke-fail)\n")

     ; test that true cyclic dependency will always report the same thing
     (equal? (separate-eval
               '(begin
                  (library (invoke-cyclic)
                    (export x y)
                    (import (chezscheme))
                    (define x #f)
                    (define y
                      (eval '(if x 5 10)
                            (environment '(chezscheme) '(invoke-cyclic)))))
                  (guard (e [else
                             (guard (e2 [else
                                         (display-condition e)
                                         (newline)
                                         (display-condition e2)
                                         (newline)])
                                    (eval 'x
                                          (environment '(chezscheme) '(invoke-cyclic))))])
                         (eval 'x
                               (environment '(chezscheme) '(invoke-cyclic))))))
             "Exception: cyclic dependency involving invocation of library (invoke-cyclic)\nException: cyclic dependency involving invocation of library (invoke-cyclic)\n")

     (begin
       ; library to help make it easier to cause a failure in the visit-code that
       ; does not lead to failure during compilation of the file.
       (with-output-to-file "testfile-lr-l1.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-lr-l1)
                (export make-it-fail)
                (import (chezscheme))
                (define make-it-fail
                  (make-parameter #f (lambda (x) (and x #t)))))))
         'replace)
       ; simple test to define one macro and potentially to raise an error when
       ; defining the second one.
       (with-output-to-file "testfile-lr-l2.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-lr-l2)
                (export M1 M2)
                (import (chezscheme) (testfile-lr-l1))
                (define-syntax M1 (identifier-syntax #f))

                (define-syntax M2
                  (if (make-it-fail)
                      (error 'M2
                             "user requested failure with (make-it-fail) parameter")
                      (lambda (x)
                        (syntax-case x () [(_ expr) #'expr])))))))
         'replace)
       ; more complete test that attempts to create the various types of things
       ; that can be defined in visit code so that we can verify things are being
       ; properly reset.
       (with-output-to-file "testfile-lr-l3.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-lr-l3)
                (export a b c d e f g h)
                (import (chezscheme) (testfile-lr-l1))

                (module a (x) (define x 5))
                (alias b cons)
                (define-syntax c
                  (make-compile-time-value 5))
                (define d 5)
                (meta define e 5)
                (define-syntax f (identifier-syntax #f))
                (define $g (make-parameter #f))
                (define-syntax g
                  (make-variable-transformer
                    (lambda (x)
                      (syntax-case x ()
                        [(set! _ v) #'($g v)]
                        [_ #'($g)]
                        [(_ e* ...) #'(($g) e* ...)]))))
                (define-property f g 10)
                (define-syntax h
                  (if (make-it-fail)
                      (error 'h
                             "user requested failure with (make-it-fail) parameter")
                      (lambda (x)
                        (syntax-case x () [(_ expr) #'expr])))))))
         'replace)
       (separate-compile
         '(lambda (x)
            (parameterize ([compile-imported-libraries #t])
              (for-each compile-library x)))
         '(list "testfile-lr-l1" "testfile-lr-l2" "testfile-lr-l3"))
       #t)

     (equal? (separate-eval
               '(begin
                  (import (testfile-lr-l2) (testfile-lr-l1))
                  (make-it-fail #t)
                  (guard (e [else
                             (guard (e2 [else
                                         (display-condition e)
                                         (newline)
                                         (display-condition e2)
                                         (newline)])
                                    (eval 'M1 (environment '(testfile-lr-l2))))])
                         (eval 'M1 (environment '(testfile-lr-l2))))))
             "Exception in M2: user requested failure with (make-it-fail) parameter\nException in M2: user requested failure with (make-it-fail) parameter\n")

     ; module is defined as part of import code, run time bindings are setup as part of invoke code
     (equal? (separate-eval
               '(begin
                  (import (testfile-lr-l3) (testfile-lr-l1))
                  (make-it-fail #t)
                  (import a)
                  x))
             "5\n")

     ; alias is part of module binding ribcage, set up by import code
     (equal? (separate-eval
               '(begin
                  (import (testfile-lr-l3) (testfile-lr-l1))
                  (make-it-fail #t)
                  (b 'a 'b)))
             "(a . b)\n")

     ; compile-time-value is set in visit code, should show same error each time it is referenced
     (equal? (separate-eval
               '(begin
                  (library (lookup)
                    (export lookup)
                    (import (chezscheme))
                    (define-syntax lookup
                      (lambda (x)
                        (syntax-case x ()
                          [(_ id) (lambda (rho) #`'#,(rho #'id))]
                          [(_ id key) (lambda (rho) #`'#,(rho #'id #'key))]))))
                  (import (testfile-lr-l3) (testfile-lr-l1))
                  (make-it-fail #t)
                  (guard (e [else
                             (guard (e2 [else
                                         (display-condition e)
                                         (newline)
                                         (display-condition e2)
                                         (newline)])
                                    (eval '(lookup c)
                                          (environment '(testfile-lr-l3) '(lookup))))])
                         (eval '(lookup c)
                               (environment '(testfile-lr-l3) '(lookup))))))
             "Exception in h: user requested failure with (make-it-fail) parameter\nException in h: user requested failure with (make-it-fail) parameter\n")

     ; defines are set up as part of invoke code
     (equal? (separate-eval
               '(begin
                  (import (testfile-lr-l3) (testfile-lr-l1))
                  (make-it-fail #t)
                  d))
             "5\n")

     ; meta defines are set up as part of visit code
     (equal? (separate-eval
               '(begin
                  (import (testfile-lr-l3) (testfile-lr-l1))
                  (make-it-fail #t)
                  (guard (e [else
                             (guard (e2 [else
                                         (display-condition e)
                                         (newline)
                                         (display-condition e2)
                                         (newline)])
                                    (eval '(let ()
                                             (define-syntax get-e
                                               (lambda (x)
                                                 (syntax-case x ()
                                                   [(_) #`'#,e])))
                                             (get-e))
                                          (environment '(chezscheme) '(testfile-lr-l3))))])
                         (eval '(let ()
                                  (define-syntax get-e
                                    (lambda (x)
                                      (syntax-case x ()
                                        [(_) #`'#,e])))
                                  (get-e))
                               (environment '(chezscheme) '(testfile-lr-l3))))))
             "Exception in h: user requested failure with (make-it-fail) parameter\nException in h: user requested failure with (make-it-fail) parameter\n")

     ; macros are set up as part of visit code
     (equal? (separate-eval
               '(begin
                  (import (testfile-lr-l3) (testfile-lr-l1))
                  (make-it-fail #t)
                  (guard (e [else
                             (guard (e2 [else
                                         (display-condition e)
                                         (newline)
                                         (display-condition e2)
                                         (newline)])
                                    (eval 'f (environment '(testfile-lr-l3))))])
                         (eval 'f (environment '(testfile-lr-l3))))))
             "Exception in h: user requested failure with (make-it-fail) parameter\nException in h: user requested failure with (make-it-fail) parameter\n")

     ; variable transformer macros are set up as part of visit code
     (equal? (separate-eval
               '(begin
                  (import (testfile-lr-l3) (testfile-lr-l1))
                  (make-it-fail #t)
                  (guard (e [else
                             (guard (e2 [else
                                         (display-condition e)
                                         (newline)
                                         (display-condition e2)
                                         (newline)])
                                    (eval 'g (environment '(testfile-lr-l3))))])
                         (eval 'g (environment '(testfile-lr-l3))))))
             "Exception in h: user requested failure with (make-it-fail) parameter\nException in h: user requested failure with (make-it-fail) parameter\n")

     ; properties are setup as part of visit code.
     (equal? (separate-eval
               '(begin
                  (library (lookup)
                    (export lookup)
                    (import (chezscheme))
                    (define-syntax lookup
                      (lambda (x)
                        (syntax-case x ()
                          [(_ id) (lambda (rho) #`'#,(rho #'id))]
                          [(_ id key) (lambda (rho) #`'#,(rho #'id #'key))]))))
                  (import (testfile-lr-l3) (testfile-lr-l1))
                  (make-it-fail #t)
                  (guard (e [else
                             (guard (e2 [else
                                         (display-condition e)
                                         (newline)
                                         (display-condition e2)
                                         (newline)])
                                    (eval '(lookup f g)
                                          (environment '(testfile-lr-l3) '(lookup))))])
                         (eval '(lookup f g)
                               (environment '(testfile-lr-l3) '(lookup))))))
             "Exception in h: user requested failure with (make-it-fail) parameter\nException in h: user requested failure with (make-it-fail) parameter\n")

     ;; re-arm import code if it complains about a library that is not visible
     (begin
       (with-output-to-file "testfile-lr-l4.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-lr-l4)
                (export x)
                (import (chezscheme))
                (define x 123))))
         'replace)
       (with-output-to-file "testfile-lr-p4.ss"
         (lambda ()
           (for-each
             pretty-print
             '((import (testfile-lr-l4) (scheme))
               (define (run args)
                 (guard (c [#t (display-condition c) (newline)])
                        (pretty-print
                          (top-level-value (car args)
                            (environment (cdr args))))))
               (when (> x 0)
                     ;; reference export
                     (let ([args (map string->symbol
                                      (command-line-arguments))])
                       (if (= (length args) 2)
                           (begin (run args) (run args))
                           (error #f "expected 2 args")))))))
         'replace)
       (separate-eval
         '(parameterize
            ([compile-imported-libraries #t] [generate-wpo-files #t])
            (compile-program "testfile-lr-p4.ss")
            (compile-whole-program
              "testfile-lr-p4.wpo"
              "testfile-lr-p4-visible"
              #t)
            (compile-whole-program
              "testfile-lr-p4.wpo"
              "testfile-lr-p4-not-visible"
              #f)))
       (equal? (separate-eval
                 '(parameterize
                    ([command-line-arguments '("x" "testfile-lr-l4")])
                    (load-program "testfile-lr-p4-visible")
                    (load-program "testfile-lr-p4-not-visible")))
               (string-append
                 "123\n"
                 "123\n"
                 "Exception in visit: library (testfile-lr-l4) is not visible\n"
                 "Exception in visit: library (testfile-lr-l4) is not visible\n"))))

(mat cross-library-optimization
     (begin
       (with-output-to-file "testfile-clo-1a.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-clo-1a)
                (export f)
                (import (chezscheme))
                (define f (lambda (s) (format "~s!\n" s))))))
         'replace)
       (with-output-to-file "testfile-clo-1b.ss"
         (lambda ()
           (pretty-print '(import (chezscheme) (testfile-clo-1a)))
           (pretty-print '(display-string (f 'hello))))
         'replace)
       #t)
     (eqv? (compile-library "testfile-clo-1a") (void))
     ; in this case, can't propage f because of the embedded string constant,
     ; so program depends on library at run time
     (equal? (compile-program "testfile-clo-1b") '((testfile-clo-1a)))
     (equal? (with-output-to-string
               (lambda ()
                 (load-program "testfile-clo-1b.so")))
             "hello!\n")
     (begin
       (with-output-to-file "testfile-clo-2a.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-clo-2a)
                (export f)
                (import (chezscheme))
                (define f (lambda (s) (symbol->string s))))))
         'replace)
       (with-output-to-file "testfile-clo-2b.ss"
         (lambda ()
           (pretty-print '(import (chezscheme) (testfile-clo-2a)))
           (pretty-print '(display-string (f 'hello))))
         'replace)
       #t)
     (eqv? (compile-library "testfile-clo-2a") (void))
     ; in this case, nothing stopping propagation of f,
     ; so program doesn't necessarily depend on library at run time
     (and (member (compile-program "testfile-clo-2b")
                  '(() ((testfile-clo-2a))))
          #t)
     (equal? (with-output-to-string
               (lambda ()
                 (load-program "testfile-clo-2b.so")))
             "hello")
     ; testing internal consistency for library w/externally visible side effect, which we don't guarantee
     ; will happen if all runtime references are optimized away
     (begin
       (with-output-to-file "testfile-clo-3a.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-clo-3a)
                (export g h)
                (import (chezscheme))
                (define (f) (putprop 'spam 'canned #t))
                (define (g) (getprop 'spam 'canned #f))
                (define (h) (remprop 'spam 'canned))
                (f))))
         'replace)
       (with-output-to-file "testfile-clo-3b.ss"
         (lambda ()
           (pretty-print '(import (chezscheme) (testfile-clo-3a)))
           (pretty-print '(write (g))))
         'replace)
       #t)
     (equal? (let ([libs (parameterize ([compile-imported-libraries #t])
                           (compile-program "testfile-clo-3b"))])
               (cond
                 ; if compiled program depends on the library, the externally visible side effect (putprop) will be done
                 [(equal? libs '((testfile-clo-3a)))
                  (cons (equal? (with-output-to-string
                                  (lambda ()
                                    (load-program "testfile-clo-3b.so")))
                                "#t")
                        (let ()
                          (import (testfile-clo-3a))
                          (g)))]
                 ; otherwise not
                 [(equal? libs '())
                  (cons (equal? (with-output-to-string
                                  (lambda ()
                                    (load-program "testfile-clo-3b.so")))
                                "#f")
                        (not (let () (import (testfile-clo-3a)) (g))))]
                 [else 'oops]))
             '(#t . #t))
     (equal? (let () (import (testfile-clo-3a)) (h)) (void))
     (not (let () (import (testfile-clo-3a)) (g))))

(mat lots-of-libraries
     (begin
       (define (lol-mklibname n)
         (string->symbol (format "testfile-lol-~d" n)))
       (define (lol-mkvarname n)
         (string->symbol (format "n~d" n)))
       (define lol-fiblib
         (lambda (n)
           (let fiblib ([n n])
             (if (fx= n 1)
                 `((library (testfile-lol-1)
                     (export n1)
                     (import (chezscheme))
                     (define n1 1))
                   (library (testfile-lol-0)
                     (export n0)
                     (import (chezscheme))
                     (define n0 0)))
                 (cons `(library (,(lol-mklibname n))
                          (export ,(lol-mkvarname n))
                          (import (chezscheme)
                            (,(lol-mklibname (fx- n 1)))
                            (,(lol-mklibname (fx- n 2))))
                          (define ,(lol-mkvarname n)
                            (+ ,(lol-mkvarname (fx- n 1))
                               ,(lol-mkvarname (fx- n 2)))))
                       (fiblib (fx- n 1)))))))
       #t)
     (eqv? (let ([n 10])
             (eval `(begin
                      ,@(reverse (lol-fiblib n))
                      (let ()
                        (import (,(lol-mklibname n)))
                        ,(lol-mkvarname n)))))
           55)
     (begin
       (define lol-n 100)
       (do ([lib* (lol-fiblib lol-n) (cdr lib*)] [n lol-n (fx- n 1)])
           ((null? lib*))
           (with-output-to-file (format "~s.ss" (lol-mklibname n))
             (lambda () (pretty-print (car lib*)))
             'replace))
       (with-output-to-file "testfile-lol-prog.ss"
         (lambda ()
           (for-each
             pretty-print
             `((import (chezscheme) (,(lol-mklibname lol-n)))
               (pretty-print ,(lol-mkvarname lol-n)))))
         'replace)
       (define $lol-watchdog
         (let ([t (current-time 'time-utc)])
           (let ([time-n 3])
             (separate-eval
               `(parameterize ([compile-imported-libraries #t])
                  (compile-library
                    ,(format "~a.ss" (lol-mklibname time-n)))))
             (do ([n 0 (+ n 1)])
                 ((> n time-n))
                 (delete-file (format "~a.so" (lol-mklibname n)))))
           (let ([t (time-difference (current-time 'time-utc) t)])
             (let ([t-reasonable
                     (let ([ns (* (+ (* (time-second t) (expt 10 9))
                                     (time-nanosecond t))
                                  lol-n)])
                       (make-time 'time-duration
                         (remainder ns (expt 10 9))
                         (quotient ns (expt 10 9))))])
               `(let ([t (current-time 'time-utc)])
                  (timer-interrupt-handler
                    (let ([t-reasonable
                            (make-time 'time-duration
                              ,(time-nanosecond t-reasonable)
                              ,(time-second t-reasonable))])
                      (lambda ()
                        (unless (time<=? (time-difference (current-time 'time-utc) t)
                                         t-reasonable)
                                (errorf #f "unreasonable time elapsed"))
                        (set-timer 10000))))
                  ((timer-interrupt-handler)))))))
       #t)
     (string? (separate-compile
                `(lambda (x)
                   ,$lol-watchdog
                   (parameterize ([compile-imported-libraries #t])
                     (compile-program x)))
                'lol-prog))
     (equal? (separate-eval
               `(begin
                  ,$lol-watchdog
                  (load-program "testfile-lol-prog.so")))
             (format "~d\n"
               (let fib ([i 1] [n1 1] [n0 0])
                 (if (fx= i lol-n)
                     n1
                     (fib (+ i 1) (+ n1 n0) n1)))))
     ; test rebuild
     (string? (separate-compile
                `(lambda (x)
                   ,$lol-watchdog
                   (parameterize ([compile-imported-libraries #t])
                     (compile-program x)))
                'lol-prog))
     ; test maybe rebuild
     (string? (separate-compile
                `(lambda (x)
                   ,$lol-watchdog
                   (parameterize ([compile-imported-libraries #t])
                     (maybe-compile-program x)))
                'lol-prog)))

(mat import-dependencies
     (begin
       (with-output-to-file "testfile-a.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-a)
                (export a x)
                (import (chezscheme))
                (define-syntax a
                  (begin
                    (printf "ct\n")
                    (identifier-syntax 3)))
                (define x (begin (printf "rt\n") 4)))))
         'replace)
       (separate-compile 'compile-library 'a)
       #t)
     (begin
       (with-output-to-file "testfile-m1.ss"
         (lambda ()
           (pretty-print
             '(module (q1)
                (import (testfile-a))
                (define-syntax q1 (identifier-syntax a)))))
         'replace)
       (separate-compile 'compile-file 'm1)
       #t)
     (equal? (separate-eval '(load "testfile-m1.so") 'q1) "ct\n3\n")
     (begin
       (with-output-to-file "testfile-m2.ss"
         (lambda ()
           (pretty-print
             '(module (q2)
                (import (testfile-a))
                (define-syntax q2 (identifier-syntax x)))))
         'replace)
       (separate-compile 'compile-file 'm2)
       #t)
     (equal? (separate-eval '(load "testfile-m2.so") 'q2) "rt\n4\n")
     (begin
       (sleep (make-time 'time-duration 1000000 1))
       (with-output-to-file "testfile-a.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-a)
                (export a x)
                (import (chezscheme))
                (define-syntax a
                  (begin
                    (printf "ct\n")
                    (identifier-syntax 33)))
                (define x (begin (printf "rt\n") 44)))))
         'replace)
       (separate-compile 'compile-library 'a)
       (separate-compile 'maybe-compile-file 'm1)
       (separate-compile 'maybe-compile-file 'm2)
       #t)
     (equal? (separate-eval '(load "testfile-m1.so") 'q1) "ct\n33\n")
     (equal? (separate-eval '(load "testfile-m2.so") 'q2) "rt\n44\n")
     ; --------
     (begin
       (with-output-to-file "testfile-a.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-a)
                (export a x)
                (import (chezscheme))
                (define-syntax a
                  (begin
                    (printf "ct\n")
                    (identifier-syntax 3)))
                (define x (begin (printf "rt\n") 4)))))
         'replace)
       (separate-compile 'compile-library 'a)
       #t)
     (begin
       (with-output-to-file "testfile-m3.ss"
         (lambda ()
           (pretty-print
             '(define-syntax q3
                (let ()
                  (import (testfile-a))
                  (identifier-syntax a)))))
         'replace)
       (separate-compile 'compile-file 'm3)
       #t)
     (equal? (separate-eval '(load "testfile-m3.so") 'q3) "ct\n3\n")
     (begin
       (with-output-to-file "testfile-m4.ss"
         (lambda ()
           (pretty-print
             '(define-syntax q4
                (let ()
                  (import (testfile-a))
                  (identifier-syntax x)))))
         'replace)
       (separate-compile 'compile-file 'm4)
       #t)
     (equal? (separate-eval '(load "testfile-m4.so") 'q4) "rt\n4\n")
     (begin
       (sleep (make-time 'time-duration 1000000 1))
       (with-output-to-file "testfile-a.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-a)
                (export a x)
                (import (chezscheme))
                (define-syntax a
                  (begin
                    (printf "ct\n")
                    (identifier-syntax 33)))
                (define x (begin (printf "rt\n") 44)))))
         'replace)
       (separate-compile 'compile-library 'a)
       (separate-compile 'maybe-compile-file 'm3)
       (separate-compile 'maybe-compile-file 'm4)
       #t)
     (equal? (separate-eval '(load "testfile-m3.so") 'q3) "ct\n33\n")
     (equal? (separate-eval '(load "testfile-m4.so") 'q4) "rt\n44\n")
     ; --------
     (begin
       (with-output-to-file "testfile-a.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-a)
                (export a x)
                (import (chezscheme))
                (define-syntax a
                  (begin
                    (printf "ct\n")
                    (identifier-syntax 3)))
                (define x (begin (printf "rt\n") 4)))))
         'replace)
       (separate-compile 'compile-library 'a)
       #t)
     (begin
       (with-output-to-file "testfile-m5.ss"
         (lambda ()
           (pretty-print
             '(define-property q5 q5 (let () (import (testfile-a)) #'a))))
         'replace)
       (separate-compile 'compile-file 'm5)
       #t)
     (equal? (separate-eval '(load "testfile-m5.so")
               '(let ()
                  (define-syntax ref-prop
                    (lambda (x)
                      (lambda (r)
                        (syntax-case x ()
                          [(_ id key) (r #'id #'key)]))))
                  (ref-prop q5 q5)))
             "ct\n3\n")
     (begin
       (with-output-to-file "testfile-m6.ss"
         (lambda ()
           (pretty-print
             '(define-property q6 q6 (let () (import (testfile-a)) #'x))))
         'replace)
       (separate-compile 'compile-file 'm6)
       #t)
     (equal? (separate-eval '(load "testfile-m6.so")
               '(let ()
                  (define-syntax ref-prop
                    (lambda (x)
                      (lambda (r)
                        (syntax-case x ()
                          [(_ id key) (r #'id #'key)]))))
                  (ref-prop q6 q6)))
             "rt\n4\n")
     (begin
       (sleep (make-time 'time-duration 1000000 1))
       (with-output-to-file "testfile-a.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-a)
                (export a x)
                (import (chezscheme))
                (define-syntax a
                  (begin
                    (printf "ct\n")
                    (identifier-syntax 33)))
                (define x (begin (printf "rt\n") 44)))))
         'replace)
       (separate-compile 'compile-library 'a)
       (separate-compile 'maybe-compile-file 'm5)
       (separate-compile 'maybe-compile-file 'm6)
       #t)
     (equal? (separate-eval '(load "testfile-m5.so")
               '(let ()
                  (define-syntax ref-prop
                    (lambda (x)
                      (lambda (r)
                        (syntax-case x ()
                          [(_ id key) (r #'id #'key)]))))
                  (ref-prop q5 q5)))
             "ct\n33\n")
     (equal? (separate-eval '(load "testfile-m6.so")
               '(let ()
                  (define-syntax ref-prop
                    (lambda (x)
                      (lambda (r)
                        (syntax-case x ()
                          [(_ id key) (r #'id #'key)]))))
                  (ref-prop q6 q6)))
             "rt\n44\n")
     ; --------
     (begin
       (with-output-to-file "testfile-a.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-a)
                (export a x)
                (import (chezscheme))
                (define-syntax a
                  (begin
                    (printf "ct\n")
                    (identifier-syntax 3)))
                (define x (begin (printf "rt\n") 4)))))
         'replace)
       (separate-compile 'compile-library 'a)
       #t)
     (begin
       (with-output-to-file "testfile-m7.ss"
         (lambda ()
           (pretty-print
             '(meta define q7 (let () (import (testfile-a)) #'a))))
         'replace)
       (separate-compile 'compile-file 'm7)
       #t)
     (equal? (separate-eval '(load "testfile-m7.so")
               '(let ()
                  (define-syntax qq (lambda (x) q7))
                  qq))
             "ct\n3\n")
     (begin
       (with-output-to-file "testfile-m8.ss"
         (lambda ()
           (pretty-print
             '(meta define q8 (let () (import (testfile-a)) #'x))))
         'replace)
       (separate-compile 'compile-file 'm8)
       #t)
     (equal? (separate-eval '(load "testfile-m8.so")
               '(let ()
                  (define-syntax qq (lambda (x) q8))
                  qq))
             "rt\n4\n")
     (begin
       (sleep (make-time 'time-duration 1000000 1))
       (with-output-to-file "testfile-a.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-a)
                (export a x)
                (import (chezscheme))
                (define-syntax a
                  (begin
                    (printf "ct\n")
                    (identifier-syntax 33)))
                (define x (begin (printf "rt\n") 44)))))
         'replace)
       (separate-compile 'compile-library 'a)
       (separate-compile 'maybe-compile-file 'm7)
       (separate-compile 'maybe-compile-file 'm8)
       #t)
     (equal? (separate-eval '(load "testfile-m7.so")
               '(let ()
                  (define-syntax qq (lambda (x) q7))
                  qq))
             "ct\n33\n")
     (equal? (separate-eval '(load "testfile-m8.so")
               '(let ()
                  (define-syntax qq (lambda (x) q8))
                  qq))
             "rt\n44\n"))

(mat eval-when-library
     (begin
       (with-output-to-file "testfile-ewl1.ss"
         (lambda ()
           (pretty-print
             '(eval-when ()
                (library (testfile-ewl1)
                  (export x)
                  (import (rnrs))
                  (define-syntax x (identifier-syntax 23))))))
         'replace)
       (with-output-to-file "testfile-ewl2.ss"
         (lambda ()
           (pretty-print
             '(eval-when (eval)
                (library (testfile-ewl2)
                  (export x)
                  (import (rnrs))
                  (define-syntax x (identifier-syntax 23))))))
         'replace)
       (with-output-to-file "testfile-ewl3.ss"
         (lambda ()
           (pretty-print
             '(eval-when (load)
                (library (testfile-ewl3)
                  (export x)
                  (import (rnrs))
                  (define-syntax x (identifier-syntax 23))))))
         'replace)
       (with-output-to-file "testfile-ewl4.ss"
         (lambda ()
           (pretty-print
             '(eval-when (visit)
                (library (testfile-ewl4)
                  (export x)
                  (import (rnrs))
                  (define-syntax x (identifier-syntax 23))))))
         'replace)
       (with-output-to-file "testfile-ewl5.ss"
         (lambda ()
           (pretty-print
             '(eval-when (revisit)
                (library (testfile-ewl5)
                  (export x)
                  (import (rnrs))
                  (define-syntax x (identifier-syntax 23))))))
         'replace)
       (with-output-to-file "testfile-ewl6.ss"
         (lambda ()
           (pretty-print
             '(eval-when (compile)
                (library (testfile-ewl6)
                  (export x)
                  (import (rnrs))
                  (define-syntax x (identifier-syntax 23))))))
         'replace)
       (for-each
         delete-file
         '("testfile-ewl1.so"
            "testfile-ewl2.so"
            "testfile-ewl3.so"
            "testfile-ewl4.so"
            "testfile-ewl5.so"
            "testfile-ewl6.so"))
       #t)
     ; loading testfile-ewlx.ss did not define library (testfile-ewlx)
     (error? (let ([x 55]) (import (testfile-ewl1)) x))
     (error? (let ([x 55]) (import (testfile-ewl3)) x))
     (error? (let ([x 55]) (import (testfile-ewl4)) x))
     (error? (let ([x 55]) (import (testfile-ewl5)) x))
     (error? (let ([x 55]) (import (testfile-ewl6)) x))
     (begin
       (for-each
         separate-compile
         '(ewl1 ewl2 ewl3 ewl4 ewl5 ewl6))
       (for-each
         load-library
         '("testfile-ewl1.so"
            "testfile-ewl2.so"
            "testfile-ewl3.so"
            "testfile-ewl4.so"
            "testfile-ewl5.so"
            "testfile-ewl6.so"))
       #t)
     ; loading testfile-ewlx.so did not define library (testfile-ewlx)
     ; actually "testfile-ewlx.ss did not ..." (ss rather than so)
     ;   now that load-library reloads source when dependency changes
     (error? (let ([x 55]) (import (testfile-ewl1)) x))
     (error? (let ([x 55]) (import (testfile-ewl2)) x))
     (error? (let ([x 55]) (import (testfile-ewl6)) x))
     (begin
       (load-library "testfile-ewl2.ss")
       (compile-library "testfile-ewl6")
       #t)
     (eqv? (let ([x 55]) (import (testfile-ewl2)) x) 23)
     (eqv? (let ([x 55]) (import (testfile-ewl3)) x) 23)
     (eqv? (let ([x 55]) (import (testfile-ewl4)) x) 23)
     (eqv? (let ([x 55]) (import (testfile-ewl5)) x) 23)
     (eqv? (let ([x 55]) (import (testfile-ewl6)) x) 23))

(mat library-directories
     (let ([x (library-directories)])
       (and (list? x)
            (andmap (lambda (x)
                      (and (pair? x)
                           (string? (car x))
                           (string? (cdr x))))
                    x)))
     (if (windows?)
         (parameterize ([library-directories "a1;boo;c:/;dxxy"])
           (equal? (library-directories)
             '(("a1" . "a1")
               ("boo" . "boo")
               ("c:/" . "c:/")
               ("dxxy" . "dxxy"))))
         (parameterize ([library-directories "a1:boo:c;/:dxxy"])
           (equal? (library-directories)
             '(("a1" . "a1")
               ("boo" . "boo")
               ("c;/" . "c;/")
               ("dxxy" . "dxxy")))))
     (if (windows?)
         (parameterize ([library-directories "a1;boo;;boo-obj;c:/;;dxxy"])
           (equal? (library-directories)
             '(("a1" . "a1") ("boo" . "boo-obj") ("c:/" . "dxxy"))))
         (parameterize ([library-directories "a1:boo::boo-obj:c;/::dxxy"])
           (equal? (library-directories)
             '(("a1" . "a1") ("boo" . "boo-obj") ("c;/" . "dxxy")))))
     (let ([default (library-directories)])
       (if (windows?)
           (parameterize ([library-directories "a1;boo;c:/;dxxy;"])
             (equal? (library-directories)
               `(,@'(("a1" . "a1")
                     ("boo" . "boo")
                     ("c:/" . "c:/")
                     ("dxxy" . "dxxy")) ,@default)))
           (parameterize ([library-directories "a1:boo:c;/:dxxy:"])
             (equal? (library-directories)
               `(,@'(("a1" . "a1")
                     ("boo" . "boo")
                     ("c;/" . "c;/")
                     ("dxxy" . "dxxy")) ,@default)))))
     (begin
       (with-output-to-file "testfile-ld1.ss"
         (lambda ()
           (pretty-print
             `(library (,(string->symbol (cd)) testfile-ld1)
                       (export x)
                       (import (rnrs))
                       (define-syntax x
                         (identifier-syntax 23)))))
         'replace)
       #t)
     (error? ; library not found
       (parameterize ([library-directories '()])
         (eval `(lambda () (import (testfile-ld1)) x))))
     (eqv? ((parameterize ([library-directories '()])
              (eval `(lambda ()
                       (import (,(string->symbol (cd)) testfile-ld1))
                       x))))
           23))

(mat library-extensions
     (let ([x (library-extensions)])
       (and (list? x)
            (andmap (lambda (x)
                      (and (pair? x)
                           (string? (car x))
                           (string? (cdr x))))
                    x)))
     (if (windows?)
         (parameterize ([library-extensions ".a1.sls;.boo;.crud;.junk"])
           (equal? (library-extensions)
             '((".a1.sls" . ".a1.so")
               (".boo" . ".so")
               (".crud" . ".so")
               (".junk" . ".so"))))
         (parameterize ([library-extensions ".a1.sls:.boo:.crud:.junk"])
           (equal? (library-extensions)
             '((".a1.sls" . ".a1.so")
               (".boo" . ".so")
               (".crud" . ".so")
               (".junk" . ".so")))))
     (let ([default (library-extensions)])
       (if (windows?)
           (parameterize ([library-extensions ".a1.sls;.boo;.crud;.junk;"])
             (equal? (library-extensions)
               `(,@'((".a1.sls" . ".a1.so")
                     (".boo" . ".so")
                     (".crud" . ".so")
                     (".junk" . ".so")) ,@default)))
           (parameterize ([library-extensions ".a1.sls:.boo:.crud:.junk:"])
             (equal? (library-extensions)
               `(,@'((".a1.sls" . ".a1.so")
                     (".boo" . ".so")
                     (".crud" . ".so")
                     (".junk" . ".so")) ,@default)))))
     (let ([default (library-extensions)])
       (if (windows?)
           (parameterize
             ([library-extensions ".a1.sls;.boo;;.booso;.crud;;.junk;"])
             (equal? (library-extensions)
               `(,@'((".a1.sls" . ".a1.so")
                     (".boo" . ".booso")
                     (".crud" . ".junk")) ,@default)))
           (parameterize
             ([library-extensions ".a1.sls:.boo::.booso:.crud::.junk:"])
             (equal? (library-extensions)
               `(,@'((".a1.sls" . ".a1.so")
                     (".boo" . ".booso")
                     (".crud" . ".junk")) ,@default))))))

(mat library-search-handler
     (procedure? (library-search-handler))
     (eq? (library-search-handler) default-library-search-handler)
     (error? (default-library-search-handler "not-symbol" '(lib) '() '()))
     (error? (default-library-search-handler
               'import
               'bad-library-name
               '()
               '()))
     (error? (default-library-search-handler 'import
               '(lib)
               '(("invalid" "path" "list"))
               '()))
     (error? (default-library-search-handler 'import
               '(lib)
               '(("foo" . "bar"))
               '(("bad") ("extensions"))))
     (error? (parameterize
               ([library-search-handler
                  (lambda (who path dir* all-ext*)
                    (values '(bad source path) #f #f))])
               (eval '(import (foo)))))
     (error? (parameterize
               ([library-search-handler
                  (lambda (who path dir* all-ext*)
                    (values #f '(bad object path) #f))])
               (eval '(import (foo)))))
     (error? (parameterize
               ([library-search-handler
                  (lambda (who path dir* all-ext*)
                    (values #f #f #t))])
               (eval '(import (foo)))))
     (begin
       (mkdir "lsh-testdir")
       (mkdir "lsh-testdir/src1")
       (mkdir "lsh-testdir/src2")
       (mkdir "lsh-testdir/obj")
       #t)
     (begin
       (with-output-to-file "lsh-testdir/src1/lib.ss"
         (lambda ()
           (pretty-print
             '(library (lib)
                (export a)
                (import (scheme))
                (define a "src1 provided this a"))))
         'replace)
       (with-output-to-file "lsh-testdir/src2/lib.ss"
         (lambda ()
           (pretty-print
             '(library (lib)
                (export a)
                (import (scheme))
                (define a "a from src2"))))
         'replace)
       (with-output-to-file "lsh-testdir/src2/foo.ss"
         (lambda ()
           (pretty-print
             '(library (foo) (export a) (import (scheme) (lib)))))
         'replace)
       (parameterize
         ([generate-wpo-files #t]
          [compile-imported-libraries #t]
          [library-directories '(("src2" . "obj"))])
         (compile-file "lsh-testdir/src2/lib.ss" "lsh-testdir/obj/lib.so")
         (compile-file "lsh-testdir/src2/foo.ss" "lsh-testdir/obj/foo.so"))
       #t)
     (equal? "a from src2\n"
       (separate-eval '(cd "lsh-testdir")
         '(library-extensions '((".ss" . ".so")))
         '(library-directories '(("src2" . "obj") ("src1" . "obj")))
         '(library-search-handler
            (lambda (who path dir* all-ext*)
              (let-values ([(src-path obj-path obj-exists?)
                            (default-library-search-handler
                              who
                              path
                              dir*
                              all-ext*)])
                (assert (equal? src-path "src2/lib.ss"))
                (assert (equal? obj-path "obj/lib.so"))
                (assert obj-exists?)
                (values src-path obj-path obj-exists?))))
         '(printf "~a\n" (let () (import (lib)) a))))
     (equal? "src1 provided this a\n"
       (separate-eval '(cd "lsh-testdir")
         '(library-extensions '((".ss" . ".so")))
         '(library-directories '(("src2" . "obj") ("src1" . "obj")))
         '(library-search-handler
            (lambda (who path dir* all-ext*)
              (assert (eq? who 'import))
              (assert (equal? path '(lib)))
              (assert (equal? dir* (library-directories)))
              (assert (equal? all-ext* (library-extensions)))
              ;; switcheroo
              (values "src1/lib.ss" #f #f)))
         '(printf "~a\n" (let () (import (lib)) a))))
     (equal? (string-append
               "compiling src1/lib.ss with output to obj/lib-compiled.so\n"
               "src1 provided this a\n")
       (separate-eval '(cd "lsh-testdir")
         '(compile-imported-libraries #t)
         '(library-search-handler
            (lambda (who path dir* all-ext*)
              (values "src1/lib.ss" "obj/lib-compiled.so" #f)))
         '(printf "~a\n" (let () (import (lib)) a))))
     ;; the default library-search-handler finds obj/lib.wpo
     ;; so no libraries are needed at run time
     (equal? "()\n"
       (separate-eval '(cd "lsh-testdir")
         '(library-extensions '((".ss" . ".so")))
         '(library-directories '(("src1" . "obj") ("src2" . "obj")))
         '(compile-whole-library "obj/foo.wpo" "foo.library")))
     (equal? "((lib))\n"
       (separate-eval '(cd "lsh-testdir")
         '(library-extensions '((".ss" . ".so")))
         '(library-directories '(("src1" . "obj") ("src2" . "obj")))
         '(define (check who path dir*)
            (assert (eq? who 'compile-whole-library))
            (assert (equal? path '(lib)))
            (assert (equal? dir* (library-directories))))
         '(library-search-handler
            (lambda (who path dir* all-ext*)
              (check who path dir*)
              (assert (equal? all-ext* '((".ss" . ".wpo"))))
              ;; default search finds the wpo file, but ...
              (let-values ([(src-path obj-path obj-exists?)
                            (default-library-search-handler
                              who
                              path
                              dir*
                              all-ext*)])
                ;; user reordered library-directories since compiling the wpo file
                (assert (equal? src-path "src1/lib.ss"))
                (assert (equal? obj-path "obj/lib.wpo"))
                (assert obj-exists?))
              ;; ... we install a new handler that returns the object file instead
              (library-search-handler
                (lambda (who path dir* all-ext*)
                  (check who path dir*)
                  (assert (equal? all-ext* (library-extensions)))
                  (values #f "obj/lib.so" #t)))
              ;; ... and report no .wpo file found so we fall back to the
              ;; library-search-handler just installed
              (values #f #f #f)))
         '(compile-whole-library "obj/foo.wpo" "foo.library")))
     (begin (rm-rf "lsh-testdir") #t))

(mat compile-imported-libraries
     (not (compile-imported-libraries))
     (begin (mkdir "testdir") #t)
     (begin
       (define $cil '())
       (with-output-to-file "testdir/cil1.sls"
         (lambda ()
           (pretty-print
             '(eval-when (compile)
                (set! $cil (cons 'cil1 $cil))))
           (pretty-print
             '(library (testdir cil1)
                (export a)
                (import (rnrs))
                (define x 57388321)
                (define-syntax a (lambda (q) #'x)))))
         'replace)
       (with-output-to-file "testdir/cil2.sls"
         (lambda ()
           (pretty-print
             '(eval-when (compile)
                (set! $cil (cons 'cil2 $cil))))
           (pretty-print
             '(library (testdir cil2)
                (export a b f get-y)
                (import (rnrs) (testdir cil1))
                (define y #f)
                (define get-y (lambda () y))
                (define b (lambda () (list a)))
                (define f (lambda (v) (set! y v))))))
         'replace)
       (with-output-to-file "testdir/cil"
         (lambda ()
           (display "#! /usr/bin/env scheme-script\n")
           (pretty-print '(import (rnrs) (testdir cil2)))
           (pretty-print '(f (cons (b) a))))
         'replace)
       #t)
     (equal? (parameterize
               ([compile-imported-libraries #t]
                [compile-file-message #f]
                [compile-library-handler
                  (lambda args
                    (printf "hello!\n")
                    (flush-output-port)
                    (apply compile-library args)
                    (printf "goodbye.\n")
                    (flush-output-port))])
               (with-output-to-string
                 (lambda () (load-program "testdir/cil"))))
             "hello!\nhello!\ngoodbye.\ngoodbye.\n")
     (file-exists? "testdir/cil1.so")
     (file-exists? "testdir/cil2.so")
     (equal? $cil '(cil1 cil2))
     (equal? (let () (import (testdir cil2)) (get-y))
             '((57388321) . 57388321))
     (equal? (let () (import (testdir cil2)) (f 772) (get-y)) 772)
     (eq? (parameterize ([compile-imported-libraries #t])
            (load-program "testdir/cil"))
          (void))
     (equal? (let () (import (testdir cil2)) (get-y))
             '((57388321) . 57388321))
     (equal? $cil '(cil1 cil2))
     (begin (rm-rf "testdir") #t)
     ; once again with extension .ss, to see if position in library-extensions list matters
     (begin (mkdir "testdir") #t)
     (begin
       (define $cil '())
       (with-output-to-file "testdir/cil3.ss"
         (lambda ()
           (pretty-print
             '(eval-when (compile)
                (set! $cil (cons 'cil3 $cil))))
           (pretty-print
             '(library (testdir cil3)
                (export a)
                (import (rnrs))
                (define x 57388321)
                (define-syntax a (lambda (q) #'x)))))
         'replace)
       (with-output-to-file "testdir/cil4.ss"
         (lambda ()
           (pretty-print
             '(eval-when (compile)
                (set! $cil (cons 'cil4 $cil))))
           (pretty-print
             '(library (testdir cil4)
                (export a b f get-y)
                (import (rnrs) (testdir cil3))
                (define y #f)
                (define get-y (lambda () y))
                (define b (lambda () (list a)))
                (define f (lambda (v) (set! y v))))))
         'replace)
       (with-output-to-file "testdir/cil"
         (lambda ()
           (display "#! /usr/bin/env scheme-script\n")
           (pretty-print '(import (rnrs) (testdir cil4)))
           (pretty-print '(f (cons (b) a))))
         'replace)
       #t)
     (eq? (parameterize ([compile-imported-libraries #t])
            (load-program "testdir/cil"))
          (void))
     (file-exists? "testdir/cil3.so")
     (file-exists? "testdir/cil4.so")
     (equal? $cil '(cil3 cil4))
     (equal? (let () (import (testdir cil4)) (get-y))
             '((57388321) . 57388321))
     (equal? (let () (import (testdir cil4)) (f 772) (get-y)) 772)
     (eq? (parameterize ([compile-imported-libraries #t])
            (load-program "testdir/cil"))
          (void))
     (equal? (let () (import (testdir cil4)) (get-y))
             '((57388321) . 57388321))
     (equal? $cil '(cil3 cil4))
     (begin (rm-rf "testdir") (rm-rf "objdir") #t)
     ; try again with different library-directories and library-extensions
     (begin (mkdir "testdir") #t)
     (begin
       (define $cil '())
       (with-output-to-file "testdir/cil5.ss"
         (lambda ()
           (pretty-print
             '(eval-when (compile)
                (set! $cil (cons 'cil5 $cil))))
           (pretty-print
             '(library (testdir cil5)
                (export a)
                (import (rnrs))
                (define x 57388321)
                (define-syntax a (lambda (q) #'x)))))
         'replace)
       (with-output-to-file "testdir/cil6.sls"
         (lambda ()
           (pretty-print
             '(eval-when (compile)
                (set! $cil (cons 'cil6 $cil))))
           (pretty-print
             '(library (testdir cil6)
                (export a b f get-y)
                (import (rnrs) (testdir cil5))
                (define y #f)
                (define get-y (lambda () y))
                (define b (lambda () (list a)))
                (define f (lambda (v) (set! y v))))))
         'replace)
       (with-output-to-file "testdir/cil"
         (lambda ()
           (display "#! /usr/bin/env scheme-script\n")
           (pretty-print '(import (rnrs) (testdir cil6)))
           (pretty-print '(f (cons (b) a))))
         'replace)
       #t)
     (eq? (parameterize
            ([compile-imported-libraries #t]
             [library-directories '(("." . "objdir"))]
             [library-extensions '((".sls" . ".bar") (".ss" . ".foo"))])
            (load-program "testdir/cil"))
          (void))
     (file-exists? "objdir/testdir/cil5.foo")
     (file-exists? "objdir/testdir/cil6.bar")
     (equal? $cil '(cil5 cil6))
     (equal? (let () (import (testdir cil6)) (get-y))
             '((57388321) . 57388321))
     (equal? (let () (import (testdir cil6)) (f 772) (get-y)) 772)
     (eq? (parameterize
            ([compile-imported-libraries #t]
             [library-directories '(("." . "objdir"))]
             [library-extensions '((".sls" . ".bar") (".ss" . ".foo"))])
            (load-program "testdir/cil"))
          (void))
     (equal? (let () (import (testdir cil6)) (get-y))
             '((57388321) . 57388321))
     (equal? $cil '(cil5 cil6))
     (begin (rm-rf "testdir") (rm-rf "objdir") #t)
     ; what if we compile explicitly first?
     (begin (mkdir "testdir") #t)
     (begin
       (define $cil '())
       (with-output-to-file "testdir/cil7.sls"
         (lambda ()
           (pretty-print
             '(eval-when (compile)
                (set! $cil (cons 'cil7 $cil))))
           (pretty-print
             '(library (testdir cil7)
                (export a)
                (import (rnrs))
                (define x 57388321)
                (define-syntax a (lambda (q) #'x)))))
         'replace)
       (with-output-to-file "testdir/cil8.sls"
         (lambda ()
           (pretty-print
             '(eval-when (compile)
                (set! $cil (cons 'cil8 $cil))))
           (pretty-print
             '(library (testdir cil8)
                (export a b f get-y)
                (import (rnrs) (testdir cil7))
                (define y #f)
                (define get-y (lambda () y))
                (define b (lambda () (list a)))
                (define f (lambda (v) (set! y v))))))
         'replace)
       (with-output-to-file "testdir/cil"
         (lambda ()
           (display "#! /usr/bin/env scheme-script\n")
           (pretty-print '(import (rnrs) (testdir cil8)))
           (pretty-print '(f (cons (b) a))))
         'replace)
       (compile-library "testdir/cil7.sls")
       (compile-library "testdir/cil8.sls")
       #t)
     (file-exists? "testdir/cil7.so")
     (file-exists? "testdir/cil8.so")
     (equal? $cil '(cil8 cil7))
     (eq? (parameterize ([compile-imported-libraries #t])
            (load-program "testdir/cil"))
          (void))
     (equal? $cil '(cil8 cil7))
     (equal? (let () (import (testdir cil8)) (get-y))
             '((57388321) . 57388321))
     (begin (rm-rf "testdir") #t)
     ; what if we compile ahead of time, and put .so in library extensions?
     (begin (mkdir "testdir") #t)
     (begin
       (define $cil '())
       (with-output-to-file "testdir/cil9.sls"
         (lambda ()
           (pretty-print
             '(eval-when (compile)
                (set! $cil (cons 'cil9 $cil))))
           (pretty-print
             '(library (testdir cil9)
                (export a)
                (import (rnrs))
                (define x 57388321)
                (define-syntax a (lambda (q) #'x)))))
         'replace)
       (with-output-to-file "testdir/cil10.sls"
         (lambda ()
           (pretty-print
             '(eval-when (compile)
                (set! $cil (cons 'cil10 $cil))))
           (pretty-print
             '(library (testdir cil10)
                (export a b f get-y)
                (import (rnrs) (testdir cil9))
                (define y #f)
                (define get-y (lambda () y))
                (define b (lambda () (list a)))
                (define f (lambda (v) (set! y v))))))
         'replace)
       (with-output-to-file "testdir/cil"
         (lambda ()
           (display "#! /usr/bin/env scheme-script\n")
           (pretty-print '(import (rnrs) (testdir cil10)))
           (pretty-print '(f (cons (b) a))))
         'replace)
       (compile-library "testdir/cil9.sls")
       (compile-library "testdir/cil10.sls")
       #t)
     (file-exists? "testdir/cil9.so")
     (file-exists? "testdir/cil10.so")
     (equal? $cil '(cil10 cil9))
     (eq? (parameterize
            ([compile-imported-libraries #t]
             [library-extensions (cons ".so" (library-extensions))])
            (load-program "testdir/cil"))
          (void))
     (equal? $cil '(cil10 cil9))
     (equal? (let () (import (testdir cil10)) (get-y))
             '((57388321) . 57388321))
     (begin (rm-rf "testdir") #t)
     ; separate compilation
     (begin (mkdir "testdir") #t)
     (begin
       (define $cil '())
       (with-output-to-file "testdir/cil11.sls"
         (lambda ()
           (pretty-print
             '(eval-when (compile)
                (set! $cil (cons 'cil11 $cil))))
           (pretty-print
             '(library (testdir cil11)
                (export a)
                (import (rnrs))
                (define x 57388321)
                (define-syntax a (lambda (q) #'x)))))
         'replace)
       (with-output-to-file "testdir/cil12.sls"
         (lambda ()
           (pretty-print
             '(eval-when (compile)
                (set! $cil (cons 'cil12 $cil))))
           (pretty-print
             '(library (testdir cil12)
                (export a b f get-y)
                (import (rnrs) (testdir cil11))
                (define y #f)
                (define get-y (lambda () y))
                (define b (lambda () (list a)))
                (define f (lambda (v) (set! y v))))))
         'replace)
       (with-output-to-file "testdir/cil.ss"
         (lambda ()
           (display "#! /usr/bin/env scheme-script\n")
           (pretty-print '(import (rnrs) (testdir cil12)))
           (pretty-print '(f (cons (b) a))))
         'replace)
       #t)
     (begin
       (separate-compile
         '(lambda (x)
            (set! $cil '())
            (parameterize ([compile-imported-libraries #t])
              (compile-program x)))
         "testdir/cil")
       #t)
     (file-exists? "testdir/cil.so")
     (file-exists? "testdir/cil11.so")
     (file-exists? "testdir/cil12.so")
     (equal? $cil '())
     (equal? (let () (import (testdir cil11)) a) 57388321)
     (eq? (parameterize ([compile-imported-libraries #t])
            (load-program "testdir/cil.so"))
          (void))
     (equal? (let () (import (testdir cil12)) (get-y))
             '((57388321) . 57388321))
     (equal? $cil '())
     (begin (rm-rf "testdir") #t)
     ; test auto recompilation if dependency is recompiled
     (begin (mkdir "testdir") #t)
     (begin
       (with-output-to-file "testdir/cil13.sls"
         (lambda ()
           (pretty-print
             '(library (testdir cil13)
                (export a x)
                (import (rnrs))
                (define x 73)
                (define-syntax a (lambda (q) #'(+ x 6))))))
         'replace)
       (with-output-to-file "testdir/cil14.sls"
         (lambda ()
           (pretty-print
             '(library (testdir cil14)
                (export a b f get-y)
                (import (rnrs) (testdir cil13))
                (define y #f)
                (define get-y (lambda () y))
                (define b (lambda () (list a x)))
                (define f (lambda (v) (set! y v))))))
         'replace)
       (with-output-to-file "testdir/cil-a.ss"
         (lambda ()
           (display "#! /usr/bin/env scheme-script\n")
           (pretty-print '(import (rnrs) (testdir cil14)))
           (pretty-print '(f (cons (b) a)))
           (pretty-print '(display (get-y))))
         'replace)
       (with-output-to-file "testdir/cil15.sls"
         (lambda ()
           (pretty-print
             '(library (testdir cil15)
                (export a x)
                (import (rnrs))
                (define x 73)
                (define-syntax a (lambda (q) #'(+ x 6))))))
         'replace)
       (with-output-to-file "testdir/cil16.sls"
         (lambda ()
           (pretty-print
             '(library (testdir cil16)
                (export a b f get-y)
                (import (rnrs) (testdir cil15))
                (define y #f)
                (define get-y (lambda () y))
                (define b (lambda () (list a x)))
                (define f (lambda (v) (set! y v))))))
         'replace)
       (with-output-to-file "testdir/cil-b.ss"
         (lambda ()
           (display "#! /usr/bin/env scheme-script\n")
           (pretty-print '(import (rnrs) (testdir cil16)))
           (pretty-print '(f (cons (b) a)))
           (pretty-print '(display (get-y))))
         'replace)
       (with-output-to-file "testdir/cil17.sls"
         (lambda ()
           (pretty-print
             '(library (testdir cil17)
                (export a x)
                (import (rnrs))
                (define x 73)
                (define-syntax a (lambda (q) #'(+ x 6))))))
         'replace)
       (with-output-to-file "testdir/cil18.sls"
         (lambda ()
           (pretty-print
             '(library (testdir cil18)
                (export a b f get-y)
                (import (rnrs) (testdir cil17))
                (define y #f)
                (define get-y (lambda () y))
                (define b (lambda () (list a x)))
                (define f (lambda (v) (set! y v))))))
         'replace)
       (with-output-to-file "testdir/cil-c.ss"
         (lambda ()
           (display "#! /usr/bin/env scheme-script\n")
           (pretty-print '(import (rnrs) (testdir cil18)))
           (pretty-print '(f (cons (b) a)))
           (pretty-print '(display (get-y))))
         'replace)
       #t)
     ; compile 'em all in a separate process
     (begin
       (separate-compile
         '(lambda (x)
            (parameterize ([compile-imported-libraries #t])
              (compile-program x)))
         "testdir/cil-a")
       (separate-compile
         '(lambda (x)
            (parameterize ([compile-imported-libraries #t])
              (compile-program x)))
         "testdir/cil-b")
       (separate-compile
         '(lambda (x)
            (parameterize ([compile-imported-libraries #t])
              (compile-program x)))
         "testdir/cil-c")
       #t)
     (file-exists? "testdir/cil-a.so")
     (file-exists? "testdir/cil13.so")
     (file-exists? "testdir/cil14.so")
     (file-exists? "testdir/cil-b.so")
     (file-exists? "testdir/cil15.so")
     (file-exists? "testdir/cil16.so")
     (file-exists? "testdir/cil-c.so")
     (file-exists? "testdir/cil13.so")
     (file-exists? "testdir/cil14.so")
     ; can't test programs' output here, since we don't want
     ; to load the libraries until after the next step
     ; now delete object file or modify source file and recompile
     (begin
       ; ensure a different time stamp
       (delete-file "testdir/cil13.so")
       (separate-compile
         '(lambda (x)
            (parameterize ([compile-imported-libraries #t])
              (compile-program x)))
         "testdir/cil-a")
       (sleep (make-time 'time-duration 0 1))
       (with-output-to-file "testdir/cil15.sls"
         (lambda ()
           (pretty-print
             '(library (testdir cil15)
                (export a x)
                (import (rnrs))
                (define x -73)
                (define-syntax a (lambda (q) #'(+ x 6))))))
         'replace)
       (separate-compile
         '(lambda (x)
            (parameterize ([compile-imported-libraries #t])
              (compile-program x)))
         "testdir/cil-b")
       (delete-file "testdir/cil17.so")
       (separate-compile
         '(lambda (x)
            (parameterize ([compile-imported-libraries #f])
              ; #f here rather than #t should cause failure
              (compile-program x)))
         "testdir/cil-c")
       #t)
     (file-exists? "testdir/cil-a.so")
     (file-exists? "testdir/cil13.so")
     (file-exists? "testdir/cil14.so")
     (file-exists? "testdir/cil-b.so")
     (file-exists? "testdir/cil15.so")
     (file-exists? "testdir/cil16.so")
     ; testdir/cil-c.so exists now that load-library reloads source when dependency changes
     (file-exists? "testdir/cil-c.so")
     (file-exists? "testdir/cil13.so")
     (file-exists? "testdir/cil14.so")
     (file-exists? "testdir/cil-a.so")
     (file-exists? "testdir/cil13.so")
     (file-exists? "testdir/cil14.so")
     ; now test programs' output
     (equal? (with-output-to-string
               (lambda () (load-program "testdir/cil-a.so")))
             "((79 73) . 79)")
     (equal? (with-output-to-string
               (lambda () (load-program "testdir/cil-b.so")))
             "((-67 -73) . -67)")
     (begin (rm-rf "testdir") #t)
     ; ---------------------------------------------------------------
     (begin (mkdir "testdir") #t)
     (begin
       (with-output-to-file "testdir/cil19A.ss"
         (lambda ()
           (pretty-print
             '(library (testdir cil19A)
                (export x)
                (import (chezscheme))
                (define x (make-parameter 13)))))
         'replace)
       (with-output-to-file "testdir/cil19B.ss"
         (lambda ()
           (pretty-print
             '(library (testdir cil19B)
                (export y)
                (import (chezscheme))
                ; importing from within RHS to make sure RHS imports are tracked
                (define y
                  (make-parameter
                    (let ()
                      (import (testdir cil19A))
                      (+ (x) 5)))))))
         'replace)
       (with-output-to-file "testdir/cil19C.ss"
         (lambda ()
           (pretty-print '(import (chezscheme) (testdir cil19B)))
           (pretty-print '(pretty-print (y))))
         'replace)
       #t)
     (equal? (separate-eval '(compile-imported-libraries #t)
               '(load-program "testdir/cil19C.ss"))
             "compiling testdir/cil19B.ss with output to testdir/cil19B.so\ncompiling testdir/cil19A.ss with output to testdir/cil19A.so\n18\n")
     (file-exists? "testdir/cil19A.so")
     (file-exists? "testdir/cil19B.so")
     (equal? (separate-eval '(compile-imported-libraries #t)
               '(load-program "testdir/cil19C.ss"))
             "18\n")
     ; now add an include file
     (begin
       (sleep (make-time 'time-duration 0 1))
       (with-output-to-file "testdir/cil19A1.ss"
         (lambda ()
           (pretty-print '(define x (make-parameter 19))))
         'replace)
       (with-output-to-file "testdir/cil19A.ss"
         (lambda ()
           (pretty-print
             '(library (testdir cil19A)
                (export x)
                (import (chezscheme))
                (include "cil19A1.ss"))))
         'replace)
       #t)
     (equal? (separate-eval '(compile-imported-libraries #t)
               '(load-program "testdir/cil19C.ss"))
             "compiling testdir/cil19A.ss with output to testdir/cil19A.so\ncompiling testdir/cil19B.ss with output to testdir/cil19B.so\n24\n")
     (equal? (separate-eval '(compile-imported-libraries #t)
               '(load-program "testdir/cil19C.ss"))
             "24\n")
     ; now change first include file to include a second
     (begin
       (sleep (make-time 'time-duration 0 1))
       (with-output-to-file "testdir/cil19A2.ss"
         (lambda ()
           (pretty-print '(define x (make-parameter 23))))
         'replace)
       (with-output-to-file "testdir/cil19A1.ss"
         (lambda () (pretty-print '(include "cil19A2.ss")))
         'replace)
       #t)
     ; load w/compile-imported-libraries #f---should get old result
     ; not longer now that load-library reloads source when dependency changes
     (equal? (separate-eval '(compile-imported-libraries #f)
               '(load-program "testdir/cil19C.ss"))
             "28\n"
             #;
             "24\n")
     ; should get new result with compile-imported-libraries #t
     (equal? (separate-eval '(compile-imported-libraries #t)
               '(load-program "testdir/cil19C.ss"))
             "compiling testdir/cil19A.ss with output to testdir/cil19A.so\ncompiling testdir/cil19B.ss with output to testdir/cil19B.so\n28\n")
     (equal? (separate-eval '(compile-imported-libraries #t)
               '(load-program "testdir/cil19C.ss"))
             "28\n")
     ; now change second include file
     (begin
       (sleep (make-time 'time-duration 0 1))
       (with-output-to-file "testdir/cil19A2.ss"
         (lambda ()
           (pretty-print '(define x (make-parameter 31))))
         'replace)
       #t)
     (equal? (separate-eval '(compile-imported-libraries #t)
               '(load-program "testdir/cil19C.ss"))
             "compiling testdir/cil19A.ss with output to testdir/cil19A.so\ncompiling testdir/cil19B.ss with output to testdir/cil19B.so\n36\n")
     (equal? (separate-eval '(compile-imported-libraries #t)
               '(load-program "testdir/cil19C.ss"))
             "36\n")
     (begin (rm-rf "testdir") #t))

(mat import-notify
     (eq? (import-notify 'yes) (void))
     (eq? (import-notify) #t)
     (begin
       (with-output-to-file "testfile-imno1.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-imno1)
                       (export x)
                       (import (rnrs))
                       (define x -73))))
         'replace)
       (with-output-to-file "testfile-imno2.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-imno2)
                (export y)
                (import (rnrs) (testfile-imno1))
                (define y (+ x x)))))
         'replace)
       (separate-compile 'imno1)
       #t)
     (equal? (parameterize ([console-output-port (open-output-string)])
               (eval '(lambda () (import (testfile-imno2)) y))
               (get-output-string (console-output-port)))
             "import: did not find source file \"testfile-imno2.chezscheme.sls\"\nimport: found source file \"testfile-imno2.ss\"\nimport: did not find corresponding object file \"testfile-imno2.so\"\nimport: loading source file \"testfile-imno2.ss\"\nimport: did not find source file \"testfile-imno1.chezscheme.sls\"\nimport: found source file \"testfile-imno1.ss\"\nimport: found corresponding object file \"testfile-imno1.so\"\nimport: object file is not older\nimport: loading object file \"testfile-imno1.so\"\n")
     (eq? (import-notify #f) (void)))

(mat rnrs-libraries
     (equal? (let ([cons void]) (let () (import (rnrs base)) (cons 3 4)))
             '(3 . 4)))

(mat top-level-program
     (equal? (with-output-to-string
               (lambda ()
                 (eval '(top-level-program (import (scheme))
                          (define-syntax a
                            (identifier-syntax (cons x y)))
                          (define x 55)
                          (printf "x = ~s\n" x)
                          (define y 'yyy)
                          (printf "(a x y) = ~s\n" (list a x y))))))
             "x = 55\n(a x y) = ((55 . yyy) 55 yyy)\n")
     (equal? (with-output-to-string
               (lambda ()
                 (with-output-to-file "testfile-tlp1.ss"
                   (lambda ()
                     (pretty-print
                       '(library (testfile-tlp1)
                          (export $tlp-x $tlp-y)
                          (import (scheme))
                          (define-syntax $tlp-y
                            (begin
                              (printf "visiting tlp1\n")
                              (identifier-syntax (cons ($tlp-x) (z)))))
                          (define z (make-parameter 'zzz))
                          (define $tlp-x
                            (make-parameter 'xxx))
                          (printf "invoking tlp1\n"))))
                   'replace)
                 (with-output-to-file "testfile-tlp.ss"
                   (lambda ()
                     (pretty-print
                       '(top-level-program
                          (import (testfile-tlp1)
                                  (rnrs)
                                  (only (scheme) list printf))
                          (define-syntax a
                            (identifier-syntax (cons x y)))
                          (define x ($tlp-x))
                          (printf "x = ~s\n" x)
                          (define y $tlp-y)
                          (printf "(a x y) = ~s\n" (list a x y)))))
                   'replace)
                 ; compile in same Scheme process
                 (compile-file "testfile-tlp1")
                 (compile-file "testfile-tlp")))
             "compiling testfile-tlp1.ss with output to testfile-tlp1.so\nvisiting tlp1\ncompiling testfile-tlp.ss with output to testfile-tlp.so\n")
     (equal? (with-output-to-string (lambda () (load "testfile-tlp.so")))
             "invoking tlp1\nx = xxx\n(a x y) = ((xxx xxx . zzz) xxx (xxx . zzz))\n")
     (begin
       (with-output-to-file "testfile-tlp2.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-tlp2)
                (export $tlp-x $tlp-y)
                (import (scheme))
                (define-syntax $tlp-y
                  (begin
                    (printf "visiting tlp2\n")
                    (identifier-syntax (cons ($tlp-x) z))))
                (define z 'zzz)
                (define $tlp-x (make-parameter 'xxx))
                (printf "invoking tlp2\n"))))
         'replace)
       (with-output-to-file "testfile-tlp.ss"
         (lambda ()
           (pretty-print
             '(top-level-program
                (import (testfile-tlp2) (rnrs) (only (scheme) list printf))
                (define-syntax a
                  (identifier-syntax (cons x y)))
                (define x ($tlp-x))
                (printf "x = ~s\n" x)
                (define y $tlp-y)
                (printf "(a x y) = ~s\n" (list a x y)))))
         'replace)
       (for-each separate-compile '(tlp2 tlp))
       #t)
     (equal? (with-output-to-string (lambda () (load "testfile-tlp.so")))
             "invoking tlp2\nx = xxx\n(a x y) = ((xxx xxx . zzz) xxx (xxx . zzz))\n")
     (begin
       (with-output-to-file "testfile.ss"
         (lambda ()
           (for-each
             pretty-print
             '((import (rnrs))
               (define x 0)
               (define (inc v) (set! x (+ x v)) x)
               (if (inc 3)))))
         'replace)
       #t)
     (error? ; invalid syntax (if (inc 3)) at [not near] line 4, char 1
             (load-program "testfile.ss"))
     (equal? (with-output-to-string
               (lambda ()
                 (with-output-to-file "testfile-tlp1.ss"
                   (lambda ()
                     (pretty-print
                       '(library (testfile-tlp1)
                          (export $tlp-x $tlp-y)
                          (import (scheme))
                          (define-syntax $tlp-y
                            (begin
                              (printf "visiting tlp1\n")
                              (identifier-syntax (cons ($tlp-x) (z)))))
                          (define z (make-parameter 'zzz))
                          (define $tlp-x
                            (make-parameter 'xxx))
                          (printf "invoking tlp1\n"))))
                   'replace)
                 (with-output-to-file "testfile-tlp.ss"
                   (lambda ()
                     (for-each
                       pretty-print
                       '((import (testfile-tlp1)
                                 (rnrs)
                                 (only (scheme) list printf))
                         (define-syntax a
                           (identifier-syntax (cons x y)))
                         (define x ($tlp-x))
                         (printf "x = ~s\n" x)
                         (define y $tlp-y)
                         (printf "(a x y) = ~s\n" (list a x y)))))
                   'replace)
                 ; compile in same Scheme process
                 (compile-library "testfile-tlp1")
                 (compile-program "testfile-tlp")))
             "compiling testfile-tlp1.ss with output to testfile-tlp1.so\nvisiting tlp1\ncompiling testfile-tlp.ss with output to testfile-tlp.so\n")
     (equal? (with-output-to-string
               (lambda () (load-library "testfile-tlp1.so")))
             "")
     (equal? (with-output-to-string
               (lambda () (load-program "testfile-tlp.so")))
             "invoking tlp1\nx = xxx\n(a x y) = ((xxx xxx . zzz) xxx (xxx . zzz))\n")
     ; load again from source
     (equal? (with-output-to-string
               (lambda () (load-library "testfile-tlp1.ss")))
             "visiting tlp1\n")
     (error? ; wrong version of testfile-tlp1
             (load-program "testfile-tlp.so"))
     (equal? (with-output-to-string
               (lambda () (load-program "testfile-tlp.ss")))
             "invoking tlp1\nx = xxx\n(a x y) = ((xxx xxx . zzz) xxx (xxx . zzz))\n")
     (begin
       (delete-file "testfile-tlp1.so")
       (delete-file "testfile-tlp.so")
       #t)
     (begin
       (with-output-to-file "testfile-tlp1.ss"
         (lambda ()
           (parameterize ([print-vector-length #t])
             (pretty-print
               '(library (testfile-tlp1)
                  (export $tlp-z)
                  (import (chezscheme))
                  (define $tlp-z '#3(1 2))))))
         'replace)
       (with-output-to-file "testfile-tlp.ss"
         (lambda ()
           (parameterize ([print-vector-length #t])
             (for-each
               pretty-print
               '((import (testfile-tlp1) (chezscheme))
                 (pretty-print (equal? $tlp-z '#3(1 2)))))))
         'replace)
       #t)
     (error? ; nonstandard vector-length syntax
             (compile-library "testfile-tlp1"))
     (error? ; nonstandard vector-length syntax
             (compile-program "testfile-tlp"))
     (error? ; nonstandard vector-length syntax
             (load-library "testfile-tlp1.ss"))
     (error? ; nonstandard vector-length syntax
             (load-program "testfile-tlp.ss"))
     (begin
       (with-output-to-file "testfile-tlp1.ss"
         (lambda ()
           (display "#!chezscheme\n")
           (parameterize ([print-vector-length #t])
             (pretty-print
               '(library (testfile-tlp1)
                  (export $tlp-z)
                  (import (chezscheme))
                  (define $tlp-z '#3(1 2))))))
         'replace)
       (with-output-to-file "testfile-tlp.ss"
         (lambda ()
           (display "#!chezscheme\n")
           (parameterize ([print-vector-length #t])
             (for-each
               pretty-print
               '((import (testfile-tlp1) (chezscheme))
                 (pretty-print (equal? $tlp-z '#3(1 2)))))))
         'replace)
       #t)
     (equal? (begin
               (compile-library "testfile-tlp1")
               (compile-program "testfile-tlp")
               (with-output-to-string
                 (lambda ()
                   (load-library "testfile-tlp1.so")
                   (load-program "testfile-tlp.so"))))
             "#t\n")
     (equal? (with-output-to-string
               (lambda ()
                 (load-library "testfile-tlp1.ss")
                 (load-program "testfile-tlp.ss")))
             "#t\n")
     ; test to make sure compiled top-level-program doesn't try to
     ; load libraries upon which it should not depend
     (equal? (begin
               (with-output-to-file "testfile-tlp3.ss"
                 (lambda ()
                   (pretty-print
                     '(library (testfile-tlp3)
                        (export t1-x)
                        (import (chezscheme))
                        (define t1-x 332211))))
                 'replace)
               (with-output-to-file "testfile-tlp4.ss"
                 (lambda ()
                   (pretty-print
                     '(library (testfile-tlp4)
                        (export t2-q)
                        (import (chezscheme) (testfile-tlp3))
                        (define-syntax t2-q
                          (lambda (x) t1-x)))))
                 'replace)
               (with-output-to-file "testfile-tlp5.ss"
                 (lambda ()
                   (pretty-print '(import (chezscheme) (testfile-tlp4)))
                   (pretty-print '(pretty-print t2-q)))
                 'replace)
               (separate-compile 'compile-library 'tlp3)
               (separate-compile 'compile-library 'tlp4)
               (separate-compile 'compile-program 'tlp5)
               (delete-file "testfile-tlp3.ss")
               (delete-file "testfile-tlp4.ss")
               (delete-file "testfile-tlp3.so")
               (delete-file "testfile-tlp4.so")
               (printf "loading testfile-tlp5.so\n")
               (with-output-to-string
                 (lambda ()
                   (load-program "testfile-tlp5.so"))))
             "332211\n")
     ; check dependencies returned by compile-program
     (equal? (let ()
               (define dep8)
               (with-output-to-file "testfile-tlp6.ss"
                 (lambda ()
                   (pretty-print
                     '(library (testfile-tlp6)
                        (export t1-x)
                        (import (chezscheme))
                        (define t1-x 332211))))
                 'replace)
               (with-output-to-file "testfile-tlp7.ss"
                 (lambda ()
                   (pretty-print
                     '(library (testfile-tlp7)
                        (export t2-q)
                        (import (chezscheme) (testfile-tlp6))
                        (define-syntax t2-q
                          (lambda (x) t1-x)))))
                 'replace)
               (with-output-to-file "testfile-tlp8.ss"
                 (lambda ()
                   (pretty-print '(import (chezscheme) (testfile-tlp7)))
                   (pretty-print '(pretty-print t2-q)))
                 'replace)
               (compile-library "testfile-tlp6")
               (compile-library "testfile-tlp7")
               (set! dep8 (compile-program "testfile-tlp8"))
               (printf "loading testfile-tlp8.so\n")
               (list (with-output-to-string
                       (lambda ()
                         (load-program "testfile-tlp8.so")))
                     dep8))
             '("332211\n" ()))
     ; version of the above where program does depend on something
     (equal? (let ()
               (define dep8)
               (with-output-to-file "testfile-tlp9.ss"
                 (lambda ()
                   (pretty-print
                     '(library (testfile-tlp9)
                        (export t1-x)
                        (import (chezscheme))
                        (define t1-x
                          (make-parameter 332211)))))
                 'replace)
               (with-output-to-file "testfile-tlp10.ss"
                 (lambda ()
                   (pretty-print
                     '(library (testfile-tlp10)
                        (export t2-q)
                        (import (chezscheme) (testfile-tlp9))
                        (define-syntax t2-q
                          (identifier-syntax (t1-x))))))
                 'replace)
               (with-output-to-file "testfile-tlp11.ss"
                 (lambda ()
                   (pretty-print '(import (chezscheme) (testfile-tlp10)))
                   (pretty-print '(pretty-print t2-q)))
                 'replace)
               ; if we don't let the compilation happen implicitly, the filename
               ; for (testfile-tlp9) doesn't get set
               (parameterize ([compile-imported-libraries #t])
                 (set! dep8
                   (compile-program "testfile-tlp11")))
               (printf "loading testfile-tlp11.so\n")
               (list (with-output-to-string
                       (lambda ()
                         (load-program "testfile-tlp11.so")))
                     dep8))
             '("332211\n" ((testfile-tlp9))))
     (equal? (library-object-filename '(testfile-tlp9)) "testfile-tlp9.so")
     ; make sure internal module bindings are properly set up before
     ; the body forms are processed
     (begin
       (top-level-program (import (chezscheme))
         (module ((a x))
           (define x 3)
           (define-syntax a (identifier-syntax x))
           (putprop 'tlp-spam 'tlp 7))
         a
         (putprop 'tlp-spam 'spam a))
       (and (eqv? (getprop 'tlp-spam 'spam) 3)
            (eqv? (getprop 'tlp-spam 'tlp) 7)
            (remprop 'tlp-spam 'spam)
            (remprop 'tlp-spam 'tlp)
            #t))
     ; make sure we ignore return value(s) of interleaved init expressions
     (equal? (with-output-to-string
               (lambda ()
                 ; prevent cp0 from fixing the problem
                 (parameterize ([run-cp0 (lambda (f x) x)])
                   (eval '(top-level-program (import (scheme))
                            (define (f)
                              (printf "hello\n")
                              (values 1 2 3))
                            (f)
                            (define x 'world)
                            (pretty-print x))))))
             "hello\nworld\n"))

(mat library-meta
     (begin
       (with-output-to-file "testfile-lm-a1.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-lm-a1)
                (export a)
                (import (chezscheme))
                (meta define a #'17))))
         'replace)
       (with-output-to-file "testfile-lm-a2.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-lm-a2)
                (export b)
                (import (chezscheme) (testfile-lm-a1))
                (define-syntax b (lambda (q) a)))))
         'replace)
       (for-each separate-compile '(lm-a1 lm-a2))
       #t)
     (equal? (let () (import (testfile-lm-a2)) b) 17)
     (error? ; attempt to assign unbound variable
       (let ()
         (import (testfile-lm-a1))
         (define-syntax b (lambda (q) (set! a (+ a 1)) a))))
     ; test $visit-library
     (begin
       (with-output-to-file "testfile-lm-b1.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-lm-b1)
                (export a)
                (import (chezscheme))
                (meta define a #'17))))
         'replace)
       (with-output-to-file "testfile-lm-b2.ss"
         (lambda ()
           (pretty-print '(import (testfile-lm-b1)))
           (pretty-print '(define-syntax b (lambda (q) a))))
         'replace)
       (for-each separate-compile '(lm-b1 lm-b2))
       #t)
     (equal? (with-output-to-string
               (lambda ()
                 (parameterize ([trace-output-port (current-output-port)])
                   (load "testfile-lm-b2.so"))))
             "")
     (eqv? b 17))

(mat library-introspection
     (error? (library-exports 'foo))
     (error? (library-exports '(1 2 3)))
     (error? (library-exports '(probably not a valid loaded library)))
     (error? (library-exports '(probably not a valid loaded library (2 3))))
     (error? (library-exports '(rnrs (six))))
     (error? (library-exports '(rnrs (1))))
     (error? (library-version 'foo))
     (error? (library-version '(1 2 3)))
     (error? (library-version '(probably not a valid loaded library)))
     (error? (library-version
               '(probably not a valid loaded library ((>= 0)))))
     (error? (library-version '(rnrs (3 . 4))))
     (error? (library-version '(rnrs (1))))
     (error? (library-requirements 'foo))
     (error? (library-requirements '(1 2 3)))
     (error? (library-requirements '(probably not a valid loaded library)))
     (error? (library-requirements
               '(probably not a valid loaded library (1))))
     (error? (library-requirements '(rnrs (3.0))))
     (error? (library-requirements '(rnrs (1))))
     (error? (library-object-filename 'foo))
     (error? (library-object-filename '(1 2 3)))
     (error? (library-object-filename
               '(probably not a valid loaded library)))
     (error? (library-object-filename
               '(probably not a valid loaded library (2 3))))
     (error? (library-object-filename '(rnrs (six))))
     (error? (library-object-filename '(rnrs (1))))

     (error? (library-requirements 'foo (library-requirements-options)))
     (error? (library-requirements '(1 2 3) (library-requirements-options)))
     (error? (library-requirements '(probably not a valid loaded library)
               (library-requirements-options)))
     (error? (library-requirements
               '(probably not a valid loaded library (1))
               (library-requirements-options)))
     (error? (library-requirements '(rnrs (3.0))
               (library-requirements-options)))
     (error? (library-requirements '(rnrs (1))
               (library-requirements-options)))

     (enum-set? (library-requirements-options))
     (error? (library-requirements-options . a))
     (error? (library-requirements-options spam))
     (error? (library-requirements-options import spam))

     (error? (library-requirements '(chezscheme) 'import))
     (error? (library-requirements '(chezscheme) '(import)))
     (error? (library-requirements '(chezscheme) '()))

     (begin
       (define set-equal?
         (lambda (s1 s2)
           (and (= (length s1) (length s2))
                (andmap (lambda (x) (member x s2)) s1)
                #t)))
       #t)
     (list? (library-list))
     (andmap list? (library-list))
     (andmap (lambda (x) (andmap symbol? x)) (library-list))
     (begin (library (null) (export) (import)) #t)
     (let ([ls (library-list)])
       (and (member '(rnrs) ls)
            (member '(rnrs strings) ls)
            (member '(rnrs io ports) ls)
            (member '(chezscheme) ls)
            (member '(scheme) ls)
            (member '(null) ls))
       #t)
     (null? (library-exports '(null)))
     (set-equal? (library-exports '(rnrs mutable-pairs))
       '(set-car! set-cdr!))
     (equal? (sort string<?
                   (map symbol->string
                        (library-exports '(scheme))))
             (sort string<?
                   (map symbol->string
                        (library-exports '(chezscheme)))))
     (equal? (library-version '(rnrs)) '(6))
     (equal? (library-version '(rnrs (6))) '(6))
     (equal? (library-version '(rnrs (or (6) (7)))) '(6))
     (equal? (library-version '(rnrs (or (6) (7)))) '(6))
     (equal? (library-version '(scheme)) '())
     (equal? (library-requirements '(scheme)) '())
     (equal? (library-requirements '(scheme)
               (library-requirements-options))
             '())
     (equal? (library-requirements '(scheme)
               (library-requirements-options import))
             '())
     (equal? (library-requirements '(scheme ())) '())
     (equal? (library-requirements '(rnrs)) '())
     (equal? (library-requirements '(null)) '())
     (not (library-object-filename '(rnrs)))
     (not (library-object-filename '(rnrs (6))))
     (not (library-object-filename '(rnrs (or (6) (7)))))
     (not (library-object-filename '(rnrs (or (6) (7)))))
     (not (library-object-filename '(scheme)))
     (begin
       (library (li1 (3 4 5))
         (export x y)
         (import (chezscheme))
         (define-syntax x (lambda (x) 3))
         (define y (+ x 1)))
       (library (li2 (7 2))
         (export x z w)
         (import (rnrs) (li1 (3)))
         (define z (+ x y))
         (define-syntax w (lambda (q) (* y 2))))
       (library (li2a (7 2))
         (export x z w)
         (import (rnrs) (li1 (3)))
         (define z (+ x x))
         (define-syntax w (lambda (q) (* y 2))))
       #t)
     (and (member '(li1) (library-list))
          (member '(li2) (library-list))
          (member '(li2a) (library-list))
          #t)
     (equal? (library-version '(li1)) '(3 4 5))
     (equal? (library-version '(li2)) '(7 2))
     (equal? (library-version '(li2 ((>= 5)))) '(7 2))
     (equal? (library-version '(li2 (7 (>= 1)))) '(7 2))
     (error? (library-version '(li2 (6))))
     (set-equal? (library-exports '(li1)) '(x y))
     (set-equal? (library-exports '(li2)) '(x z w))
     (set-equal? (library-exports '(li2 ((>= 5)))) '(x z w))
     (set-equal? (library-exports '(li2 (7 (>= 1)))) '(x z w))
     (error? (library-exports '(li2 (6))))
     (not (library-object-filename '(li1)))
     (not (library-object-filename '(li2)))
     (not (library-object-filename '(li2 ((>= 5)))))
     (not (library-object-filename '(li2 (7 (>= 1)))))
     (error? (library-exports '(li2 (6))))
     (set-equal? (library-requirements '(li1)) '((chezscheme)))
     (set-equal? (library-requirements '(li2 ((>= 7))))
       '((rnrs (6)) (li1 (3 4 5))))
     (set-equal? (library-requirements '(li2)) '((rnrs (6)) (li1 (3 4 5))))
     (set-equal?
       (library-requirements '(li2) (library-requirements-options import))
       '((rnrs (6)) (li1 (3 4 5))))
     (set-equal?
       (library-requirements '(li2)
         (library-requirements-options visit@visit))
       '())
     (set-equal?
       (library-requirements '(li2)
         (library-requirements-options invoke@visit))
       '((li1 (3 4 5))))
     (set-equal?
       (library-requirements '(li2) (library-requirements-options invoke))
       '((li1 (3 4 5))))
     (error? (library-requirements '(li2 (6))))
     (set-equal? (library-requirements '(li2a))
       '((rnrs (6)) (li1 (3 4 5))))
     (set-equal?
       (library-requirements '(li2a) (library-requirements-options import))
       '((rnrs (6)) (li1 (3 4 5))))
     (set-equal?
       (library-requirements '(li2a)
         (library-requirements-options visit@visit))
       '())
     (set-equal?
       (library-requirements '(li2a)
         (library-requirements-options invoke@visit))
       '((li1 (3 4 5))))
     (set-equal?
       (library-requirements '(li2a) (library-requirements-options invoke))
       '())
     (equal? (let () (import (li1) (li2)) (list x y z w)) '(3 4 7 8))
     ; make sure requirements haven't changed just because we used the exports
     (set-equal? (library-requirements '(li1)) '((chezscheme)))
     (set-equal? (library-requirements '(li2)) '((rnrs (6)) (li1 (3 4 5))))
     (begin
       (define-syntax $li-a
         (syntax-rules ()
           [(_ name a p)
            (begin
              (library name
                (export a y)
                (import (rnrs))
                (define-syntax a
                  (identifier-syntax (cons y 1)))
                (define y 'hello))
              (define p (lambda () (import name) y)))]))
       ($li-a ($li-spam) q $li-get-y)
       #t)
     (eq? ($li-get-y) 'hello)
     (equal? (let () (import ($li-spam)) q) '(hello . 1))
     (eqv? (let ([y 75]) (import ($li-spam)) y) 75)
     (begin
       (with-output-to-file "testfile-li3.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-li3)
                (export x)
                (import (rnrs))
                (define x 3))))
         'replace)
       (with-output-to-file "testfile-li4.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-li4)
                (export x)
                (import (rnrs))
                (define x 3))))
         'replace)
       (with-output-to-file "testfile-li5.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-li5)
                (export x)
                (import (rnrs))
                (define x 3))))
         'replace)
       (separate-compile 'li5)
       #t)
     (equal? (parameterize ([compile-imported-libraries #t])
               (eval '(let () (import (testfile-li3)) x))
               (library-object-filename '(testfile-li3)))
             "testfile-li3.so")
     (equal? (parameterize ([compile-imported-libraries #f])
               (eval '(let () (import (testfile-li4)) x))
               (library-object-filename '(testfile-li4)))
             #f)
     (equal? (begin
               (eval '(let () (import (testfile-li5)) x))
               (library-object-filename '(testfile-li5)))
             "testfile-li5.so")
     (equal? (begin
               (load-library "testfile-li3.ss")
               (library-object-filename '(testfile-li3)))
             #f)
     (equal? (begin
               (load-library "testfile-li3.so")
               (library-object-filename '(testfile-li3)))
             "testfile-li3.so"))

(mat rnrs-eval
     (begin
       (define $eval-e1 (environment '(rnrs)))
       (environment? $eval-e1))
     (error? ; variable environment not bound
             (r6rs:eval 'environment $eval-e1))
     (error? ; variable eval not bound
             (r6rs:eval 'eval $eval-e1))
     (eq? (r6rs:eval 'cons $eval-e1) cons)
     (error? ; invalid context for definition
             (r6rs:eval '(define x 4) $eval-e1))
     (error? ; invalid context for definition
             (r6rs:eval '(define foo 4) $eval-e1))
     (error? ; cannot assign cons
             (r6rs:eval '(set! cons 4) $eval-e1))
     (error? ; cannot assign foo
             (r6rs:eval '(set! foo 4) $eval-e1))
     (begin
       (with-output-to-file "testfile-eval1.ss"
         (lambda ()
           (pretty-print
             '(library (testfile-eval1)
                (export canned spam list define quote set!)
                (import (rnrs))
                (define-syntax canned
                  (begin
                    (display "testfile-eval1 visit")
                    (newline)
                    (identifier-syntax tuna)))
                (define spam (lambda () (cons 'not canned)))
                (define tuna 'yummy)
                (display "testfile-eval1 invoke")
                (newline))))
         'replace)
       #t)
     (equal? (r6rs:eval '(list canned (spam))
               (environment '(testfile-eval1)))
             '(yummy (not . yummy)))
     (error? ; cons is not bound
       (r6rs:eval '(cons canned (spam)) (environment '(testfile-eval1))))
     (error? ; invalid context for definition
             (r6rs:eval '(define foo 3) (environment '(testfile-eval1))))
     (error? ; cannot assign
       (r6rs:eval '(set! spam 3) (environment '(testfile-eval1))))
     (error? ; cannot assign
       (r6rs:eval '(set! foo 3) (environment '(testfile-eval1))))
     (error? ; invalid definition in immutable environment
             (let ([env (environment '(testfile-eval1))])
               (eval `(define cons ',vector) env)))
     (equal? (let ([env (copy-environment (environment '(testfile-eval1)))])
               (eval `(define cons ',vector) env)
               (r6rs:eval '(cons canned (spam)) env))
             '#(yummy (not . yummy)))
     (eq? (r6rs:eval '(let () (import (scheme)) compile)
            (environment '(only (scheme) let import)))
          compile))

(mat top-level-syntax-functions
     (error? (top-level-syntax "hello"))
     (error? (top-level-syntax))
     (error? (top-level-syntax 'hello 'hello))
     (error? (top-level-syntax (scheme-environment) (scheme-environment)))
     (error? (top-level-syntax? "hello"))
     (error? (top-level-syntax?))
     (error? (top-level-syntax? 'hello 'hello))
     (error? (top-level-syntax? (scheme-environment) (scheme-environment)))
     (error? (define-top-level-syntax "hello" "hello"))
     (error? (define-top-level-syntax))
     (error? (define-top-level-syntax 15))
     (error? (define-top-level-syntax 'hello 'hello 'hello))
     (error? (define-top-level-syntax (scheme-environment)
               (scheme-environment)
               (scheme-environment)))
     (error? (let ([e (scheme-environment)])
               (define-top-level-syntax 'p (lambda (x) "hello") e)))
     (error? (let ([e (copy-environment (scheme-environment) #f)])
               (define-top-level-syntax 'p void e)))
     (error? (let ([e (scheme-environment)]) (top-level-syntax 'p e)))
     (and (top-level-syntax 'hopenotdefined) #t)
     (and (top-level-syntax 'cons) #t)
     (and (top-level-syntax 'scheme) #t)
     (error? (top-level-syntax 'cond (environment)))
     (top-level-syntax? 'hopenotdefined)
     (top-level-syntax? 'cons)
     (top-level-syntax? 'scheme)
     (not (top-level-syntax? 'cond (environment)))

     (top-level-syntax? 'cond)
     (procedure? (top-level-syntax 'cond))

     (begin
       (define-top-level-syntax '$tls-foo (syntax-rules () [(_ x) (x x)]))
       #t)
     (equal? ($tls-foo list) `(,list))

     (equal? (parameterize
               ([interaction-environment
                  (copy-environment (scheme-environment) #t)])
               (let ([t (syntax-rules () [(_ x y) (* x y)])])
                 (eval `(define-syntax cons ',t))
                 (eval '(cons 3 4))))
             12)
     (equal? (let ([e (environment '(only (scheme) cond))])
               (list (top-level-syntax? 'cond e)
                     (eq? (top-level-syntax 'cond e)
                          (top-level-syntax 'cond (scheme-environment)))
                     (top-level-syntax? 'cdr e)))
             '(#t #t #f))
     (equal? (let ([e (copy-environment (environment) #t)])
               (let ([t1 (lambda (x) 17)]
                     [t2 (syntax-rules () [(_ x y) (list y x)])])
                 (define-top-level-syntax 'p t1 e)
                 (define-top-level-syntax 'q t2 e)
                 (list (top-level-syntax? 'p e)
                       (top-level-syntax? 'q e)
                       (top-level-syntax? 'r e)
                       (eq? (top-level-syntax 'p e) t1)
                       (eq? (top-level-syntax 'q e) t2)
                       ((top-level-syntax 'p e) 'p)
                       (eval '(q 3 4) e)
                       (eval 'p e))))
             '(#t #t #t #t #t 17 (4 3) 17)))

(mat annotations
     (error? ; #f is not a string
       (make-source-file-descriptor #f
         (open-bytevector-input-port (string->utf8 "hello"))))
     (error? ; 17 is not a binary-input port
             (make-source-file-descriptor "foo" 17))
     (error? ; #<input port stdin> is not a binary-input port
             (make-source-file-descriptor "foo"
               (open-string-input-port "oops")))
     (error? ; #<binary input port> does not supoprt port-position and set-port-position!
             (make-source-file-descriptor "foo"
               (make-custom-binary-input-port "foo"
                 (lambda (bv s c) 0)
                 #f
                 #f
                 #f)
               #t))
     (begin
       (define str "(ugh (if \x3b2;))")
       (define bv (string->utf8 str))
       (define ip (open-bytevector-input-port bv))
       (define sfd
         (make-source-file-descriptor "foo" ip #t))
       #t)
     (not (= (bytevector-length bv) (string-length str)))
     (error? ; sfd is not an sfd
             (make-source-object 'sfd 2 3))
     (error? ; two is not an exact integer
             (make-source-object sfd 'two 3))
     (error? ; three is not an exact integer
             (make-source-object sfd 2 'three))
     (error? ; bfp 3 is not between 0 and efp 2
             (make-source-object sfd 3 2))
     (error? ; bfp -7 not between 0 and efp -3
             (make-source-object sfd -7 -3))
     (error? ; bfp -7 is not between 0 and efp 3
             (make-source-object sfd -7 3))
     (error? ; bfp -7 is not between 0 and efp 3
             (make-source-object sfd -7 3 2 1))
     (error? ; one is not an exact integer
             (make-source-object sfd 1 2 'one 1))
     (error? ; one is not an exact integer
             (make-source-object sfd 1 2 1 'one))
     (error? ; zero is not an exact positive integer
             (make-source-object sfd 1 2 0 1))
     (error? ; zero is not an exact positive integer
             (make-source-object sfd 1 2 1 0))
     (error? ; bfp 3 is not between 0 and efp 2
             (make-source-object sfd 3 2 1 1))
     (begin
       (define source (make-source-object sfd 2 3))
       (define source-at-line-two
         (make-source-object sfd 3 5 2 1))
       #t)
     (error? ; source is not a source object
             (make-annotation #f 'source #f))
     (begin
       (define a
         (make-annotation '(if 3) source '(if I were a rich man)))
       (define a-at-line-two
         (make-annotation
           '(if 3)
           source-at-line-two
           '(if I were a rich man)))
       (define x (datum->syntax #'* a))
       #t)
     (source-file-descriptor? sfd)
     (not (source-file-descriptor? source))
     (source-object? source)
     (source-object? source-at-line-two)
     (not (source-object? sfd))
     (not (source-object? a))
     (annotation? a)
     (not (annotation? source))
     (error? ; #<source> is not an sfd
             (source-file-descriptor-path source))
     (error? ; #<annotation> is not an sfd
             (source-file-descriptor-checksum a))
     (error? ; #<sfd> is not a source object
             (source-object-sfd sfd))
     (error? ; #<annotation> is not a source object
             (source-object-bfp a))
     (error? ; 3 is not a source object
             (source-object-efp 3))
     (error? ; 3 is not a source object
             (source-object-line 3))
     (error? ; 3 is not a source object
             (source-object-column 3))
     (error? ; 3 is not an annotation
             (annotation-expression 3))
     (error? ; #<source> is not an annotation
             (annotation-stripped source))
     (error? ; #<sfd> is not an annotation
             (annotation-source sfd))
     (error? ; #<source> is not an annotation
             (annotation-option-set source))
     (error? ; invalid syntax
             (annotation-options . debug))
     (error? ; invalid syntax
             (annotation-options 3 profile))
     (error? ; invalid option
             (annotation-options fig))
     (error? ; invalid option
             (annotation-options debug fig))
     (error? ; invalid option
             (annotation-options fig profile))
     (equal? (source-file-descriptor-path sfd) "foo")
     (number? (source-file-descriptor-checksum sfd))
     (eq? (source-object-sfd source) sfd)
     (eq? (source-object-bfp source) 2)
     (eq? (source-object-efp source) 3)
     (eq? (source-object-line source) #f)
     (eq? (source-object-column source) #f)
     (eq? (source-object-sfd source) sfd)
     (eq? (source-object-bfp source-at-line-two) 3)
     (eq? (source-object-efp source-at-line-two) 5)
     (eq? (source-object-line source-at-line-two) 2)
     (eq? (source-object-column source-at-line-two) 1)
     (equal? (annotation-expression a) '(if 3))
     (eq? (annotation-source a) source)
     (equal? (annotation-stripped a) '(if I were a rich man))
     (enum-set=? (annotation-option-set a)
       (annotation-options debug profile))
     (enum-set=?
       (annotation-option-set
         (make-annotation
           '(if 3)
           source
           '(if I were a rich man)
           (annotation-options)))
       (annotation-options))
     (enum-set=?
       (annotation-option-set
         (make-annotation
           '(if 3)
           source
           '(if I were a rich man)
           (annotation-options debug)))
       (annotation-options debug))
     (enum-set=?
       (annotation-option-set
         (make-annotation
           '(if 3)
           source
           '(if I were a rich man)
           (annotation-options profile)))
       (annotation-options profile))
     (enum-set=?
       (annotation-option-set
         (make-annotation
           '(if 3)
           source
           '(if I were a rich man)
           (annotation-options debug profile)))
       (annotation-options debug profile))
     (enum-set=?
       (annotation-option-set
         (make-annotation
           '(if 3)
           source
           '(if I were a rich man)
           (annotation-options profile debug)))
       (annotation-options debug profile))
     (eq? (syntax->annotation x) a)
     (not (syntax->annotation #'(a b c)))
     (not (syntax->annotation '(a b c)))
     (not (syntax->annotation #f))
     (error? ; invalid syntax (if I were a rich man) at char 2 of foo
             (expand a))
     (error? ; invalid syntax (if I were a rich man) at line 2, char 1 of foo
             (expand a-at-line-two))
     (error? ; invalid syntax (if I were a rich man) at char 2 of foo
             (eval a))
     (error? ; invalid syntax (if I were a rich man) at char 2, char 1 of foo
             (eval a-at-line-two))
     (error? ; invalid syntax (if I were a rich man) at char 2 of foo
             (eval '(let ()
                      (define-syntax foo
                        (lambda (z) (datum->syntax #'* a)))
                      foo)))
     (error? ; invalid syntax (if I were a rich man) at line 2, char 1 of foo
             (eval '(let ()
                      (define-syntax foo
                        (lambda (z)
                          (datum->syntax #'* a-at-line-two)))
                      foo)))
     (error? ; invalid syntax (if I were a rich man) at char 2 of foo
       (eval '(let ()
                (define-syntax foo
                  (lambda (z)
                    (datum->syntax #'*
                      (make-annotation
                        '(if 3)
                        source
                        '(if I were a rich man)
                        (annotation-options debug profile)))))
                foo)))
     (error? ; invalid syntax (if I were a rich man) at line 2, char 1 of foo
       (eval '(let ()
                (define-syntax foo
                  (lambda (z)
                    (datum->syntax #'*
                      (make-annotation
                        '(if 3)
                        source-at-line-two
                        '(if I were a rich man)
                        (annotation-options debug profile)))))
                foo)))
     (error? ; invalid syntax (if I were a rich man) at char 2 of foo
       (eval '(let ()
                (define-syntax foo
                  (lambda (z)
                    (datum->syntax #'*
                      (make-annotation
                        '(if 3)
                        source
                        '(if I were a rich man)
                        (annotation-options debug)))))
                foo)))
     (error? ; invalid syntax (if I were a rich man)
       (eval '(let ()
                (define-syntax foo
                  (lambda (z)
                    (datum->syntax #'*
                      (make-annotation
                        '(if 3)
                        source
                        '(if I were a rich man)
                        (annotation-options profile)))))
                foo)))
     (error? ; invalid syntax (if I were a rich man)
       (eval '(let ()
                (define-syntax foo
                  (lambda (z)
                    (datum->syntax #'*
                      (make-annotation
                        '(if 3)
                        source
                        '(if I were a rich man)
                        (annotation-options)))))
                foo)))
     (error? ; invalid argument count in call (f) at char 2 of foo
       (eval '(let ()
                (define-syntax foo
                  (lambda (z)
                    (datum->syntax #'*
                      `(let ([f (lambda (x) x)])
                         ,(make-annotation
                            '(f)
                            source
                            '(f)
                            (annotation-options debug profile))))))
                foo)))
     (error? ; invalid argument count in call (f) at line 2, char 1 of foo
       (eval '(let ()
                (define-syntax foo
                  (lambda (z)
                    (datum->syntax #'*
                      `(let ([f (lambda (x) x)])
                         ,(make-annotation
                            '(f)
                            source-at-line-two
                            '(f)
                            (annotation-options debug profile))))))
                foo)))
     (error? ; invalid argument count in call (f) at char 2 of foo
       (eval '(let ()
                (define-syntax foo
                  (lambda (z)
                    (datum->syntax #'*
                      `(let ([f (lambda (x) x)])
                         ,(make-annotation
                            '(f)
                            source
                            '(f)
                            (annotation-options debug))))))
                foo)))
     (error? ; invalid argument count in call (f)
       (eval '(let ()
                (define-syntax foo
                  (lambda (z)
                    (datum->syntax #'*
                      `(let ([f (lambda (x) x)])
                         ,(make-annotation
                            '(f)
                            source
                            '(f)
                            (annotation-options profile))))))
                foo)))
     (error? ; invalid argument count in call (f)
       (eval '(let ()
                (define-syntax foo
                  (lambda (z)
                    (datum->syntax #'*
                      `(let ([f (lambda (x) x)])
                         ,(make-annotation
                            '(f)
                            source
                            '(f)
                            (annotation-options))))))
                foo)))
     (begin (profile-clear) #t)
     (begin
       (define foo
         (parameterize ([compile-profile #t] [current-eval compile])
           (eval '(lambda ()
                    (define-syntax foo
                      (lambda (z)
                        (datum->syntax #'*
                          (make-annotation
                            `(,(make-annotation '+
                                 (make-source-object sfd 2 3)
                                 '+
                                 (annotation-options debug profile))
                              ,(make-annotation
                                 '3(make-source-object sfd 4 5)
                                 '3(annotation-options))
                              ,(make-annotation
                                 '44(make-source-object sfd 8 10)
                                 '44(annotation-options debug)))
                            (make-source-object sfd 1 11)
                            '(+ 3 44)
                            (annotation-options profile)))))
                    foo))))
       #t)
     (equal? (foo) 47)
     (equal? (let ([ls (profile-dump-list)])
               (vector (find (lambda (x)
                               (equal? (list-head (cdr x) 3) '("foo" 1 11)))
                             ls)
                       (find (lambda (x) (equal? (list-head (cdr x) 3) '("foo" 2 3))) ls)
                       (find (lambda (x) (equal? (list-head (cdr x) 3) '("foo" 4 5))) ls)
                       (find (lambda (x) (equal? (list-head (cdr x) 3) '("foo" 8 10))) ls)))
             '#((1 "foo" 1 11 #f #f) (1 "foo" 2 3 #f #f) #f #f))
     (begin (profile-clear) #t)
     (begin
       (define ip (transcoded-port ip (native-transcoder)))
       (define-values (x fp) (get-datum/annotations ip sfd 0))
       #t)
     (error? ; #<sfd> is not a textual input port
             (get-datum/annotations sfd sfd 0))
     (error? ; #<input port> is not an sfd
             (get-datum/annotations ip ip 0))
     (error? ; #<sfd> is not a valid file position
             (get-datum/annotations ip sfd sfd))
     (error? ; -5 is not a valid file position
             (get-datum/annotations ip sfd -5))
     (error? ; 5.0 is not a valid file position
             (get-datum/annotations ip sfd 5.0))
     (eqv? fp (string-length str))
     (annotation? x)
     (equal? (annotation-stripped x) (with-input-from-string str read))
     (equal? (let f ([x x])
               (and (annotation? x)
                    (let ([x (annotation-expression x)])
                      (if (list? x) (map f x) x))))
             (with-input-from-string str read))
     (begin (define source (annotation-source x)) #t)
     (source-object? source)
     (eq? (source-object-sfd source) sfd)
     (eqv? (source-object-bfp source) 0)
     (eqv? (source-object-efp source) (string-length str))
     (error? ; not a string
             (source-file-descriptor 'spam 0))
     (error? ; not an exact nonnegative integer
             (source-file-descriptor "spam" -1))
     (error? ; not an exact nonnegative integer
             (source-file-descriptor "spam" 1.0))
     (source-file-descriptor? (source-file-descriptor "spam" #x34534a5))
     (source-file-descriptor?
       (source-file-descriptor
         "spam"
         #x20333333333339999999997834443333337))
     (equal? (source-file-descriptor-path
               (source-file-descriptor
                 "spam"
                 #x20333333333339999999997834443333337))
             "spam")
     (equal? (source-file-descriptor-checksum
               (source-file-descriptor
                 "spam"
                 #x20333333333339999999997834443333337))
             #x20333333333339999999997834443333337)
     (error? ; not an sfd
             (locate-source "spam" 17))
     (error? ; not an exact nonnegative integer
             (locate-source sfd -1))
     (error? ; not an exact nonnegative integer
             (locate-source sfd 'a))
     (let-values ([() (locate-source sfd 7)]) #t)
     (begin
       (with-output-to-file "testfile.ss"
         (lambda ()
           (printf "; bogus exports\n")
           (printf "(module (a 3)\n")
           (printf "  (define a 3))\n"))
         'replace)
       #t)
     (equal? (guard (c [(syntax-violation? c)
                        (let* ([form (syntax-violation-form c)]
                               [annotation (syntax->annotation form)]
                               [source (annotation-source annotation)])
                          (cons (call-with-values
                                  (lambda ()
                                    (locate-source
                                      (source-object-sfd source)
                                      (source-object-bfp source)))
                                  vector)
                                (call-with-values
                                  (lambda ()
                                    (locate-source
                                      (source-object-sfd source)
                                      (source-object-efp source)))
                                  vector)))])
                    (load "testfile.ss"))
             '(#("testfile.ss" 2 12) . #("testfile.ss" 2 13)))
     (equal? (let ([sfd (source-file-descriptor
                          (source-file-descriptor-path sfd)
                          (source-file-descriptor-checksum sfd))])
               (let ([source (make-source-object sfd 2 3)])
                 (guard (c [(syntax-violation? c)
                            (let* ([form (syntax-violation-form c)]
                                   [annotation (syntax->annotation form)]
                                   [source (annotation-source annotation)])
                              (cons (call-with-values
                                      (lambda ()
                                        (locate-source
                                          (source-object-sfd source)
                                          (source-object-bfp source)))
                                      vector)
                                    (call-with-values
                                      (lambda ()
                                        (locate-source
                                          (source-object-sfd source)
                                          (source-object-efp source)))
                                      vector)))])
                        (load "testfile.ss"))))
             '(#("testfile.ss" 2 12) . #("testfile.ss" 2 13)))

     (error? ; not a source object
             (locate-source-object-source "spam" #t #t))
     (error? (current-locate-source-object-source 7))
     (error? (current-locate-source-object-source "string"))
     (error? ; not a source object
       ((current-locate-source-object-source) "spam" #t #t))
     (error? ; invalid syntax (if I were a rich man) at line 200, char 17 of foo
       (parameterize
         ([current-locate-source-object-source
            (lambda (src start? cache?)
              (values (source-file-descriptor-path (source-object-sfd src))
                      200
                      17))])
         (expand a))))

(mat annotations-via-recorded-lines
     (error? (current-make-source-object 7))
     (error? (current-make-source-object "string"))
     (begin
       (define sfd-with-lines
         (let ((op (open-output-file "testfile.ss" 'replace)))
           (display "apple\n  banana\ncoconut" op)
           (close-port op)
           (let* ([ip (open-file-input-port "testfile.ss")]
                  [sfd (make-source-file-descriptor "testfile.ss" ip)])
             (close-port ip)
             sfd)))
       (define input-string-with-lines
         "Apple\n  Banana\nCoconut\nMore")
       (define input-port-with-lines
         (open-string-input-port input-string-with-lines))
       (define input-port-with-line-pos 0)
       (define (make-make-source-object/get-lines expected-sfd)
         (lambda (sfd bfp efp)
           (if (eq? sfd expected-sfd)
               ;; Gather line and column now:
               (let-values ([(path line col) (locate-source sfd bfp #t)])
                 (make-source-object sfd bfp efp line col))
               (error 'recording-make-source-object
                      "reading some other file?"))))
       (define (read-with-lines)
         (parameterize
           ([current-make-source-object
              (make-make-source-object/get-lines sfd-with-lines)])
           (let-values
             ([(v pos)
               (get-datum/annotations
                 input-port-with-lines
                 sfd-with-lines
                 input-port-with-line-pos)])
             (set! input-port-with-line-pos pos)
             v)))
       #t)
     (begin
       (define line-one (read-with-lines))
       (annotation? line-one))
     (equal? (annotation-stripped line-one) 'Apple)
     (equal? (source-object-bfp (annotation-source line-one)) 0)
     (equal? (source-object-line (annotation-source line-one)) 1)
     (equal? (source-object-column (annotation-source line-one)) 1)
     (begin
       (define line-two (read-with-lines))
       (annotation? line-two))
     (equal? (source-object-bfp (annotation-source line-two)) 8)
     (equal? (source-object-line (annotation-source line-two)) 2)
     (equal? (source-object-column (annotation-source line-two)) 3)
     (begin
       (define line-three (read-with-lines))
       (annotation? line-three))
     (equal? (source-object-bfp (annotation-source line-three)) 15)
     (equal? (source-object-line (annotation-source line-three)) 3)
     (equal? (source-object-column (annotation-source line-three)) 1)
     (annotation? (read-with-lines))
     ; 'More
     (eof-object? (read-with-lines))

     ;; Make sure lines are calculated right with input that is longer than
     ;; the file buffer size:
     (begin
       (define input-string-with-lines
         (string-append "\""
           (make-string (* 2 (file-buffer-size)) #\a)
           "\""
           "\nend"))
       (define input-port-with-lines
         (open-string-input-port input-string-with-lines))
       (define sfd-with-lines
         (let ((op (open-output-file "testfile.ss" 'replace)))
           (display input-string-with-lines op)
           (close-port op)
           (let* ([ip (open-file-input-port "testfile.ss")]
                  [sfd (make-source-file-descriptor "testfile.ss" ip)])
             (close-port ip)
             sfd)))
       (define input-port-with-line-pos 0)
       (define (read-with-lines)
         (parameterize
           ([current-make-source-object
              (make-make-source-object/get-lines sfd-with-lines)])
           (let-values
             ([(v pos)
               (get-datum/annotations
                 input-port-with-lines
                 sfd-with-lines
                 input-port-with-line-pos)])
             (set! input-port-with-line-pos pos)
             v)))
       (define line-one (read-with-lines))
       (annotation? line-one))
     (string? (annotation-stripped line-one))
     (begin
       (define line-two (read-with-lines))
       (annotation? line-two))
     (equal? (source-object-line (annotation-source line-two)) 2)
     (equal? (source-object-column (annotation-source line-two)) 1))

(mat locate-source-caching
     (begin
       (define (make-expr n)
         `(let ()
            ,@(let loop ([i n])
                (if (zero? i)
                    '(#t)
                    (cons `(let-values ([(x y z) (values 1 2 3)]) x)
                          (loop (sub1 i)))))))

       (define (time-expr n)
         (with-output-to-file "testfile.ss"
           (lambda () (pretty-print (make-expr n)))
           'truncate)
         (collect)
         (parameterize ([collect-request-handler void])
           (let ([start (current-time)])
             (load "testfile.ss" expand)
             (let ([delta (time-difference (current-time) start)])
               (+ (* #e1e9 (time-second delta)) (time-nanosecond delta))))))

       (let loop ([tries 3])
         (when (zero? tries)
               (error 'source-cache-test
                      "loading lots of `let-values` forms seems to take too long"))
         (let ([t1000 (time-expr 1000)] [t10000 (time-expr 10000)])
           (or (> (* 20 t1000) t10000)
               (begin
                 (printf "t1000 = ~s, t10000 = ~s, t10000 / t1000 = ~s\n"
                         t1000
                         t10000
                         (inexact (/ t10000 t1000)))
                 (loop (sub1 tries)))))))

     (begin
       (define sfd-to-cache
         (let ((op (open-output-file "testfile.ss" 'replace)))
           (display "apple\n  banana\ncoconut" op)
           (close-port op)
           (let* ([ip (open-file-input-port "testfile.ss")]
                  [sfd (make-source-file-descriptor "testfile.ss" ip)])
             (close-port ip)
             sfd)))

       (equal? (call-with-values
                 (lambda ()
                   (locate-source sfd-to-cache 8 #t))
                 (case-lambda
                   [(name line col) (list line col)]))
               '(2 3)))

     (begin
       (let ((op (open-output-file "testfile.ss" 'replace)))
         (display "1\n2\n3\n4\n5\n6789" op)
         (close-port op))
       ;; Cache may report the old source line,
       ;; or uncached should report no line:
       (equal? (call-with-values
                 (lambda ()
                   (locate-source sfd-to-cache 8 #t))
                 (case-lambda
                   [() '(2 3)]
                   ; report no line same as expected cache
                   [(name line col) (list line col)]))
               '(2 3)))

     ;; An uncached lookup defniitely reports no line:
     (equal? (call-with-values (lambda () (locate-source sfd-to-cache 8 #f))
               (lambda () 'none))
             'none)

     (begin
       (collect (collect-maximum-generation))
       ;; After collecting the maximum generation, the
       ;; cached information shoould definitely be gone:
       (equal? (call-with-values
                 (lambda ()
                   (locate-source sfd-to-cache 8 #t))
                 (lambda () 'gone))
               'gone)))

(mat include
     (error? ; invalid syntax
             (expand '(include spam)))
     (error? ; invalid syntax
       (parameterize ([source-directories '("../s" "../c")])
         (expand '(include spam)))))

(mat extend-syntax
     (begin (extend-syntax (foo) [(foo a b) (list a b)]) #t)
     (equal? (foo 3 4) '(3 4))
     (begin
       (extend-syntax (foo bar)
         [(foo) '()]
         [(foo (bar x)) x]
         [(foo x) (cons x '())]
         [(foo x y ...) (cons x (foo y ...))])
       #t)
     (equal? (foo 'a 'b 'c 'd) '(a b c d))
     (equal? (foo 'a 'b 'c (bar 'd)) '(a b c . d))
     (begin
       (extend-syntax (foo)
         [(foo ((x v) ...) e1 e2 ...)
          (andmap symbol? '(x ...))
          ((lambda (x ...) e1 e2 ...) v ...)]
         [(foo ((lambda (x ...) e1 e2 ...) v ...))
          (= (length '(x ...)) (length '(v ...)))
          (foo ((x v) ...) e1 e2 ...)])
       #t)
     (equal? (foo ((a 3) (b 4)) (cons a b)) '(3 . 4))
     (error? (extend-syntax (foo ...) [(foo ...) 0]))
     (error? (extend-syntax (foo) [(foo x ... y) 0]))
     (error? (extend-syntax (foo) [(foo x . ...) 0]))
     (error? (extend-syntax (foo) [(foo (...)) 0]))
     (error? (extend-syntax (foo) [(foo x x) 0]))
     (begin (extend-syntax (foo) [(foo foo) 0]) #t)
     (begin
       (extend-syntax (foo) [(foo keys) (with ([x `,'keys]) 'x)])
       (equal? (foo (a b c)) '(a b c)))
     (begin
       (extend-syntax (foo) [(foo x y) '`(x ,@y)])
       (equal? (foo a b) '`(a ,@b)))
     (begin
       (extend-syntax (foo)
         ; test exponential "with" time problem
         [(foo)
          (with ([a1 1]
                 [b1 2]
                 [c1 3]
                 [d1 4]
                 [e1 5]
                 [f1 6]
                 [g1 7]
                 [h1 8]
                 [a2 1]
                 [b2 2]
                 [c2 3]
                 [d2 4]
                 [e2 5]
                 [f2 6]
                 [g2 7]
                 [h2 8]
                 [a3 1]
                 [b3 2]
                 [c3 3]
                 [d3 4]
                 [e3 5]
                 [f3 6]
                 [g3 7]
                 [h3 8]
                 [a4 1]
                 [b4 2]
                 [c4 3]
                 [d4 4]
                 [e4 5]
                 [f4 6]
                 [g4 7]
                 [h4 8]
                 [a5 1]
                 [b5 2]
                 [c5 3]
                 [d5 4]
                 [e5 5]
                 [f5 6]
                 [g5 7]
                 [h5 8]
                 [a6 1]
                 [b6 2]
                 [c6 3]
                 [d6 4]
                 [e6 5]
                 [f6 6]
                 [g6 7]
                 [h6 8]
                 [a7 1]
                 [b7 2]
                 [c7 3]
                 [d7 4]
                 [e7 5]
                 [f7 6]
                 [g7 7]
                 [h7 8]
                 [a8 1]
                 [b8 2]
                 [c8 3]
                 [d8 4]
                 [e8 5]
                 [f8 6]
                 [g8 7]
                 [h8 8])
                '(a1 b2 c3 d4 e5 f6 g7 h8))])
       (equal? (foo) '(1 2 3 4 5 6 7 8)))
     (equal? (letrec* ((x 3) (y (+ x 2))) (list x y)) '(3 5)))

(mat with
     (begin
       (extend-syntax (foo)
         [(foo x ...) (with ([n (length '(x ...))]) (list n 'x ...))])
       #t)
     (equal? (foo 3 2 1) '(3 3 2 1))
     (begin
       (extend-syntax (foo)
         [(foo (x ...) ...)
          (list (with ([(y ...) '(x ... (with ([n (length '(x ...))]) n))])
                      (with ([(z ...) (reverse '(y ...))]) (list 'z ...)))
                ...)])
       #t)
     (equal? (foo) '())
     (equal? (foo (a b) (c d e)) '((2 b a) (3 e d c)))
     (begin
       (extend-syntax (foo)
         [(foo x ...)
          (with ([(y1 y2 ...) '(x ...)]) (with ([(z1 z2) 'y1]) '(z2 z1)))])
       #t)
     (equal? (foo (a b) (c d) (e f)) '(b a)))
;;; fx.ms
;;; Copyright 1984-2017 Cisco Systems, Inc.
;;; 
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;; 
;;; http://www.apache.org/licenses/LICENSE-2.0
;;; 
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

(mat fx=
     (not (fx= 3 4))
     (not (fx= 4 3))
     (fx= 4 4)
     (not (fx= -4 4))
     (not (fx= 4 -4))
     (not (fx= -4 -3))
     (not (fx= -3 -4))
     (fx= -4)
     (fx= -4 -4)
     (fx= -4 -4 -4)
     (error? (fx= (list 'a)))
     (error? (fx= (+ (most-positive-fixnum) 1) 3 2))
     (error? (fx= (- (most-negative-fixnum) 1) 3))
     (guard (c [#t #t]) (fx= 3 4 (error #f "oops")))
     (guard (c [#t #t]) (fx= 3 (error #f "oops") 4))
     (guard (c [#t #t]) (fx= (error #f "oops") 3 4))
     (guard (c [#t #t]) (not (fx= (error #f "oops"))))
     (test-cp0-expansion eqv? '(fx= -3 -7) #f)
     (test-cp0-expansion eqv? '(fx= -3 0) #f)
     (test-cp0-expansion eqv? '(fx= 0 -3) #f)
     (test-cp0-expansion eqv? '(fx= 0 0) #t)
     (test-cp0-expansion eqv? '(fx= -3 -3) #t)
     (test-cp0-expansion eqv? '(fx= 12 12) #t)
     (test-cp0-expansion eqv? '(fx= -3 -7 -7) #f)
     (test-cp0-expansion eqv? '(fx= -3 -3 0) #f)
     (test-cp0-expansion eqv? '(fx= 0 -3 0) #f)
     (test-cp0-expansion eqv? '(fx= 0 0 0) #t)
     (test-cp0-expansion eqv? '(fx= -3 -3 -3) #t)
     (test-cp0-expansion eqv? '(fx= 12 12 12) #t))

(mat fx<
     (fx< 3 4)
     (not (fx< 4 3))
     (not (fx< 4 4))
     (fx< -4 4)
     (not (fx< 4 -4))
     (fx< -4 -3)
     (not (fx< -3 -4))
     (not (fx< -4 -4))
     (not (fx< -4 -4))
     (not (fx< -4 -4 -4))
     (error? (fx< 'a))
     (error? (fx< (+ (most-positive-fixnum) 1) 3 2))
     (error? (fx< (- (most-negative-fixnum) 1) 3))
     (guard (c [#t #t]) (fx< 4 3 (error #f "oops")))
     (guard (c [#t #t]) (fx< 4 (error #f "oops") 3))
     (guard (c [#t #t]) (fx< (error #f "oops") 4 3))
     (guard (c [#t #t]) (not (fx< (error #f "oops"))))
     (test-cp0-expansion eqv? '(fx< -3 -7) #f)
     (test-cp0-expansion eqv? '(fx< -3 0) #t)
     (test-cp0-expansion eqv? '(fx< 0 -3) #f)
     (test-cp0-expansion eqv? '(fx< 0 0) #f)
     (test-cp0-expansion eqv? '(fx< -3 -3) #f)
     (test-cp0-expansion eqv? '(fx< 12 12) #f)
     (test-cp0-expansion eqv? '(fx< -3 -7 -7) #f)
     (test-cp0-expansion eqv? '(fx< -3 -2 0) #t)
     (test-cp0-expansion eqv? '(fx< -3 -3 0) #f)
     (test-cp0-expansion eqv? '(fx< 0 -3 0) #f)
     (test-cp0-expansion eqv? '(fx< 0 0 0) #f)
     (test-cp0-expansion eqv? '(fx< -3 -3 -3) #f)
     (test-cp0-expansion eqv? '(fx< 12 12 12) #f))

(mat fx>
     (not (fx> 3 4))
     (fx> 4 3)
     (not (fx> 4 4))
     (not (fx> -4 4))
     (fx> 4 -4)
     (not (fx> -4 -3))
     (fx> -3 -4)
     (fx> -4)
     (not (fx> -4 -4))
     (not (fx> -4 -4 -4))
     (error? (fx> "hi"))
     (error? (fx> (+ (most-positive-fixnum) 1) 3 2))
     (error? (fx> (- (most-negative-fixnum) 1) 3))
     (guard (c [#t #t]) (fx> 3 4 (error #f "oops")))
     (guard (c [#t #t]) (fx> 3 (error #f "oops") 4))
     (guard (c [#t #t]) (fx> (error #f "oops") 3 4))
     (guard (c [#t #t]) (not (fx> (error #f "oops"))))
     (test-cp0-expansion eqv? '(fx> -3 -7) #t)
     (test-cp0-expansion eqv? '(fx> -3 0) #f)
     (test-cp0-expansion eqv? '(fx> 0 -3) #t)
     (test-cp0-expansion eqv? '(fx> 0 0) #f)
     (test-cp0-expansion eqv? '(fx> -3 -3) #f)
     (test-cp0-expansion eqv? '(fx> 12 12) #f)
     (test-cp0-expansion eqv? '(fx> -3 -7 -7) #f)
     (test-cp0-expansion eqv? '(fx> -3 -2 0) #f)
     (test-cp0-expansion eqv? '(fx> 0 -2 -3) #t)
     (test-cp0-expansion eqv? '(fx> -3 -3 0) #f)
     (test-cp0-expansion eqv? '(fx> 0 -3 0) #f)
     (test-cp0-expansion eqv? '(fx> 0 0 0) #f)
     (test-cp0-expansion eqv? '(fx> -3 -3 -3) #f)
     (test-cp0-expansion eqv? '(fx> 12 12 12) #f))

(mat fx<=
     (fx<= 3 4)
     (not (fx<= 4 3))
     (fx<= 4 4)
     (fx<= -4 4)
     (not (fx<= 4 -4))
     (fx<= -4 -3)
     (not (fx<= -3 -4))
     (fx<= -4)
     (fx<= -4 -4)
     (fx<= -4 -4 -4)
     (error? (fx<= '(a . b)))
     (error? (fx<= (+ (most-positive-fixnum) 1) 3 2))
     (error? (fx<= (- (most-negative-fixnum) 1) 3))
     (guard (c [#t #t]) (fx<= 4 3 (error #f "oops")))
     (guard (c [#t #t]) (fx<= 4 (error #f "oops") 3))
     (guard (c [#t #t]) (fx<= (error #f "oops") 4 3))
     (guard (c [#t #t]) (not (fx<= (error #f "oops"))))
     (test-cp0-expansion eqv? '(fx<= -3 -7) #f)
     (test-cp0-expansion eqv? '(fx<= -3 0) #t)
     (test-cp0-expansion eqv? '(fx<= 0 -3) #f)
     (test-cp0-expansion eqv? '(fx<= 0 0) #t)
     (test-cp0-expansion eqv? '(fx<= -3 -3) #t)
     (test-cp0-expansion eqv? '(fx<= 12 12) #t)
     (test-cp0-expansion eqv? '(fx<= -3 -7 -7) #f)
     (test-cp0-expansion eqv? '(fx<= -3 -2 0) #t)
     (test-cp0-expansion eqv? '(fx<= 0 -2 -3) #f)
     (test-cp0-expansion eqv? '(fx<= -3 -3 0) #t)
     (test-cp0-expansion eqv? '(fx<= 0 -3 0) #f)
     (test-cp0-expansion eqv? '(fx<= 0 0 0) #t)
     (test-cp0-expansion eqv? '(fx<= -3 -3 -3) #t)
     (test-cp0-expansion eqv? '(fx<= 12 12 12) #t))

(mat fx>=
     (not (fx>= 3 4))
     (fx>= 4 3)
     (fx>= 4 4)
     (not (fx>= -4 4))
     (fx>= 4 -4)
     (not (fx>= -4 -3))
     (fx>= -3 -4)
     (fx>= -4)
     (fx>= -4 -4)
     (fx>= -4 -4 -4)
     (error? (fx>= '(a . b)))
     (error? (fx>= (+ (most-positive-fixnum) 1) 3 2))
     (error? (fx>= (- (most-negative-fixnum) 1) 3))
     (guard (c [#t #t]) (fx>= 3 4 (error #f "oops")))
     (guard (c [#t #t]) (fx>= 3 (error #f "oops") 4))
     (guard (c [#t #t]) (fx>= (error #f "oops") 3 4))
     (guard (c [#t #t]) (not (fx<= (error #f "oops"))))
     (test-cp0-expansion eqv? '(fx>= -3 -7) #t)
     (test-cp0-expansion eqv? '(fx>= -3 0) #f)
     (test-cp0-expansion eqv? '(fx>= 0 -3) #t)
     (test-cp0-expansion eqv? '(fx>= 0 0) #t)
     (test-cp0-expansion eqv? '(fx>= -3 -3) #t)
     (test-cp0-expansion eqv? '(fx>= 12 12) #t)
     (test-cp0-expansion eqv? '(fx>= -3 -7 -7) #t)
     (test-cp0-expansion eqv? '(fx>= -3 -2 0) #f)
     (test-cp0-expansion eqv? '(fx>= 0 -2 -3) #t)
     (test-cp0-expansion eqv? '(fx>= -3 -3 0) #f)
     (test-cp0-expansion eqv? '(fx>= 0 -3 0) #f)
     (test-cp0-expansion eqv? '(fx>= 0 0 0) #t)
     (test-cp0-expansion eqv? '(fx>= -3 -3 -3) #t)
     (test-cp0-expansion eqv? '(fx>= 12 12 12) #t))

(mat fx=?
     (not (fx=? 3 4))
     (not (fx=? 4 3))
     (fx=? 4 4)
     (not (fx=? -4 4))
     (not (fx=? 4 -4))
     (not (fx=? -4 -3))
     (not (fx=? -3 -4))
     (fx=? -4 -4)
     (fx=? -4 -4 -4)
     (error? (fx=? (list 'a) 3))
     (error? (fx=? (+ (greatest-fixnum) 1) 3 2))
     (error? (fx=? (- (least-fixnum) 1) 3))
     (error? (fx=? 1))
     (fx=? (least-fixnum) (- (expt 2 (- (fixnum-width) 1))))
     (fx=? (greatest-fixnum) (- (expt 2 (- (fixnum-width) 1)) 1))
     (guard (c [#t #t]) (fx=? 3 4 (error #f "oops")))
     (guard (c [#t #t]) (fx=? 3 (error #f "oops") 4))
     (guard (c [#t #t]) (fx=? (error #f "oops") 3 4))
     (guard (c [#t #t]) (not (fx=? (error #f "oops"))))
     (test-cp0-expansion eqv? '(fx=? -3 -7) #f)
     (test-cp0-expansion eqv? '(fx=? -3 0) #f)
     (test-cp0-expansion eqv? '(fx=? 0 -3) #f)
     (test-cp0-expansion eqv? '(fx=? 0 0) #t)
     (test-cp0-expansion eqv? '(fx=? -3 -3) #t)
     (test-cp0-expansion eqv? '(fx=? 12 12) #t)
     (test-cp0-expansion eqv? '(fx=? -3 -7 -7) #f)
     (test-cp0-expansion eqv? '(fx=? -3 -3 0) #f)
     (test-cp0-expansion eqv? '(fx=? 0 -3 0) #f)
     (test-cp0-expansion eqv? '(fx=? 0 0 0) #t)
     (test-cp0-expansion eqv? '(fx=? -3 -3 -3) #t)
     (test-cp0-expansion eqv? '(fx=? 12 12 12) #t))

(mat fx<?
     (fx<? 3 4)
     (not (fx<? 4 3))
     (not (fx<? 4 4))
     (fx<? -4 4)
     (not (fx<? 4 -4))
     (fx<? -4 -3)
     (not (fx<? -3 -4))
     (not (fx<? -4 -4))
     (not (fx<? -4 -4))
     (not (fx<? -4 -4 -4))
     (error? (fx<? 'a 3))
     (error? (fx<? (+ (greatest-fixnum) 1) 3 2))
     (error? (fx<? (- (least-fixnum) 1) 3))
     (error? (fx<? 1))
     (guard (c [#t #t]) (fx<? 4 3 (error #f "oops")))
     (guard (c [#t #t]) (fx<? 4 (error #f "oops") 3))
     (guard (c [#t #t]) (fx<? (error #f "oops") 4 3))
     (guard (c [#t #t]) (not (fx<? (error #f "oops"))))
     (test-cp0-expansion eqv? '(fx<? -3 -7) #f)
     (test-cp0-expansion eqv? '(fx<? -3 0) #t)
     (test-cp0-expansion eqv? '(fx<? 0 -3) #f)
     (test-cp0-expansion eqv? '(fx<? 0 0) #f)
     (test-cp0-expansion eqv? '(fx<? -3 -3) #f)
     (test-cp0-expansion eqv? '(fx<? 12 12) #f)
     (test-cp0-expansion eqv? '(fx<? -3 -7 -7) #f)
     (test-cp0-expansion eqv? '(fx<? -3 -2 0) #t)
     (test-cp0-expansion eqv? '(fx<? 0 -2 -3) #f)
     (test-cp0-expansion eqv? '(fx<? -3 -3 0) #f)
     (test-cp0-expansion eqv? '(fx<? 0 -3 0) #f)
     (test-cp0-expansion eqv? '(fx<? 0 0 0) #f)
     (test-cp0-expansion eqv? '(fx<? -3 -3 -3) #f)
     (test-cp0-expansion eqv? '(fx<? 12 12 12) #f))

(mat fx>?
     (not (fx>? 3 4))
     (fx>? 4 3)
     (not (fx>? 4 4))
     (not (fx>? -4 4))
     (fx>? 4 -4)
     (not (fx>? -4 -3))
     (fx>? -3 -4)
     (not (fx>? -4 -4))
     (not (fx>? -4 -4 -4))
     (error? (fx>? 3 "hi"))
     (error? (fx>? (+ (greatest-fixnum) 1) 3 2))
     (error? (fx>? (- (least-fixnum) 1) 3))
     (error? (fx>? 1))
     (guard (c [#t #t]) (fx>? 3 4 (error #f "oops")))
     (guard (c [#t #t]) (fx>? 3 (error #f "oops") 4))
     (guard (c [#t #t]) (fx>? (error #f "oops") 3 4))
     (guard (c [#t #t]) (not (fx>? (error #f "oops"))))
     (test-cp0-expansion eqv? '(fx>? -3 -7) #t)
     (test-cp0-expansion eqv? '(fx>? -3 0) #f)
     (test-cp0-expansion eqv? '(fx>? 0 -3) #t)
     (test-cp0-expansion eqv? '(fx>? 0 0) #f)
     (test-cp0-expansion eqv? '(fx>? -3 -3) #f)
     (test-cp0-expansion eqv? '(fx>? 12 12) #f)
     (test-cp0-expansion eqv? '(fx>? -3 -7 -7) #f)
     (test-cp0-expansion eqv? '(fx>? -3 -2 0) #f)
     (test-cp0-expansion eqv? '(fx>? 0 -2 -3) #t)
     (test-cp0-expansion eqv? '(fx>? -3 -3 0) #f)
     (test-cp0-expansion eqv? '(fx>? 0 -3 0) #f)
     (test-cp0-expansion eqv? '(fx>? 0 0 0) #f)
     (test-cp0-expansion eqv? '(fx>? -3 -3 -3) #f)
     (test-cp0-expansion eqv? '(fx>? 12 12 12) #f))

(mat fx<=?
     (fx<=? 3 4)
     (not (fx<=? 4 3))
     (fx<=? 4 4)
     (fx<=? -4 4)
     (not (fx<=? 4 -4))
     (fx<=? -4 -3)
     (not (fx<=? -3 -4))
     (fx<=? -4 -4)
     (fx<=? -4 -4 -4)
     (error? (fx<=? 3 '(a . b)))
     (error? (fx<=? (+ (greatest-fixnum) 1) 3 2))
     (error? (fx<=? (- (least-fixnum) 1) 3))
     (error? (fx<=? 1))
     (guard (c [#t #t]) (fx<=? 4 3 (error #f "oops")))
     (guard (c [#t #t]) (fx<=? 4 (error #f "oops") 3))
     (guard (c [#t #t]) (fx<=? (error #f "oops") 4 3))
     (guard (c [#t #t]) (not (fx<=? (error #f "oops"))))
     (test-cp0-expansion eqv? '(fx<=? -3 -7) #f)
     (test-cp0-expansion eqv? '(fx<=? -3 0) #t)
     (test-cp0-expansion eqv? '(fx<=? 0 -3) #f)
     (test-cp0-expansion eqv? '(fx<=? 0 0) #t)
     (test-cp0-expansion eqv? '(fx<=? -3 -3) #t)
     (test-cp0-expansion eqv? '(fx<=? 12 12) #t)
     (test-cp0-expansion eqv? '(fx<=? -3 -7 -7) #f)
     (test-cp0-expansion eqv? '(fx<=? -3 -2 0) #t)
     (test-cp0-expansion eqv? '(fx<=? 0 -2 -3) #f)
     (test-cp0-expansion eqv? '(fx<=? -3 -3 0) #t)
     (test-cp0-expansion eqv? '(fx<=? 0 -3 0) #f)
     (test-cp0-expansion eqv? '(fx<=? 0 0 0) #t)
     (test-cp0-expansion eqv? '(fx<=? -3 -3 -3) #t)
     (test-cp0-expansion eqv? '(fx<=? 12 12 12) #t))

(mat fx>=?
     (not (fx>=? 3 4))
     (fx>=? 4 3)
     (fx>=? 4 4)
     (not (fx>=? -4 4))
     (fx>=? 4 -4)
     (not (fx>=? -4 -3))
     (fx>=? -3 -4)
     (fx>=? -4 -4)
     (fx>=? -4 -4 -4)
     (error? (fx>=? 3 '(a . b)))
     (error? (fx>=? (+ (greatest-fixnum) 1) 3 2))
     (error? (fx>=? (- (least-fixnum) 1) 3))
     (error? (fx>=? 1))
     (guard (c [#t #t]) (fx>=? 3 4 (error #f "oops")))
     (guard (c [#t #t]) (fx>=? 3 (error #f "oops") 4))
     (guard (c [#t #t]) (fx>=? (error #f "oops") 3 4))
     (guard (c [#t #t]) (not (fx>=? (error #f "oops"))))
     (test-cp0-expansion eqv? '(fx>=? -3 -7) #t)
     (test-cp0-expansion eqv? '(fx>=? -3 0) #f)
     (test-cp0-expansion eqv? '(fx>=? 0 -3) #t)
     (test-cp0-expansion eqv? '(fx>=? 0 0) #t)
     (test-cp0-expansion eqv? '(fx>=? -3 -3) #t)
     (test-cp0-expansion eqv? '(fx>=? 12 12) #t)
     (test-cp0-expansion eqv? '(fx>=? -3 -7 -7) #t)
     (test-cp0-expansion eqv? '(fx>=? -3 -2 0) #f)
     (test-cp0-expansion eqv? '(fx>=? 0 -2 -3) #t)
     (test-cp0-expansion eqv? '(fx>=? -3 -3 0) #f)
     (test-cp0-expansion eqv? '(fx>=? 0 -3 0) #f)
     (test-cp0-expansion eqv? '(fx>=? 0 0 0) #t)
     (test-cp0-expansion eqv? '(fx>=? -3 -3 -3) #t)
     (test-cp0-expansion eqv? '(fx>=? 12 12 12) #t))

(mat $fxu<
     (#%$fxu< 3 7)
     (#%$fxu< 3 -7)
     (not (#%$fxu< -3 -7))
     (not (#%$fxu< -3 7))
     (not (#%$fxu< -3 -3))
     (not (#%$fxu< 3 3))
     (not (#%$fxu< 0 0))
     (not (#%$fxu< -3 0))
     (#%$fxu< 0 -3)
     (not (#%$fxu< 3 0))
     (#%$fxu< 0 3)
     (error? (#%$fxu< 'a))
     (error? (#%$fxu< (+ (most-positive-fixnum) 1) 3 2))
     (error? (#%$fxu< (- (most-negative-fixnum) 1) 3))
     (guard (c [#t #t]) (#%$fxu< 4 3 (error #f "oops")))
     (guard (c [#t #t]) (#%$fxu< 4 (error #f "oops") 3))
     (guard (c [#t #t]) (#%$fxu< (error #f "oops") 4 3))
     (guard (c [#t #t]) (not (#%$fxu< (error #f "oops"))))
     (test-cp0-expansion eqv? '(#%$fxu< -3 -7) #f)
     (test-cp0-expansion eqv? '(#%$fxu< -3 0) #f)
     (test-cp0-expansion eqv? '(#%$fxu< 0 -3) #t))

(mat fx+
     (eqv? (fx+ 3 0) 3)
     (eqv? (fx+ 3 1) 4)
     (eqv? (fx+ 3 4) 7)
     (eqv? (fx+ -3 4) 1)
     (eqv? (fx+ 3 -4) -1)
     (eqv? (fx+ 3 -3) 0)
     (eqv? (fx+ 3 3) 6)
     (eqv? (fx+) 0)
     (eqv? (fx+ 3) 3)
     (eqv? (fx+ 3 4 5) 12)
     (error? (fx+ '(a . b)))
     (error? (fx+ (most-positive-fixnum) 1))
     (error? (fx+ (+ (most-positive-fixnum) 1) 3 2))
     (error? (fx+ (- (most-negative-fixnum) 1) 3))
     ; test for bug introduced temporarily into 4.1q
     (eqv? (let* ((f (lambda (x) x)) (g (lambda (x) (f (fx+ x 1))))) (g 2))
           3)
     (eqv? (let* ((f (lambda (x) x)) (g (lambda (x) (f (fx+ 1 x))))) (g 2))
           3)
     (eqv? (let* ((f (lambda (x) x)) (g (lambda (x) (f (fx+ x x))))) (g 2))
           4)
     (eqv? (let* ((f (lambda (x) x)) (g (lambda (x) (f (fx+ (f x) 1)))))
             (g 2))
           3)
     (eqv? (let* ((f (lambda (x) x)) (g (lambda (x) (f (fx+ 1 (f x))))))
             (g 2))
           3)
     ; test for bug introduced into 4.1s or before & fixed in 4.1v
     (eqv? (let ([f (lambda (n)
                      (do ((i 0 (fx+ i 1))) ((fx= i n)) (fx+ i 1)))])
             (f 1000))
           (void))
     (error? ; oops
       (fx+ 'a 'b (error #f "oops")))
     (error? ; oops
       (fx+ 'a (error #f "oops") 'c))
     (error? ; oops
       (fx+ (error #f "oops") 'b 'c))
     (error? ; #f is not a fixnum
             (fx+ 3 #f))
     (error? ; #f is not a fixnum
             (fx+ #f 3))
     (test-cp0-expansion eqv? '(fx+ 3 0) 3)
     (test-cp0-expansion eqv? '(fx+ 3 1) 4)
     (test-cp0-expansion eqv? '(fx+ 3 4) 7)
     (test-cp0-expansion eqv? '(fx+ -3 4) 1)
     (test-cp0-expansion eqv? '(fx+ 3 -4) -1)
     (test-cp0-expansion eqv? '(fx+ 3 -3) 0)
     (test-cp0-expansion eqv? '(fx+ 3 3) 6)
     (test-cp0-expansion eqv? '(fx+) 0)
     (test-cp0-expansion eqv? '(fx+ 3) 3)
     (test-cp0-expansion eqv? '(fx+ 3 4 5) 12))

(mat r6rs:fx+
     (eqv? (r6rs:fx+ 3 0) 3)
     (eqv? (r6rs:fx+ 3 1) 4)
     (eqv? (r6rs:fx+ 3 4) 7)
     (eqv? (r6rs:fx+ -3 4) 1)
     (eqv? (r6rs:fx+ 3 -4) -1)
     (eqv? (r6rs:fx+ 3 -3) 0)
     (eqv? (r6rs:fx+ 3 3) 6)
     (error? (r6rs:fx+ '(a . b) 3))
     (error? (r6rs:fx+ (greatest-fixnum) 1))
     (error? (r6rs:fx+ (+ (greatest-fixnum) 1) 3))
     (error? (r6rs:fx+ (- (least-fixnum) 1) 3))
     ; test for bug introduced temporarily into 4.1q
     (eqv? (let* ((f (lambda (x) x)) (g (lambda (x) (f (r6rs:fx+ x 1)))))
             (g 2))
           3)
     (eqv? (let* ((f (lambda (x) x)) (g (lambda (x) (f (r6rs:fx+ 1 x)))))
             (g 2))
           3)
     (eqv? (let* ((f (lambda (x) x)) (g (lambda (x) (f (r6rs:fx+ x x)))))
             (g 2))
           4)
     (eqv? (let* ((f (lambda (x) x))
                  (g (lambda (x) (f (r6rs:fx+ (f x) 1)))))
             (g 2))
           3)
     (eqv? (let* ((f (lambda (x) x))
                  (g (lambda (x) (f (r6rs:fx+ 1 (f x))))))
             (g 2))
           3)
     ; test for bug introduced into 4.1s or before & fixed in 4.1v
     (eqv? (let ([f (lambda (n)
                      (do ((i 0 (r6rs:fx+ i 1)))
                          ((fx= i n))
                          (r6rs:fx+ i 1)))])
             (f 1000))
           (void))
     (error? ; #f is not a fixnum
             (fx+ 3 #f))
     (error? ; #f is not a fixnum
             (fx+ #f 3))
     (test-cp0-expansion eqv? '(r6rs:fx+ 3 0) 3)
     (test-cp0-expansion eqv? '(r6rs:fx+ 3 1) 4)
     (test-cp0-expansion eqv? '(r6rs:fx+ 3 4) 7)
     (test-cp0-expansion eqv? '(r6rs:fx+ -3 4) 1)
     (test-cp0-expansion eqv? '(r6rs:fx+ 3 -4) -1)
     (test-cp0-expansion eqv? '(r6rs:fx+ 3 -3) 0)
     (test-cp0-expansion eqv? '(r6rs:fx+ 3 3) 6))

(mat fx-
     (eqv? (fx- 3 0) 3)
     (eqv? (fx- 3 1) 2)
     (eqv? (fx- 3 4) -1)
     (eqv? (fx- -3 4) -7)
     (eqv? (fx- 3 -4) 7)
     (eqv? (fx- 3 -3) 6)
     (eqv? (fx- 3 3) 0)
     (eqv? (fx- 3) -3)
     (eqv? (fx- 3 4 5) -6)
     (error? (fx- '(a . b)))
     (error? (fx- (most-negative-fixnum) 1))
     (error? (fx- (+ (most-positive-fixnum) 1) 3 2))
     (error? (fx- (- (most-negative-fixnum) 1) 3))
     ; test for bug introduced temporarily into 4.1q
     (eqv? (let* ((f (lambda (x) x)) (g (lambda (x) (f (fx- x 1))))) (g 2))
           1)
     (eqv? (let* ((f (lambda (x) x)) (g (lambda (x) (f (fx- 1 x))))) (g 2))
           -1)
     (eqv? (let* ((f (lambda (x) x)) (g (lambda (x) (f (fx- x x))))) (g 2))
           0)
     (eqv? (let* ((f (lambda (x) x)) (g (lambda (x) (f (fx- (f x) 1)))))
             (g 2))
           1)
     (eqv? (let* ((f (lambda (x) x)) (g (lambda (x) (f (fx- 1 (f x))))))
             (g 2))
           -1)
     (error? ; #f is not a fixnum
             (fx- 3 #f))
     (error? ; #f is not a fixnum
             (fx- #f 3))
     (test-cp0-expansion eqv? '(fx- 3 0) 3)
     (test-cp0-expansion eqv? '(fx- 3 1) 2)
     (test-cp0-expansion eqv? '(fx- 3 4) -1)
     (test-cp0-expansion eqv? '(fx- -3 4) -7)
     (test-cp0-expansion eqv? '(fx- 3 -4) 7)
     (test-cp0-expansion eqv? '(fx- 3 -3) 6)
     (test-cp0-expansion eqv? '(fx- 3 3) 0)
     (test-cp0-expansion eqv? '(fx- 3) -3)
     (test-cp0-expansion eqv? '(fx- 3 4 5) -6))

(mat r6rs:fx-
     (eqv? (r6rs:fx- 3 0) 3)
     (eqv? (r6rs:fx- 3 1) 2)
     (eqv? (r6rs:fx- 3 4) -1)
     (eqv? (r6rs:fx- -3 4) -7)
     (eqv? (r6rs:fx- 3 -4) 7)
     (eqv? (r6rs:fx- 3 -3) 6)
     (eqv? (r6rs:fx- 3 3) 0)
     (eqv? (r6rs:fx- 3) -3)
     (error? (r6rs:fx- '(a . b)))
     (error? (r6rs:fx- (least-fixnum) 1))
     (error? (r6rs:fx- (+ (greatest-fixnum) 1) 3))
     (error? (r6rs:fx- (- (least-fixnum) 1) 3))
     ; test for bug introduced temporarily into 4.1q
     (eqv? (let* ((f (lambda (x) x)) (g (lambda (x) (f (r6rs:fx- x 1)))))
             (g 2))
           1)
     (eqv? (let* ((f (lambda (x) x)) (g (lambda (x) (f (r6rs:fx- 1 x)))))
             (g 2))
           -1)
     (eqv? (let* ((f (lambda (x) x)) (g (lambda (x) (f (r6rs:fx- x x)))))
             (g 2))
           0)
     (eqv? (let* ((f (lambda (x) x))
                  (g (lambda (x) (f (r6rs:fx- (f x) 1)))))
             (g 2))
           1)
     (eqv? (let* ((f (lambda (x) x))
                  (g (lambda (x) (f (r6rs:fx- 1 (f x))))))
             (g 2))
           -1)
     (error? ; #f is not a fixnum
             (fx- 3 #f))
     (error? ; #f is not a fixnum
             (fx- #f 3))
     (test-cp0-expansion eqv? '(r6rs:fx- 3 0) 3)
     (test-cp0-expansion eqv? '(r6rs:fx- 3 1) 2)
     (test-cp0-expansion eqv? '(r6rs:fx- 3 4) -1)
     (test-cp0-expansion eqv? '(r6rs:fx- -3 4) -7)
     (test-cp0-expansion eqv? '(r6rs:fx- 3 -4) 7)
     (test-cp0-expansion eqv? '(r6rs:fx- 3 -3) 6)
     (test-cp0-expansion eqv? '(r6rs:fx- 3 3) 0)
     (test-cp0-expansion eqv? '(r6rs:fx- 3) -3))

(mat fx*
     (eqv? (fx* 3 0) 0)
     (eqv? (fx* 3 1) 3)
     (eqv? (fx* 3 4) 12)
     (eqv? (fx* -3 4) -12)
     (eqv? (fx* 3 -4) -12)
     (eqv? (fx* 3 -3) -9)
     (eqv? (fx* 3 3) 9)
     (eqv? (fx*) 1)
     (eqv? (fx* 3) 3)
     (eqv? (fx* 3 4 5) 60)
     (error? (fx* '(a . b)))
     (error? (fx* (most-positive-fixnum) 2))
     (error? (fx* (+ (most-positive-fixnum) 1) 3 2))
     (error? (fx* (- (most-negative-fixnum) 1) 3))
     (error? ; #f is not a fixnum
             (fx* 3 #f))
     (error? ; #f is not a fixnum
             (fx* #f 3))
     (test-cp0-expansion eqv? '(fx* 3 0) 0)
     (test-cp0-expansion eqv? '(fx* 3 1) 3)
     (test-cp0-expansion eqv? '(fx* 3 4) 12)
     (test-cp0-expansion eqv? '(fx* -3 4) -12)
     (test-cp0-expansion eqv? '(fx* 3 -4) -12)
     (test-cp0-expansion eqv? '(fx* 3 -3) -9)
     (test-cp0-expansion eqv? '(fx* 3 3) 9)
     (test-cp0-expansion eqv? '(fx*) 1)
     (test-cp0-expansion eqv? '(fx* 3) 3)
     (test-cp0-expansion eqv? '(fx* 3 4 5) 60))

(mat r6rs:fx*
     (eqv? (r6rs:fx* 3 0) 0)
     (eqv? (r6rs:fx* 3 1) 3)
     (eqv? (r6rs:fx* 3 4) 12)
     (eqv? (r6rs:fx* -3 4) -12)
     (eqv? (r6rs:fx* 3 -4) -12)
     (eqv? (r6rs:fx* 3 -3) -9)
     (eqv? (r6rs:fx* 3 3) 9)
     (error? (r6rs:fx* 3 '(a . b)))
     (error? (r6rs:fx* (greatest-fixnum) 2))
     (error? (r6rs:fx* (+ (greatest-fixnum) 1) 3))
     (error? (r6rs:fx* (- (least-fixnum) 1) 3))
     (error? ; #f is not a fixnum
             (fx* 3 #f))
     (error? ; #f is not a fixnum
             (fx* #f 3))
     (test-cp0-expansion eqv? '(r6rs:fx* 3 0) 0)
     (test-cp0-expansion eqv? '(r6rs:fx* 3 1) 3)
     (test-cp0-expansion eqv? '(r6rs:fx* 3 4) 12)
     (test-cp0-expansion eqv? '(r6rs:fx* -3 4) -12)
     (test-cp0-expansion eqv? '(r6rs:fx* 3 -4) -12)
     (test-cp0-expansion eqv? '(r6rs:fx* 3 -3) -9)
     (test-cp0-expansion eqv? '(r6rs:fx* 3 3) 9))

(mat fxquotient
     (eqv? (fxquotient 3 1) 3)
     (eqv? (fxquotient 3 4) 0)
     (eqv? (fxquotient -4 3) -1)
     (eqv? (fxquotient 4 -3) -1)
     (eqv? (fxquotient 3 -3) -1)
     (eqv? (fxquotient 3 3) 1)
     (eqv? (fxquotient 13 3) 4)
     (eqv? (fxquotient -13 3) -4)
     (eqv? (fxquotient 13 -3) -4)
     (eqv? (fxquotient -13 -3) 4)
     (eqv? (fxquotient 3) 0)
     (eqv? (fxquotient -3) 0)
     (eqv? (fxquotient 1) 1)
     (eqv? (fxquotient -1) -1)
     (eqv? (fxquotient 19 3 2) 3)
     (error? (fxquotient '(a . b)))
     (error? (fxquotient 0))
     (error? (fxquotient (+ (most-positive-fixnum) 1) 3 2))
     (error? (fxquotient (- (most-negative-fixnum) 1) 3))
     (error? (fxquotient (most-negative-fixnum) -1))
     (equal? (map (lambda (x) (fxquotient x 64))
                  '(0 5 31 32 33 63 64 65 127 128 129))
             '(0 0 0 0 0 0 1 1 1 2 2))
     (equal? (map (lambda (x) (fxquotient x 64))
                  '(0 -5 -31 -32 -33 -63 -64 -65 -127 -128 -129))
             '(0 0 0 0 0 0 -1 -1 -1 -2 -2))
     (test-cp0-expansion eqv? '(fxquotient 3 1) 3)
     (test-cp0-expansion eqv? '(fxquotient 3 4) 0)
     (test-cp0-expansion eqv? '(fxquotient -4 3) -1)
     (test-cp0-expansion eqv? '(fxquotient 4 -3) -1)
     (test-cp0-expansion eqv? '(fxquotient 3 -3) -1)
     (test-cp0-expansion eqv? '(fxquotient 3 3) 1)
     (test-cp0-expansion eqv? '(fxquotient 13 3) 4)
     (test-cp0-expansion eqv? '(fxquotient -13 3) -4)
     (test-cp0-expansion eqv? '(fxquotient 13 -3) -4)
     (test-cp0-expansion eqv? '(fxquotient -13 -3) 4)
     (test-cp0-expansion eqv? '(fxquotient 3) 0)
     (test-cp0-expansion eqv? '(fxquotient -3) 0)
     (test-cp0-expansion eqv? '(fxquotient 1) 1)
     (test-cp0-expansion eqv? '(fxquotient -1) -1)
     (test-cp0-expansion eqv? '(fxquotient 19 3 2) 3))

(mat fx/
     (eqv? (fx/ 3 1) 3)
     (eqv? (fx/ 3 4) 0)
     (eqv? (fx/ -4 3) -1)
     (eqv? (fx/ 4 -3) -1)
     (eqv? (fx/ 3 -3) -1)
     (eqv? (fx/ 3 3) 1)
     (eqv? (fx/ 13 3) 4)
     (eqv? (fx/ -13 3) -4)
     (eqv? (fx/ 13 -3) -4)
     (eqv? (fx/ -13 -3) 4)
     (eqv? (fx/ -13 4) -3)
     (eqv? (fx/ 3) 0)
     (eqv? (fx/ -3) 0)
     (eqv? (fx/ 1) 1)
     (eqv? (fx/ -1) -1)
     (eqv? (fx/ 19 3 2) 3)
     (error? (fx/ '(a . b)))
     (error? (fx/ 0))
     (error? (fx/ (+ (most-positive-fixnum) 1) 3 2))
     (error? (fx/ (- (most-negative-fixnum) 1) 3))
     (error? (fx/ (most-negative-fixnum) -1))
     (equal? (map (lambda (x) (fx/ x 64))
                  '(0 5 31 32 33 63 64 65 127 128 129))
             '(0 0 0 0 0 0 1 1 1 2 2))
     (equal? (map (lambda (x) (fx/ x 64))
                  '(0 -5 -31 -32 -33 -63 -64 -65 -127 -128 -129))
             '(0 0 0 0 0 0 -1 -1 -1 -2 -2))
     (test-cp0-expansion eqv? '(fx/ 3 1) 3)
     (test-cp0-expansion eqv? '(fx/ 3 4) 0)
     (test-cp0-expansion eqv? '(fx/ -4 3) -1)
     (test-cp0-expansion eqv? '(fx/ 4 -3) -1)
     (test-cp0-expansion eqv? '(fx/ 3 -3) -1)
     (test-cp0-expansion eqv? '(fx/ 3 3) 1)
     (test-cp0-expansion eqv? '(fx/ 13 3) 4)
     (test-cp0-expansion eqv? '(fx/ -13 3) -4)
     (test-cp0-expansion eqv? '(fx/ 13 -3) -4)
     (test-cp0-expansion eqv? '(fx/ -13 -3) 4)
     (test-cp0-expansion eqv? '(fx/ -13 4) -3)
     (test-cp0-expansion eqv? '(fx/ 3) 0)
     (test-cp0-expansion eqv? '(fx/ -3) 0)
     (test-cp0-expansion eqv? '(fx/ 1) 1)
     (test-cp0-expansion eqv? '(fx/ -1) -1)
     (test-cp0-expansion eqv? '(fx/ 19 3 2) 3))

(mat fxzero?
     (fxzero? 0)
     (not (fxzero? 1))
     (not (fxzero? -1))
     (not (fxzero? (most-positive-fixnum)))
     (not (fxzero? (most-negative-fixnum)))
     (error? (fxzero? 'a))
     (error? (fxzero? (+ (most-positive-fixnum) 1)))
     (error? (fxzero? (- (most-negative-fixnum) 1)))
     (test-cp0-expansion eqv? '(fxzero? 0) #t)
     (test-cp0-expansion eqv? '(not (fxzero? 1)) #t)
     (test-cp0-expansion eqv? '(not (fxzero? -1)) #t)
     (test-cp0-expansion eqv? '(not (fxzero? (most-positive-fixnum))) #t)
     (test-cp0-expansion eqv? '(not (fxzero? (most-negative-fixnum))) #t))

(mat fxpositive?
     (not (fxpositive? 0))
     (fxpositive? 1)
     (not (fxpositive? -1))
     (fxpositive? (most-positive-fixnum))
     (not (fxpositive? (most-negative-fixnum)))
     (error? (fxpositive? 'a))
     (error? (fxpositive? (+ (most-positive-fixnum) 1)))
     (error? (fxpositive? (- (most-negative-fixnum) 1)))
     (test-cp0-expansion eqv? '(not (fxpositive? 0)) #t)
     (test-cp0-expansion eqv? '(fxpositive? 1) #t)
     (test-cp0-expansion eqv? '(not (fxpositive? -1)) #t)
     (test-cp0-expansion eqv? '(fxpositive? (most-positive-fixnum)) #t)
     (test-cp0-expansion eqv?
       '(not (fxpositive? (most-negative-fixnum)))
       #t))

(mat fxnonpositive?
     (fxnonpositive? 0)
     (not (fxnonpositive? 1))
     (fxnonpositive? -1)
     (not (fxnonpositive? (most-positive-fixnum)))
     (fxnonpositive? (most-negative-fixnum))
     (error? (fxnonpositive? 'a))
     (error? (fxnonpositive? (+ (most-positive-fixnum) 1)))
     (error? (fxnonpositive? (- (most-negative-fixnum) 1)))
     (test-cp0-expansion eqv? '(fxnonpositive? 0) #t)
     (test-cp0-expansion eqv? '(not (fxnonpositive? 1)) #t)
     (test-cp0-expansion eqv? '(fxnonpositive? -1) #t)
     (test-cp0-expansion eqv?
       '(not (fxnonpositive? (most-positive-fixnum)))
       #t)
     (test-cp0-expansion eqv? '(fxnonpositive? (most-negative-fixnum)) #t))

(mat fxnegative?
     (not (fxnegative? 0))
     (not (fxnegative? 1))
     (fxnegative? -1)
     (not (fxnegative? (most-positive-fixnum)))
     (fxnegative? (most-negative-fixnum))
     (error? (fxnegative? 'a))
     (error? (fxnegative? (+ (most-positive-fixnum) 1)))
     (error? (fxnegative? (- (most-negative-fixnum) 1)))
     (test-cp0-expansion eqv? '(not (fxnegative? 0)) #t)
     (test-cp0-expansion eqv? '(not (fxnegative? 1)) #t)
     (test-cp0-expansion eqv? '(fxnegative? -1) #t)
     (test-cp0-expansion eqv?
       '(not (fxnegative? (most-positive-fixnum)))
       #t)
     (test-cp0-expansion eqv? '(fxnegative? (most-negative-fixnum)) #t))

(mat fxnonnegative?
     (fxnonnegative? 0)
     (fxnonnegative? 1)
     (not (fxnonnegative? -1))
     (fxnonnegative? (most-positive-fixnum))
     (not (fxnonnegative? (most-negative-fixnum)))
     (error? (fxnonnegative? 'a))
     (error? (fxnonnegative? (+ (most-positive-fixnum) 1)))
     (error? (fxnonnegative? (- (most-negative-fixnum) 1)))
     (test-cp0-expansion eqv? '(fxnonnegative? 0) #t)
     (test-cp0-expansion eqv? '(fxnonnegative? 1) #t)
     (test-cp0-expansion eqv? '(not (fxnonnegative? -1)) #t)
     (test-cp0-expansion eqv? '(fxnonnegative? (most-positive-fixnum)) #t)
     (test-cp0-expansion eqv?
       '(not (fxnonnegative? (most-negative-fixnum)))
       #t))

(mat fxodd?
     (not (fxodd? 0))
     (fxodd? 1)
     (not (fxodd? 2))
     (fxodd? -1)
     (not (fxodd? -2))
     (fxodd? (most-positive-fixnum))
     (not (fxodd? (most-negative-fixnum)))
     (error? (fxodd? 'a))
     (error? (fxodd? (+ (most-positive-fixnum) 1)))
     (error? (fxodd? (- (most-negative-fixnum) 1)))
     (test-cp0-expansion eqv? '(not (fxodd? 0)) #t)
     (test-cp0-expansion eqv? '(fxodd? 1) #t)
     (test-cp0-expansion eqv? '(not (fxodd? 2)) #t)
     (test-cp0-expansion eqv? '(fxodd? -1) #t)
     (test-cp0-expansion eqv? '(not (fxodd? -2)) #t)
     (test-cp0-expansion eqv? '(fxodd? (most-positive-fixnum)) #t)
     (test-cp0-expansion eqv? '(not (fxodd? (most-negative-fixnum))) #t))

(mat fxeven?
     (fxeven? 0)
     (not (fxeven? 1))
     (fxeven? 2)
     (not (fxeven? -1))
     (fxeven? -2)
     (not (fxeven? (most-positive-fixnum)))
     (fxeven? (most-negative-fixnum))
     (error? (fxeven? 'a))
     (error? (fxeven? (+ (most-positive-fixnum) 1)))
     (error? (fxeven? (- (most-negative-fixnum) 1)))
     (test-cp0-expansion eqv? '(fxeven? 0) #t)
     (test-cp0-expansion eqv? '(not (fxeven? 1)) #t)
     (test-cp0-expansion eqv? '(fxeven? 2) #t)
     (test-cp0-expansion eqv? '(not (fxeven? -1)) #t)
     (test-cp0-expansion eqv? '(fxeven? -2) #t)
     (test-cp0-expansion eqv? '(not (fxeven? (most-positive-fixnum))) #t)
     (test-cp0-expansion eqv? '(fxeven? (most-negative-fixnum)) #t))

(mat fxabs
     (eqv? (fxabs 0) 0)
     (eqv? (fxabs -1) 1)
     (eqv? (fxabs 1) 1)
     (eqv? (fxabs (most-positive-fixnum)) (most-positive-fixnum))
     (eqv? (fxabs (+ (most-negative-fixnum) 1)) (most-positive-fixnum))
     (error? (fxabs (most-negative-fixnum)))
     (error? (fxabs (+ (most-positive-fixnum) 1)))
     (error? (fxabs (- (most-negative-fixnum) 1)))
     (error? (fxabs "hi there"))
     (error? (fxabs 1.2))
     (error? (fxabs -1.2))
     (test-cp0-expansion eqv? '(fxabs 0) 0)
     (test-cp0-expansion eqv? '(fxabs 2) 2)
     (test-cp0-expansion eqv? '(fxabs -2) 2))

(mat fx1-
     (eqv? (fx1- 0) -1)
     (eqv? (fx1- 1) 0)
     (eqv? (fx1- -1) -2)
     (test-cp0-expansion eqv? '(fx1- 0) -1)
     (test-cp0-expansion eqv? '(fx1- 1) 0)
     (test-cp0-expansion eqv? '(fx1- -1) -2)
     (error? (fx1- (most-negative-fixnum)))
     (error? (fx1- (- (most-negative-fixnum) 1)))
     (error? (fx1- (+ (most-positive-fixnum) 1)))
     (error? (fx1- 'a)))

(mat fx1+
     (eqv? (fx1+ 0) 1)
     (eqv? (fx1+ 1) 2)
     (eqv? (fx1+ -1) 0)
     (test-cp0-expansion eqv? '(fx1+ 0) 1)
     (test-cp0-expansion eqv? '(fx1+ 1) 2)
     (test-cp0-expansion eqv? '(fx1+ -1) 0)
     (error? (fx1+ (most-positive-fixnum)))
     (error? (fx1+ (- (most-negative-fixnum) 1)))
     (error? (fx1+ (+ (most-positive-fixnum) 1)))
     (error? (fx1+ 'a))
     ; test for bug introduced into 4.1s or before & fixed in 4.1v
     (eqv? (let ([f (lambda (n)
                      (do ((i 0 (fx+ i 1))) ((fx= i n)) (fx1+ i)))])
             (f 1000))
           (void)))

(mat fxmin
     (error? (fxmin))
     (eqv? (fxmin -1) -1)
     (eqv? (fxmin -1 0) -1)
     (eqv? (fxmin 0 -1) -1)
     (eqv? (fxmin -1 1) -1)
     (eqv? (fxmin 1 -1) -1)
     (eqv? (fxmin 1 0 -1) -1)
     (eqv? (fxmin 1 (most-negative-fixnum) 0 -1) (most-negative-fixnum))
     (eqv? (fxmin 1 (most-positive-fixnum) 0 -1) -1)
     (error? (fxmin 'a 0 1))
     (error? (fxmin (+ (most-positive-fixnum) 1)))
     (error? (fxmin (- (most-negative-fixnum) 1) 0))
     (error? (fxmin 'a))
     (error? (fxmin 0 1 -2 1 'a))
     (test-cp0-expansion eqv? '(fxmin 0 1 2) 0)
     (test-cp0-expansion eqv? '(fxmin 2 1 0) 0)
     (test-cp0-expansion eqv? '(fxmin 0 2 1) 0))

(mat fxmax
     (error? (fxmax))
     (eqv? (fxmax -1) -1)
     (eqv? (fxmax -1 0) 0)
     (eqv? (fxmax 0 -1) 0)
     (eqv? (fxmax -1 1) 1)
     (eqv? (fxmax 1 -1) 1)
     (eqv? (fxmax 1 0 -1) 1)
     (eqv? (fxmax 1 (most-negative-fixnum) 0 -1) 1)
     (eqv? (fxmax 1 (most-positive-fixnum) 0 -1) (most-positive-fixnum))
     (error? (fxmax 'a 0 1))
     (error? (fxmax (+ (most-positive-fixnum) 1)))
     (error? (fxmax (- (most-negative-fixnum) 1) 0))
     (error? (fxmax 'a))
     (error? (fxmax 0 1 -2 1 'a))
     (test-cp0-expansion eqv? '(fxmax 0 1 2) 2)
     (test-cp0-expansion eqv? '(fxmax 2 1 0) 2)
     (test-cp0-expansion eqv? '(fxmax 0 2 1) 2))

(mat fxmodulo
     (eqv? (fxmodulo -7 2) 1)
     (eqv? (fxmodulo 5 3) 2)
     (eqv? (fxmodulo 5 -3) -1)
     (eqv? (fxmodulo -5 -3) -2)
     (error? (fxmodulo 'a 3))
     (error? (fxmodulo (+ (most-positive-fixnum) 1) 3))
     (error? (fxmodulo (- (most-negative-fixnum) 1) 3))
     (error? (fxmodulo 7 0))
     (equal? (map (lambda (x) (fxmodulo x 64))
                  '(0 5 31 32 33 63 64 65 127 128 129))
             '(0 5 31 32 33 63 0 1 63 0 1))
     (equal? (map (lambda (x) (fxmodulo x 64))
                  '(0 -5 -31 -32 -33 -63 -64 -65 -127 -128 -129))
             '(0 59 33 32 31 1 0 63 1 0 63))
     (equal? (map (lambda (x)
                    (parameterize
                      ([optimize-level 2]
                       [enable-cp0 #t]
                       [#%$suppress-primitive-inlining #f])
                      (expand/optimize `(fxmodulo ,x 64))))
                  '(0 5 31 32 33 63 64 65 127 128 129))
             '(0 5 31 32 33 63 0 1 63 0 1))
     (equal? (map (lambda (x)
                    (parameterize
                      ([optimize-level 2]
                       [enable-cp0 #t]
                       [#%$suppress-primitive-inlining #f])
                      (expand/optimize `(fxmodulo ,x 64))))
                  '(0 -5 -31 -32 -33 -63 -64 -65 -127 -128 -129))
             '(0 59 33 32 31 1 0 63 1 0 63)))

(mat fxremainder
     (eqv? (fxremainder -7 2) -1)
     (eqv? (fxremainder 5 3) 2)
     (eqv? (fxremainder 5 -3) 2)
     (eqv? (fxremainder -5 -3) -2)
     (error? (fxremainder 'a 3))
     (error? (fxremainder (+ (most-positive-fixnum) 1) 3))
     (error? (fxremainder (- (most-negative-fixnum) 1) 3))
     (error? (fxremainder 7 0))
     (equal? (map (lambda (x) (fxremainder x 64))
                  '(0 5 31 32 33 63 64 65 127 128 129))
             '(0 5 31 32 33 63 0 1 63 0 1))
     (equal? (map (lambda (x) (fxremainder x 64))
                  '(0 -5 -31 -32 -33 -63 -64 -65 -127 -128 -129))
             '(0 -5 -31 -32 -33 -63 0 -1 -63 0 -1))
     (equal? (map (lambda (x)
                    (parameterize
                      ([optimize-level 2]
                       [enable-cp0 #t]
                       [#%$suppress-primitive-inlining #f])
                      (expand/optimize `(fxremainder ,x 64))))
                  '(0 5 31 32 33 63 64 65 127 128 129))
             '(0 5 31 32 33 63 0 1 63 0 1))
     (equal? (map (lambda (x)
                    (parameterize
                      ([optimize-level 2]
                       [enable-cp0 #t]
                       [#%$suppress-primitive-inlining #f])
                      (expand/optimize `(fxremainder ,x 64))))
                  '(0 -5 -31 -32 -33 -63 -64 -65 -127 -128 -129))
             '(0 -5 -31 -32 -33 -63 0 -1 -63 0 -1)))

(mat fxlogior
     ; same as fxlogor
     (error? (fxlogior "hello"))
     (error? (fxlogior (+ (most-positive-fixnum) 1)))
     (error? (fxlogior (- (most-negative-fixnum) 1) 7))
     (error? (fxlogior 7 8 (- (most-negative-fixnum) 1) 8 9))
     (eqv? (fxlogior 0 0) 0)
     (eqv? (fxlogior 1 0) 1)
     (eqv? (fxlogior 1 1) 1)
     (eqv? (fxlogior 0 1) 1)
     (eqv? (fxlogior 2 1) 3)
     (eqv? (fxlogior 5 2) 7)
     (eqv? (fxlogior -1 2) -1)
     (eqv? (fxlogior) 0)
     (eqv? (fxlogior #x1212121) #x1212121)
     (eqv? (fxlogior #x1212121 #x2222222 #x0301030) #x3333333)
     (eqv? (fxlogior #b1010111 #b1001011 -1 #b1011110 #b1000111) -1)
     (eqv? (fxlogior #b1010111 #b1001011 0 #b1011110 #b1000111) #b1011111)
     (test-cp0-expansion eqv? '(fxlogior 0 0) 0)
     (test-cp0-expansion eqv? '(fxlogior 1 0) 1)
     (test-cp0-expansion eqv? '(fxlogior 1 1) 1)
     (test-cp0-expansion eqv? '(fxlogior 0 1) 1)
     (test-cp0-expansion eqv? '(fxlogior 2 1) 3)
     (test-cp0-expansion eqv? '(fxlogior 5 2) 7)
     (test-cp0-expansion eqv? '(fxlogior -1 2) -1)
     (test-cp0-expansion eqv? '(fxlogior) 0)
     (test-cp0-expansion eqv? '(fxlogior #x1212121) #x1212121)
     (test-cp0-expansion eqv?
       '(fxlogior #x1212121 #x2222222 #x0301030)
       #x3333333)
     (test-cp0-expansion eqv?
       '(fxlogior #b1010111 #b1001011 -1 #b1011110 #b1000111)
       -1)
     (test-cp0-expansion eqv?
       '(fxlogior #b1010111 #b1001011 0 #b1011110 #b1000111)
       #b1011111))

(mat fxior
     ; same as fxlogor
     (error? (fxior "hello"))
     (error? (fxior (+ (most-positive-fixnum) 1)))
     (error? (fxior (- (most-negative-fixnum) 1) 7))
     (error? (fxior 7 8 (- (most-negative-fixnum) 1) 8 9))
     (eqv? (fxior 0 0) 0)
     (eqv? (fxior 1 0) 1)
     (eqv? (fxior 1 1) 1)
     (eqv? (fxior 0 1) 1)
     (eqv? (fxior 2 1) 3)
     (eqv? (fxior 5 2) 7)
     (eqv? (fxior -1 2) -1)
     (eqv? (fxior) 0)
     (eqv? (fxior #x1212121) #x1212121)
     (eqv? (fxior #x1212121 #x2222222 #x0301030) #x3333333)
     (eqv? (fxior #b1010111 #b1001011 -1 #b1011110 #b1000111) -1)
     (eqv? (fxior #b1010111 #b1001011 0 #b1011110 #b1000111) #b1011111)
     (test-cp0-expansion eqv? '(fxior 0 0) 0)
     (test-cp0-expansion eqv? '(fxior 1 0) 1)
     (test-cp0-expansion eqv? '(fxior 1 1) 1)
     (test-cp0-expansion eqv? '(fxior 0 1) 1)
     (test-cp0-expansion eqv? '(fxior 2 1) 3)
     (test-cp0-expansion eqv? '(fxior 5 2) 7)
     (test-cp0-expansion eqv? '(fxior -1 2) -1)
     (test-cp0-expansion eqv? '(fxior) 0)
     (test-cp0-expansion eqv? '(fxior #x1212121) #x1212121)
     (test-cp0-expansion eqv?
       '(fxior #x1212121 #x2222222 #x0301030)
       #x3333333)
     (test-cp0-expansion eqv?
       '(fxior #b1010111 #b1001011 -1 #b1011110 #b1000111)
       -1)
     (test-cp0-expansion eqv?
       '(fxior #b1010111 #b1001011 0 #b1011110 #b1000111)
       #b1011111))

(mat fxlogor
     (error? (fxlogor "hello"))
     (error? (fxlogor (+ (most-positive-fixnum) 1)))
     (error? (fxlogor (- (most-negative-fixnum) 1) 7))
     (error? (fxlogor 7 8 (- (most-negative-fixnum) 1) 8 9))
     (eqv? (fxlogor 0 0) 0)
     (eqv? (fxlogor 1 0) 1)
     (eqv? (fxlogor 1 1) 1)
     (eqv? (fxlogor 0 1) 1)
     (eqv? (fxlogor 2 1) 3)
     (eqv? (fxlogor 5 2) 7)
     (eqv? (fxlogor -1 2) -1)
     (eqv? (fxlogor) 0)
     (eqv? (fxlogor #x1212121) #x1212121)
     (eqv? (fxlogor #x1212121 #x2222222 #x0301030) #x3333333)
     (eqv? (fxlogor #b1010111 #b1001011 -1 #b1011110 #b1000111) -1)
     (eqv? (fxlogor #b1010111 #b1001011 0 #b1011110 #b1000111) #b1011111)
     (test-cp0-expansion eqv? '(fxlogor 0 0) 0)
     (test-cp0-expansion eqv? '(fxlogor 1 0) 1)
     (test-cp0-expansion eqv? '(fxlogor 1 1) 1)
     (test-cp0-expansion eqv? '(fxlogor 0 1) 1)
     (test-cp0-expansion eqv? '(fxlogor 2 1) 3)
     (test-cp0-expansion eqv? '(fxlogor 5 2) 7)
     (test-cp0-expansion eqv? '(fxlogor -1 2) -1)
     (test-cp0-expansion eqv? '(fxlogor) 0)
     (test-cp0-expansion eqv? '(fxlogor #x1212121) #x1212121)
     (test-cp0-expansion eqv?
       '(fxlogor #x1212121 #x2222222 #x0301030)
       #x3333333)
     (test-cp0-expansion eqv?
       '(fxlogor #b1010111 #b1001011 -1 #b1011110 #b1000111)
       -1)
     (test-cp0-expansion eqv?
       '(fxlogor #b1010111 #b1001011 0 #b1011110 #b1000111)
       #b1011111))

(mat fxlogand
     (error? (fxlogand "hello"))
     (error? (fxlogand (+ (most-positive-fixnum) 1)))
     (error? (fxlogand 7 (- (most-negative-fixnum) 1)))
     (error? (fxlogand 7 (- (most-negative-fixnum) 1) 8 9))
     (eqv? (fxlogand 0 0) 0)
     (eqv? (fxlogand 1 0) 0)
     (eqv? (fxlogand 0 1) 0)
     (eqv? (fxlogand 1 1) 1)
     (eqv? (fxlogand 2 1) 0)
     (eqv? (fxlogand 3 1) 1)
     (eqv? (fxlogand 12 6) 4)
     (eqv? (fxlogand) -1)
     (eqv? (fxlogand #x1212121) #x1212121)
     (eqv? (fxlogand #x1212121 #x2222222 #x0301030) #x200020)
     (eqv? (fxlogand #b1110111 #b1101011 -1 #b1011110 #b1000111) #b1000010)
     (eqv? (fxlogand #b1110111 #b1101011 0 #b1011110 #b1000111) 0)
     (test-cp0-expansion eqv? '(fxlogand 0 0) 0)
     (test-cp0-expansion eqv? '(fxlogand 1 0) 0)
     (test-cp0-expansion eqv? '(fxlogand 0 1) 0)
     (test-cp0-expansion eqv? '(fxlogand 1 1) 1)
     (test-cp0-expansion eqv? '(fxlogand 2 1) 0)
     (test-cp0-expansion eqv? '(fxlogand 3 1) 1)
     (test-cp0-expansion eqv? '(fxlogand 12 6) 4)
     (test-cp0-expansion eqv? '(fxlogand) -1)
     (test-cp0-expansion eqv? '(fxlogand #x1212121) #x1212121)
     (test-cp0-expansion eqv?
       '(fxlogand #x1212121 #x2222222 #x0301030)
       #x200020)
     (test-cp0-expansion eqv?
       '(fxlogand #b1110111 #b1101011 -1 #b1011110 #b1000111)
       #b1000010)
     (test-cp0-expansion eqv?
       '(fxlogand #b1110111 #b1101011 0 #b1011110 #b1000111)
       0))

(mat fxand
     (error? (fxand "hello"))
     (error? (fxand (+ (most-positive-fixnum) 1)))
     (error? (fxand 7 (- (most-negative-fixnum) 1)))
     (error? (fxand 7 (- (most-negative-fixnum) 1) 8 9))
     (eqv? (fxand 0 0) 0)
     (eqv? (fxand 1 0) 0)
     (eqv? (fxand 0 1) 0)
     (eqv? (fxand 1 1) 1)
     (eqv? (fxand 2 1) 0)
     (eqv? (fxand 3 1) 1)
     (eqv? (fxand 12 6) 4)
     (eqv? (fxand) -1)
     (eqv? (fxand #x1212121) #x1212121)
     (eqv? (fxand #x1212121 #x2222222 #x0301030) #x200020)
     (eqv? (fxand #b1110111 #b1101011 -1 #b1011110 #b1000111) #b1000010)
     (eqv? (fxand #b1110111 #b1101011 0 #b1011110 #b1000111) 0)
     (test-cp0-expansion eqv? '(fxand 0 0) 0)
     (test-cp0-expansion eqv? '(fxand 1 0) 0)
     (test-cp0-expansion eqv? '(fxand 0 1) 0)
     (test-cp0-expansion eqv? '(fxand 1 1) 1)
     (test-cp0-expansion eqv? '(fxand 2 1) 0)
     (test-cp0-expansion eqv? '(fxand 3 1) 1)
     (test-cp0-expansion eqv? '(fxand 12 6) 4)
     (test-cp0-expansion eqv? '(fxand) -1)
     (test-cp0-expansion eqv? '(fxand #x1212121) #x1212121)
     (test-cp0-expansion eqv?
       '(fxand #x1212121 #x2222222 #x0301030)
       #x200020)
     (test-cp0-expansion eqv?
       '(fxand #b1110111 #b1101011 -1 #b1011110 #b1000111)
       #b1000010)
     (test-cp0-expansion eqv?
       '(fxand #b1110111 #b1101011 0 #b1011110 #b1000111)
       0))

(mat fxlogxor
     (error? (fxlogxor "hello"))
     (error? (fxlogxor (+ (most-positive-fixnum) 1)))
     (error? (fxlogxor 7 (- (most-negative-fixnum) 1)))
     (error? (fxlogxor 7 (- (most-negative-fixnum) 1) 8 9))
     (eqv? (fxlogxor 0 0) 0)
     (eqv? (fxlogxor 1 0) 1)
     (eqv? (fxlogxor 1 1) 0)
     (eqv? (fxlogxor 0 1) 1)
     (eqv? (fxlogxor 2 1) 3)
     (eqv? (fxlogxor 5 2) 7)
     (eqv? (fxlogxor -1 2) -3)
     (eqv? (fxlogxor) 0)
     (eqv? (fxlogxor #x1212121) #x1212121)
     (eqv? (fxlogxor #x1212121 #x2222222 #x0301030) #x3331333)
     (eqv? (fxlogxor #b1010111 #b1001011 -1 #b1011110 #b1000111) -6)
     (eqv? (fxlogxor #b1010111 #b1001011 0 #b1011110 #b1000111) 5)
     (test-cp0-expansion eqv? '(fxlogxor 0 0) 0)
     (test-cp0-expansion eqv? '(fxlogxor 1 0) 1)
     (test-cp0-expansion eqv? '(fxlogxor 1 1) 0)
     (test-cp0-expansion eqv? '(fxlogxor 0 1) 1)
     (test-cp0-expansion eqv? '(fxlogxor 2 1) 3)
     (test-cp0-expansion eqv? '(fxlogxor 5 2) 7)
     (test-cp0-expansion eqv? '(fxlogxor -1 2) -3)
     (test-cp0-expansion eqv? '(fxlogxor) 0)
     (test-cp0-expansion eqv? '(fxlogxor #x1212121) #x1212121)
     (test-cp0-expansion eqv?
       '(fxlogxor #x1212121 #x2222222 #x0301030)
       #x3331333)
     (test-cp0-expansion eqv?
       '(fxlogxor #b1010111 #b1001011 -1 #b1011110 #b1000111)
       -6)
     (test-cp0-expansion eqv?
       '(fxlogxor #b1010111 #b1001011 0 #b1011110 #b1000111)
       5))

(mat fxxor
     (error? (fxxor "hello"))
     (error? (fxxor (+ (most-positive-fixnum) 1)))
     (error? (fxxor 7 (- (most-negative-fixnum) 1)))
     (error? (fxxor 7 (- (most-negative-fixnum) 1) 8 9))
     (eqv? (fxxor 0 0) 0)
     (eqv? (fxxor 1 0) 1)
     (eqv? (fxxor 1 1) 0)
     (eqv? (fxxor 0 1) 1)
     (eqv? (fxxor 2 1) 3)
     (eqv? (fxxor 5 2) 7)
     (eqv? (fxxor -1 2) -3)
     (eqv? (fxxor) 0)
     (eqv? (fxxor #x1212121) #x1212121)
     (eqv? (fxxor #x1212121 #x2222222 #x0301030) #x3331333)
     (eqv? (fxxor #b1010111 #b1001011 -1 #b1011110 #b1000111) -6)
     (eqv? (fxxor #b1010111 #b1001011 0 #b1011110 #b1000111) 5)
     (test-cp0-expansion eqv? '(fxxor 0 0) 0)
     (test-cp0-expansion eqv? '(fxxor 1 0) 1)
     (test-cp0-expansion eqv? '(fxxor 1 1) 0)
     (test-cp0-expansion eqv? '(fxxor 0 1) 1)
     (test-cp0-expansion eqv? '(fxxor 2 1) 3)
     (test-cp0-expansion eqv? '(fxxor 5 2) 7)
     (test-cp0-expansion eqv? '(fxxor -1 2) -3)
     (test-cp0-expansion eqv? '(fxxor) 0)
     (test-cp0-expansion eqv? '(fxxor #x1212121) #x1212121)
     (test-cp0-expansion eqv?
       '(fxxor #x1212121 #x2222222 #x0301030)
       #x3331333)
     (test-cp0-expansion eqv?
       '(fxxor #b1010111 #b1001011 -1 #b1011110 #b1000111)
       -6)
     (test-cp0-expansion eqv?
       '(fxxor #b1010111 #b1001011 0 #b1011110 #b1000111)
       5))

(mat fxlognot
     (error? (fxlognot "hello"))
     (error? (fxlognot (+ (most-positive-fixnum) 1)))
     (error? (fxlognot (- (most-negative-fixnum) 1)))
     (eqv? (fxlognot 0) -1)
     (eqv? (fxlognot -1) 0)
     (eqv? (fxlognot 2) -3)
     (test-cp0-expansion eqv? '(fxlognot 0) -1)
     (test-cp0-expansion eqv? '(fxlognot -1) 0)
     (test-cp0-expansion eqv? '(fxlognot 2) -3))

(mat fxnot
     (error? (fxnot "hello"))
     (error? (fxnot (+ (most-positive-fixnum) 1)))
     (error? (fxnot (- (most-negative-fixnum) 1)))
     (eqv? (fxnot 0) -1)
     (eqv? (fxnot -1) 0)
     (eqv? (fxnot 2) -3)
     (test-cp0-expansion eqv? '(fxnot 0) -1)
     (test-cp0-expansion eqv? '(fxnot -1) 0)
     (test-cp0-expansion eqv? '(fxnot 2) -3))

(mat fxsll
     (error? (fxsll 1 -1))
     (eqv? (fxsll 1 0) 1)
     (eqv? (fxsll 1 1) 2)
     (eqv? (fxsll 1 2) 4)
     (eqv? (fxsll 1 3) 8)
     (eqv? (fxsll 1 4) 16)
     (eqv? (fxsll 1 (/ 8 2)) 16)
     (eqv? (fxsll (fxsra (most-positive-fixnum) 1) 1)
           (- (most-positive-fixnum) 1))
     (eqv? (fxsll (fxsra (most-negative-fixnum) 1) 1)
           (most-negative-fixnum))
     (error? (fxsll 0 (+ (fixnum-width) 1)))
     ; check for overflow error when sign changes
     (error? (fxsll 1 (- (fixnum-width) 1)))
     (error? (fxsll #x1001 (- (fixnum-width) 2)))
     (error? (fxsll -1 (fixnum-width)))
     (error? (fxsll (most-positive-fixnum) 1))
     (error? (fxsll (most-positive-fixnum) 10))
     (error? (fxsll #x-1001 (- (fixnum-width) 2)))
     (error? (fxsll (most-negative-fixnum) 1))
     (eqv? (fxsll 0 (fixnum-width)) 0)
     (let ()
       (define expt2
         (lambda (i) (if (= i 0) 1 (* 2 (expt2 (- i 1))))))
       (define check
         ; use trace-define to debug
         (lambda (i)
           (let ([x (expt2 i)])
             (and (eqv? (fxsll 1 i) x)
                  (eqv? (fxsll -1 i) (- x))))))
       (do ([i 0 (fx+ i 1)] [a #t (and a (check i))])
           ((fx= i (- (fixnum-width) 1)) a)))
     (test-cp0-expansion eqv? '(fxsll 1 0) 1)
     (test-cp0-expansion eqv? '(fxsll 1 1) 2)
     (test-cp0-expansion eqv? '(fxsll 1 2) 4)
     (test-cp0-expansion eqv? '(fxsll 1 3) 8)
     (test-cp0-expansion eqv? '(fxsll 1 4) 16)
     (test-cp0-expansion eqv? '(fxsll 1 (/ 8 2)) 16))

(mat fxarithmetic-shift-left
     ; bound on shift count is one less than for fxsll
     (error? (fxarithmetic-shift-left 0 (fixnum-width)))
     (error? (fxarithmetic-shift-left 0 'a))
     (error? (fxarithmetic-shift-left 0 1e23))
     (error? (fxarithmetic-shift-left 0 (+ (most-positive-fixnum) 1)))
     (error? (fxarithmetic-shift-left 1 -1))
     (eqv? (fxarithmetic-shift-left 1 0) 1)
     (eqv? (fxarithmetic-shift-left 1 1) 2)
     (eqv? (fxarithmetic-shift-left 1 2) 4)
     (eqv? (fxarithmetic-shift-left 1 3) 8)
     (eqv? (fxarithmetic-shift-left 1 4) 16)
     (eqv? (fxarithmetic-shift-left 1 (/ 8 2)) 16)
     (eqv? (fxarithmetic-shift-left (fxsra (most-positive-fixnum) 1) 1)
           (- (most-positive-fixnum) 1))
     (eqv? (fxarithmetic-shift-left (fxsra (most-negative-fixnum) 1) 1)
           (most-negative-fixnum))
     ; check for overflow error when sign changes
     (error? (fxarithmetic-shift-left 1 (- (fixnum-width) 1)))
     (error? (fxarithmetic-shift-left #x1001 (- (fixnum-width) 2)))
     (error? (fxarithmetic-shift-left -1 (fixnum-width)))
     (error? (fxarithmetic-shift-left (most-positive-fixnum) 1))
     (error? (fxarithmetic-shift-left (most-positive-fixnum) 10))
     (error? (fxarithmetic-shift-left #x-1001 (- (fixnum-width) 2)))
     (error? (fxarithmetic-shift-left (most-negative-fixnum) 1))
     (let ()
       (define expt2
         (lambda (i) (if (= i 0) 1 (* 2 (expt2 (- i 1))))))
       (define check
         ; use trace-define to debug
         (lambda (i)
           (let ([x (expt2 i)])
             (and (eqv? (fxarithmetic-shift-left 1 i) x)
                  (eqv? (fxarithmetic-shift-left -1 i) (- x))))))
       (do ([i 0 (fx+ i 1)] [a #t (and a (check i))])
           ((fx= i (- (fixnum-width) 1)) a)))
     (test-cp0-expansion eqv? '(fxarithmetic-shift-left 1 0) 1)
     (test-cp0-expansion eqv? '(fxarithmetic-shift-left 1 1) 2)
     (test-cp0-expansion eqv? '(fxarithmetic-shift-left 1 2) 4)
     (test-cp0-expansion eqv? '(fxarithmetic-shift-left 1 3) 8)
     (test-cp0-expansion eqv? '(fxarithmetic-shift-left 1 4) 16)
     (test-cp0-expansion eqv? '(fxarithmetic-shift-left 1 (/ 8 2)) 16))

(mat fxsrl
     (error? (fxsrl 1 -1))
     (error? (fxsrl 1 (+ (integer-length (most-positive-fixnum)) 2)))
     (error? (fxsrl 1 'a))
     (error? (fxsrl 'a 17))
     (error? (fxsrl (+ (most-positive-fixnum) 1) 2))
     (eqv? (fxsrl 16 5) 0)
     (eqv? (fxsrl 16 4) 1)
     (eqv? (fxsrl 16 3) 2)
     (eqv? (fxsrl 16 2) 4)
     (eqv? (fxsrl 16 1) 8)
     (eqv? (fxsrl 16 0) 16)
     (eqv? (fxsrl -1 1) (most-positive-fixnum))
     (eqv? (fxsrl 16 (/ 8 2)) 1)
     (test-cp0-expansion eqv? '(fxsrl 16 5) 0)
     (test-cp0-expansion eqv? '(fxsrl 16 4) 1)
     (test-cp0-expansion eqv? '(fxsrl 16 3) 2)
     (test-cp0-expansion eqv? '(fxsrl 16 2) 4)
     (test-cp0-expansion eqv? '(fxsrl 16 1) 8)
     (test-cp0-expansion eqv? '(fxsrl 16 0) 16)
     (test-cp0-expansion eqv? '(fxsrl -1 1) (most-positive-fixnum))
     (test-cp0-expansion eqv? '(fxsrl 16 (/ 8 2)) 1))

(mat fxsra
     (error? (fxsra 1 -1))
     (error? (fxsra 1 (+ (integer-length (most-positive-fixnum)) 2)))
     (error? (fxsra 1 'a))
     (error? (fxsra 'a 17))
     (error? (fxsra (+ (most-positive-fixnum) 1) 2))
     (error? (fxsra 0 (+ (fixnum-width) 1)))
     (eqv? (fxsra 0 (fixnum-width)) 0)
     (eqv? (fxsra 16 5) 0)
     (eqv? (fxsra 16 4) 1)
     (eqv? (fxsra 16 3) 2)
     (eqv? (fxsra 16 2) 4)
     (eqv? (fxsra 16 1) 8)
     (eqv? (fxsra 16 0) 16)
     (eqv? (fxsra -1 1) -1)
     (eqv? (fxsra 16 (/ 8 2)) 1)
     (test-cp0-expansion eqv? '(fxsra 0 (fixnum-width)) 0)
     (test-cp0-expansion eqv? '(fxsra 16 5) 0)
     (test-cp0-expansion eqv? '(fxsra 16 4) 1)
     (test-cp0-expansion eqv? '(fxsra 16 3) 2)
     (test-cp0-expansion eqv? '(fxsra 16 2) 4)
     (test-cp0-expansion eqv? '(fxsra 16 1) 8)
     (test-cp0-expansion eqv? '(fxsra 16 0) 16)
     (test-cp0-expansion eqv? '(fxsra -1 1) -1)
     (test-cp0-expansion eqv? '(fxsra 16 (/ 8 2)) 1))

(mat fxarithmetic-shift-right
     ; bound on shift count is one less than for fxsll
     (error? (fxarithmetic-shift-right 1 -1))
     (error? (fxarithmetic-shift-right 1
               (+ (integer-length (most-positive-fixnum)) 2)))
     (error? (fxarithmetic-shift-right 1 'a))
     (error? (fxarithmetic-shift-right 'a 17))
     (error? (fxarithmetic-shift-right (+ (most-positive-fixnum) 1) 2))
     (error? (fxarithmetic-shift-right 0 (fixnum-width)))
     (eqv? (fxarithmetic-shift-right 16 5) 0)
     (eqv? (fxarithmetic-shift-right 16 4) 1)
     (eqv? (fxarithmetic-shift-right 16 3) 2)
     (eqv? (fxarithmetic-shift-right 16 2) 4)
     (eqv? (fxarithmetic-shift-right 16 1) 8)
     (eqv? (fxarithmetic-shift-right 16 0) 16)
     (eqv? (fxarithmetic-shift-right -1 1) -1)
     (eqv? (fxarithmetic-shift-right 16 (/ 8 2)) 1)
     (test-cp0-expansion eqv? '(fxarithmetic-shift-right 16 5) 0)
     (test-cp0-expansion eqv? '(fxarithmetic-shift-right 16 4) 1)
     (test-cp0-expansion eqv? '(fxarithmetic-shift-right 16 3) 2)
     (test-cp0-expansion eqv? '(fxarithmetic-shift-right 16 2) 4)
     (test-cp0-expansion eqv? '(fxarithmetic-shift-right 16 1) 8)
     (test-cp0-expansion eqv? '(fxarithmetic-shift-right 16 0) 16)
     (test-cp0-expansion eqv? '(fxarithmetic-shift-right -1 1) -1)
     (test-cp0-expansion eqv? '(fxarithmetic-shift-right 16 (/ 8 2)) 1))

(mat fxarithmetic-shift
     (error? (fxarithmetic-shift 1 (fixnum-width)))
     (error? (fxarithmetic-shift 1 (- (fixnum-width))))
     (error? (fxarithmetic-shift 1 'a))
     (error? (fxarithmetic-shift 'a 17))
     (error? (fxarithmetic-shift (+ (most-positive-fixnum) 1) 2))
     (eqv? (fxarithmetic-shift 0 (- (fixnum-width) 1)) 0)
     (eqv? (fxarithmetic-shift 16 -5) 0)
     (eqv? (fxarithmetic-shift 16 -4) 1)
     (eqv? (fxarithmetic-shift 16 -3) 2)
     (eqv? (fxarithmetic-shift 16 -2) 4)
     (eqv? (fxarithmetic-shift 16 -1) 8)
     (eqv? (fxarithmetic-shift 16 -0) 16)
     (eqv? (fxarithmetic-shift -1 -1) -1)
     (eqv? (fxarithmetic-shift 16 (/ -8 2)) 1)
     (eqv? (fxarithmetic-shift 1 0) 1)
     (eqv? (fxarithmetic-shift 1 1) 2)
     (eqv? (fxarithmetic-shift 1 2) 4)
     (eqv? (fxarithmetic-shift 1 3) 8)
     (eqv? (fxarithmetic-shift 1 4) 16)
     (eqv? (fxarithmetic-shift 1 (/ 8 2)) 16)
     (eqv? (fxarithmetic-shift (fxsra (most-positive-fixnum) 1) 1)
           (- (most-positive-fixnum) 1))
     (eqv? (fxarithmetic-shift (fxsra (most-negative-fixnum) 1) 1)
           (most-negative-fixnum))
     ; check for overflow error when sign changes
     (error? (fxarithmetic-shift 1 (- (fixnum-width) 1)))
     (error? (fxarithmetic-shift #x1001 (- (fixnum-width) 2)))
     (error? (fxarithmetic-shift -1 (fixnum-width)))
     (error? (fxarithmetic-shift (most-positive-fixnum) 1))
     (error? (fxarithmetic-shift (most-positive-fixnum) 10))
     (error? (fxarithmetic-shift #x-1001 (- (fixnum-width) 2)))
     (error? (fxarithmetic-shift (most-negative-fixnum) 1))
     (let ()
       (define expt2
         (lambda (i) (if (= i 0) 1 (* 2 (expt2 (- i 1))))))
       (define check
         ; use trace-define to debug
         (lambda (i)
           (let ([x (expt2 i)])
             (and (eqv? (fxarithmetic-shift 1 i) x)
                  (eqv? (fxarithmetic-shift -1 i) (- x))))))
       (do ([i 0 (fx+ i 1)] [a #t (and a (check i))])
           ((fx= i (- (fixnum-width) 1)) a)))
     (test-cp0-expansion eqv?
       '(fxarithmetic-shift 0 (- (fixnum-width) 1))
       0)
     (test-cp0-expansion eqv? '(fxarithmetic-shift 16 -5) 0)
     (test-cp0-expansion eqv? '(fxarithmetic-shift 16 -4) 1)
     (test-cp0-expansion eqv? '(fxarithmetic-shift 16 -3) 2)
     (test-cp0-expansion eqv? '(fxarithmetic-shift 16 -2) 4)
     (test-cp0-expansion eqv? '(fxarithmetic-shift 16 -1) 8)
     (test-cp0-expansion eqv? '(fxarithmetic-shift 16 -0) 16)
     (test-cp0-expansion eqv? '(fxarithmetic-shift -1 -1) -1)
     (test-cp0-expansion eqv? '(fxarithmetic-shift 16 (/ -8 2)) 1)
     (test-cp0-expansion eqv? '(fxarithmetic-shift 1 0) 1)
     (test-cp0-expansion eqv? '(fxarithmetic-shift 1 1) 2)
     (test-cp0-expansion eqv? '(fxarithmetic-shift 1 2) 4)
     (test-cp0-expansion eqv? '(fxarithmetic-shift 1 3) 8)
     (test-cp0-expansion eqv? '(fxarithmetic-shift 1 4) 16)
     (test-cp0-expansion eqv? '(fxarithmetic-shift 1 (/ 8 2)) 16))

(mat fxbit-field
     (error? (fxbit-field))
     (error? (fxbit-field 35))
     (error? (fxbit-field 35 5))
     (error? (fxbit-field 35 5 8 15))
     (error? (fxbit-field 35.0 5 8))
     (error? (fxbit-field 35 5.0 8))
     (error? (fxbit-field 35 5 8.0))
     (error? (fxbit-field 'a 5 8))
     (error? (fxbit-field 35 '(a b) 8))
     (error? (fxbit-field 35 5 "hello"))
     (error? (fxbit-field 35 -5 8))
     (error? (fxbit-field 35 5 -8))
     (error? (fxbit-field 35 5 3))
     (error? (fxbit-field 35
               (* (greatest-fixnum) 2)
               (+ (* (greatest-fixnum) 2) 10)))
     (error? (fxbit-field 35 10 (+ (* (greatest-fixnum) 2) 10)))
     (error? (fxbit-field 35 (fixnum-width) (fixnum-width)))
     (error? (fxbit-field 35 0 (fixnum-width)))
     (eqv? (fxbit-field #b11100100111110101011 5 5) 0)
     (eqv? (fxbit-field #b11100100111110101011 5 6) 1)
     (eqv? (fxbit-field #b11100100111110101011 0 8) #b10101011)
     (eqv? (fxbit-field #b11100100111110101011 5 15) #b1001111101)
     (eqv? (fxbit-field #b11100100111110101011 5 23) #b111001001111101)
     (eqv? (fxbit-field -1 5 23) #b111111111111111111)
     (eqv? (fxbit-field -5 0 5) #b11011)
     (eqv? (fxbit-field -5 1 5) #b1101)
     (eqv? (fxbit-field -5 2 5) #b110)
     (eqv? (fxbit-field -5 2 20) #b111111111111111110)
     (do ([n 10000 (fx- n 1)])
         ((fx= n 0) #t)
         (let ([x (random (greatest-fixnum))])
           (let ([len (fxlength x)])
             (let ([i (random len)] [j (random len)])
               (let-values ([(i j) (if (fx< i j) (values i j) (values j i))])
                 (unless (= (fxior (fxarithmetic-shift-left (fxbit-field x i j) i)
                                   (fxarithmetic-shift-left (fxbit-field x j len) j)
                                   (fxbit-field x 0 i))
                            x)
                         (errorf #f "failed for ~s, ~s, ~s" x i j)))))))
     (do ([n 10000 (fx- n 1)])
         ((fx= n 0) #t)
         (let ([x (- (random (greatest-fixnum)))])
           (let ([len (fxlength x)])
             (let ([i (random len)] [j (random len)])
               (let-values ([(i j) (if (fx< i j) (values i j) (values j i))])
                 (unless (= (fxior (fxarithmetic-shift-left -1 len)
                              (fxarithmetic-shift-left (fxbit-field x i j) i)
                              (fxarithmetic-shift-left (fxbit-field x j len) j)
                              (fxbit-field x 0 i))
                            x)
                         (errorf #f "failed for ~s, ~s, ~s" x i j)))))))
     (eqv? (fxbit-field 3 15 23) 0)
     (eqv? (fxbit-field -3 15 23) #b11111111)

     (test-cp0-expansion eqv? '(fxbit-field #b11100100111110101011 5 5) 0)
     (test-cp0-expansion eqv? '(fxbit-field #b11100100111110101011 5 6) 1)
     (test-cp0-expansion eqv?
       '(fxbit-field #b11100100111110101011 0 8)
       #b10101011)
     (test-cp0-expansion eqv?
       '(fxbit-field #b11100100111110101011 5 15)
       #b1001111101)
     (test-cp0-expansion eqv?
       '(fxbit-field #b11100100111110101011 5 23)
       #b111001001111101)
     (test-cp0-expansion eqv? '(fxbit-field -1 5 23) #b111111111111111111)
     (test-cp0-expansion eqv? '(fxbit-field -5 0 5) #b11011)
     (test-cp0-expansion eqv? '(fxbit-field -5 1 5) #b1101)
     (test-cp0-expansion eqv? '(fxbit-field -5 2 5) #b110)
     (test-cp0-expansion eqv? '(fxbit-field -5 2 20) #b111111111111111110)
     (test-cp0-expansion eqv? '(fxbit-field 3 15 23) 0)
     (test-cp0-expansion eqv? '(fxbit-field -3 15 23) #b11111111))

(mat fxlength
     (error? (fxlength))
     (error? (fxlength 1 1 1))
     (error? (fxlength .1))
     (= (fxlength 0) 0)
     (= (fxlength 1) 1)
     (= (fxlength 3) 2)
     (= (fxlength 4) 3)
     (= (fxlength 7) 3)
     (= (fxlength -1) 0)
     (= (fxlength -4) 2)
     (= (fxlength -7) 3)
     (= (fxlength -8) 3)
     (= (fxlength (most-positive-fixnum)) (- (fixnum-width) 1))
     (= (fxlength (most-negative-fixnum)) (- (fixnum-width) 1))
     (test-cp0-expansion = '(fxlength 0) 0)
     (test-cp0-expansion = '(fxlength 1) 1)
     (test-cp0-expansion = '(fxlength 3) 2)
     (test-cp0-expansion = '(fxlength 4) 3)
     (test-cp0-expansion = '(fxlength 7) 3)
     (test-cp0-expansion = '(fxlength -1) 0)
     (test-cp0-expansion = '(fxlength -4) 2)
     (test-cp0-expansion = '(fxlength -7) 3)
     (test-cp0-expansion = '(fxlength -8) 3)
     (test-cp0-expansion =
       '(fxlength (most-positive-fixnum))
       (- (fixnum-width) 1))
     (test-cp0-expansion =
       '(fxlength (most-negative-fixnum))
       (- (fixnum-width) 1))
     (let ()
       (define r6rs-length
         (lambda (x)
           (do ([result 0 (fx+ result 1)]
                [bits (if (fxnegative? x) (fxnot x) x)
                      (fxarithmetic-shift-right bits 1)])
               ((fxzero? bits) result))))
       (let f ([n 10000])
         (or (fx= n 0)
             (let ([x (random (greatest-fixnum))])
               (and (= (fxlength x) (r6rs-length x))
                    (= (fxlength (- x)) (r6rs-length (- x)))
                    (f (fx- n 1))))))))

(mat fxbit-count
     (error? (fxbit-count))
     (error? (fxbit-count 75 32))
     (error? (fxbit-count 3.0))
     (error? (fxbit-count 'a))
     (error? (fxbit-count (+ (most-positive-fixnum) 1)))
     (error? (fxbit-count (- (most-negative-fixnum) 1)))
     (eqv? (fxbit-count 0) 0)
     (eqv? (fxbit-count #xabcd) 10)
     (eqv? (fxbit-count -1) -1)
     (eqv? (fxbit-count -10) -3)
     (equal? (map fxbit-count '(0 1 2 3 4 5 6 7 8 9 10))
             '(0 1 1 2 1 2 2 3 1 2 2))
     (equal? (map fxbit-count '(-1 -2 -3 -4 -5 -6 -7 -8 -9 -10))
             '(-1 -2 -2 -3 -2 -3 -3 -4 -2 -3))
     (test-cp0-expansion eqv? '(fxbit-count 0) 0)
     (test-cp0-expansion eqv? '(fxbit-count #xabcd) 10)
     (test-cp0-expansion eqv? '(fxbit-count -1) -1)
     (test-cp0-expansion eqv? '(fxbit-count -10) -3)
     (equal? (map (lambda (x)
                    (parameterize
                      ([optimize-level 2]
                       [enable-cp0 #t]
                       [#%$suppress-primitive-inlining #f])
                      (expand/optimize `(fxbit-count ,x))))
                  '(0 1 2 3 4 5 6 7 8 9 10))
             '(0 1 1 2 1 2 2 3 1 2 2))
     (equal? (map (lambda (x)
                    (parameterize
                      ([optimize-level 2]
                       [enable-cp0 #t]
                       [#%$suppress-primitive-inlining #f])
                      (expand/optimize `(fxbit-count ,x))))
                  '(-1 -2 -3 -4 -5 -6 -7 -8 -9 -10))
             '(-1 -2 -2 -3 -2 -3 -3 -4 -2 -3))
     (let ([n (+ (greatest-fixnum) 1)])
       (let f ([i 2] [j 1])
         (or (= i n)
             (and (eqv? (fxbit-count i) 1)
                  (eqv? (fxbit-count (+ i 1)) 2)
                  (eqv? (fxbit-count (- i 1)) j)
                  (f (bitwise-arithmetic-shift i 1) (+ j 1))))))
     (let ([n (+ (greatest-fixnum) 1)])
       (define slow-bit-count
         (lambda (x)
           (if (< x 0)
               (bitwise-not (slow-bit-count (bitwise-not x)))
               (let f ([x x] [c 0])
                 (if (= x 0)
                     c
                     (f (bitwise-arithmetic-shift-right x 1)
                        (if (bitwise-bit-set? x 0)
                            (+ c 1)
                            c)))))))
       (let f ([i 10000])
         (let ([r (random n)])
           (or (fx= i 0)
               (and (= (fxbit-count r) (slow-bit-count r))
                    (= (fxbit-count (- r)) (slow-bit-count (- r)))
                    (f (fx- i 1))))))))

(mat fxfirst-bit-set
     (error? (fxfirst-bit-set))
     (error? (fxfirst-bit-set 75 32))
     (error? (fxfirst-bit-set 3.0))
     (error? (fxfirst-bit-set 'a))
     (error? (fxfirst-bit-set (+ (most-positive-fixnum) 1)))
     (error? (fxfirst-bit-set (- (most-negative-fixnum) 1)))
     (eqv? (fxfirst-bit-set 0) -1)
     (eqv? (fxfirst-bit-set 1) 0)
     (eqv? (fxfirst-bit-set -1) 0)
     (eqv? (fxfirst-bit-set -4) 2)
     (eqv? (fxfirst-bit-set (least-fixnum)) (fx- (fixnum-width) 1))
     (equal? (map fxfirst-bit-set '(0 1 2 3 4 5 6 7 8 9 10))
             '(-1 0 1 0 2 0 1 0 3 0 1))
     (equal? (map fxfirst-bit-set '(-1 -2 -3 -4 -5 -6 -7 -8 -9 -10))
             '(0 1 0 2 0 1 0 3 0 1))
     (test-cp0-expansion eqv? '(fxfirst-bit-set 0) -1)
     (test-cp0-expansion eqv? '(fxfirst-bit-set 1) 0)
     (test-cp0-expansion eqv? '(fxfirst-bit-set -1) 0)
     (test-cp0-expansion eqv? '(fxfirst-bit-set -4) 2)
     (test-cp0-expansion eqv?
       '(fxfirst-bit-set (least-fixnum))
       (fx- (fixnum-width) 1))
     (equal? (map (lambda (x)
                    (parameterize
                      ([optimize-level 2]
                       [enable-cp0 #t]
                       [#%$suppress-primitive-inlining #f])
                      (expand/optimize `(fxfirst-bit-set ,x))))
                  '(0 1 2 3 4 5 6 7 8 9 10))
             '(-1 0 1 0 2 0 1 0 3 0 1))
     (equal? (map (lambda (x)
                    (parameterize
                      ([optimize-level 2]
                       [enable-cp0 #t]
                       [#%$suppress-primitive-inlining #f])
                      (expand/optimize `(fxfirst-bit-set ,x))))
                  '(-1 -2 -3 -4 -5 -6 -7 -8 -9 -10))
             '(0 1 0 2 0 1 0 3 0 1))
     (let ([n (+ (greatest-fixnum) 1)])
       (let f ([i 2] [j 1])
         (or (= i n)
             (and (eqv? (fxfirst-bit-set i) j)
                  (eqv? (fxfirst-bit-set (+ i 1)) 0)
                  (eqv? (fxfirst-bit-set (- i 1)) 0)
                  (f (bitwise-arithmetic-shift i 1) (fx+ j 1))))))
     (let ([n (+ (greatest-fixnum) 1)])
       (define slow-first-bit-set
         (lambda (x)
           (if (= x 0)
               0
               (let f ([x x])
                 (if (fxodd? x) 0 (+ (f (fxsrl x 1)) 1))))))
       (let f ([i 10000])
         (let ([r (random n)])
           (unless (fx= i 0)
                   (unless (and (= (fxfirst-bit-set r) (slow-first-bit-set r))
                                (= (fxfirst-bit-set (- r))
                                   (slow-first-bit-set (- r))))
                           (errorf #f "failed for ~s" r))
                   (f (fx- i 1)))))
       #t))

(mat fxlogtest
     (error? (fxlogtest))
     (error? (fxlogtest 1))
     (error? (fxlogtest 1 2 3))
     (error? (fxlogtest 3.4 5))
     (error? (fxlogtest 5 "3"))
     (error? (fxlogtest (+ (most-positive-fixnum) 1) 0))
     (error? (fxlogtest 0 (+ (most-positive-fixnum) 1)))
     (error? (fxlogtest (- (most-negative-fixnum) 1) 0))
     (error? (fxlogtest 0 (- (most-negative-fixnum) 1)))
     (eqv? (fxlogtest 750 -1) #t)
     (eqv? (fxlogtest -1 -6) #t)
     (eqv? (fxlogtest 0 -1) #f)
     (eqv? (fxlogtest -1 0) #f)
     (eqv? (fxlogtest #b1000101001 #b0111010110) #f)
     (eqv? (fxlogtest #b1000101001 #b0111110110) #t)
     (eqv? (fxlogtest #b1010101001 #b0111010110) #t)
     (eqv? (fxlogtest (most-positive-fixnum) 3) #t)
     (eqv? (fxlogtest (most-negative-fixnum) 3) #f)
     (eqv? (fxlogtest (most-negative-fixnum) (most-negative-fixnum)) #t)
     (eqv? (fxlogtest (most-negative-fixnum) (most-positive-fixnum)) #f)
     (test-cp0-expansion eqv? '(fxlogtest #b1000101001 #b0111010110) #f)
     (test-cp0-expansion eqv? '(fxlogtest #b1000101001 #b0111110110) #t)
     (test-cp0-expansion eqv? '(fxlogtest #b1010101001 #b0111010110) #t)
     (test-cp0-expansion eqv? '(fxlogtest (most-positive-fixnum) 3) #t)
     (test-cp0-expansion eqv? '(fxlogtest (most-negative-fixnum) 3) #f)
     (test-cp0-expansion eqv?
       '(fxlogtest (most-negative-fixnum) (most-negative-fixnum))
       #t)
     (test-cp0-expansion eqv?
       '(fxlogtest (most-negative-fixnum) (most-positive-fixnum))
       #f)

     ; make sure we've properly labeled fxlogtest an arith-pred in primvars.ss
     (begin
       (define ($fxlogtest-foo x y)
         (if (fxlogtest x y) 'yes 'no))
       (equal? (list ($fxlogtest-foo 3 4) ($fxlogtest-foo 3 3)) '(no yes))))

(mat fxif
     (error? (fxif))
     (error? (fxif 0))
     (error? (fxif 0 0))
     (error? (fxif 0 0 0 0))
     (error? (fxif 'a 0 0))
     (error? (fxif 0 3.4 0))
     (error? (fxif 0 0 '(a)))
     (error? (fxif (+ (most-positive-fixnum) 1) 0 0))
     (error? (fxif 0 (+ (most-positive-fixnum) 1) 0))
     (error? (fxif 0 0 (+ (most-positive-fixnum) 1)))
     (error? (fxif (- (most-negative-fixnum) 1) 0 0))
     (error? (fxif 0 (- (most-negative-fixnum) 1) 0))
     (error? (fxif 0 0 (- (most-negative-fixnum) 1)))
     (eqv? (fxif 0 0 0) 0)
     (eqv? (fxif 0 -1 0) 0)
     (eqv? (fxif 0 0 -1) -1)
     (eqv? (fxif #b10101010 0 -1) (fxnot #b10101010))
     (eqv? (fxif #b10101010 -1 0) #b10101010)
     (eqv? (fxif #b11001110001101 #b11111110000000 #b11001100110011)
           #b11001110110010)
     (test-cp0-expansion eqv? '(fxif 0 0 0) 0)
     (test-cp0-expansion eqv? '(fxif 0 -1 0) 0)
     (test-cp0-expansion eqv? '(fxif 0 0 -1) -1)
     (test-cp0-expansion eqv? '(fxif #b10101010 0 -1) (fxnot #b10101010))
     (test-cp0-expansion eqv? '(fxif #b10101010 -1 0) #b10101010)
     (test-cp0-expansion eqv?
       '(fxif #b11001110001101 #b11111110000000 #b11001100110011)
       #b11001110110010)
     (let ([n (+ (greatest-fixnum) 1)])
       (define r6rs-fxif
         (lambda (ei1 ei2 ei3)
           (bitwise-ior (bitwise-and ei1 ei2)
             (bitwise-and (bitwise-not ei1) ei3))))
       (let f ([i 10000])
         (unless (fx= i 0)
                 (let ([x (random n)] [y (random n)] [z (random n)])
                   (unless (and (= (fxif x y z) (r6rs-fxif x y z))
                                (= (fxif (fxnot x) y z) (r6rs-fxif (fxnot x) y z))
                                (= (fxif (fxnot x) y (fxnot z))
                                   (r6rs-fxif (fxnot x) y (fxnot z)))
                                (= (fxif x (fxnot y) z) (r6rs-fxif x (fxnot y) z))
                                (= (fxif (fxnot x) (fxnot y) (fxnot z))
                                   (r6rs-fxif (fxnot x) (fxnot y) (fxnot z))))
                           (errorf #f "failed for ~s, ~s, ~s" x y z)))
                 (f (fx- i 1))))
       #t))

(mat fxlogbit?
     (error? (fxlogbit?))
     (error? (fxlogbit? 1))
     (error? (fxlogbit? 1 2 3))
     (error? (fxlogbit? 3.4 5))
     (error? (fxlogbit? 5 "3"))
     (error? (fxlogbit? 0 (+ (most-positive-fixnum) 1)))
     (error? (fxlogbit? 0 (- (most-negative-fixnum) 1)))
     (error? (fxlogbit? -1 -1))
     (eqv? (do ([i 0 (fx+ i 1)] [a #t (and a (fxlogbit? i -1))])
               ((fx> i (integer-length (most-positive-fixnum))) a))
           #t)
     (eqv? (do ([i 0 (fx+ i 1)]
                [a #t (and a (fxlogbit? i (most-positive-fixnum)))])
               ((fx= i (integer-length (most-positive-fixnum))) a))
           #t)
     (eqv? (fxlogbit? (integer-length (most-positive-fixnum))
             (most-positive-fixnum))
           #f)
     (eqv? (fxlogbit? 0 #b0111010110) #f)
     (eqv? (fxlogbit? 4 #b0111010110) #t)
     (eqv? (fxlogbit? 8 #b0111010110) #t)
     (eqv? (fxlogbit? 9 #b0111010110) #f)
     (eqv? (fxlogbit? (integer-length (most-positive-fixnum)) #b0111010110)
           #f)
     (eqv? (fxlogbit? 0 -6) #f)
     (eqv? (fxlogbit? 1 -6) #t)
     (eqv? (fxlogbit? 2 -6) #f)
     (eqv? (do ([i 3 (fx+ i 1)] [a #t (and a (fxlogbit? i -6))])
               ((fx= i (integer-length (most-positive-fixnum))) a))
           #t)
     ; check to see if we can look as far to the left as we please ...
     (eqv? (fxlogbit? (+ (integer-length (most-positive-fixnum)) 1) -1) #t)
     (eqv? (fxlogbit? (expt (integer-length (most-positive-fixnum)) 2)
             (most-positive-fixnum))
           #f)
     (eqv? (fxlogbit? (expt (integer-length (most-positive-fixnum)) 2) -1)
           #t)

     ; make sure we've properly labeled fxlogbit? an arith-pred in primvars.ss
     (begin
       (define ($fxlogbit?-foo x y)
         (if (fxlogbit? x y) 'yes 'no))
       (equal? (list ($fxlogbit?-foo 2 4) ($fxlogbit?-foo 3 3)) '(yes no)))
     (test-cp0-expansion eqv?
       '(fxlogbit? (integer-length (most-positive-fixnum))
          (most-positive-fixnum))
       #f)
     (test-cp0-expansion eqv? '(fxlogbit? 0 #b0111010110) #f)
     (test-cp0-expansion eqv? '(fxlogbit? 4 #b0111010110) #t)
     (test-cp0-expansion eqv? '(fxlogbit? 8 #b0111010110) #t)
     (test-cp0-expansion eqv? '(fxlogbit? 9 #b0111010110) #f)
     (test-cp0-expansion eqv?
       '(fxlogbit? (integer-length (most-positive-fixnum)) #b0111010110)
       #f)
     (test-cp0-expansion eqv? '(fxlogbit? 0 -6) #f)
     (test-cp0-expansion eqv? '(fxlogbit? 1 -6) #t)
     (test-cp0-expansion eqv? '(fxlogbit? 2 -6) #f)
     (test-cp0-expansion eqv?
       '(fxlogbit? (+ (integer-length (most-positive-fixnum)) 1) -1)
       #t)
     (test-cp0-expansion eqv?
       '(fxlogbit? (expt (integer-length (most-positive-fixnum)) 2)
          (most-positive-fixnum))
       #f)
     (test-cp0-expansion eqv?
       '(fxlogbit? (expt (integer-length (most-positive-fixnum)) 2) -1)
       #t))

(mat fxbit-set?
     (error? (fxbit-set?))
     (error? (fxbit-set? 1))
     (error? (fxbit-set? 1 2 3))
     (error? (fxbit-set? 3.4 5))
     (error? (fxbit-set? 5 "3"))
     (error? (fxbit-set? (+ (most-positive-fixnum) 1) 0))
     (error? (fxbit-set? (- (most-negative-fixnum) 1) 0))
     (error? (fxbit-set? -1 -1))
     (eqv? (do ([i 0 (fx+ i 1)] [a #t (and a (fxbit-set? -1 i))])
               ((fx> i (integer-length (most-positive-fixnum))) a))
           #t)
     (eqv? (do ([i 0 (fx+ i 1)]
                [a #t (and a (fxbit-set? (most-positive-fixnum) i))])
               ((fx= i (integer-length (most-positive-fixnum))) a))
           #t)
     (eqv? (fxbit-set? (most-positive-fixnum)
             (integer-length (most-positive-fixnum)))
           #f)
     (eqv? (fxbit-set? #b0111010110 0) #f)
     (eqv? (fxbit-set? #b0111010110 4) #t)
     (eqv? (fxbit-set? #b0111010110 8) #t)
     (eqv? (fxbit-set? #b0111010110 9) #f)
     (eqv? (fxbit-set? #b0111010110
             (integer-length (most-positive-fixnum)))
           #f)
     (eqv? (fxbit-set? -6 0) #f)
     (eqv? (fxbit-set? -6 1) #t)
     (eqv? (fxbit-set? -6 2) #f)
     (eqv? (do ([i 3 (fx+ i 1)] [a #t (and a (fxbit-set? -6 i))])
               ((fx= i (integer-length (most-positive-fixnum))) a))
           #t)
     ; check to see if we can look as far to the left as we please ...
     (eqv? (fxbit-set? -1 (+ (integer-length (most-positive-fixnum)) 1))
           #t)
     (eqv? (fxbit-set? (most-positive-fixnum)
             (expt (integer-length (most-positive-fixnum)) 2))
           #f)
     (eqv? (fxbit-set? -1 (expt (integer-length (most-positive-fixnum)) 2))
           #t)

     ; make sure we've properly labeled fxbit-set? an arith-pred in primvars.ss
     (begin
       (define ($fxbit-set?-foo x y)
         (if (fxbit-set? x y) 'yes 'no))
       (equal? (list ($fxbit-set?-foo 4 2) ($fxbit-set?-foo 3 3))
               '(yes no)))
     ;; cp0 handler tests
     (test-cp0-expansion eqv?
       '(fxbit-set? (most-positive-fixnum)
          (integer-length (most-positive-fixnum)))
       #f)
     (test-cp0-expansion eqv? '(fxbit-set? #b0111010110 0) #f)
     (test-cp0-expansion eqv? '(fxbit-set? #b0111010110 4) #t)
     (test-cp0-expansion eqv? '(fxbit-set? #b0111010110 8) #t)
     (test-cp0-expansion eqv? '(fxbit-set? #b0111010110 9) #f)
     (test-cp0-expansion eqv?
       '(fxbit-set? #b0111010110 (integer-length (most-positive-fixnum)))
       #f)
     (test-cp0-expansion eqv? '(fxbit-set? -6 0) #f)
     (test-cp0-expansion eqv? '(fxbit-set? -6 1) #t)
     (test-cp0-expansion eqv? '(fxbit-set? -6 2) #f)
     ; check to see if we can look as far to the left as we please ...
     (test-cp0-expansion eqv?
       '(fxbit-set? -1 (+ (integer-length (most-positive-fixnum)) 1))
       #t)
     (test-cp0-expansion eqv?
       '(fxbit-set? (most-positive-fixnum)
          (expt (integer-length (most-positive-fixnum)) 2))
       #f)
     (test-cp0-expansion eqv?
       '(fxbit-set? -1 (expt (integer-length (most-positive-fixnum)) 2))
       #t)

     ; make sure we've properly labeled fxbit-set? an arith-pred in primvars.ss
     (begin
       (define ($fxbit-set?-foo x y)
         (if (parameterize
               ([optimize-level 2]
                [enable-cp0 #t]
                [#%$suppress-primitive-inlining #f])
               (expand/optimize `(fxbit-set? ,x ,y)))
             'yes
             'no))
       (equal? (list ($fxbit-set?-foo 4 2) ($fxbit-set?-foo 3 3))
               '(yes no))))

(mat fxlogbit0
     (error? (fxlogbit0))
     (error? (fxlogbit0 1))
     (error? (fxlogbit0 1 2 3))
     (error? (fxlogbit0 3.4 5))
     (error? (fxlogbit0 5 "3"))
     (error? (fxlogbit0 0 (+ (most-positive-fixnum) 1)))
     (error? (fxlogbit0 0 (- (most-negative-fixnum) 1)))
     (error? (fxlogbit0 -1 -1))
     (error? (fxlogbit0 (integer-length (most-positive-fixnum)) -1))
     (eqv? (fxlogbit0 2 0) 0)
     (eqv? (fxlogbit0 2 -1) -5)
     (eqv? (fxlogbit0 3 #b10101010) #b10100010)
     (eqv? (fxlogbit0 4 #b10101010) #b10101010)
     (andmap values
       (let ([p? (lambda (i) (fx= (fxlogbit0 i -1) (fx- -1 (expt 2 i))))])
         (let f ([i 0])
           (if (fx= i (integer-length (most-positive-fixnum)))
               '()
               (cons (p? i) (f (fx+ i 1)))))))
     (let ([p? (lambda (n i)
                 (fx= (fxlogbit0 i n) (fxlogand (lognot (fxsll 1 i)) n)))])
       (let g ([j 1000])
         (or (fx= j 0)
             (let ([n (+ (random (+ (- (most-positive-fixnum) (most-negative-fixnum))
                                    1))
                         (most-negative-fixnum))])
               (let f ([i 0])
                 (if (fx= i (integer-length (most-positive-fixnum)))
                     (g (fx- j 1))
                     (and (p? n i) (f (fx+ i 1)))))))))
     (test-cp0-expansion eqv? '(fxlogbit0 2 0) 0)
     (test-cp0-expansion eqv? '(fxlogbit0 2 -1) -5)
     (test-cp0-expansion eqv? '(fxlogbit0 3 #b10101010) #b10100010)
     (test-cp0-expansion eqv? '(fxlogbit0 4 #b10101010) #b10101010))

(mat fxlogbit1
     (error? (fxlogbit1))
     (error? (fxlogbit1 1))
     (error? (fxlogbit1 1 2 3))
     (error? (fxlogbit1 3.4 5))
     (error? (fxlogbit1 5 "3"))
     (error? (fxlogbit1 0 (+ (most-positive-fixnum) 1)))
     (error? (fxlogbit1 0 (- (most-negative-fixnum) 1)))
     (error? (fxlogbit1 -1 -1))
     (error? (fxlogbit1 (integer-length (most-positive-fixnum)) 0))
     (eqv? (fxlogbit1 2 0) 4)
     (eqv? (fxlogbit1 2 -1) -1)
     (eqv? (fxlogbit1 3 #b10101010) #b10101010)
     (eqv? (fxlogbit1 4 #b10101010) #b10111010)
     (andmap values
       (let ([p? (lambda (i) (fx= (fxlogbit1 i 0) (ash 1 i)))])
         (let f ([i 0])
           (if (fx= i (integer-length (most-positive-fixnum)))
               '()
               (cons (p? i) (f (fx+ i 1)))))))
     (let ([p? (lambda (n i) (fx= (fxlogbit1 i n) (fxlogor (fxsll 1 i) n)))])
       (let g ([j 1000])
         (or (fx= j 0)
             (let ([n (+ (random (+ (- (most-positive-fixnum) (most-negative-fixnum))
                                    1))
                         (most-negative-fixnum))])
               (let f ([i 0])
                 (if (fx= i (integer-length (most-positive-fixnum)))
                     (g (fx- j 1))
                     (and (p? n i) (f (fx+ i 1)))))))))
     (test-cp0-expansion eqv? '(fxlogbit1 2 0) 4)
     (test-cp0-expansion eqv? '(fxlogbit1 2 -1) -1)
     (test-cp0-expansion eqv? '(fxlogbit1 3 #b10101010) #b10101010)
     (test-cp0-expansion eqv? '(fxlogbit1 4 #b10101010) #b10111010))

(mat fxcopy-bit
     (error? (fxcopy-bit))
     (error? (fxcopy-bit 1))
     (error? (fxcopy-bit 3 1))
     (error? (fxcopy-bit 3 1 0 0))
     (error? (fxcopy-bit 5 3.4 0))
     (error? (fxcopy-bit "3" 5 0))
     (error? (fxcopy-bit (+ (most-positive-fixnum) 1) 0 0))
     (error? (fxcopy-bit (- (most-negative-fixnum) 1) 0 1))
     (error? (fxcopy-bit -1 -1 0))
     (error? (fxcopy-bit -1 -1 1))
     (error? (fxcopy-bit -1 (fx- (fixnum-width) 1) 0))
     (error? (fxcopy-bit -1 (fx- (fixnum-width) 1) 1))
     (eqv? (fxcopy-bit 0 2 0) 0)
     (eqv? (fxcopy-bit -1 2 0) -5)
     (eqv? (fxcopy-bit #b10101010 3 0) #b10100010)
     (eqv? (fxcopy-bit #b10101010 4 0) #b10101010)
     (andmap values
       (let ([p? (lambda (i) (fx= (fxcopy-bit -1 i 0) (fx- -1 (expt 2 i))))])
         (let f ([i 0])
           (if (fx= i (integer-length (most-positive-fixnum)))
               '()
               (cons (p? i) (f (fx+ i 1)))))))
     (let ([p? (lambda (n i)
                 (fx= (fxcopy-bit n i 0) (fxlogand (lognot (fxsll 1 i)) n)))])
       (let g ([j 1000])
         (or (fx= j 0)
             (let ([n (+ (random (+ (- (most-positive-fixnum) (most-negative-fixnum))
                                    1))
                         (most-negative-fixnum))])
               (let f ([i 0])
                 (if (fx= i (integer-length (most-positive-fixnum)))
                     (g (fx- j 1))
                     (and (p? n i) (f (fx+ i 1)))))))))
     (eqv? (fxcopy-bit 0 2 1) 4)
     (eqv? (fxcopy-bit -1 2 1) -1)
     (eqv? (fxcopy-bit #b10101010 3 1) #b10101010)
     (eqv? (fxcopy-bit #b10101010 4 1) #b10111010)
     (andmap values
       (let ([p? (lambda (i) (fx= (fxcopy-bit 0 i 1) (ash 1 i)))])
         (let f ([i 0])
           (if (fx= i (integer-length (most-positive-fixnum)))
               '()
               (cons (p? i) (f (fx+ i 1)))))))
     (let ([p? (lambda (n i)
                 (fx= (fxcopy-bit n i 1) (fxlogor (fxsll 1 i) n)))])
       (let g ([j 1000])
         (or (fx= j 0)
             (let ([n (+ (random (+ (- (most-positive-fixnum) (most-negative-fixnum))
                                    1))
                         (most-negative-fixnum))])
               (let f ([i 0])
                 (if (fx= i (integer-length (most-positive-fixnum)))
                     (g (fx- j 1))
                     (and (p? n i) (f (fx+ i 1)))))))))
     ;; cp0 handler tests
     (test-cp0-expansion eqv? '(fxcopy-bit 0 2 1) 4)
     (test-cp0-expansion eqv? '(fxcopy-bit -1 2 1) -1)
     (test-cp0-expansion eqv? '(fxcopy-bit #b10101010 3 1) #b10101010)
     (test-cp0-expansion eqv? '(fxcopy-bit #b10101010 4 1) #b10111010)
     (andmap values
       (let ([p? (lambda (i)
                   (fx= (parameterize
                          ([optimize-level 2]
                           [enable-cp0 #t]
                           [#%$suppress-primitive-inlining #f])
                          (expand/optimize `(fxcopy-bit 0 ,i 1)))
                        (ash 1 i)))])
         (let f ([i 0])
           (if (fx= i (integer-length (most-positive-fixnum)))
               '()
               (cons (p? i) (f (fx+ i 1)))))))
     (let ([p? (lambda (n i)
                 (fx= (parameterize
                        ([optimize-level 2]
                         [enable-cp0 #t]
                         [#%$suppress-primitive-inlining #f])
                        (expand/optimize `(fxcopy-bit ,n ,i 1)))
                      (fxlogor (fxsll 1 i) n)))])
       (let g ([j 1000])
         (or (fx= j 0)
             (let ([n (+ (random (+ (- (most-positive-fixnum) (most-negative-fixnum))
                                    1))
                         (most-negative-fixnum))])
               (let f ([i 0])
                 (if (fx= i (integer-length (most-positive-fixnum)))
                     (g (fx- j 1))
                     (and (p? n i) (f (fx+ i 1))))))))))

(mat fxcopy-bit-field
     (error? (fxcopy-bit-field))
     (error? (fxcopy-bit-field 1))
     (error? (fxcopy-bit-field 3 1))
     (error? (fxcopy-bit-field 3 1 0))
     (error? (fxcopy-bit-field 3 1 0 0 0))
     (error? (fxcopy-bit-field "3" 0 0 0))
     (error? (fxcopy-bit-field 0 3.4 0 0))
     (error? (fxcopy-bit-field 0 0 3/4 0))
     (error? (fxcopy-bit-field 0 0 0 'spam))
     (error? (fxcopy-bit-field (+ (most-positive-fixnum) 1) 0 0 0))
     (error? (fxcopy-bit-field (- (most-negative-fixnum) 1) 0 0 0))
     (error? (fxcopy-bit-field 0 (+ (most-positive-fixnum) 1) 0 0))
     (error? (fxcopy-bit-field 0 (- (most-negative-fixnum) 1) 0 0))
     (error? (fxcopy-bit-field 0 0 (+ (most-positive-fixnum) 1) 0))
     (error? (fxcopy-bit-field 0 0 (- (most-negative-fixnum) 1) 0))
     (error? (fxcopy-bit-field 0 0 0 (+ (most-positive-fixnum) 1)))
     (error? (fxcopy-bit-field 0 0 0 (+ (most-positive-fixnum) 1)))
     (error? (fxcopy-bit-field 0 -1 0 0))
     (error? (fxcopy-bit-field 0 0 -1 0))
     (error? (fxcopy-bit-field 0 (fixnum-width) (fixnum-width) 0))
     (error? (fxcopy-bit-field 0 0 (fixnum-width) 0))
     (error? (fxcopy-bit-field 0 1 0 0))
     (error? (fxcopy-bit-field 0 5 2 0))
     (error? (fxcopy-bit-field 0
               (fx- (fixnum-width) 1)
               (fx- (fixnum-width) 2)
               0))
     (eqv? (fxcopy-bit-field 0 2 3 0) 0)
     (eqv? (fxcopy-bit-field 0 2 3 -1) 4)
     (eqv? (fxcopy-bit-field -1 2 3 0) -5)
     (eqv? (fxcopy-bit-field -1 0 3 0) -8)
     (eqv? (fxcopy-bit-field 0 0 3 -1) 7)
     (eqv? (fxcopy-bit-field #b10101010 3 4 0) #b10100010)
     (eqv? (fxcopy-bit-field #b10101010 4 5 0) #b10101010)
     (eqv? (fxcopy-bit-field #b10101010 0 4 0) #b10100000)
     (eqv? (fxcopy-bit-field #b10101010 0 4 #b0101) #b10100101)
     (begin
       (define $fxbf1
         (let ([fb (fixnum-width)])
           (lambda (x v)
             (list (fxcopy-bit-field x 0 (- fb 1) v)
                   (fxcopy-bit-field x 20 (- fb 1) v)))))
       #t)
     (equal? ($fxbf1 0 0) '(0 0))
     (equal? ($fxbf1 0 -1)
       (list (most-positive-fixnum)
             (- (most-positive-fixnum) (- (expt 2 20) 1))))
     (equal? ($fxbf1 -1 0)
       (list (most-negative-fixnum)
             (+ (most-negative-fixnum) (- (expt 2 20) 1))))

     (andmap values
       (let ([p? (lambda (i)
                   (fx= (fxcopy-bit-field -1 i (fx+ i 1) 0)
                        (fx- -1 (expt 2 i))))])
         (let f ([i 0])
           (if (fx= i (integer-length (most-positive-fixnum)))
               '()
               (cons (p? i) (f (fx+ i 1)))))))
     (let ([p? (lambda (n i)
                 (fx= (fxcopy-bit-field n i (fx+ i 1) 0)
                      (fxlogand (lognot (fxsll 1 i)) n)))])
       (let g ([j 1000])
         (or (fx= j 0)
             (let ([n (+ (random (+ (- (most-positive-fixnum) (most-negative-fixnum))
                                    1))
                         (most-negative-fixnum))])
               (let f ([i 0])
                 (if (fx= i (integer-length (most-positive-fixnum)))
                     (g (fx- j 1))
                     (and (p? n i) (f (fx+ i 1)))))))))
     (eqv? (fxcopy-bit-field 0 2 3 1) 4)
     (eqv? (fxcopy-bit-field -1 2 3 1) -1)
     (eqv? (fxcopy-bit-field #b10101010 3 4 1) #b10101010)
     (eqv? (fxcopy-bit-field #b10101010 4 5 1) #b10111010)
     (andmap values
       (let ([p? (lambda (i)
                   (fx= (fxcopy-bit-field 0 i (fx+ i 1) 1) (ash 1 i)))])
         (let f ([i 0])
           (if (fx= i (integer-length (most-positive-fixnum)))
               '()
               (cons (p? i) (f (fx+ i 1)))))))
     (let ([p? (lambda (n i)
                 (fx= (fxcopy-bit-field n i (fx+ i 1) 1)
                      (fxlogor (fxsll 1 i) n)))])
       (let g ([j 1000])
         (or (fx= j 0)
             (let ([n (+ (random (+ (- (most-positive-fixnum) (most-negative-fixnum))
                                    1))
                         (most-negative-fixnum))])
               (let f ([i 0])
                 (if (fx= i (integer-length (most-positive-fixnum)))
                     (g (fx- j 1))
                     (and (p? n i) (f (fx+ i 1)))))))))
     (let ([p? (lambda (n i)
                 (fx= (fxcopy-bit-field n i (fx+ i 3) #b110110101)
                      (fxior (fxsll #b101 i) (fxcopy-bit n (fx+ i 1) 0))))])
       (let g ([j 1000])
         (or (fx= j 0)
             (let ([n (+ (random (+ (- (most-positive-fixnum) (most-negative-fixnum))
                                    1))
                         (most-negative-fixnum))])
               (let f ([i 0])
                 (if (fx= i
                          (fx- (integer-length (most-positive-fixnum)) 3))
                     (g (fx- j 1))
                     (and (p? n i) (f (fx+ i 1)))))))))

     (test-cp0-expansion eqv? '(fxcopy-bit-field 0 2 3 0) 0)
     (test-cp0-expansion eqv? '(fxcopy-bit-field 0 2 3 -1) 4)
     (test-cp0-expansion eqv? '(fxcopy-bit-field -1 2 3 0) -5)
     (test-cp0-expansion eqv? '(fxcopy-bit-field -1 0 3 0) -8)
     (test-cp0-expansion eqv? '(fxcopy-bit-field 0 0 3 -1) 7)
     (test-cp0-expansion eqv?
       '(fxcopy-bit-field #b10101010 3 4 0)
       #b10100010)
     (test-cp0-expansion eqv?
       '(fxcopy-bit-field #b10101010 4 5 0)
       #b10101010)
     (test-cp0-expansion eqv?
       '(fxcopy-bit-field #b10101010 0 4 0)
       #b10100000)
     (test-cp0-expansion eqv?
       '(fxcopy-bit-field #b10101010 0 4 #b0101)
       #b10100101)
     (test-cp0-expansion eqv? '(fxcopy-bit-field 0 2 3 1) 4)
     (test-cp0-expansion eqv? '(fxcopy-bit-field -1 2 3 1) -1)
     (test-cp0-expansion eqv?
       '(fxcopy-bit-field #b10101010 3 4 1)
       #b10101010)
     (test-cp0-expansion eqv?
       '(fxcopy-bit-field #b10101010 4 5 1)
       #b10111010))

(mat fxdiv-and-mod
     ; fxdiv-and-mod
     (error? (fxdiv-and-mod 17 3.0))
     (error? (fxdiv-and-mod 3.0 17))
     (error? (fxdiv-and-mod 'a 17))
     (error? (fxdiv-and-mod 17 '(a)))
     (error? (fxdiv-and-mod 17 0))
     (error? (fxdiv-and-mod -17 0))
     (error? (fxdiv-and-mod (most-negative-fixnum) -1))
     ; fxdiv
     (error? (fxdiv 17 3.0))
     (error? (fxdiv 3.0 17))
     (error? (fxdiv 'a 17))
     (error? (fxdiv 17 '(a)))
     (error? (fxdiv 17 0))
     (error? (fxdiv -17 0))
     (error? (fxdiv (most-negative-fixnum) -1))
     ; fxmod
     (error? (fxmod 17 3.0))
     (error? (fxmod 3.0 17))
     (error? (fxmod 'a 17))
     (error? (fxmod 17 '(a)))
     (error? (fxmod 17 0))
     (error? (fxmod -17 0))
     ; no overflow for fxmod:
     (eqv? (fxmod (most-negative-fixnum) -1) 0)
     ; fxdiv-and-mod
     (begin
       (define $d&m fxdiv-and-mod)
       (define ($dmpair x y)
         (and (not (fx= y 0))
              (call-with-values (lambda () ($d&m x y)) cons)))
       (define ($dmpairs x y)
         (list ($dmpair x y)
               ($dmpair (- x) y)
               ($dmpair x (- y))
               ($dmpair (- x) (- y))
               ($dmpair y x)
               ($dmpair (- y) x)
               ($dmpair y (- x))
               ($dmpair (- y) (- x))))
       #t)
     (equal? ($dmpairs 0 5) '((0 . 0) (0 . 0) (0 . 0) (0 . 0) #f #f #f #f))
     (equal? ($dmpairs 15 37)
       '((0 . 15)
         (-1 . 22)
         (0 . 15)
         (1 . 22)
         (2 . 7)
         (-3 . 8)
         (-2 . 7)
         (3 . 8)))
     (equal? ($dmpairs 24 8)
       '((3 . 0)
         (-3 . 0)
         (-3 . 0)
         (3 . 0)
         (0 . 8)
         (-1 . 16)
         (0 . 8)
         (1 . 16)))
     ; fxdiv with fxmod
     (begin
       (set! $d&m
         (lambda (x y) (values (fxdiv x y) (fxmod x y))))
       #t)
     (equal? ($dmpairs 0 5) '((0 . 0) (0 . 0) (0 . 0) (0 . 0) #f #f #f #f))
     (equal? ($dmpairs 15 37)
       '((0 . 15)
         (-1 . 22)
         (0 . 15)
         (1 . 22)
         (2 . 7)
         (-3 . 8)
         (-2 . 7)
         (3 . 8)))
     (equal? ($dmpairs 24 8)
       '((3 . 0)
         (-3 . 0)
         (-3 . 0)
         (3 . 0)
         (0 . 8)
         (-1 . 16)
         (0 . 8)
         (1 . 16)))
     (equal? (map (lambda (x) (fxdiv x 64))
                  '(0 5 31 32 33 63 64 65 127 128 129))
             '(0 0 0 0 0 0 1 1 1 2 2))
     (equal? (map (lambda (x)
                    (parameterize
                      ([optimize-level 2]
                       [enable-cp0 #t]
                       [#%$suppress-primitive-inlining #f])
                      (expand/optimize `(fxdiv ,x 64))))
                  '(0 5 31 32 33 63 64 65 127 128 129))
             '(0 0 0 0 0 0 1 1 1 2 2))
     (equal? (map (lambda (x)
                    (parameterize
                      ([optimize-level 2]
                       [enable-cp0 #t]
                       [#%$suppress-primitive-inlining #f])
                      (expand/optimize `(fxmod ,x 64))))
                  '(0 5 31 32 33 63 64 65 127 128 129))
             '(0 5 31 32 33 63 0 1 63 0 1))
     (equal? (map (lambda (x) (let-values ([ls (fxdiv-and-mod x 64)]) ls))
                  '(0 5 31 32 33 63 64 65 127 128 129))
             '((0 0)
               (0 5)
               (0 31)
               (0 32)
               (0 33)
               (0 63)
               (1 0)
               (1 1)
               (1 63)
               (2 0)
               (2 1)))
     (equal? (map (lambda (x) (fxdiv x 64))
                  '(0 -5 -31 -32 -33 -63 -64 -65 -127 -128 -129))
             '(0 -1 -1 -1 -1 -1 -1 -2 -2 -2 -3))
     (equal? (map (lambda (x)
                    (parameterize
                      ([optimize-level 2]
                       [enable-cp0 #t]
                       [#%$suppress-primitive-inlining #f])
                      (expand/optimize `(fxdiv ,x 64))))
                  '(0 -5 -31 -32 -33 -63 -64 -65 -127 -128 -129))
             '(0 -1 -1 -1 -1 -1 -1 -2 -2 -2 -3))
     (equal? (map (lambda (x) (fxmod x 64))
                  '(0 -5 -31 -32 -33 -63 -64 -65 -127 -128 -129))
             '(0 59 33 32 31 1 0 63 1 0 63))
     (equal? (map (lambda (x)
                    (parameterize
                      ([optimize-level 2]
                       [enable-cp0 #t]
                       [#%$suppress-primitive-inlining #f])
                      (expand/optimize `(fxmod ,x 64))))
                  '(0 -5 -31 -32 -33 -63 -64 -65 -127 -128 -129))
             '(0 59 33 32 31 1 0 63 1 0 63))
     (equal? (map (lambda (x) (let-values ([ls (fxdiv-and-mod x 64)]) ls))
                  '(0 -5 -31 -32 -33 -63 -64 -65 -127 -128 -129))
             '((0 0)
               (-1 59)
               (-1 33)
               (-1 32)
               (-1 31)
               (-1 1)
               (-1 0)
               (-2 63)
               (-2 1)
               (-2 0)
               (-3 63))))

(mat fxdiv0-and-mod0
     ; fxdiv0-and-mod0
     (error? (fxdiv0-and-mod0 17 3.0))
     (error? (fxdiv0-and-mod0 3.0 17))
     (error? (fxdiv0-and-mod0 'a 17))
     (error? (fxdiv0-and-mod0 17 '(a)))
     (error? (fxdiv0-and-mod0 17 0))
     (error? (fxdiv0-and-mod0 -17 0))
     (error? (fxdiv0-and-mod0 (most-negative-fixnum) -1))
     ; fxdiv0
     (error? (fxdiv0 17 3.0))
     (error? (fxdiv0 3.0 17))
     (error? (fxdiv0 'a 17))
     (error? (fxdiv0 17 '(a)))
     (error? (fxdiv0 17 0))
     (error? (fxdiv0 -17 0))
     (error? (fxdiv0 (most-negative-fixnum) -1))
     ; fxmod0
     (error? (fxmod0 17 3.0))
     (error? (fxmod0 3.0 17))
     (error? (fxmod0 'a 17))
     (error? (fxmod0 17 '(a)))
     (error? (fxmod0 17 0))
     (error? (fxmod0 -17 0))
     ; no overflow for fxmod0:
     (eqv? (fxmod0 (most-negative-fixnum) -1) 0)
     ; fxdiv0-and-mod0
     (begin
       (define $d&m fxdiv0-and-mod0)
       (define ($dmpair x y)
         (and (not (fx= y 0))
              (call-with-values (lambda () ($d&m x y)) cons)))
       (define ($dmpairs x y)
         (list ($dmpair x y)
               ($dmpair (- x) y)
               ($dmpair x (- y))
               ($dmpair (- x) (- y))
               ($dmpair y x)
               ($dmpair (- y) x)
               ($dmpair y (- x))
               ($dmpair (- y) (- x))))
       #t)
     (equal? ($dmpairs 0 5) '((0 . 0) (0 . 0) (0 . 0) (0 . 0) #f #f #f #f))
     (equal? ($dmpairs 15 37)
       '((0 . 15)
         (0 . -15)
         (0 . 15)
         (0 . -15)
         (2 . 7)
         (-2 . -7)
         (-2 . 7)
         (2 . -7)))
     ; fxdiv0 with fxmod0
     (begin
       (set! $d&m
         (lambda (x y) (values (fxdiv0 x y) (fxmod0 x y))))
       #t)
     (equal? ($dmpairs 0 5) '((0 . 0) (0 . 0) (0 . 0) (0 . 0) #f #f #f #f))
     (equal? ($dmpairs 15 37)
       '((0 . 15)
         (0 . -15)
         (0 . 15)
         (0 . -15)
         (2 . 7)
         (-2 . -7)
         (-2 . 7)
         (2 . -7)))
     (equal? (map (lambda (x) (fxdiv0 x 64))
                  '(0 5 31 32 33 63 64 65 127 128 129))
             '(0 0 0 1 1 1 1 1 2 2 2))
     (equal? (map (lambda (x)
                    (parameterize
                      ([optimize-level 2]
                       [enable-cp0 #t]
                       [#%$suppress-primitive-inlining #f])
                      (expand/optimize `(fxdiv0 ,x 64))))
                  '(0 5 31 32 33 63 64 65 127 128 129))
             '(0 0 0 1 1 1 1 1 2 2 2))
     (equal? (map (lambda (x) (fxmod0 x 64))
                  '(0 5 31 32 33 63 64 65 127 128 129))
             '(0 5 31 -32 -31 -1 0 1 -1 0 1))
     (equal? (map (lambda (x)
                    (parameterize
                      ([optimize-level 2]
                       [enable-cp0 #t]
                       [#%$suppress-primitive-inlining #f])
                      (expand/optimize `(fxmod0 ,x 64))))
                  '(0 5 31 32 33 63 64 65 127 128 129))
             '(0 5 31 -32 -31 -1 0 1 -1 0 1))
     (equal? (map (lambda (x)
                    (let-values ([ls (fxdiv0-and-mod0 x 64)])
                      ls))
                  '(0 5 31 32 33 63 64 65 127 128 129))
             '((0 0)
               (0 5)
               (0 31)
               (1 -32)
               (1 -31)
               (1 -1)
               (1 0)
               (1 1)
               (2 -1)
               (2 0)
               (2 1)))
     (equal? (map (lambda (x) (fxdiv0 x 64))
                  '(0 -5 -31 -32 -33 -63 -64 -65 -127 -128 -129))
             '(0 0 0 0 -1 -1 -1 -1 -2 -2 -2))
     (equal? (map (lambda (x) (fxmod0 x 64))
                  '(0 -5 -31 -32 -33 -63 -64 -65 -127 -128 -129))
             '(0 -5 -31 -32 31 1 0 -1 1 0 -1))
     (equal? (map (lambda (x)
                    (let-values ([ls (fxdiv0-and-mod0 x 64)])
                      ls))
                  '(0 -5 -31 -32 -33 -63 -64 -65 -127 -128 -129))
             '((0 0)
               (0 -5)
               (0 -31)
               (0 -32)
               (-1 31)
               (-1 1)
               (-1 0)
               (-1 -1)
               (-2 1)
               (-2 0)
               (-2 -1))))

(mat fx+/carry
     (error? (fx+/carry))
     (error? (fx+/carry 1))
     (error? (fx+/carry 1 2))
     (error? (fx+/carry 1 2 3 4))
     (error? (fx+/carry 1.0 2 3))
     (error? (fx+/carry 1 2.0 3))
     (error? (fx+/carry 1 2 3.0))
     (error? (fx+/carry 1/2 2 3))
     (error? (fx+/carry 1 2/3 3))
     (error? (fx+/carry 1 2 3/4))
     (error? (fx+/carry 'a 2 3))
     (error? (fx+/carry 1 'b 3))
     (error? (fx+/carry 1 2 'c))
     (error? (fx+/carry (+ (greatest-fixnum) 1) 2 3))
     (error? (fx+/carry 1 (+ (greatest-fixnum) 1) 3))
     (error? (fx+/carry 1 2 (+ (greatest-fixnum) 1)))
     (error? (fx+/carry (- (least-fixnum) 1) 2 3))
     (error? (fx+/carry 1 (- (least-fixnum) 1) 3))
     (error? (fx+/carry 1 2 (- (least-fixnum) 1)))
     (let ()
       (define (r6rs-fx+/carry fx1 fx2 fx3)
         (let ([s (+ fx1 fx2 fx3)])
           (values (mod0 s (expt 2 (fixnum-width)))
                   (div0 s (expt 2 (fixnum-width))))))
       (define-syntax eqv2?
         (syntax-rules ()
           [(_ x y)
            (let-values ([(x1 x2) x] [(y1 y2) y])
              (and (eqv? x1 y1) (eqv? x2 y2)))]))
       (let ([m (- (+ (greatest-fixnum) 1) (least-fixnum))])
         (define (mrandom)
           (- (+ (greatest-fixnum) 1) (random m)))
         (let f ([n 1000])
           (unless (fx= n 0)
                   (let ([x (mrandom)] [y (mrandom)] [z (mrandom)])
                     (unless (eqv2? (fx+/carry x y z) (r6rs-fx+/carry x y z))
                             (errorf #f "failed for ~s, ~s, ~s" x y z)))
                   (f (fx- n 1)))))
       #t)
     (let-values ([(r c) (fx+/carry 100 20 3)])
       (and (= r 123) (= c 0)))
     (equal? (parameterize
               ([optimize-level 2]
                [enable-cp0 #t]
                [#%$suppress-primitive-inlining #f])
               (expand/optimize '(fx+/carry 100 20 3)))
             '(#3%values 123 0)))

(mat fx-/carry
     (error? (fx-/carry))
     (error? (fx-/carry 1))
     (error? (fx-/carry 1 2))
     (error? (fx-/carry 1 2 3 4))
     (error? (fx-/carry 1.0 2 3))
     (error? (fx-/carry 1 2.0 3))
     (error? (fx-/carry 1 2 3.0))
     (error? (fx-/carry 1/2 2 3))
     (error? (fx-/carry 1 2/3 3))
     (error? (fx-/carry 1 2 3/4))
     (error? (fx-/carry 'a 2 3))
     (error? (fx-/carry 1 'b 3))
     (error? (fx-/carry 1 2 'c))
     (error? (fx-/carry (+ (greatest-fixnum) 1) 2 3))
     (error? (fx-/carry 1 (+ (greatest-fixnum) 1) 3))
     (error? (fx-/carry 1 2 (+ (greatest-fixnum) 1)))
     (error? (fx-/carry (- (least-fixnum) 1) 2 3))
     (error? (fx-/carry 1 (- (least-fixnum) 1) 3))
     (error? (fx-/carry 1 2 (- (least-fixnum) 1)))
     (let ()
       (define (r6rs-fx-/carry fx1 fx2 fx3)
         (let ([s (- fx1 fx2 fx3)])
           (values (mod0 s (expt 2 (fixnum-width)))
                   (div0 s (expt 2 (fixnum-width))))))
       (define-syntax eqv2?
         (syntax-rules ()
           [(_ x y)
            (let-values ([(x1 x2) x] [(y1 y2) y])
              (and (eqv? x1 y1) (eqv? x2 y2)))]))
       (let ([m (- (+ (greatest-fixnum) 1) (least-fixnum))])
         (define (mrandom)
           (- (+ (greatest-fixnum) 1) (random m)))
         (let f ([n 1000])
           (unless (fx= n 0)
                   (let ([x (mrandom)] [y (mrandom)] [z (mrandom)])
                     (unless (eqv2? (fx-/carry x y z) (r6rs-fx-/carry x y z))
                             (errorf #f "failed for ~s, ~s, ~s" x y z)))
                   (f (fx- n 1)))))
       #t)
     (let-values ([(r c) (fx-/carry 100 20 3)])
       (and (= r 77) (= c 0)))
     (equal? (parameterize
               ([optimize-level 2]
                [enable-cp0 #t]
                [#%$suppress-primitive-inlining #f])
               (expand/optimize '(fx-/carry 100 20 3)))
             '(#3%values 77 0)))

(mat fx*/carry
     (error? (fx*/carry))
     (error? (fx*/carry 1))
     (error? (fx*/carry 1 2))
     (error? (fx*/carry 1 2 3 4))
     (error? (fx*/carry 1.0 2 3))
     (error? (fx*/carry 1 2.0 3))
     (error? (fx*/carry 1 2 3.0))
     (error? (fx*/carry 1/2 2 3))
     (error? (fx*/carry 1 2/3 3))
     (error? (fx*/carry 1 2 3/4))
     (error? (fx*/carry 'a 2 3))
     (error? (fx*/carry 1 'b 3))
     (error? (fx*/carry 1 2 'c))
     (error? (fx*/carry (+ (greatest-fixnum) 1) 2 3))
     (error? (fx*/carry 1 (+ (greatest-fixnum) 1) 3))
     (error? (fx*/carry 1 2 (+ (greatest-fixnum) 1)))
     (error? (fx*/carry (- (least-fixnum) 1) 2 3))
     (error? (fx*/carry 1 (- (least-fixnum) 1) 3))
     (error? (fx*/carry 1 2 (- (least-fixnum) 1)))
     (let ()
       (define (r6rs-fx*/carry fx1 fx2 fx3)
         (let ([s (+ (* fx1 fx2) fx3)])
           (values (mod0 s (expt 2 (fixnum-width)))
                   (div0 s (expt 2 (fixnum-width))))))
       (define-syntax eqv2?
         (syntax-rules ()
           [(_ x y)
            (let-values ([(x1 x2) x] [(y1 y2) y])
              (and (eqv? x1 y1) (eqv? x2 y2)))]))
       (let ([m (- (+ (greatest-fixnum) 1) (least-fixnum))])
         (define (mrandom)
           (- (+ (greatest-fixnum) 1) (random m)))
         (let f ([n 1000])
           (unless (fx= n 0)
                   (let ([x (mrandom)] [y (mrandom)] [z (mrandom)])
                     (unless (eqv2? (fx*/carry x y z) (r6rs-fx*/carry x y z))
                             (errorf #f "failed for ~s, ~s, ~s" x y z)))
                   (f (fx- n 1)))))
       #t)
     (let-values ([(r c) (fx*/carry 100 20 3)])
       (and (= r 2003) (= c 0)))
     (equal? (parameterize
               ([optimize-level 2]
                [enable-cp0 #t]
                [#%$suppress-primitive-inlining #f])
               (expand/optimize '(fx*/carry 100 20 3)))
             '(#3%values 2003 0)))

(mat fxrotate-bit-field
     (error? (fxrotate-bit-field))
     (error? (fxrotate-bit-field 0))
     (error? (fxrotate-bit-field 0 0))
     (error? (fxrotate-bit-field 0 0 0))
     (error? (fxrotate-bit-field 0 0 0 0 0))
     (error? (fxrotate-bit-field 'a 0 0 0))
     (error? (fxrotate-bit-field 0 0.0 0 0))
     (error? (fxrotate-bit-field 0 0 2.0 0))
     (error? (fxrotate-bit-field 0 0 0 3/4))
     (error? (fxrotate-bit-field 0 -1 0 0))
     (error? (fxrotate-bit-field 0 0 -1 0))
     (error? (fxrotate-bit-field 0 0 0 -1))
     (error? (fxrotate-bit-field 0 -10 -5 0))
     (error? (fxrotate-bit-field (+ (most-positive-fixnum) 1) 0 0 0))
     (error? (fxrotate-bit-field (- (most-negative-fixnum) 1) 0 0 0))
     (error? (fxrotate-bit-field 0 (fixnum-width) 0 0))
     (error? (fxrotate-bit-field 0 (+ (most-positive-fixnum) 1) 0 0))
     (error? (fxrotate-bit-field 0 (- (most-negative-fixnum) 1) 0 0))
     (error? (fxrotate-bit-field 0 0 (fixnum-width) 0))
     (error? (fxrotate-bit-field 0 0 (+ (most-positive-fixnum) 1) 0))
     (error? (fxrotate-bit-field 0 0 (- (most-negative-fixnum) 1) 0))
     (error? (fxrotate-bit-field 0 0 0 (+ (most-positive-fixnum) 1)))
     (error? (fxrotate-bit-field 0 0 0 (- (most-negative-fixnum) 1)))
     (error? (fxrotate-bit-field 0 7 5 0))
     (error? (fxrotate-bit-field 0
               (+ (most-positive-fixnum) 1)
               (most-positive-fixnum)
               0))
     (error? (fxrotate-bit-field 0
               (+ (most-positive-fixnum) 2)
               (+ (most-positive-fixnum) 1)
               0))
     (error? (fxrotate-bit-field 0 5 5 1))
     (eqv? (fxrotate-bit-field #b10101010 5 5 0) #b10101010)
     (eqv? (fxrotate-bit-field 0 0 1 0) 0)
     (eqv? (fxrotate-bit-field -1 0 1 0) -1)
     (eqv? (fxrotate-bit-field #b101101011101111 2 7 3) #b101101011111011)
     (eqv? (fxrotate-bit-field
             (greatest-fixnum)
             0
             (fx- (fixnum-width) 1)
             15)
           (greatest-fixnum))
     (eqv? (fxrotate-bit-field
             (greatest-fixnum)
             0
             (fx- (fixnum-width) 1)
             (fx- (fixnum-width) 2))
           (greatest-fixnum))
     (eqv? (fxrotate-bit-field (least-fixnum) 0 (fx- (fixnum-width) 1) 15)
           (least-fixnum))
     (eqv? (fxrotate-bit-field
             (least-fixnum)
             0
             (fx- (fixnum-width) 1)
             (fx- (fixnum-width) 2))
           (least-fixnum))
     (eqv? (fxrotate-bit-field -1 0 (fx- (fixnum-width) 1) 15) -1)
     (eqv? (fxrotate-bit-field
             -1
             0
             (fx- (fixnum-width) 1)
             (fx- (fixnum-width) 2))
           -1)
     (let ()
       (define (r6rs-bitwise-rotate-bit-field ei1 ei2 ei3 ei4)
         (let* ([n ei1]
                [start ei2]
                [end ei3]
                [count ei4]
                [width (- end start)])
           (if (positive? width)
               (let* ([count (mod count width)]
                      [field0 (bitwise-bit-field n start end)]
                      [field1 (bitwise-arithmetic-shift-left field0 count)]
                      [field2 (bitwise-arithmetic-shift-right field0
                                (- width count))]
                      [field (bitwise-ior field1 field2)])
                 (bitwise-copy-bit-field n start end field))
               n)))
       (do ([n 500 (fx- n 1)])
           ((fx= n 0) #t)
           (let ([x (random (+ (most-positive-fixnum) 1))])
             (let ([i (random (fixnum-width))] [j (random (fixnum-width))])
               (let-values ([(i j) (if (< i j) (values i j) (values j i))])
                 (unless (fx= i j)
                         (let ([k (random (fx- j i))])
                           (unless (and (= (fxrotate-bit-field x i j k)
                                           (r6rs-bitwise-rotate-bit-field x i j k))
                                        (= (fxrotate-bit-field (- x) i j k)
                                           (r6rs-bitwise-rotate-bit-field (- x) i j k)))
                                   (errorf #f "failed for ~s ~s ~s ~s" x i j k)))))))))
     (test-cp0-expansion eqv?
       '(fxrotate-bit-field #b10101010 5 5 0)
       #b10101010)
     (test-cp0-expansion eqv? '(fxrotate-bit-field 0 0 1 0) 0)
     (test-cp0-expansion eqv? '(fxrotate-bit-field -1 0 1 0) -1)
     (test-cp0-expansion eqv?
       '(fxrotate-bit-field #b101101011101111 2 7 3)
       #b101101011111011)
     (test-cp0-expansion eqv?
       '(fxrotate-bit-field (greatest-fixnum) 0 (fx- (fixnum-width) 1) 15)
       (greatest-fixnum))
     (test-cp0-expansion eqv?
       '(fxrotate-bit-field
          (greatest-fixnum)
          0
          (fx- (fixnum-width) 1)
          (fx- (fixnum-width) 2))
       (greatest-fixnum))
     (test-cp0-expansion eqv?
       '(fxrotate-bit-field (least-fixnum) 0 (fx- (fixnum-width) 1) 15)
       (least-fixnum))
     (test-cp0-expansion eqv?
       '(fxrotate-bit-field
          (least-fixnum)
          0
          (fx- (fixnum-width) 1)
          (fx- (fixnum-width) 2))
       (least-fixnum))
     (test-cp0-expansion eqv?
       '(fxrotate-bit-field -1 0 (fx- (fixnum-width) 1) 15)
       -1)
     (test-cp0-expansion eqv?
       '(fxrotate-bit-field
          -1
          0
          (fx- (fixnum-width) 1)
          (fx- (fixnum-width) 2))
       -1))

(mat fxreverse-bit-field
     (error? (fxreverse-bit-field))
     (error? (fxreverse-bit-field 0))
     (error? (fxreverse-bit-field 0 0))
     (error? (fxreverse-bit-field 0 0 0 0))
     (error? (fxreverse-bit-field 'a 0 0))
     (error? (fxreverse-bit-field 0 0.0 0))
     (error? (fxreverse-bit-field 0 0 2.0))
     (error? (fxreverse-bit-field 0 -1 0))
     (error? (fxreverse-bit-field 0 0 -1))
     (error? (fxreverse-bit-field 0 -10 -5))
     (error? (fxreverse-bit-field (+ (most-positive-fixnum) 1) 0 0))
     (error? (fxreverse-bit-field (- (most-negative-fixnum) 1) 0 0))
     (error? (fxreverse-bit-field 0 (fixnum-width) 0))
     (error? (fxreverse-bit-field 0 (+ (most-positive-fixnum) 1) 0))
     (error? (fxreverse-bit-field 0 (- (most-negative-fixnum) 1) 0))
     (error? (fxreverse-bit-field 0 0 (fixnum-width)))
     (error? (fxreverse-bit-field 0 0 (+ (most-positive-fixnum) 1)))
     (error? (fxreverse-bit-field 0 0 (- (most-negative-fixnum) 1)))
     (error? (fxreverse-bit-field 0 7 5))
     (eqv? (fxreverse-bit-field 0 0 10) 0)
     (eqv? (fxreverse-bit-field -1 0 10) -1)
     (eqv? (fxreverse-bit-field #b101101011101111 2 7) #b101101011101111)
     (eqv? (fxreverse-bit-field #b101101011101111 3 9) #b101101101110111)
     (eqv? (fxreverse-bit-field (greatest-fixnum) 0 (fx- (fixnum-width) 1))
           (greatest-fixnum))
     (eqv? (fxreverse-bit-field (greatest-fixnum) 0 (fx- (fixnum-width) 1))
           (greatest-fixnum))
     (eqv? (fxreverse-bit-field (least-fixnum) 0 (fx- (fixnum-width) 1))
           (least-fixnum))
     (eqv? (fxreverse-bit-field (least-fixnum) 0 (fx- (fixnum-width) 1))
           (least-fixnum))
     (eqv? (fxreverse-bit-field -1 0 (fx- (fixnum-width) 1)) -1)
     (eqv? (fxreverse-bit-field -1 0 (fx- (fixnum-width) 1)) -1)
     (let ()
       (define (refimpl n start end)
         (define (swap n i j)
           (fxcopy-bit
             (fxcopy-bit n i (fxbit-field n j (fx+ j 1)))
             j
             (fxbit-field n i (fx+ i 1))))
         (let ([end (fx- end 1)])
           (if (fx>= start end)
               n
               (refimpl (swap n start end) (fx+ start 1) end))))
       (do ([n 500 (fx- n 1)])
           ((fx= n 0) #t)
           (let ([x (random (+ (most-positive-fixnum) 1))])
             (let ([i (random (fixnum-width))] [j (random (fixnum-width))])
               (let-values ([(i j) (if (< i j) (values i j) (values j i))])
                 (unless (and (= (fxreverse-bit-field x i j) (refimpl x i j))
                              (= (fxreverse-bit-field (- x) i j)
                                 (refimpl (- x) i j)))
                         (errorf #f "failed for ~s ~s ~s" x i j)))))))
     (test-cp0-expansion eqv? '(fxreverse-bit-field 0 0 10) 0)
     (test-cp0-expansion eqv? '(fxreverse-bit-field -1 0 10) -1)
     (test-cp0-expansion eqv?
       '(fxreverse-bit-field #b101101011101111 2 7)
       #b101101011101111)
     (test-cp0-expansion eqv?
       '(fxreverse-bit-field #b101101011101111 3 9)
       #b101101101110111)
     (test-cp0-expansion eqv?
       '(fxreverse-bit-field (greatest-fixnum) 0 (fx- (fixnum-width) 1))
       (greatest-fixnum))
     (test-cp0-expansion eqv?
       '(fxreverse-bit-field (greatest-fixnum) 0 (fx- (fixnum-width) 1))
       (greatest-fixnum))
     (test-cp0-expansion eqv?
       '(fxreverse-bit-field (least-fixnum) 0 (fx- (fixnum-width) 1))
       (least-fixnum))
     (test-cp0-expansion eqv?
       '(fxreverse-bit-field (least-fixnum) 0 (fx- (fixnum-width) 1))
       (least-fixnum))
     (test-cp0-expansion eqv?
       '(fxreverse-bit-field -1 0 (fx- (fixnum-width) 1))
       -1)
     (test-cp0-expansion eqv?
       '(fxreverse-bit-field -1 0 (fx- (fixnum-width) 1))
       -1))
;;; fl.ms
;;; Copyright 1984-2017 Cisco Systems, Inc.
;;; 
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;; 
;;; http://www.apache.org/licenses/LICENSE-2.0
;;; 
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

(mat flonum->fixnum
     (error? (flonum->fixnum))
     (error? (flonum->fixnum 3.3 4.4))
     (error? (flonum->fixnum 3))
     (error? (flonum->fixnum 'a))
     (error? (flonum->fixnum (* (inexact (most-positive-fixnum)) 2.0)))
     (error? (flonum->fixnum (* (inexact (most-negative-fixnum)) 2.0)))
     (eq? (+ (ash (most-positive-fixnum) -1) 1)
          (flonum->fixnum (* (+ (ash (most-positive-fixnum) -1) 1) 1.0)))
     (eq? (most-negative-fixnum)
          (flonum->fixnum (* (most-negative-fixnum) 1.0)))
     (eq? (flonum->fixnum 0.0) 0)
     (eq? (flonum->fixnum 1.0) 1)
     (eq? (flonum->fixnum +4.5) +4)
     (eq? (flonum->fixnum +4.3) +4)
     (eq? (flonum->fixnum +4.0) +4)
     (eq? (flonum->fixnum +3.6) +3)
     (eq? (flonum->fixnum +3.5) +3)
     (eq? (flonum->fixnum +3.4) +3)
     (eq? (flonum->fixnum +3.0) +3)
     (eq? (flonum->fixnum +2.6) +2)
     (eq? (flonum->fixnum +1.0) +1)
     (eq? (flonum->fixnum +.5) 0)
     (eq? (flonum->fixnum -.5) 0)
     (eq? (flonum->fixnum -1.0) -1)
     (eq? (flonum->fixnum -2.6) -2)
     (eq? (flonum->fixnum -3.0) -3)
     (eq? (flonum->fixnum -3.4) -3)
     (eq? (flonum->fixnum -3.5) -3)
     (eq? (flonum->fixnum -3.6) -3)
     (eq? (flonum->fixnum -4.0) -4)
     (eq? (flonum->fixnum -4.3) -4)
     (eq? (flonum->fixnum -4.5) -4)

     (test-cp0-expansion eq?
       '(+ (ash (most-positive-fixnum) -1) 1)
       (flonum->fixnum (* (+ (ash (most-positive-fixnum) -1) 1) 1.0)))
     (test-cp0-expansion eq?
       '(most-negative-fixnum)
       (flonum->fixnum (* (most-negative-fixnum) 1.0)))
     (test-cp0-expansion eq? '(flonum->fixnum 0.0) 0)
     (test-cp0-expansion eq? '(flonum->fixnum 1.0) 1)
     (test-cp0-expansion eq? '(flonum->fixnum +4.5) +4)
     (test-cp0-expansion eq? '(flonum->fixnum +4.3) +4)
     (test-cp0-expansion eq? '(flonum->fixnum +4.0) +4)
     (test-cp0-expansion eq? '(flonum->fixnum +3.6) +3)
     (test-cp0-expansion eq? '(flonum->fixnum +3.5) +3)
     (test-cp0-expansion eq? '(flonum->fixnum +3.4) +3)
     (test-cp0-expansion eq? '(flonum->fixnum +3.0) +3)
     (test-cp0-expansion eq? '(flonum->fixnum +2.6) +2)
     (test-cp0-expansion eq? '(flonum->fixnum +1.0) +1)
     (test-cp0-expansion eq? '(flonum->fixnum +.5) 0)
     (test-cp0-expansion eq? '(flonum->fixnum -.5) 0)
     (test-cp0-expansion eq? '(flonum->fixnum -1.0) -1)
     (test-cp0-expansion eq? '(flonum->fixnum -2.6) -2)
     (test-cp0-expansion eq? '(flonum->fixnum -3.0) -3)
     (test-cp0-expansion eq? '(flonum->fixnum -3.4) -3)
     (test-cp0-expansion eq? '(flonum->fixnum -3.5) -3)
     (test-cp0-expansion eq? '(flonum->fixnum -3.6) -3)
     (test-cp0-expansion eq? '(flonum->fixnum -4.0) -4)
     (test-cp0-expansion eq? '(flonum->fixnum -4.3) -4)
     (test-cp0-expansion eq? '(flonum->fixnum -4.5) -4))

(mat fixnum->flonum
     (error? (fixnum->flonum))
     (error? (fixnum->flonum 3 4))
     (error? (fixnum->flonum 3.4))
     (error? (fixnum->flonum 'a))
     (error? (fixnum->flonum (+ (most-positive-fixnum) 1)))
     (= (fixnum->flonum (most-positive-fixnum))
        (* (most-positive-fixnum) 1.0))
     (= (fixnum->flonum 0) 0.0)
     (= (fixnum->flonum 1) 1.0)
     (test-cp0-expansion =
       '(fixnum->flonum (most-positive-fixnum))
       (* (most-positive-fixnum) 1.0))
     (test-cp0-expansion = '(fixnum->flonum 0) 0.0)
     (test-cp0-expansion = '(fixnum->flonum 1) 1.0)
     (test-cp0-expansion = '(fixnum->flonum -1) -1.0)
     (test-cp0-expansion = '(fixnum->flonum -1) -1.0))

(mat fl=
     (not (fl= 3.0 4.0))
     (not (fl= 4.0 3.0))
     (fl= 4.1 4.1)
     (not (fl= -4.1 4.1))
     (not (fl= 4.1 -4.1))
     (not (fl= -4.272 -3.272))
     (not (fl= -3.01e-10 -.01e-3))
     (fl= -4e-4)
     (fl= -4e-4 -4e-4)
     (fl= -4e4 -4e4 -4e4)
     (error? (fl=))
     (error? (fl= (list 'a)))
     (error? (fl= 'a 3.1))
     (error? (fl= 3.1 'a))
     (error? (fl= 3.0 3.0 3))
     (error? (fl= 3.0 3.1 3))
     (error? (fl= 3.5 3.5 7/2 4.5))
     (error? (fl= 3.5 4.5 7/2 3.5))
     (guard (c [#t #t]) (fl= 3.0 4.0 (error #f "oops")))
     (guard (c [#t #t]) (fl= 3.0 (error #f "oops") 4.0))
     (guard (c [#t #t]) (fl= (error #f "oops") 3.0 4.0))
     (guard (c [#t #t]) (not (fl= (error #f "oops")))))

(mat fl<
     (fl< 3.0 4.0)
     (not (fl< 4.0 3.0))
     (not (fl< 4.1 4.1))
     (fl< -4.1 4.1)
     (not (fl< 4.1 -4.1))
     (fl< -4.272 -3.272)
     (not (fl< -3.01e-10 -.01e-3))
     (fl< -4e-4)
     (not (fl< -4e-4 -4e-4))
     (not (fl< -4e-4 -4e-4 -4e-4))
     (error? (fl<))
     (error? (fl< (list 'a)))
     (error? (fl< 'a 3.1))
     (error? (fl< 3.1 'a))
     (error? (fl< 3.0 3.1 3))
     (error? (fl< 3.0 3.0 3))
     (error? (fl< 3.5 3.5 7/2 4.5))
     (error? (fl< 3.5 4.5 7/2 3.5))
     (guard (c [#t #t]) (fl< 4.0 3.0 (error #f "oops")))
     (guard (c [#t #t]) (fl< 4.0 (error #f "oops") 3.0))
     (guard (c [#t #t]) (fl< (error #f "oops") 4.0 3.0))
     (guard (c [#t #t]) (not (fl< (error #f "oops")))))

(mat fl>
     (not (fl> 3.0 4.0))
     (fl> 4.0 3.0)
     (not (fl> 4.1 4.1))
     (not (fl> -4.1 4.1))
     (fl> 4.1 -4.1)
     (not (fl> -4.272 -3.272))
     (fl> -3.01e-10 -.01e-3)
     (fl> -4e-4)
     (not (fl> -4e-4 -4e-4))
     (not (fl> -4e-4 -4e-4 -4e-4))
     (error? (fl>))
     (error? (fl> (list 'a)))
     (error? (fl> 'a 3.1))
     (error? (fl> 3.1 'a))
     (error? (fl> 3.1 3.0 3))
     (error? (fl> 3.0 3.0 3))
     (error? (fl> 3.5 3.5 7/2 4.5))
     (error? (fl> 3.5 4.5 7/2 3.5))
     (guard (c [#t #t]) (fl> 3.0 4.0 (error #f "oops")))
     (guard (c [#t #t]) (fl> 3.0 (error #f "oops") 4.0))
     (guard (c [#t #t]) (fl> (error #f "oops") 3.0 4.0))
     (guard (c [#t #t]) (not (fl> (error #f "oops")))))

(mat fl<=
     (fl<= 3.0 4.0)
     (not (fl<= 4.0 3.0))
     (fl<= 4.1 4.1)
     (fl<= -4.1 4.1)
     (not (fl<= 4.1 -4.1))
     (fl<= -4.272 -3.272)
     (not (fl<= -3.01e-10 -.01e-3))
     (fl<= -4e-4)
     (fl<= -4e-4 -4e-4)
     (fl<= -4e-4 -4e-4 -4e-4)
     (error? (fl<=))
     (error? (fl<= (list 'a)))
     (error? (fl<= 'a 3.1))
     (error? (fl<= 3.1 'a))
     (error? (fl<= 3.0 3.0 3))
     (error? (fl<= 3.1 3.0 3))
     (error? (fl<= 3.5 3.5 7/2 4.5))
     (error? (fl<= 3.5 4.5 7/2 3.5))
     (guard (c [#t #t]) (fl<= 4.0 3.0 (error #f "oops")))
     (guard (c [#t #t]) (fl<= 4.0 (error #f "oops") 3.0))
     (guard (c [#t #t]) (fl<= (error #f "oops") 4.0 3.0))
     (guard (c [#t #t]) (not (fl<= (error #f "oops")))))

(mat fl>=
     (not (fl>= 3.0 4.0))
     (fl>= 4.0 3.0)
     (fl>= 4.1 4.1)
     (not (fl>= -4.1 4.1))
     (fl>= 4.1 -4.1)
     (not (fl>= -4.272 -3.272))
     (fl>= -3.01e-10 -.01e-3)
     (fl>= -4e-4)
     (fl>= -4e-4 -4e-4)
     (fl>= -4e-4 -4e-4 -4e-4)
     (error? (fl>=))
     (error? (fl>= (list 'a)))
     (error? (fl>= 'a 3.1))
     (error? (fl>= 3.1 'a))
     (error? (fl>= 3.0 3.0 3))
     (error? (fl>= 3.0 3.1 3))
     (error? (fl>= 3.5 3.5 7/2 4.5))
     (error? (fl>= 3.5 4.5 7/2 3.5))
     (guard (c [#t #t]) (fl>= 3.0 4.0 (error #f "oops")))
     (guard (c [#t #t]) (fl>= 3.0 (error #f "oops") 4.0))
     (guard (c [#t #t]) (fl>= (error #f "oops") 3.0 4.0))
     (guard (c [#t #t]) (not (fl>= (error #f "oops")))))

(mat fl=?
     (not (fl=? 3.0 4.0))
     (not (fl=? 4.0 3.0))
     (fl=? 4.1 4.1)
     (not (fl=? -4.1 4.1))
     (not (fl=? 4.1 -4.1))
     (not (fl=? -4.272 -3.272))
     (not (fl=? -3.01e-10 -.01e-3))
     (fl=? -4e-4 -4e-4)
     (fl=? -4e4 -4e4 -4e4)
     (error? (fl=?))
     (error? (fl=? 3.4))
     (error? (fl=? 'a 3.1))
     (error? (fl=? 3.1 'a))
     (error? (fl=? 3.0 3.0 3))
     (error? (fl=? 3.0 3.1 3))
     (error? (fl=? 3.5 3.5 7/2 4.5))
     (error? (fl=? 3.5 4.5 7/2 3.5))
     (guard (c [#t #t]) (fl=? 3.0 4.0 (error #f "oops")))
     (guard (c [#t #t]) (fl=? 3.0 (error #f "oops") 4.0))
     (guard (c [#t #t]) (fl=? (error #f "oops") 3.0 4.0))
     (guard (c [#t #t]) (not (fl=? (error #f "oops")))))

(mat fl<?
     (fl<? 3.0 4.0)
     (not (fl<? 4.0 3.0))
     (not (fl<? 4.1 4.1))
     (fl<? -4.1 4.1)
     (not (fl<? 4.1 -4.1))
     (fl<? -4.272 -3.272)
     (not (fl<? -3.01e-10 -.01e-3))
     (not (fl<? -4e-4 -4e-4))
     (not (fl<? -4e-4 -4e-4 -4e-4))
     (error? (fl<?))
     (error? (fl<? 3.4))
     (error? (fl<? 'a 3.1))
     (error? (fl<? 3.1 'a))
     (error? (fl<? 3.0 3.1 3))
     (error? (fl<? 3.0 3.0 3))
     (error? (fl<? 3.5 3.5 7/2 4.5))
     (error? (fl<? 3.5 4.5 7/2 3.5))
     (guard (c [#t #t]) (fl<? 4.0 3.0 (error #f "oops")))
     (guard (c [#t #t]) (fl<? 4.0 (error #f "oops") 3.0))
     (guard (c [#t #t]) (fl<? (error #f "oops") 4.0 3.0))
     (guard (c [#t #t]) (not (fl<? (error #f "oops")))))

(mat fl>?
     (not (fl>? 3.0 4.0))
     (fl>? 4.0 3.0)
     (not (fl>? 4.1 4.1))
     (not (fl>? -4.1 4.1))
     (fl>? 4.1 -4.1)
     (not (fl>? -4.272 -3.272))
     (fl>? -3.01e-10 -.01e-3)
     (not (fl>? -4e-4 -4e-4))
     (not (fl>? -4e-4 -4e-4 -4e-4))
     (error? (fl>?))
     (error? (fl>? 3.4))
     (error? (fl>? 'a 3.1))
     (error? (fl>? 3.1 'a))
     (error? (fl>? 3.1 3.0 3))
     (error? (fl>? 3.0 3.0 3))
     (error? (fl>? 3.5 3.5 7/2 4.5))
     (error? (fl>? 3.5 4.5 7/2 3.5))
     (guard (c [#t #t]) (fl>? 3.0 4.0 (error #f "oops")))
     (guard (c [#t #t]) (fl>? 3.0 (error #f "oops") 4.0))
     (guard (c [#t #t]) (fl>? (error #f "oops") 3.0 4.0))
     (guard (c [#t #t]) (not (fl>? (error #f "oops")))))

(mat fl<=?
     (fl<=? 3.0 4.0)
     (not (fl<=? 4.0 3.0))
     (fl<=? 4.1 4.1)
     (fl<=? -4.1 4.1)
     (not (fl<=? 4.1 -4.1))
     (fl<=? -4.272 -3.272)
     (not (fl<=? -3.01e-10 -.01e-3))
     (fl<=? -4e-4 -4e-4)
     (fl<=? -4e-4 -4e-4 -4e-4)
     (error? (fl<=?))
     (error? (fl<=? 3.4))
     (error? (fl<=? 'a 3.1))
     (error? (fl<=? 3.1 'a))
     (error? (fl<=? 3.0 3.0 3))
     (error? (fl<=? 3.1 3.0 3))
     (error? (fl<=? 3.5 3.5 7/2 4.5))
     (error? (fl<=? 3.5 4.5 7/2 3.5))
     (guard (c [#t #t]) (fl<=? 4.0 3.0 (error #f "oops")))
     (guard (c [#t #t]) (fl<=? 4.0 (error #f "oops") 3.0))
     (guard (c [#t #t]) (fl<=? (error #f "oops") 4.0 3.0))
     (guard (c [#t #t]) (not (fl<=? (error #f "oops")))))

(mat fl>=?
     (not (fl>=? 3.0 4.0))
     (fl>=? 4.0 3.0)
     (fl>=? 4.1 4.1)
     (not (fl>=? -4.1 4.1))
     (fl>=? 4.1 -4.1)
     (not (fl>=? -4.272 -3.272))
     (fl>=? -3.01e-10 -.01e-3)
     (fl>=? -4e-4 -4e-4)
     (fl>=? -4e-4 -4e-4 -4e-4)
     (error? (fl>=?))
     (error? (fl>=? 3.4))
     (error? (fl>=? 'a 3.1))
     (error? (fl>=? 3.1 'a))
     (error? (fl>=? 3.0 3.0 3))
     (error? (fl>=? 3.0 3.1 3))
     (error? (fl>=? 3.5 3.5 7/2 4.5))
     (error? (fl>=? 3.5 4.5 7/2 3.5))
     (guard (c [#t #t]) (fl>=? 3.0 4.0 (error #f "oops")))
     (guard (c [#t #t]) (fl>=? 3.0 (error #f "oops") 4.0))
     (guard (c [#t #t]) (fl>=? (error #f "oops") 3.0 4.0))
     (guard (c [#t #t]) (not (fl>=? (error #f "oops")))))

(mat fl+
     (eqv? (fl+) 0.0)
     (eqv? (fl+ -3.0) -3.0)
     (eqv? (fl+ -3.0 4.0) 1.0)
     (eqv? (fl+ (inexact 1/3) (inexact 1/3))
           (+ (inexact 1/3) (inexact 1/3)))
     (eqv? (fl+ 3.25 4.375 5.625) (+ 3.25 4.375 5.625))
     (error? (fl+ '(a . b)))
     (error? (fl+ 2.0 1))
     (error? (fl+ 1.0 -3.0 2/3))
     (string=? (number->string (fl+)) "0.0")
     (test-cp0-expansion eqv? '(fl+) 0.0)
     (test-cp0-expansion eqv? '(fl+ -3.0) -3.0)
     (test-cp0-expansion eqv? '(fl+ -3.0 4.0) 1.0)
     (test-cp0-expansion eqv?
       '(fl+ (inexact 1/3) (inexact 1/3))
       (+ (inexact 1/3) (inexact 1/3)))
     (test-cp0-expansion eqv? '(fl+ 3.25 4.375 5.625) (+ 3.25 4.375 5.625)))

(mat fl-
     (error? (fl-))
     (eqv? (fl- -3.0) 3.0)
     (eqv? (fl- -3.0 4.0) -7.0)
     (eqv? (fl- (inexact 1/3) (inexact 1/7))
           (- (inexact 1/3) (inexact 1/7)))
     (eqv? (fl- 3.25 4.375 5.625) (- 3.25 4.375 5.625))
     (error? (fl- '(a . b)))
     (error? (fl- 2.0 1))
     (error? (fl- 'a 'b))
     (error? (fl- 'a 'b 'c))
     (error? (fl- 1.0 -3.0 2/3))
     (error? (fl- 1.0 'b 2.0))
     (test-cp0-expansion eqv? '(fl- -3.0) 3.0)
     (test-cp0-expansion eqv? '(fl- -3.0 4.0) -7.0)
     (test-cp0-expansion eqv?
       '(fl- (inexact 1/3) (inexact 1/7))
       (- (inexact 1/3) (inexact 1/7)))
     (test-cp0-expansion eqv? '(fl- 3.25 4.375 5.625) (- 3.25 4.375 5.625)))

(mat fl*
     (eqv? (fl*) 1.0)
     (eqv? (fl* -3.0) -3.0)
     (eqv? (fl* -3.0 4.0) -12.0)
     (eqv? (fl* (inexact 1/3) (inexact 1/3))
           (* (inexact 1/3) (inexact 1/3)))
     (eqv? (fl* 3.25 4.375 5.625) (* 3.25 4.375 5.625))
     (error? (fl* '(a . b)))
     (error? (fl* 2.0 1))
     (error? (fl* 1.0 -3.0 2/3))
     (string=? (number->string (fl*)) "1.0")
     (test-cp0-expansion eqv? '(fl*) 1.0)
     (test-cp0-expansion eqv? '(fl* -3.0) -3.0)
     (test-cp0-expansion eqv? '(fl* -3.0 4.0) -12.0)
     (test-cp0-expansion eqv?
       '(fl* (inexact 1/3) (inexact 1/3))
       (* (inexact 1/3) (inexact 1/3)))
     (test-cp0-expansion eqv? '(fl* 3.25 4.375 5.625) (* 3.25 4.375 5.625)))

(mat fl/
     (error? (fl/))
     (eqv? (fl/ -3.0) (/ -3.0))
     (eqv? (fl/ -3.0 4.0) -.75)
     (eqv? (fl/ (inexact 1/3) (inexact 1/7))
           (/ (inexact 1/3) (inexact 1/7)))
     (eqv? (fl/ 3.25 4.375 5.625) (/ 3.25 4.375 5.625))
     (error? (fl/ '(a . b)))
     (error? (fl/ 2.0 1))
     (error? (fl/ 1.0 -3.0 2/3))
     (test-cp0-expansion eqv? '(fl/ -3.0) (/ -3.0))
     (test-cp0-expansion eqv? '(fl/ -3.0 4.0) -.75)
     (test-cp0-expansion eqv?
       '(fl/ (inexact 1/3) (inexact 1/7))
       (/ (inexact 1/3) (inexact 1/7)))
     (test-cp0-expansion eqv? '(fl/ 3.25 4.375 5.625) (/ 3.25 4.375 5.625)))

(mat flabs
     (error? (flabs))
     (error? (flabs 1 2))
     (error? (flabs 'a))
     (error? (flabs 1))
     (error? (flabs -3/4))
     (error? (flabs 3+4i))
     (error? (flabs 3.3+4.5i))
     (fl~= (flabs 1.83) 1.83)
     (fl~= (flabs -0.093) 0.093)
     (== (flabs -0.0) 0.0)
     (== (flabs 0.0) 0.0)
     (== (flabs +inf.0) +inf.0)
     (== (flabs -inf.0) +inf.0)
     (== (flabs +nan.0) +nan.0)
     (eqv? (flabs 0.0) 0.0)
     (eqv? (flabs -1.0) 1.0)
     (eqv? (flabs 1.0) 1.0))

(mat fllog
     (error? (fllog))
     (error? (fllog 3))
     (error? (fllog 'a))
     (error? (fllog 0))
     (fl~= (fllog 1.0) 0.0)
     (fl~= (fllog (exp 7.0)) 7.0)
     (fl~= (fllog (exp 10.2)) 10.2)
     (fl~= (fllog 1e30) (inexact (log #e1e30)))
     (fl~= (/ (log (expt 10 500)) (fllog 10.0)) 500.0)
     (fl~= (log 3/4) (fllog .75))
     (fl~= (fllog 10.0 10.0) 1.0)
     (fl~= (fllog 50.0 50.0) 1.0)
     (fl~= (fllog 1000.0 10.0) 3.0)
     ; r6rs:
     (== (fllog +inf.0) +inf.0)
     (== (fllog 0.0) -inf.0)
     (== (fllog -inf.0) +nan.0))

(mat flexp
     (error? (flexp))
     (error? (flexp 3.0 4.0))
     (error? (flexp 'a))
     (error? (flexp 3))
     (fl= (flexp 0.0) 1.0)
     (~= (* (flexp 1.0) (flexp 1.0)) (flexp 2.0))
     (fl~= (/ (flexp 24.2) (flexp 2.0)) (flexp 22.2))
     ; r6rs:
     (== (flexp +inf.0) +inf.0)
     (== (flexp -inf.0) 0.0))

(mat flsin
     (and (> pi 3.14159265) (< pi 3.14159266))
     (error? (flsin))
     (error? (flsin 3.0 4.0))
     (error? (flsin 'a))
     (error? (flsin 3))
     (fl~= (flsin (/ pi 6)) 0.5))

(mat flcos
     (error? (flcos))
     (error? (flcos 3.0 4.0))
     (error? (flcos 'a))
     (error? (flcos 3))
     (fl~= (flcos (/ pi 3)) 0.5)
     (let ([x 3.3])
       (let ([s (flsin x)] [c (flcos x)])
         (~= (+ (* s s) (* c c)) 1.0))))

(mat fltan
     (error? (fltan))
     (error? (fltan 3.0 4.0))
     (error? (fltan 'a))
     (error? (fltan 3))
     (fl~= (fltan (/ pi 4)) 1.0)
     (let ([x 4.4]) (~= (fltan x) (/ (flsin x) (flcos x)))))

(mat flasin
     (error? (flasin))
     (error? (flasin 3.0 4.0))
     (error? (flasin 'a))
     (error? (flasin 3))
     (fl~= (flasin 1.0) (/ pi 2))
     (let ([x 1.0]) (fl~= (flasin (flsin x)) x))
     (let ([x 0.5]) (fl~= (flasin (flsin x)) x)))

(mat flacos
     (error? (flacos))
     (error? (flacos 3.0 4.0))
     (error? (flacos 'a))
     (error? (flacos 3))
     (fl~= (flacos 0.5) (/ pi 3))
     (let ([x 0.5]) (fl~= (flacos (flcos x)) x)))

(mat flatan
     (error? (flatan))
     (error? (flatan 3.0 4.0 5.0))
     (error? (flatan 'a))
     (error? (flatan 'a 3.0))
     (error? (flatan 3.0 'a))
     (error? (flatan 3 4))
     (error? (flatan +i))
     (error? (flatan -i))
     (fl~= (flatan 1.0) (/ pi 4))
     (fl~= (flatan 2.0 2.0) (/ pi 4))
     (let ([x 0.5]) (fl~= (flatan (fltan x)) x))
     (fl~= (flatan 10.0 -10.0) (angle -10+10i))
     (fl~= (flatan 10.0 -10.0) (angle -10.0+10.0i))
     (fl~= (flatan 10.0 -10.0) (flatan 10.0 -10.0))
     ; r6rs:
     (== (flatan -inf.0) -1.5707963267948965)
     (== (flatan +inf.0) 1.5707963267948965))

(mat flsqrt
     (error? (flsqrt))
     (error? (flsqrt 3.0 4.0))
     (error? (flsqrt 'a))
     (error? (flsqrt 3))
     (== (flsqrt -1.0) (nan))
     (~= (flsqrt 9.0) 3.0)
     (~= (flsqrt #i1/4) #e1/2)
     (~= (* (flsqrt 189.0) (flsqrt 189.0)) 189.0)
     (fl~= (* (flsqrt 2.0) (flsqrt 2.0)) 2.0)
     (~= (flsqrt 1e38) (sqrt #e1e38))
     ; r6rs:
     (== (flsqrt +inf.0) +inf.0)
     (== (flsqrt -0.0) -0.0))

(mat flexpt
     (error? (flexpt))
     (error? (flexpt 5.0))
     (error? (flexpt 3.0 4.0 5.0))
     (error? (flexpt 'a 3.0))
     (error? (flexpt 3.0 'a))
     (error? (flexpt 0.0 -1))
     (error? (flexpt 0.0 +1i))
     (fl~= (flexpt 10.0 -20.0) 1e-20)
     (eqv? (flexpt 2.0 10.0) 1024.0)
     (eqv? (flexpt 0.0 0.0) 1.0)
     (eqv? (flexpt 0.0 2.0) 0.0)
     (eqv? (flexpt 100.0 0.0) 1.0)
     (eqv? (flexpt 2.0 -10.0) #i1/1024)
     (eqv? (flexpt #i-1/2 #i5) #i-1/32)
     (fl~= (flexpt 9.0 #i1/2) 3.0)
     (fl~= (flexpt 3.0 3.0) 27.0)
     (~= (flexpt -0.5 2.0) .25)
     (~= (flexpt -0.5 -2.0) 4.0)
     (~= (flexpt 3.0 2.5) (flsqrt (* 3.0 3.0 3.0 3.0 3.0)))
     (fl= (flexpt 0.0 2.0) 0.0)
     (fl= (flexpt 0.0 0.0) 1.0)
     (fl= (flexpt 2.0 0.0) 1.0)
     (fl~= (flexpt #i-2/3 #i-3) #i-27/8)
     (fl= (flexpt 10.0 -1000.0) 0.0)
     (fl= (flexpt .1 1000.0) 0.0)
     (~= (flexpt #i11 #i1/2) (flsqrt #i11))
     (fl~= (flexpt 1.5e-20 0.5) (flsqrt 1.5e-20))
     (equal? (let ([ls '(a b c)])
               (let ([n (flexpt (begin (set! ls (append ls ls)) 2.0)
                                (begin
                                  (set! ls (reverse ls))
                                  3.0))])
                 (cons n ls)))
             '(8.0 c b a c b a)))

(mat fltruncate
     (error? (fltruncate))
     (error? (fltruncate 2.0 3.0))
     (error? (fltruncate 'a))
     (error? (fltruncate 3))
     (error? (fltruncate 2+1.0i))
     (error? (fltruncate 2+1i))
     (eqv? (fltruncate 19.0) 19.0)
     (eqv? (fltruncate #i2/3) 0.0)
     (fl~= (fltruncate #i-2/3) 0.0)
     (fl= (fltruncate #i17.3) 17.0)
     (eqv? (fltruncate #i-17/2) -8.0)
     (fl= (fltruncate 2.5) 2.0)
     ; r6rs:
     (== (fltruncate +nan.0) +nan.0))

(mat flfloor
     (error? (flfloor))
     (error? (flfloor 2.0 3.0))
     (error? (flfloor 'a))
     (error? (flfloor 3))
     (error? (flfloor 2+1.0i))
     (error? (flfloor 2+1i))
     (eqv? (flfloor 19.0) 19.0)
     (eqv? (flfloor #i2/3) 0.0)
     (eqv? (flfloor #i-2/3) -1.0)
     (fl= (flfloor #i17.3) 17.0)
     (eqv? (flfloor #i-17/2) -9.0)
     (fl= (flfloor 2.5) 2.0)
     ; r6rs:
     (== (flfloor +inf.0) +inf.0))

(mat flceiling
     (error? (flceiling))
     (error? (flceiling 2.0 3.0))
     (error? (flceiling 'a))
     (error? (flceiling 3))
     (error? (flceiling 2+1.0i))
     (eqv? (flceiling 19.0) 19.0)
     (eqv? (flceiling #i2/3) 1.0)
     (fl~= (flceiling #i-2/3) 0.0)
     (fl= (flceiling #i17.3) 18.0)
     (eqv? (flceiling #i-17/2) -8.0)
     (fl= (flceiling 2.5) 3.0)
     ; r6rs:
     (== (flceiling -inf.0) -inf.0))

(mat flround
     (error? (flround))
     (error? (flround 2.0 3))
     (error? (flround 'a))
     (error? (flround 2+1.0i))
     (error? (flround 2+1i))
     (error? (flround 19))
     (error? (flround 2/3))
     (fl= (flround 17.3) 17.0)
     (fl= (flround 2.5) 2.0)
     (fl= (flround 0.5000000000000000) 0.0)
     (fl= (flround 0.5000000000000001) 1.0))

(mat flinteger?
     (error? (flinteger? 'a))
     (error? (flinteger? "hi"))
     (error? (flinteger? (cons 3 4)))
     (error? (flinteger? 3.0+0.0i))
     (error? (flinteger? 3.0+1.0i))
     (flinteger? 3.0)
     (flinteger? 23048230482304.0)
     (not (flinteger? #i-3/4))
     (flinteger? -1.0)
     (flinteger? 0.0)
     (flinteger? -12083.0)
     (flinteger? 4.0)
     (not (flinteger? 3.5))
     (not (flinteger? 1.8e-10))
     (flinteger? 1.8e10)
     (flinteger? -3e5)
     (not (flinteger? -1231.2344)))

(mat flnan?
     (error? (flnan? 3))
     (error? (flnan? 3/4))
     (error? (flnan? 'hi))
     (flnan? (nan))
     (not (flnan? 5.0))
     (not (flnan? +inf.0))
     (not (flnan? -inf.0)))

(mat flfinite?
     (error? (flfinite? 3))
     (error? (flfinite? 3/4))
     (error? (flfinite? 'hi))
     (not (flfinite? (nan)))
     (flfinite? 5.0)
     (not (flfinite? +inf.0))
     (not (flfinite? -inf.0))
     ; r6rs:
     (not (flfinite? +inf.0))
     (flfinite? 5.0))

(mat flinfinite?
     (error? (flinfinite? 3))
     (error? (flinfinite? 3/4))
     (error? (flinfinite? 'hi))
     (not (flinfinite? (nan)))
     (not (flinfinite? 5.0))
     (flinfinite? +inf.0)
     (flinfinite? -inf.0)
     ; r6rs:
     (not (flinfinite? 5.0))
     (flinfinite? +inf.0))

(mat flzero?
     (error? (flzero?))
     (error? (flzero? 0.0 1.0))
     (error? (flzero? 'a))
     (error? (flzero? 3))
     (flzero? 0.0)
     (flzero? #i0/5)
     (not (flzero? 234.0))
     (not (flzero? #i23423423/234241211))
     (not (flzero? 23.4))
     (not (flzero? -1734234.0))
     (not (flzero? #i-2/3))
     (not (flzero? -0.1)))

(mat flpositive?
     (error? (flpositive?))
     (error? (flpositive? 0.0 1.0))
     (error? (flpositive? 'a))
     (error? (flpositive? 3))
     (error? (flpositive? 1+1.0i))
     (error? (flpositive? 1+1i))
     (not (flpositive? 0.0))
     (not (flpositive? #i0/5))
     (flpositive? 234.0)
     (flpositive? #i23423423/234241211)
     (flpositive? 23.4)
     (not (flpositive? -1734234.0))
     (not (flpositive? #i-2/3))
     (not (flpositive? -0.1)))

(mat flnegative?
     (error? (flnegative?))
     (error? (flnegative? 0.0 1.0))
     (error? (flnegative? 'a))
     (error? (flnegative? 3))
     (error? (flnegative? 1+1.0i))
     (error? (flnegative? 1+1i))
     (not (flnegative? 0.0))
     (not (flnegative? #i0/5))
     (not (flnegative? 234.0))
     (not (flnegative? #i23423423/234241211))
     (not (flnegative? 23.4))
     (flnegative? -1734234.0)
     (flnegative? #i-2/3)
     (flnegative? -0.1)
     ; r6rs:
     (not (flnegative? -0.0)))

(mat flnonpositive?
     (error? (flnonpositive?))
     (error? (flnonpositive? 0.0 1.0))
     (error? (flnonpositive? 'a))
     (error? (flnonpositive? 3))
     (error? (flnonpositive? 1+1.0i))
     (error? (flnonpositive? 1+1i))
     (flnonpositive? 0.0)
     (flnonpositive? #i0/5)
     (not (flnonpositive? 234.0))
     (not (flnonpositive? #i23423423/234241211))
     (not (flnonpositive? 23.4))
     (flnonpositive? -1734234.0)
     (flnonpositive? #i-2/3)
     (flnonpositive? -0.1))

(mat flnonnegative?
     (error? (flnonnegative?))
     (error? (flnonnegative? 0.0 1.0))
     (error? (flnonnegative? 'a))
     (error? (flnonnegative? 3))
     (error? (flnonnegative? 1+1i))
     (error? (flnonnegative? 1.0+1.0i))
     (flnonnegative? 0.0)
     (flnonnegative? #i0/5)
     (flnonnegative? 234.0)
     (flnonnegative? #i23423423/234241211)
     (flnonnegative? 23.4)
     (not (flnonnegative? -1734234.0))
     (not (flnonnegative? #i-2/3))
     (not (flnonnegative? -0.1)))

(mat fleven?
     (error? (fleven?))
     (error? (fleven? 0.0 1.0))
     (error? (fleven? 'a))
     (error? (fleven? 3))
     (error? (fleven? 3.2))
     (error? (fleven? 3.0+1.0i))
     (error? (fleven? 1+1i))
     (error? (fleven? +inf.0))
     (error? (fleven? +nan.0))
     (not (fleven? -3.0))
     (fleven? 2.0)
     (not (fleven? 1208312083280477.0))
     (fleven? 1208312083280478.0)
     (fleven? 4.0)
     (not (fleven? 3.0)))

(mat flodd?
     (error? (flodd?))
     (error? (flodd? 0.0 1.0))
     (error? (flodd? 'a))
     (error? (flodd? 3))
     (error? (flodd? 3.2))
     (error? (flodd? 3.0+1.0i))
     (error? (flodd? 3+1i))
     (error? (flodd? +inf.0))
     (error? (flodd? +nan.0))
     (flodd? -3.0)
     (not (flodd? 2.0))
     (flodd? 1208312083280477.0)
     (not (flodd? 1208312083280478.0))
     (not (flodd? 4.0))
     (flodd? 3.0))

(mat flmin
     (error? (flmin))
     (error? (flmin 'a))
     (error? (flmin 1.0 'a))
     (error? (flmin 1.0 'a 2.0))
     (error? (flmin 1.0 3 2.0))
     (error? (flmin 1.0 2.0 3.0 'a))
     (error? (flmin 1.0 2.0 3.0 0+1.0i))
     (error? (flmin 1.0 2.0 3.0 +1i))
     (eqv? (flmin -17.0) -17.0)
     (eqv? (flmin 3.0 -3.0) -3.0)
     (eqv? (flmin 3.2 1.0) 1.0)
     (fl= (flmin 3.2 1.0) 1.0)
     (fl= (flmin #i1/2 0.5) 0.5)
     (fl= (flmin #i-1/2 0.5) -0.5)
     (eqv? (flmin 3.0 5.0 1.0 4.0 6.0 2.0) 1.0)
     (== (flmin 4.5 (nan)) (nan))
     (== (flmin (nan) 4.5) (nan))
     (== (flmin +inf.0 (nan)) (nan))
     (== (flmin (nan) +inf.0) (nan))
     (== (flmin -inf.0 (nan)) (nan))
     (== (flmin (nan) -inf.0) (nan))
     (== (flmin 3.0 4.5 (nan) 17.3 -1.5) (nan))
     (fl= (flmin 3.0 4.5 +inf.0 17.3 -1.5) -1.5)
     (fl= (flmin 3.0 4.5 -inf.0 17.3 -1.5) -inf.0))

(mat flmax
     (error? (flmax))
     (error? (flmax 'a))
     (error? (flmax 1.0 'a))
     (error? (flmax 1.0 3))
     (error? (flmax 1.0 'a 2.0))
     (error? (flmax 1.0 2.0 3.0 'a))
     (error? (flmax 1.0 2.0 3.0 0+1.0i))
     (error? (flmax 1.0 2.0 3.0 +1i))
     (eqv? (flmax 1.0) 1.0)
     (eqv? (flmax 3.0 -3.0) 3.0)
     (fl= (flmax 3.2 1.0) 3.2)
     (fl= (flmax 3.2 1.0) 3.2)
     (fl= (flmax #i1/2 0.5) 0.5)
     (fl= (flmax #i1/2 -0.5) 0.5)
     (eqv? (flmax 3.0 5.0 1.0 4.0 6.0 2.0) 6.0)
     (== (flmax 4.5 (nan)) (nan))
     (== (flmax (nan) 4.5) (nan))
     (== (flmax +inf.0 (nan)) (nan))
     (== (flmax (nan) +inf.0) (nan))
     (== (flmax -inf.0 (nan)) (nan))
     (== (flmax (nan) -inf.0) (nan))
     (== (flmax 3.0 4.5 (nan) 17.3 -1.5) (nan))
     (fl= (flmax 3.0 4.5 +inf.0 17.3 -1.5) +inf.0)
     (fl= (flmax 3.0 4.5 -inf.0 17.3 -1.5) 17.3))

(mat flnumerator
     (error? (flnumerator))
     (error? (flnumerator 3.0 4.0))
     (error? (flnumerator 'a))
     (error? (flnumerator 3))
     (error? (flnumerator +1i))
     (error? (flnumerator 2.2+1.1i))
     (eqv? (flnumerator 3.25) 13.0)
     (eqv? (flnumerator 9.0) 9.0)
     (fl~= (let ([n (flnumerator #i2/3)] [d (fldenominator #i2/3)])
             (/ n d))
           #i2/3)
     (fl~= (flnumerator #i-9/4) -9.0)
     (== (flnumerator +nan.0) +nan.0)
     ; r6rs:
     (== (flnumerator +inf.0) +inf.0)
     (== (flnumerator -inf.0) -inf.0)
     (== (flnumerator 0.75) 3.0))

(mat fldenominator
     (error? (fldenominator))
     (error? (fldenominator 3.0 4.0))
     (error? (fldenominator 'a))
     (error? (fldenominator 3))
     (error? (fldenominator +1i))
     (error? (fldenominator 2.2+1.1i))
     (eqv? (fldenominator 3.25) 4.0)
     (eqv? (fldenominator 9.0) 1.0)
     (eqv? (fldenominator #i-9/4) 4.0)
     (== (fldenominator +nan.0) +nan.0)
     ; r6rs:
     (== (fldenominator +inf.0) 1.0)
     (== (fldenominator -inf.0) 1.0)
     (== (fldenominator 0.75) 4.0))

(mat fldiv-and-mod
     ; fldiv-and-mod
     (error? (fldiv-and-mod 17 3.0))
     (error? (fldiv-and-mod 3.0 17))
     (error? (fldiv-and-mod 'a 17.0))
     (error? (fldiv-and-mod 17.0 '(a)))
     ; fldiv
     (error? (fldiv 17 3.0))
     (error? (fldiv 3.0 17))
     (error? (fldiv 'a 17.0))
     (error? (fldiv 17.0 '(a)))
     ; flmod
     (error? (flmod 17 3.0))
     (error? (flmod 3.0 17))
     (error? (flmod 'a 17.0))
     (error? (flmod 17.0 '(a)))
     ; fldiv-and-mod
     (begin
       (define $d&m fldiv-and-mod)
       (define ($dmpair x y)
         (call-with-values (lambda () ($d&m x y)) cons))
       (define ($dmpairs x y)
         (list ($dmpair x y)
               ($dmpair (- x) y)
               ($dmpair x (- y))
               ($dmpair (- x) (- y))
               ($dmpair y x)
               ($dmpair (- y) x)
               ($dmpair y (- x))
               ($dmpair (- y) (- x))))
       (define ($dmequal? x y)
         (cond
           [(pair? x)
            (and (pair? y)
                 ($dmequal? (car x) (car y))
                 ($dmequal? (cdr x) (cdr y)))]
           [(number? x)
            (and (number? y)
                 (if (inexact? x)
                     (and (inexact? y) (== x y))
                     (and (exact? y) (= x y))))]
           [else (eq? x y)]))
       #t)
     ($dmequal? ($dmpairs 0.0 3.5)
       '((0.0 . 0.0)
         (-0.0 . 0.0)
         (-0.0 . 0.0)
         (0.0 . 0.0)
         (+inf.0 . +nan.0)
         (-inf.0 . +nan.0)
         (-inf.0 . +nan.0)
         (+inf.0 . +nan.0)))
     ($dmequal? ($dmpairs 3.5 11.25)
       '((0.0 . 3.5)
         (-1.0 . 7.75)
         (-0.0 . 3.5)
         (1.0 . 7.75)
         (3.0 . 0.75)
         (-4.0 . 2.75)
         (-3.0 . 0.75)
         (4.0 . 2.75)))
     ; fldiv with flmod
     (begin
       (set! $d&m
         (lambda (x y) (values (fldiv x y) (flmod x y))))
       #t)
     ($dmequal? ($dmpairs 0.0 3.5)
       '((0.0 . 0.0)
         (-0.0 . 0.0)
         (-0.0 . 0.0)
         (0.0 . 0.0)
         (+inf.0 . +nan.0)
         (-inf.0 . +nan.0)
         (-inf.0 . +nan.0)
         (+inf.0 . +nan.0)))
     ($dmequal? ($dmpairs 3.5 11.25)
       '((0.0 . 3.5)
         (-1.0 . 7.75)
         (-0.0 . 3.5)
         (1.0 . 7.75)
         (3.0 . 0.75)
         (-4.0 . 2.75)
         (-3.0 . 0.75)
         (4.0 . 2.75))))

(mat fldiv0-and-mod0
     ; fldiv0-and-mod0
     (error? (fldiv0-and-mod0 17 3.0))
     (error? (fldiv0-and-mod0 3.0 17))
     (error? (fldiv0-and-mod0 'a 17.0))
     (error? (fldiv0-and-mod0 17.0 '(a)))
     ; fldiv0
     (error? (fldiv0 17 3.0))
     (error? (fldiv0 3.0 17))
     (error? (fldiv0 'a 17.0))
     (error? (fldiv0 17.0 '(a)))
     ; flmod0
     (error? (flmod0 17 3.0))
     (error? (flmod0 3.0 17))
     (error? (flmod0 'a 17.0))
     (error? (flmod0 17.0 '(a)))
     ; fldiv0-and-mod0
     (begin
       (define $d&m fldiv0-and-mod0)
       (define ($dmpair x y)
         (call-with-values (lambda () ($d&m x y)) cons))
       (define ($dmpairs x y)
         (list ($dmpair x y)
               ($dmpair (- x) y)
               ($dmpair x (- y))
               ($dmpair (- x) (- y))
               ($dmpair y x)
               ($dmpair (- y) x)
               ($dmpair y (- x))
               ($dmpair (- y) (- x))))
       #t)
     ($dmequal? ($dmpairs 0.0 3.5)
       '((0.0 . 0.0)
         (-0.0 . 0.0)
         (-0.0 . 0.0)
         (0.0 . 0.0)
         (+inf.0 . +nan.0)
         (-inf.0 . +nan.0)
         (-inf.0 . +nan.0)
         (+inf.0 . +nan.0)))
     ($dmequal? ($dmpairs 3.5 11.25)
       '((0.0 . 3.5)
         (0.0 . -3.5)
         (-0.0 . 3.5)
         (0.0 . -3.5)
         (3.0 . 0.75)
         (-3.0 . -0.75)
         (-3.0 . 0.75)
         (3.0 . -0.75)))
     ($dmequal? ($dmpairs 10.0 4.0)
       '((3.0 . -2.0)
         (-2.0 . -2.0)
         (-3.0 . -2.0)
         (2.0 . -2.0)
         (0.0 . 4.0)
         (0.0 . -4.0)
         (-0.0 . 4.0)
         (0.0 . -4.0)))
     ; fldiv0 with flmod0
     (begin
       (set! $d&m
         (lambda (x y) (values (fldiv0 x y) (flmod0 x y))))
       #t)
     ($dmequal? ($dmpairs 0.0 3.5)
       '((0.0 . 0.0)
         (-0.0 . 0.0)
         (-0.0 . 0.0)
         (0.0 . 0.0)
         (+inf.0 . +nan.0)
         (-inf.0 . +nan.0)
         (-inf.0 . +nan.0)
         (+inf.0 . +nan.0)))
     ($dmequal? ($dmpairs 3.5 11.25)
       '((0.0 . 3.5)
         (0.0 . -3.5)
         (-0.0 . 3.5)
         (0.0 . -3.5)
         (3.0 . 0.75)
         (-3.0 . -0.75)
         (-3.0 . 0.75)
         (3.0 . -0.75)))
     ($dmequal? ($dmpairs 10.0 4.0)
       '((3.0 . -2.0)
         (-2.0 . -2.0)
         (-3.0 . -2.0)
         (2.0 . -2.0)
         (0.0 . 4.0)
         (0.0 . -4.0)
         (-0.0 . 4.0)
         (0.0 . -4.0))))
;;; cfl.ms
;;; Copyright 1984-2017 Cisco Systems, Inc.
;;; 
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;; 
;;; http://www.apache.org/licenses/LICENSE-2.0
;;; 
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

(define *fuzz* 1e-14)

(define ~=
  (lambda (x y)
    (or (= x y)
        (and (fl~= (inexact (real-part x)) (inexact (real-part y)))
             (fl~= (inexact (imag-part x)) (inexact (imag-part y)))))))

(define fl~=
  (lambda (x y)
    (cond
      [(and (fl>= (flabs x) 2.0) (fl>= (flabs y) 2.0))
       (fl~= (fl/ x 2.0) (fl/ y 2.0))]
      [(and (fl< 0.0 (flabs x) 1.0) (fl< 0.0 (flabs y) 1.0))
       (fl~= (fl* x 2.0) (fl* y 2.0))]
      [else
       (let ([d (flabs (fl- x y))])
         (or (fl<= d *fuzz*)
             (begin (printf "fl~~=: ~s~%" d) #f)))])))

(define cfl~=
  (lambda (x y)
    (and (fl~= (cfl-real-part x) (cfl-real-part y))
         (fl~= (cfl-imag-part x) (cfl-imag-part y)))))

(define zero 0.0)
(define a 1.1)
(define b +1.1i)
(define c 1.1+1.1i)
(define aa 1.21)
(define ab +1.21i)
(define ac 1.21+1.21i)
(define bb -1.21)
(define bc -1.21+1.21i)
(define cc +2.42i)

(mat cflonum?
     (not (cflonum? 3))
     (not (cflonum? 18/2))
     (not (cflonum? 1+0i))
     (not (cflonum? 23084982309482034820348023423048230482304))
     (not (cflonum? 203480234802384/23049821))
     (not (cflonum? -3/4))
     (not (cflonum? -1))
     (not (cflonum? 0))
     (not (cflonum? -12))
     (cflonum? 3.5)
     (cflonum? 1.8e-10)
     (cflonum? -3e5)
     (cflonum? -1231.2344)
     (cflonum? 3+5.0i)
     (cflonum? 1.8e10@10)
     (cflonum? -3e5+1.0i)
     (cflonum? -1.0i)
     (cflonum? +1.0i)
     (not (cflonum? 'a))
     (not (cflonum? "hi"))
     (not (cflonum? (cons 3 4)))
     (cflonum? a)
     (cflonum? b)
     (cflonum? c))

(mat fl-make-rectangular
     (error? (fl-make-rectangular 3 'a))
     (error? (fl-make-rectangular 'b 4))
     (error? (fl-make-rectangular 3 -4))
     (eqv? (fl-make-rectangular 3.0 -4.0) 3.0-4.0i)
     (eqv? (fl-make-rectangular a a) c))

(mat cfl-real-part
     (error? (cfl-real-part 'a))
     (error? (cfl-real-part 3/2))
     (eqv? (cfl-real-part 3.2) 3.2)
     (eqv? (cfl-real-part -1.0+2.0i) -1.0)
     (eqv? (cfl-real-part a) a)
     (eqv? (cfl-real-part c) a)
     (eqv? (cfl-real-part b) zero))

(mat cfl-imag-part
     (error? (cfl-imag-part 'a))
     (error? (cfl-imag-part -3))
     (eqv? (cfl-imag-part 3.2) zero)
     (eqv? (cfl-imag-part -1.0+2.0i) 2.0)
     (eqv? (cfl-imag-part a) zero)
     (eqv? (cfl-imag-part c) a)
     (eqv? (cfl-imag-part b) a))

(mat cfl-conjugate
     (error? (cfl-conjugate 'a))
     (eqv? (cfl-conjugate 3.2) 3.2)
     (eqv? (cfl-conjugate 3.2+2.0i) 3.2-2.0i)
     (eqv? (cfl-conjugate a) a)
     (eqv? (cfl-conjugate c) (+ a (- b)))
     (eqv? (cfl-conjugate b) -1.1i))

(mat conjugate
     (error? (conjugate 'a))
     (eqv? (conjugate 3.2) 3.2)
     (eqv? (conjugate 3.2+2.0i) 3.2-2.0i))

(mat cfl-magnitude-squared
     (error? (cfl-magnitude-squared 'a))
     (eqv? (cfl-magnitude-squared 3.2) (fl* 3.2 3.2))
     (eqv? (cfl-magnitude-squared 3.5-2.0i) 16.25)
     (fl~= (cfl-magnitude-squared 3.5@2.0) 12.25))

(mat magnitude-squared
     (error? (magnitude-squared 'a))
     (eqv? (magnitude-squared 3.5) 12.25)
     (eqv? (magnitude-squared 3.5-2.0i) 16.25)
     (fl~= (magnitude-squared 3.5@2.0) 12.25))

(mat cfl+
     (error? (cfl+ 'a))
     (error? (cfl+ 'a 3))
     (error? (cfl+ 'a 3 4))
     (eqv? (cfl+) zero)
     (eqv? (cfl+ a) a)
     (eqv? (cfl+ b) b)
     (eqv? (cfl+ c) c)
     (eqv? (cfl+ a b) c)
     (cfl~= (cfl+ a b c) (cfl+ a (cfl+ b c)))
     (cfl~= (cfl+ a b c a b c) (cfl+ (cfl+ a b c) (cfl+ a b c)))
     (cfl~= (cfl+ 1+2.0i 3.0) 4.0+2.0i)
     (cfl~= (cfl+ 1.0+2.2i -3.7+5.3i) -2.7+7.5i)
     (cfl~= (cfl+ 1.0+2.2i -3.7) -2.7+2.2i)
     (cfl~= (cfl+ 1.0 -3.7+5.3i) -2.7+5.3i)
     (cfl~= (cfl+ 1.0+2.2i +5.3i) 1.0+7.5i)
     (cfl~= (cfl+ +2.2i -3.7+5.3i) -3.7+7.5i)
     (cfl~= (cfl+ 26.0 2.0) 28.0)
     (test-cp0-expansion eqv? '(cfl+) zero)
     (test-cp0-expansion eqv? `(cfl+ ,a) a)
     (test-cp0-expansion eqv? `(cfl+ ,b) b)
     (test-cp0-expansion eqv? `(cfl+ ,c) c)
     (test-cp0-expansion eqv? `(cfl+ ,a ,b) c)
     (test-cp0-expansion cfl~= `(cfl+ ,a ,b ,c) (cfl+ a (cfl+ b c)))
     (test-cp0-expansion cfl~=
       `(cfl+ ,a ,b ,c ,a ,b ,c)
       (cfl+ (cfl+ a b c) (cfl+ a b c)))
     (test-cp0-expansion cfl~= '(cfl+ 1+2.0i 3.0) 4.0+2.0i)
     (test-cp0-expansion cfl~= '(cfl+ 1.0+2.2i -3.7+5.3i) -2.7+7.5i)
     (test-cp0-expansion cfl~= '(cfl+ 1.0+2.2i -3.7) -2.7+2.2i)
     (test-cp0-expansion cfl~= '(cfl+ 1.0 -3.7+5.3i) -2.7+5.3i)
     (test-cp0-expansion cfl~= '(cfl+ 1.0+2.2i +5.3i) 1.0+7.5i)
     (test-cp0-expansion cfl~= '(cfl+ +2.2i -3.7+5.3i) -3.7+7.5i)
     (test-cp0-expansion cfl~= '(cfl+ 26.0 2.0) 28.0))

(mat cfl-
     (error? (cfl- 'a))
     (error? (cfl- 'a 3))
     (error? (cfl- 'a 3 4))
     (error? (cfl-))
     (eqv? (cfl- a) -1.1)
     (eqv? (cfl- b) -0.0-1.1i)
     (eqv? (cfl- c) -1.1-1.1i)
     (eqv? (cfl- a a) zero)
     (cfl~= (cfl- b b) zero)
     (cfl~= (cfl- c c) zero)
     (eqv? (cfl- c a) b)
     (cfl~= (cfl- c b) a)
     (cfl~= (cfl- a b c) (cfl- (cfl- a b) c))
     (cfl~= (cfl- a b c a b c) (cfl- a (cfl+ b c a b c)))
     (cfl~= (cfl- 1+2.0i 3.0) -2.0+2.0i)
     (cfl~= (cfl- 1.0+2.2i -3.7+5.3i) 4.7-3.1i)
     (cfl~= (cfl- 1.0+2.2i -3.7) 4.7+2.2i)
     (cfl~= (cfl- 1.0 -3.7+5.3i) 4.7-5.3i)
     (cfl~= (cfl- 1.0+2.2i +5.3i) 1.0-3.1i)
     (cfl~= (cfl- +2.2i -3.7+5.3i) 3.7-3.1i)
     (cfl~= (cfl- 26.0 2.0) 24.0)
     (andmap (lambda (a)
               (andmap (lambda (b)
                         (andmap (lambda (c)
                                   (eqv? (cfl- a b c) (cfl- (cfl- a b) c)))
                                 '(0.0 -0.0)))
                       '(0.0 -0.0)))
             '(0.0 -0.0))
     (let ()
       (define-syntax ff
         (syntax-rules ()
           [(_ k1 k2)
            (lambda (x)
              (eqv? (cfl- k1 x k2) (cfl- (cfl- k1 x) k2)))]))
       (andmap (lambda (p) (and (p +0.0) (p -0.0)))
               (list (ff +0.0 +0.0)
                     (ff +0.0 -0.0)
                     (ff -0.0 +0.0)
                     (ff -0.0 -0.0))))
     (error? (cfl- 3.0 5.4 'a))
     (error? (cfl- 'a 3.0 5.4))
     (error? (cfl- 3.0 'a 5.4))
     (eqv? (cfl- 5.0 4.0 3.0 2.0) -4.0)
     (eqv? (cfl- 5.0 4.0 3.0 2.0 1.0 0.0 -1.0 -2.0) -2.0)
     (cfl~= (cfl- 1e30 1e30 7.0) -7.0)
     (test-cp0-expansion eqv? `(cfl- ,a) -1.1)
     (test-cp0-expansion eqv? `(cfl- ,b) -0.0-1.1i)
     (test-cp0-expansion eqv? `(cfl- ,c) -1.1-1.1i)
     (test-cp0-expansion eqv? `(cfl- ,a ,a) zero)
     (test-cp0-expansion cfl~= `(cfl- ,b ,b) zero)
     (test-cp0-expansion cfl~= `(cfl- ,c ,c) zero)
     (test-cp0-expansion eqv? `(cfl- ,c ,a) b)
     (test-cp0-expansion cfl~= `(cfl- ,c ,b) a)
     (test-cp0-expansion cfl~= `(cfl- ,a ,b ,c) (cfl- (cfl- a b) c))
     (test-cp0-expansion cfl~=
       `(cfl- ,a ,b ,c ,a ,b ,c)
       (cfl- a (cfl+ b c a b c)))
     (test-cp0-expansion cfl~= '(cfl- 1+2.0i 3.0) -2.0+2.0i)
     (test-cp0-expansion cfl~= '(cfl- 1.0+2.2i -3.7+5.3i) 4.7-3.1i)
     (test-cp0-expansion cfl~= '(cfl- 1.0+2.2i -3.7) 4.7+2.2i)
     (test-cp0-expansion cfl~= '(cfl- 1.0 -3.7+5.3i) 4.7-5.3i)
     (test-cp0-expansion cfl~= '(cfl- 1.0+2.2i +5.3i) 1.0-3.1i)
     (test-cp0-expansion cfl~= '(cfl- +2.2i -3.7+5.3i) 3.7-3.1i)
     (test-cp0-expansion cfl~= '(cfl- 26.0 2.0) 24.0)
     (test-cp0-expansion eqv? '(cfl- 5.0 4.0 3.0 2.0) -4.0)
     (test-cp0-expansion eqv?
       '(cfl- 5.0 4.0 3.0 2.0 1.0 0.0 -1.0 -2.0)
       -2.0)
     (test-cp0-expansion cfl~= '(cfl- 1e30 1e30 7.0) -7.0))

(mat cfl*
     (error? (cfl* 'a))
     (error? (cfl* 'a 3))
     (error? (cfl* 'a 3 4))
     (eqv? (cfl*) 1.0)
     (eqv? (cfl* a) a)
     (eqv? (cfl* b) b)
     (eqv? (cfl* c) c)
     (eqv? (cfl* zero a) zero)
     (cfl~= (cfl* zero b) zero)
     (cfl~= (cfl* zero c) zero)
     (cfl~= (cfl* a a) aa)
     (cfl~= (cfl* a b) ab)
     (cfl~= (cfl* a c) ac)
     (cfl~= (cfl* b b) bb)
     (cfl~= (cfl* b c) bc)
     (cfl~= (cfl* c c) cc)
     (cfl~= (cfl* a b c) (cfl* a (cfl* b c)))
     (cfl~= (cfl* a b c a b c) (cfl* (cfl* a b c) (cfl* a b c)))
     (cfl~= (cfl* 1+2.0i 3.0) 3.0+6.0i)
     (cfl~= (cfl* 1.0+2.0i 3.0+4.0i) -5.0+10.0i)
     (cfl~= (cfl* 1.0+2.0i 3.0) 3.0+6.0i)
     (cfl~= (cfl* -2.0 3.0+4.0i) -6.0-8.0i)
     (cfl~= (cfl* 1.0+2.0i +4.0i) -8.0+4.0i)
     (cfl~= (cfl* +2.0i 3.0+4.0i) -8.0+6.0i)
     (cfl~= (cfl* 26.0 2.0) 52.0)
     (test-cp0-expansion eqv? '(cfl*) 1.0)
     (test-cp0-expansion eqv? `(cfl* ,a) a)
     (test-cp0-expansion eqv? `(cfl* ,b) b)
     (test-cp0-expansion eqv? `(cfl* ,c) c)
     (test-cp0-expansion eqv? `(cfl* ,zero ,a) zero)
     (test-cp0-expansion cfl~= `(cfl* ,zero ,b) zero)
     (test-cp0-expansion cfl~= `(cfl* ,zero ,c) zero)
     (test-cp0-expansion cfl~= `(cfl* ,a ,a) aa)
     (test-cp0-expansion cfl~= `(cfl* ,a ,b) ab)
     (test-cp0-expansion cfl~= `(cfl* ,a ,c) ac)
     (test-cp0-expansion cfl~= `(cfl* ,b ,b) bb)
     (test-cp0-expansion cfl~= `(cfl* ,b ,c) bc)
     (test-cp0-expansion cfl~= `(cfl* ,c ,c) cc)
     (test-cp0-expansion cfl~= `(cfl* ,a ,b ,c) (cfl* a (cfl* b c)))
     (test-cp0-expansion cfl~=
       `(cfl* ,a ,b ,c ,a ,b ,c)
       (cfl* (cfl* a b c) (cfl* a b c)))
     (test-cp0-expansion cfl~= '(cfl* 1+2.0i 3.0) 3.0+6.0i)
     (test-cp0-expansion cfl~= '(cfl* 1.0+2.0i 3.0+4.0i) -5.0+10.0i)
     (test-cp0-expansion cfl~= '(cfl* 1.0+2.0i 3.0) 3.0+6.0i)
     (test-cp0-expansion cfl~= '(cfl* -2.0 3.0+4.0i) -6.0-8.0i)
     (test-cp0-expansion cfl~= '(cfl* 1.0+2.0i +4.0i) -8.0+4.0i)
     (test-cp0-expansion cfl~= '(cfl* +2.0i 3.0+4.0i) -8.0+6.0i)
     (test-cp0-expansion cfl~= '(cfl* 26.0 2.0) 52.0))

(mat cfl/
     (error? (cfl/ 'a))
     (error? (cfl/ 'a 3))
     (error? (cfl/ 'a 3 4))
     (error? (cfl/))
     (fl~= (cfl/ a) (fl/ a))
     (eqv? (cfl/ zero a) zero)
     (cfl~= (cfl/ zero b) zero)
     (cfl~= (cfl/ zero c) zero)
     (cfl~= (cfl/ a a) 1.0)
     (cfl~= (cfl/ b b) 1.0)
     (cfl~= (cfl/ c c) 1.0)
     (cfl~= (cfl/ aa a) a)
     (cfl~= (cfl/ ab b) a)
     (cfl~= (cfl/ ab a) b)
     (cfl~= (cfl/ ac c) a)
     (cfl~= (cfl/ ac a) c)
     (cfl~= (cfl/ bc c) b)
     (cfl~= (cfl/ bc b) c)
     (cfl~= (cfl/ cc c) c)
     (cfl~= (cfl/ a b c) (cfl/ (cfl/ a b) c))
     (cfl~= (cfl/ a b c a b c) (cfl/ a (cfl* b c a b c)))
     (cfl~= (cfl/ 3+6.0i 3.0) 1.0+2.0i)
     (cfl~= (cfl/ -5.0+10.0i 1.0+2.0i) 3.0+4.0i)
     (cfl~= (cfl/ -6.0-8.0i -2.0) 3.0+4.0i)
     (cfl~= (cfl/ 26.0 3.0-2.0i) 6.0+4.0i)
     (cfl~= (cfl/ -8.0+6.0i +2.0i) 3.0+4.0i)
     (cfl~= (cfl/ +26.0i 3.0+2.0i) 4.0+6.0i)
     (cfl~= (cfl/ 26.0 2.0) 13.0)
     (andmap (lambda (a)
               (andmap (lambda (b)
                         (andmap (lambda (c)
                                   (eqv? (cfl/ a b c) (cfl/ (cfl/ a b) c)))
                                 '(1e300 1e250)))
                       '(1e300 1e250)))
             '(1e300 1e250))
     (error? (cfl/ 3.0 5.4 'a))
     (error? (cfl/ 'a 3.0 5.4))
     (error? (cfl/ 3.0 'a 5.4))
     (eqv? (cfl/ 16.0 2.0 -2.0 2.0) -2.0)
     (eqv? (cfl/ 16.0 2.0 -2.0 2.0 4.0 1.0 -1.0) 0.5)
     (test-cp0-expansion eqv? `(cfl/ ,zero ,a) zero)
     (test-cp0-expansion eqv? '(cfl/ 16.0 2.0 -2.0 2.0) -2.0)
     (test-cp0-expansion eqv? '(cfl/ 16.0 2.0 -2.0 2.0 4.0 1.0 -1.0) 0.5)
     (test-cp0-expansion cfl~= `(cfl/ ,zero ,b) zero)
     (test-cp0-expansion cfl~= `(cfl/ ,zero ,c) zero)
     (test-cp0-expansion cfl~= `(cfl/ ,a ,a) 1.0)
     (test-cp0-expansion cfl~= `(cfl/ ,b ,b) 1.0)
     (test-cp0-expansion cfl~= `(cfl/ ,c ,c) 1.0)
     (test-cp0-expansion cfl~= `(cfl/ ,aa ,a) a)
     (test-cp0-expansion cfl~= `(cfl/ ,ab ,b) a)
     (test-cp0-expansion cfl~= `(cfl/ ,ab ,a) b)
     (test-cp0-expansion cfl~= `(cfl/ ,ac ,c) a)
     (test-cp0-expansion cfl~= `(cfl/ ,ac ,a) c)
     (test-cp0-expansion cfl~= `(cfl/ ,bc ,c) b)
     (test-cp0-expansion cfl~= `(cfl/ ,bc ,b) c)
     (test-cp0-expansion cfl~= `(cfl/ ,cc ,c) c)
     (test-cp0-expansion cfl~= `(cfl/ ,a ,b ,c) (cfl/ (cfl/ a b) c))
     (test-cp0-expansion cfl~=
       `(cfl/ ,a ,b ,c ,a ,b ,c)
       (cfl/ a (cfl* b c a b c)))
     (test-cp0-expansion cfl~= '(cfl/ 3+6.0i 3.0) 1.0+2.0i)
     (test-cp0-expansion cfl~= '(cfl/ -5.0+10.0i 1.0+2.0i) 3.0+4.0i)
     (test-cp0-expansion cfl~= '(cfl/ -6.0-8.0i -2.0) 3.0+4.0i)
     (test-cp0-expansion cfl~= '(cfl/ 26.0 3.0-2.0i) 6.0+4.0i)
     (test-cp0-expansion cfl~= '(cfl/ -8.0+6.0i +2.0i) 3.0+4.0i)
     (test-cp0-expansion cfl~= '(cfl/ +26.0i 3.0+2.0i) 4.0+6.0i)
     (test-cp0-expansion cfl~= '(cfl/ 26.0 2.0) 13.0))

(mat cfl=
     (error? (cfl= 'a))
     (error? (cfl= 'a 3))
     (error? (cfl= 'a 3 4))
     (error? (cfl=))
     (cfl= a a)
     (cfl= b b)
     (cfl= c c)
     (cfl= (- c c) zero)
     (cfl= (+ a b) c)
     (not (cfl= a b))
     (cfl= 1.1+1.1i c)
     (cfl= c 1.1+1.1i c)
     (not (cfl= c 1.1+1.1i c a))
     (not (cfl= 3+6.0i 3.0))
     (not (cfl= 3+6.0i +6.0i))
     (cfl= 1.0+2.0i 1.0+2.0i)
     (cfl= 5.4 5.4))

;;; foreign.ms
;;; Copyright 1984-2017 Cisco Systems, Inc.
;;; 
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;; 
;;; http://www.apache.org/licenses/LICENSE-2.0
;;; 
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

(define-syntax machine-case
  (lambda (x)
    (syntax-case x ()
      [(_ [(a ...) e ...] m ...)
       (if (memq (machine-type) (datum (a ...)))
           #'(begin (void) e ...)
           #'(machine-case m ...))]
      [(_ [else e ...]) #'(begin (void) e ...)]
      [(_) #'(void)])))

#;
(define-syntax foreign-struct-mat
  (syntax-rules ()
    [(_ name n)
     (mat name
          (set! fs-size
            ((foreign-procedure (format "s~a_size" n) () unsigned-32)))
          (set! fs-align
            ((foreign-procedure (format "s~a_align" n) () unsigned-32)))
          (set! fs-get-s
            (eval `(foreign-procedure ,(format "get_s~a" n)
                     (char)
                     (foreign-object ,fs-size ,fs-align))))
          (set! fs-get-sp
            (foreign-procedure (format "get_s~ap" n)
              (char)
              foreign-pointer))
          (set! fs-s_f1_s
            (eval `(foreign-procedure ,(format "s~a_f1_s~a" n n)
                     ((foreign-object ,fs-size ,fs-align)
                      (foreign-object ,fs-size ,fs-align))
                     (foreign-object ,fs-size ,fs-align))))
          (set! fs-sp_f1_s
            (eval `(foreign-procedure ,(format "s~ap_f1_s~a" n n)
                     (foreign-pointer (foreign-object ,fs-size ,fs-align))
                     (foreign-object ,fs-size ,fs-align))))
          (set! fs-s_f1_sp
            (eval `(foreign-procedure ,(format "s~a_f1_s~ap" n n)
                     ((foreign-object ,fs-size ,fs-align) foreign-pointer)
                     (foreign-object ,fs-size ,fs-align))))
          (set! fs-sp_f1_sp
            (eval `(foreign-procedure ,(format "s~ap_f1_s~ap" n n)
                     (foreign-pointer foreign-pointer)
                     (foreign-object ,fs-size ,fs-align))))
          (set! fs-s_f2_s
            (eval `(foreign-procedure ,(format "s~a_f2_s~a" n n)
                     (integer-32 (foreign-object ,fs-size ,fs-align)
                       (foreign-object ,fs-size ,fs-align))
                     (foreign-object ,fs-size ,fs-align))))
          (set! fs-sp_f2_s
            (eval `(foreign-procedure ,(format "s~ap_f2_s~a" n n)
                     (integer-32 foreign-pointer
                       (foreign-object ,fs-size ,fs-align))
                     (foreign-object ,fs-size ,fs-align))))
          (set! fs-s_f2_sp
            (eval `(foreign-procedure ,(format "s~a_f2_s~ap" n n)
                     (integer-32
                       (foreign-object ,fs-size ,fs-align)
                       foreign-pointer)
                     (foreign-object ,fs-size ,fs-align))))
          (set! fs-sp_f2_sp
            (eval `(foreign-procedure ,(format "s~ap_f2_s~ap" n n)
                     (integer-32 foreign-pointer foreign-pointer)
                     (foreign-object ,fs-size ,fs-align))))
          (set! fs-s_f3_s
            (eval `(foreign-procedure ,(format "s~a_f3_s~a" n n)
                     ((foreign-object ,fs-size ,fs-align)
                      (foreign-object ,fs-size ,fs-align))
                     boolean)))
          (set! fs-sp_f3_s
            (eval `(foreign-procedure ,(format "s~ap_f3_s~a" n n)
                     (foreign-pointer (foreign-object ,fs-size ,fs-align))
                     boolean)))
          (set! fs-s_f3_sp
            (eval `(foreign-procedure ,(format "s~a_f3_s~ap" n n)
                     ((foreign-object ,fs-size ,fs-align) foreign-pointer)
                     boolean)))
          (set! fs-sp_f3_sp
            (eval `(foreign-procedure ,(format "s~ap_f3_s~ap" n n)
                     (foreign-pointer foreign-pointer)
                     boolean)))

          (set! fs-a (fs-get-s #\a))
          (string? fs-a)
          (set! fs-ap (fs-get-sp #\a))
          (integer? fs-ap)
          (set! fs-b (fs-get-s #\b))
          (string? fs-b)
          (set! fs-bp (fs-get-sp #\b))
          (integer? fs-bp)


          (fs-s_f3_s fs-a fs-a)
          (fs-s_f3_s fs-a fs-ap)
          (fs-s_f3_s fs-ap fs-a)
          (fs-s_f3_s fs-ap fs-ap)
          (fs-sp_f3_s fs-a fs-a)
          (fs-sp_f3_s fs-a fs-ap)
          (fs-sp_f3_s fs-ap fs-a)
          (fs-sp_f3_s fs-ap fs-ap)
          (fs-s_f3_sp fs-a fs-a)
          (fs-s_f3_sp fs-a fs-ap)
          (fs-s_f3_sp fs-ap fs-a)
          (fs-s_f3_sp fs-ap fs-ap)
          (fs-sp_f3_sp fs-a fs-a)
          (fs-sp_f3_sp fs-a fs-ap)
          (fs-sp_f3_sp fs-ap fs-a)
          (fs-sp_f3_sp fs-ap fs-ap)

          (not (fs-s_f3_s fs-a fs-b))
          (not (fs-s_f3_s fs-a fs-bp))
          (not (fs-s_f3_s fs-ap fs-b))
          (not (fs-s_f3_s fs-ap fs-bp))
          (not (fs-sp_f3_s fs-a fs-b))
          (not (fs-sp_f3_s fs-a fs-bp))
          (not (fs-sp_f3_s fs-ap fs-b))
          (not (fs-sp_f3_s fs-ap fs-bp))
          (not (fs-s_f3_sp fs-a fs-b))
          (not (fs-s_f3_sp fs-a fs-bp))
          (not (fs-s_f3_sp fs-ap fs-b))
          (not (fs-s_f3_sp fs-ap fs-bp))
          (not (fs-sp_f3_sp fs-a fs-b))
          (not (fs-sp_f3_sp fs-a fs-bp))
          (not (fs-sp_f3_sp fs-ap fs-b))
          (not (fs-sp_f3_sp fs-ap fs-bp))

          (fs-sp_f3_sp (fs-s_f1_s fs-ap fs-bp) (fs-sp_f1_s fs-a fs-bp))
          (fs-sp_f3_sp (fs-s_f1_sp fs-ap fs-b) (fs-sp_f1_sp fs-a fs-b))

          (fs-sp_f3_sp (fs-s_f2_s 1 fs-ap fs-bp) (fs-sp_f2_s 1 fs-a fs-bp))
          (fs-sp_f3_sp (fs-s_f2_sp 1 fs-ap fs-b) (fs-sp_f2_sp 1 fs-a fs-b)))]))

(define-syntax auto-mat-ick
  (lambda (x)
    (syntax-case x ()
      ((_ name)
       (let ((ls (let f ([ls (string->list (datum name))])
                   (if (null? ls)
                       '()
                       (cons (car ls) (f (cddr ls)))))))
         (with-syntax
           ([((p v) ...)
             (map (lambda (c)
                    (case (syntax->datum c)
                      [(#\n) `(,(syntax integer-32) ,(random 1000))]
                      [(#\s)
                       `(,(syntax single-float)
                         ,(truncate (random 1000.0)))]
                      [(#\d)
                       `(,(syntax double-float)
                         ,(truncate (random 1000.0)))]))
                  ls)])
           (syntax (= (let ([x (foreign-procedure name (p ...) double-float)])
                        (x v ...))
                      (+ v ...)))))))))

(machine-case
  [(i3ob ti3ob a6ob ta6ob a6s2 ta6s2 i3s2 ti3s2 i3qnx ti3qnx)
   (mat load-shared-object
        (file-exists? "foreign1.so")
        (begin (load-shared-object "./foreign1.so") #t)
        (begin (load-shared-object "libc.so") #t)
        (error? (load-shared-object 3)))]
  [(i3le ti3le a6le ta6le arm32le tarm32le ppc32le tppc32le)
   (mat load-shared-object
        (file-exists? "foreign1.so")
        (begin (load-shared-object "./foreign1.so") #t)
        (begin (load-shared-object "libc.so.6") #t)
        (error? (load-shared-object 3)))]
  [(i3fb ti3fb a6fb ta6fb)
   (mat load-shared-object
        (file-exists? "foreign1.so")
        (begin (load-shared-object "./foreign1.so") #t)
        (begin (load-shared-object "libc.so.7") #t)
        (error? (load-shared-object 3)))]
  [(i3nb ti3nb a6nb ta6nb)
   (mat load-shared-object
        (file-exists? "foreign1.so")
        (begin (load-shared-object "./foreign1.so") #t)
        (begin (load-shared-object "libc.so") #t)
        (error? (load-shared-object 3)))]
  [(i3nt ti3nt a6nt ta6nt)
   (mat load-shared-object
        (file-exists? "foreign1.so")
        (begin (load-shared-object "foreign1.so") #t)
        (begin (load-shared-object "msvcrt.dll") #t)
        (begin (load-shared-object "kernel32.dll") #t)
        (error? (load-shared-object 3)))]
  [(i3osx ti3osx a6osx ta6osx)
   (mat load-shared-object
        (file-exists? "foreign1.so")
        (begin (load-shared-object "./foreign1.so") #t)
        (begin (load-shared-object "libc.dylib") #t)
        #t
        (error? (load-shared-object 3)))]
  [else
   (mat foreign-procedure
        (error? (foreign-procedure "foo" () scheme-object))
        (begin
          (define (idint32 x)
            (errorf 'idint32 "invalid foreign-procedure argument ~s" x))
          (procedure? idint32))
        (error? (idint32 #x80000000))
        (error? (idint32 #x80000001))
        (error? (idint32 #xffffffff))
        (error? (idint32 #x8000000080000000))
        (error? (idint32 #x-80000001))
        (error? (idint32 #x-8000000080000000))
        (error? (idint32 #f))
        (error? (idint32 "hi"))
        (begin
          (define (iduns32 x)
            (errorf 'iduns32 "invalid foreign-procedure argument ~s" x))
          (procedure? iduns32))
        (error? (iduns32 #x100000000))
        (error? (iduns32 #x8000000080000000))
        (error? (iduns32 -1))
        (error? (iduns32 #x-7fffffff))
        (error? (iduns32 #x-80000000))
        (error? (iduns32 #x-80000001))
        (error? (iduns32 #x-8000000080000000))
        (error? (iduns32 #f))
        (error? (iduns32 "hi"))
        (begin
          (define (idfix x)
            (errorf 'idfix "invalid foreign-procedure argument ~s" x))
          (procedure? idfix))
        (error? (idfix (+ (most-positive-fixnum) 1)))
        (error? (idfix (- (most-negative-fixnum) 1)))
        (error? (errorf 'id "return value ~s is out of range" #x7fffffff))
        (error? (errorf 'id "return value ~s is out of range" #x-80000000))
        (error? (errorf 'id "invalid foreign-procedure argument ~s" 0))
        (error? (errorf 'id "return value ~s is out of range" #x7fffffff))
        (error? (errorf 'id "invalid foreign-procedure argument ~s" 'foo))
        (error? (foreign-procedure 'abcde (integer-32) integer-32))
        (error? (errorf 'float_id
                        "invalid foreign-procedure argument ~s"
                        0)))])

(mat foreign-entry?
     (foreign-entry? "id")
     (foreign-entry? "idid")
     (foreign-entry? "ididid")
     (not (foreign-entry? "foo")))

(mat foreign-procedure
     (procedure?
       (foreign-procedure "idiptr" (scheme-object) scheme-object))
     (error? (foreign-procedure "i do not exist"
               (scheme-object)
               scheme-object))
     (error? (begin
               (foreign-procedure "i do not exist" () scheme-object)
               'q))
     (error? (if (foreign-procedure "i do not exist" () scheme-object)
                 'q
                 'q))
     (error? (foreign-procedure 'foo () scheme-object))
     (error? (begin (foreign-procedure 'foo () scheme-object) 'q))
     (error? (if (foreign-procedure 'foo () scheme-object) 'q 'q))

     (eq? 'foo
          ((foreign-procedure "idiptr" (scheme-object) scheme-object) 'foo))

     (parameterize ([current-eval interpret])
       (eq? 'foo
            ((foreign-procedure "idiptr" (scheme-object) scheme-object) 'foo)))

     (not (eq? 'foo
               ((foreign-procedure "idiptr" (scheme-object) void) 'foo)))

     (begin
       (define idint32
         (foreign-procedure "id" (integer-32) integer-32))
       (procedure? idint32))
     (eqv? (idint32 0) 0)
     (eqv? (idint32 #x7fffffff) #x7fffffff)
     (eqv? (idint32 -1) -1)
     (eqv? (idint32 #x-7fffffff) #x-7fffffff)
     (eqv? (idint32 #x-80000000) #x-80000000)
     (eqv? (idint32 #x80000000) (+ #x-100000000 #x80000000))
     (eqv? (idint32 #x80000001) (+ #x-100000000 #x80000001))
     (eqv? (idint32 #xffffffff) (+ #x-100000000 #xffffffff))
     (error? (idint32 #x100000000))
     (error? (idint32 #x100000001))
     (error? (idint32 #xfffffffffffffffffffffffffffff))
     (error? (idint32 #x8000000080000000))
     (error? (idint32 #x-80000001))
     (error? (idint32 #x-8000000080000000))
     (error? (idint32 #f))
     (error? (idint32 "hi"))

     (begin
       (define iduns32
         (foreign-procedure "id" (unsigned-32) unsigned-32))
       (procedure? iduns32))
     (eqv? (iduns32 0) 0)
     (eqv? (iduns32 #x7fffffff) #x7fffffff)
     (eqv? (iduns32 #x80000000) #x80000000)
     (eqv? (iduns32 #x80000001) #x80000001)
     (eqv? (iduns32 #x88000000) #x88000000)
     (eqv? (iduns32 #xffffffff) #xffffffff)
     (error? (iduns32 #x100000000))
     (error? (iduns32 #x8000000080000000))
     (eqv? (iduns32 -1) (+ #x100000000 -1))
     (eqv? (iduns32 #x-7fffffff) (+ #x100000000 #x-7fffffff))
     (eqv? (iduns32 #x-80000000) (+ #x100000000 #x-80000000))
     (error? (iduns32 #x-80000001))
     (error? (iduns32 #x-ffffffff))
     (error? (iduns32 #x-fffffffffffffffffffffffffffffffff))
     (error? (iduns32 #x-80000001))
     (error? (iduns32 #x-8000000080000000))
     (error? (iduns32 #f))
     (error? (iduns32 "hi"))

     (eqv? #xffffffff
           ((foreign-procedure "id" (integer-32) unsigned-32) -1))
     (eqv? -1
           ((foreign-procedure "id" (unsigned-32) integer-32) #xffffffff))

     (begin
       (define idfix
         (foreign-procedure "idiptr" (fixnum) fixnum))
       (procedure? idfix))
     (eqv? 0 (idfix 0))
     (eqv? -1 (idfix -1))
     (eqv? (quotient (most-positive-fixnum) 2)
           (idfix (quotient (most-positive-fixnum) 2)))
     (eqv? (quotient (most-negative-fixnum) 2)
           (idfix (quotient (most-negative-fixnum) 2)))
     (eqv? (most-positive-fixnum) (idfix (most-positive-fixnum)))
     (eqv? (most-negative-fixnum) (idfix (most-negative-fixnum)))
     (error? (idfix (+ (most-positive-fixnum) 1)))
     (error? (idfix (- (most-negative-fixnum) 1)))

     ; we've eliminated the return range checks---caveat emptor
     ;   (error? ((foreign-procedure "id" (integer-32) fixnum) #x7fffffff))
     ;   (error? ((foreign-procedure "id" (integer-32) fixnum) #x-80000000))
     ;   (error? ((foreign-procedure "id" (integer-32) char) #x7fffffff))

     (error? (foreign-procedure "id" (booleen) char))
     (error? (foreign-procedure "id" (integer-32 integer-34) char))
     (error? (foreign-procedure "id" () chare))
     (error? (foreign-procedure "id" (void) char))

     ((foreign-procedure "id" (boolean) boolean) #t)
     (not ((foreign-procedure "id" (boolean) boolean) #f))
     ((foreign-procedure "id" (boolean) boolean) 0)
     (= 1 ((foreign-procedure "id" (boolean) integer-32) #t))
     (= 1 ((foreign-procedure "id" (boolean) integer-32) 0))
     (= 0 ((foreign-procedure "id" (boolean) integer-32) #f))
     (not ((foreign-procedure "id" (integer-32) boolean) 0))
     ((foreign-procedure "id" (integer-32) boolean) 1)

     (char=? #\a ((foreign-procedure "id" (char) char) #\a))
     (= 0 ((foreign-procedure "id" (char) integer-32) #\nul))
     (char=? #\nul ((foreign-procedure "id" (integer-32) char) 0))
     (eqv? ((foreign-procedure "id" (integer-32) char) -1) #\377)
     (error? ((foreign-procedure "id" (char) void) 0))

     (let ([s "now is the time for all good men"])
       (string=? s ((foreign-procedure "idiptr" (string) string) s)))
     (let ([s "now is the time for all good men"])
       (not (eq? s ((foreign-procedure "idiptr" (string) string) s))))
     ; assuming iptr is same size as char *:
     (let ([id1 (foreign-procedure "idiptr" (string) string)]
           [id2 (foreign-procedure "idiptr" (string) iptr)]
           [id3 (foreign-procedure "idiptr" (iptr) string)])
       (and (eq? (id1 #f) #f)
            (eq? (id2 #f) 0)
            (eq? (id3 0) #f)))
     (let ()
       (define $string->bytevector
         (lambda (s)
           (let ([n (string-length s)])
             (let ([bv (make-bytevector (+ n 1))])
               (do ([i 0 (fx+ i 1)])
                   ((fx= i n))
                   (bytevector-u8-set! bv i
                     (char->integer (string-ref s i))))
               (bytevector-u8-set! bv n 0)
               bv))))
       (let ([s "now is the time for all good men"]
             [r "                                "])
         (let ([bv ($string->bytevector r)])
           ((foreign-procedure (if (windows?) "windows_strcpy" "strcpy")
              (u8* string)
              void) bv s)
           (= 0
              ((foreign-procedure (if (windows?) "windows_strcmp" "strcmp")
                 (u8* string)
                 integer-32) bv s)))))
     (error? ((foreign-procedure "id" (string) void) 'foo))

     (= ((foreign-procedure "idid" (integer-32) integer-32) #xc7c7c7)
        #xc7c7c7)
     (= ((foreign-procedure "ididid" (integer-32) integer-32) #x7c7c7c7c)
        #x7c7c7c7c)

     (= ((foreign-procedure "id" (unsigned-32) unsigned-32) #x80000000)
        #x80000000)
     (= ((foreign-procedure "id" (unsigned-32) integer-32) #x80000000)
        #x-80000000)

     (error? (foreign-procedure 'abcde (integer-32) integer-32))
     (let ([template (lambda (x) (foreign-procedure x (char) boolean))])
       (let ([id (template "id")]
             [idid (template "idid")]
             [ididid (template "ididid")])
         (and (eqv? (id #\nul) #f)
              (eqv? (idid #\001) #t)
              (eqv? (idid #\a) #t))))

     (= 0.0
        ((foreign-procedure "float_id" (double-float) double-float) 0.0))
     (= 1.1
        ((foreign-procedure "float_id" (double-float) double-float) 1.1))
     (error? ((foreign-procedure "float_id" (double-float) void) 0))

     (let ([fid (foreign-procedure "float_id" (double-float) double-float)])
       (let f ((n 10000))
         (or (= n 0)
             (let ([x (random 1.0)])
               (and (eqv? x (fid x)) (f (- n 1)))))))

     (= (+ (* 1 29)
           (* 2 31)
           (* 3 37)
           (* 5 41)
           (* 7 43)
           (* 11 47)
           (* 13 49)
           (* 17 53)
           (* 19 59)
           (* 23 61))
        ((foreign-procedure "testten"
           (integer-32
             integer-32
             integer-32
             integer-32
             integer-32
             integer-32
             integer-32
             integer-32
             integer-32
             integer-32)
           integer-32)
         29
         31
         37
         41
         43
         47
         49
         53
         59
         61))

     (= (+ 1.1 2.2 3.3 4.4 5.5 6.6 7.7 8.8)
        ((foreign-procedure "flsum8"
           (double-float
             double-float
             double-float
             double-float
             double-float
             double-float
             double-float
             double-float)
           double-float)
         1.1
         2.2
         3.3
         4.4
         5.5
         6.6
         7.7
         8.8))

     (= (+ 1 2 3 4 5 6.75 7 8.5)
        ((foreign-procedure "sparcfltest"
           (integer-32
             integer-32
             integer-32
             integer-32
             integer-32
             double-float
             integer-32
             double-float)
           double-float)
         1
         2
         3
         4
         5
         6.75
         7
         8.5))

     (= (+ 1 2 3.3)
        ((foreign-procedure "mipsfltest1"
           (integer-32 integer-32 double-float)
           double-float) 1 2 3.3))

     (= (+ 1 2.2 3.3)
        ((foreign-procedure "mipsfltest2"
           (integer-32 double-float double-float)
           double-float) 1 2.2 3.3))

     (= (+ 1
           2.25
           3
           4.5
           5
           6.75
           7
           8.25
           9.5
           10.75
           11.25
           12.5
           13.75
           14.25
           15.5
           16.75
           17.25
           18.75
           19.25)
        ((foreign-procedure "ppcfltest"
           (integer-32
             double-float
             integer-32
             double-float
             integer-32
             double-float
             integer-32
             double-float
             double-float
             double-float
             double-float
             double-float
             double-float
             double-float
             double-float
             double-float
             double-float
             double-float
             double-float)
           double-float)
         1
         2.25
         3
         4.5
         5
         6.75
         7
         8.25
         9.5
         10.75
         11.25
         12.5
         13.75
         14.25
         15.5
         16.75
         17.25
         18.75
         19.25))

     (= (+ 1
           2.25
           3
           4.5
           5
           (expt 2 36)
           6.75
           7
           8.25
           (expt 2 39)
           75
           9.5
           10.75
           11.25
           12.5
           13.75
           14.25
           15.5
           20
           16.75
           21
           (expt 2 37)
           18.75
           22
           19.25)
        ((foreign-procedure "ppcfltest2"
           (integer-32
             double-float
             integer-32
             double-float
             integer-32
             integer-64
             double-float
             integer-32
             double-float
             ; next integer should be stack-allocated with the PPC ABI
             integer-64
             integer-32
             ; but next four floats should still get registers
             double-float
             double-float
             double-float
             double-float
             ; and remaining floags and ints should go on the stack
             double-float
             single-float
             double-float
             integer-32
             double-float
             integer-32
             integer-64
             double-float
             integer-32
             double-float)
           double-float)
         1
         2.25
         3
         4.5
         5
         (expt 2 36)
         6.75
         7
         8.25
         (expt 2 39)
         75
         9.5
         10.75
         11.25
         12.5
         13.75
         14.25
         15.5
         20
         16.75
         21
         (expt 2 37)
         18.75
         22
         19.25))

     ((foreign-procedure "chk_data" () boolean))
     ((foreign-procedure "chk_bss" () boolean))
     ((foreign-procedure "chk_malloc" () boolean))

     (begin
       (define $fp-tlv
         (foreign-procedure "(cs)s_tlv" (ptr) ptr))
       (define $fp-stlv!
         (foreign-procedure "(cs)s_stlv" (ptr ptr) void))
       #t)

     (equal? (let ()
               (define-syntax list-in-order
                 (syntax-rules ()
                   [(_) '()]
                   [(_ e . rest)
                    (let ([t e])
                      (cons t (list-in-order . rest)))]))
               (list-in-order ($fp-tlv 'cons)
                 ($fp-stlv! '$fp-spam 'yum)
                 ($fp-tlv '$fp-spam)
                 (top-level-value '$fp-spam)))
             `(,cons ,(void) yum yum))

     (equal? (let ()
               (define-syntax list-in-order
                 (syntax-rules ()
                   [(_) '()]
                   [(_ e . rest)
                    (let ([t e])
                      (cons t (list-in-order . rest)))]))
               (parameterize
                 ([interaction-environment
                    (copy-environment (scheme-environment))])
                 (list-in-order (define-top-level-value 'foo 17)
                   ($fp-tlv 'foo)
                   ($fp-stlv! 'bar 55)
                   ($fp-tlv 'bar)
                   (top-level-value 'bar))))
             `(,(void) 17 ,(void) 55 55))

     (equal? (parameterize
               ([interaction-environment
                  (copy-environment (scheme-environment))])
               ; should have no effect
               ($fp-stlv! cons 3)
               (list (#%$tc-field 'disable-count (#%$tc))
                     cons
                     ($fp-tlv 'cons)))
             `(0 ,cons ,cons))

     (equal? (parameterize
               ([interaction-environment
                  (copy-environment (scheme-environment))])
               ; should have no effect
               ($fp-stlv! 'let 3)
               (list (#%$tc-field 'disable-count (#%$tc))
                     (eval '(let ((x 23)) x))))
             '(0 23))

     (equal? (let ([x ($fp-tlv '$fp-i-am-not-bound)])
               (list (#%$tc-field 'disable-count (#%$tc)) x))
             `(0 ,(#%$unbound-object)))

     (equal? (let ([x ($fp-tlv 'let)])
               (list (#%$tc-field 'disable-count (#%$tc)) x))
             `(0 ,(#%$unbound-object)))

     (equal? ((foreign-procedure "(cs)s_test_schlib" () void)) (void))

     (begin
       (define $siv
         (foreign-procedure "(cs)Sinteger_value" (ptr) void))
       (define $si32v
         (foreign-procedure "(cs)Sinteger32_value" (ptr) void))
       (define $si64v
         (foreign-procedure "(cs)Sinteger64_value" (ptr) void))
       (define ($check p n)
         (or (= (optimize-level) 3)
             (guard (c [(and (assertion-violation? c)
                             (irritants-condition? c)
                             (equal? (condition-irritants c) (list n))) #t])
                    (p n)
                    #f)))
       #t)

     ; make sure no errors for in-range inputs
     (begin
       ($si32v (- (expt 2 32) 1))
       ($si32v (- (expt 2 31)))
       ($si64v (- (expt 2 64) 1))
       ($si64v (- (expt 2 63)))
       (if (< (fixnum-width) 32)
           (begin
             ; assume 32-bit words
             ($siv (- (expt 2 32) 1))
             ($siv (- (expt 2 31))))
           (begin
             ; assume 64-bit words
             ($siv (- (expt 2 64) 1))
             ($siv (- (expt 2 63)))))
       #t)

     ; check barely out-of-range inputs
     ($check $si32v (expt 2 32))
     ($check $si32v (- -1 (expt 2 31)))
     ($check $si64v (expt 2 64))
     ($check $si64v (- -1 (expt 2 63)))
     ($check $siv (expt 2 (if (< (fixnum-width) 32) 32 64)))
     ($check $siv (- -1 (expt 2 (if (< (fixnum-width) 32) 31 63))))

     ; check further out-of-range inputs
     ($check $si32v (expt 2 36))
     ($check $si32v (- -1 (expt 2 35)))
     ($check $si64v (expt 2 68))
     ($check $si64v (- -1 (expt 2 67)))
     ($check $siv (expt 2 (if (< (fixnum-width) 32) 36 68)))
     ($check $siv (- -1 (expt 2 (if (< (fixnum-width) 32) 35 67))))
     ($check $si32v (expt 2 100))
     ($check $si32v (- -1 (expt 2 100)))
     ($check $si64v (expt 2 100))
     ($check $si64v (- -1 (expt 2 100)))
     ($check $siv (expt 2 100))
     ($check $siv (- -1 (expt 2 100))))

(mat foreign-sizeof
     (equal? (list (foreign-sizeof 'integer-8)
                   (foreign-sizeof 'unsigned-8)
                   (foreign-sizeof 'integer-16)
                   (foreign-sizeof 'unsigned-16)
                   (foreign-sizeof 'integer-24)
                   (foreign-sizeof 'unsigned-24)
                   (foreign-sizeof 'integer-32)
                   (foreign-sizeof 'unsigned-32)
                   (foreign-sizeof 'integer-40)
                   (foreign-sizeof 'unsigned-40)
                   (foreign-sizeof 'integer-48)
                   (foreign-sizeof 'unsigned-48)
                   (foreign-sizeof 'integer-56)
                   (foreign-sizeof 'unsigned-56)
                   (foreign-sizeof 'integer-64)
                   (foreign-sizeof 'unsigned-64)
                   (foreign-sizeof 'single-float)
                   (foreign-sizeof 'double-float))
             '(1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 4 8))
     ((foreign-procedure "check_types"
        (int int int int int int int int int)
        boolean)
      (foreign-sizeof 'char)
      (foreign-sizeof 'wchar)
      (foreign-sizeof 'short)
      (foreign-sizeof 'int)
      (foreign-sizeof 'long)
      (foreign-sizeof 'long-long)
      (foreign-sizeof 'float)
      (foreign-sizeof 'double)
      (foreign-sizeof 'void*))
     (equal? (foreign-sizeof 'unsigned) (foreign-sizeof 'int))
     (equal? (foreign-sizeof 'unsigned-int) (foreign-sizeof 'int))
     (equal? (foreign-sizeof 'unsigned-short) (foreign-sizeof 'short))
     (equal? (foreign-sizeof 'unsigned-long) (foreign-sizeof 'long))
     (equal? (foreign-sizeof 'unsigned-long-long)
             (foreign-sizeof 'long-long))
     (equal? (foreign-sizeof 'boolean) (foreign-sizeof 'int))
     (equal? (foreign-sizeof 'fixnum) (foreign-sizeof 'iptr))
     (equal? (foreign-sizeof 'scheme-object) (foreign-sizeof 'void*))
     (equal? (foreign-sizeof 'ptr) (foreign-sizeof 'void*))
     (equal? (foreign-sizeof 'iptr) (foreign-sizeof 'void*))
     (equal? (foreign-sizeof 'uptr) (foreign-sizeof 'void*))
     (error? (foreign-sizeof))
     (error? (foreign-sizeof 'int 'int))
     (error? (foreign-sizeof 'i-am-not-a-type))
     (error? (foreign-sizeof '1)))

(mat foreign-bytevectors
     ; test u8*, u16*, u32*
     (begin
       (define u8*->u8*
         (foreign-procedure "u8_star_to_u8_star" (u8*) u8*))
       (define u16*->u16*
         (foreign-procedure "u16_star_to_u16_star" (u16*) u16*))
       (define u32*->u32*
         (foreign-procedure "u32_star_to_u32_star" (u32*) u32*))
       #t)
     (equal? (u8*->u8* #vu8(1 2 3 4 0)) #vu8(2 3 4))
     (equal? (u16*->u16* #vu8(1 2 3 4 5 6 7 8 0 0)) #vu8(3 4 5 6 7 8))
     (equal? (u32*->u32* #vu8(1 2 3 4 5 6 7 8 9 10 11 12 0 0 0 0))
             #vu8(5 6 7 8 9 10 11 12))

     (eq? (u8*->u8* #vu8(1 0)) #vu8())
     (eq? (u16*->u16* #vu8(1 2 0 0)) #vu8())
     (eq? (u32*->u32* #vu8(1 2 3 4 0 0 0 0)) #vu8())

     (eq? (u8*->u8* #f) #f)
     (eq? (u16*->u16* #f) #f)
     (eq? (u32*->u32* #f) #f)

     (error? (u8*->u8* "hello"))
     (error? (u16*->u16* "hello"))
     (error? (u32*->u32* "hello"))
     (error? (u8*->u8* 0))
     (error? (u16*->u16* 0))
     (error? (u32*->u32* 0))

     (begin
       (define call-u8*
         (foreign-procedure "call_u8_star" (ptr u8*) u8*))
       (define call-u16*
         (foreign-procedure "call_u16_star" (ptr u16*) u16*))
       (define call-u32*
         (foreign-procedure "call_u32_star" (ptr u32*) u32*))
       (define $bytevector-map
         (lambda (p bv)
           (u8-list->bytevector (map p (bytevector->u8-list bv)))))
       #t)
     (equal? (call-u8* (foreign-callable
                         (lambda (x)
                           ($bytevector-map
                             (lambda (x)
                               (if (= x 255) 0 (+ x 100)))
                             x))
                         (u8*)
                         u8*)
                       #vu8(1 2 3 4 5 255 0))
             '#vu8(103 104 105))
     (equal? (call-u16*
               (foreign-callable
                 (lambda (x)
                   ($bytevector-map
                     (lambda (x) (if (= x 255) 0 (+ x 100)))
                     x))
                 (u16*)
                 u16*)
               #vu8(1 2 3 4 5 6 255 255 0 0))
             '#vu8(105 106))
     (equal? (call-u32*
               (foreign-callable
                 (lambda (x)
                   ($bytevector-map
                     (lambda (x) (if (= x 255) 0 (+ x 100)))
                     x))
                 (u32*)
                 u32*)
               #vu8(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 255
                    255 255 255 0 0 0 0))
             '#vu8(109 110 111 112 113 114 115 116 117 118 119 120))
     (error? (let ([frotz (foreign-callable
                            (lambda (x)
                              (list x (bytevector-length x)))
                            (u8*)
                            u8*)])
               (call-u8* frotz #vu8(1 2 3 4 5 0))))
     (error? (call-u16*
               (foreign-callable
                 (lambda (x) (list x (bytevector-length x)))
                 (u16*)
                 u16*)
               #vu8(1 2 3 4 5 6 0 0)))
     (error? (call-u32*
               (foreign-callable
                 (lambda (x) (list x (bytevector-length x)))
                 (u32*)
                 u32*)
               #vu8(1 2 3 4 5 6 7 8 0 0 0 0)))
     (error? (call-u8* (foreign-callable
                         (lambda (x)
                           (list x (bytevector-length x)))
                         (u8*)
                         u8*)
                       '#(1 2 3 4 5 0)))
     (error? (call-u16*
               (foreign-callable
                 (lambda (x) (list x (bytevector-length x)))
                 (u16*)
                 u16*)
               '#(1 2 3 4 5 6 0 0)))
     (error? (call-u32*
               (foreign-callable
                 (lambda (x) (list x (bytevector-length x)))
                 (u32*)
                 u32*)
               '#(1 2 3 4 5 6 7 8 0 0 0 0))))

(mat foreign-strings
     ; test utf-8, utf-16le, utf-16be, utf-32le, utf-32be, string, wstring
     (begin
       (define utf-8->utf-8
         (foreign-procedure "u8_star_to_u8_star" (utf-8) utf-8))
       (define utf-16le->utf-16le
         (foreign-procedure "u16_star_to_u16_star" (utf-16le) utf-16le))
       (define utf-16be->utf-16be
         (foreign-procedure "u16_star_to_u16_star" (utf-16be) utf-16be))
       (define utf-32le->utf-32le
         (foreign-procedure "u32_star_to_u32_star" (utf-32le) utf-32le))
       (define utf-32be->utf-32be
         (foreign-procedure "u32_star_to_u32_star" (utf-32be) utf-32be))
       (define string->string
         (foreign-procedure "char_star_to_char_star" (string) string))
       (define wstring->wstring
         (foreign-procedure "wchar_star_to_wchar_star" (wstring) wstring))
       #t)
     (equal? (utf-8->utf-8 "hello") "ello")
     (equal? (utf-16le->utf-16le "hello") "ello")
     (equal? (utf-16be->utf-16be "hello") "ello")
     (equal? (utf-32le->utf-32le "hello") "ello")
     (equal? (utf-32be->utf-32be "hello") "ello")
     (equal? (string->string "hello") "ello")
     (equal? (wstring->wstring "hello") "ello")

     (eq? (utf-8->utf-8 "h") "")
     (eq? (utf-16le->utf-16le "h") "")
     (eq? (utf-16be->utf-16be "h") "")
     (eq? (utf-32le->utf-32le "h") "")
     (eq? (utf-32be->utf-32be "h") "")
     (eq? (string->string "h") "")
     (eq? (wstring->wstring "h") "")

     (eq? (utf-8->utf-8 #f) #f)
     (eq? (utf-16le->utf-16le #f) #f)
     (eq? (utf-16be->utf-16be #f) #f)
     (eq? (utf-32le->utf-32le #f) #f)
     (eq? (utf-32be->utf-32be #f) #f)
     (eq? (string->string #f) #f)
     (eq? (wstring->wstring #f) #f)

     (error? (utf-8->utf-8 #vu8(1 2 3 4 0 0 0 0)))
     (error? (utf-16le->utf-16le #vu8(1 2 3 4 0 0 0 0)))
     (error? (utf-16be->utf-16be #vu8(1 2 3 4 0 0 0 0)))
     (error? (utf-32le->utf-32le #vu8(1 2 3 4 0 0 0 0)))
     (error? (utf-32be->utf-32be #vu8(1 2 3 4 0 0 0 0)))
     (error? (string->string #vu8(1 2 3 4 0 0 0 0)))
     (error? (wstring->wstring #vu8(1 2 3 4 0 0 0 0)))

     (error? (utf-8->utf-8 0))
     (error? (utf-16le->utf-16le 0))
     (error? (utf-16be->utf-16be 0))
     (error? (utf-32le->utf-32le 0))
     (error? (utf-32be->utf-32be 0))
     (error? (string->string 0))
     (error? (wstring->wstring 0))

     (begin
       (define call-utf-8
         (foreign-procedure "call_u8_star" (ptr utf-8) utf-8))
       (define call-utf-16le
         (foreign-procedure "call_u16_star" (ptr utf-16le) utf-16le))
       (define call-utf-16be
         (foreign-procedure "call_u16_star" (ptr utf-16be) utf-16be))
       (define call-utf-32le
         (foreign-procedure "call_u32_star" (ptr utf-32le) utf-32le))
       (define call-utf-32be
         (foreign-procedure "call_u32_star" (ptr utf-32be) utf-32be))
       (define call-string
         (foreign-procedure "call_string" (ptr string) string))
       (define call-wstring
         (foreign-procedure "call_wstring" (ptr wstring) wstring))
       #t)
     (equal? (call-utf-8
               (foreign-callable (lambda (x) (string-append x "$q"))
                 (utf-8)
                 utf-8)
               "hello")
             "llo$q")
     (equal? (call-utf-16le
               (foreign-callable (lambda (x) (string-append x "$q"))
                 (utf-16le)
                 utf-16le)
               "hello")
             "llo$q")
     (equal? (call-utf-16be
               (foreign-callable (lambda (x) (string-append x "$q"))
                 (utf-16be)
                 utf-16be)
               "hello")
             "llo$q")
     (equal? (call-utf-32le
               (foreign-callable (lambda (x) (string-append x "$q"))
                 (utf-32le)
                 utf-32le)
               "hello")
             "llo$q")
     (equal? (call-utf-32be
               (foreign-callable (lambda (x) (string-append x "$q"))
                 (utf-32be)
                 utf-32be)
               "hello")
             "llo$q")
     (equal? (call-string
               (foreign-callable (lambda (x) (string-append x "$q"))
                 (string)
                 string)
               "hello")
             "llo$q")
     (equal? (call-wstring
               (foreign-callable (lambda (x) (string-append x "$q"))
                 (wstring)
                 wstring)
               "hello")
             "llo$q")
     (error? (call-utf-8
               (foreign-callable (lambda (x) (list x (string-length x)))
                 (utf-8)
                 utf-8)
               "hello"))
     (error? (call-utf-16le
               (foreign-callable (lambda (x) (list x (string-length x)))
                 (utf-16le)
                 utf-16le)
               "hello"))
     (error? (call-utf-16be
               (foreign-callable (lambda (x) (list x (string-length x)))
                 (utf-16be)
                 utf-16be)
               "hello"))
     (error? (call-utf-32le
               (foreign-callable (lambda (x) (list x (string-length x)))
                 (utf-32le)
                 utf-32le)
               "hello"))
     (error? (call-utf-32be
               (foreign-callable (lambda (x) (list x (string-length x)))
                 (utf-32be)
                 utf-32be)
               "hello"))
     (error? (call-string
               (foreign-callable (lambda (x) (list x (string-length x)))
                 (string)
                 string)
               "hello"))
     (error? (call-wstring
               (foreign-callable (lambda (x) (list x (string-length x)))
                 (wstring)
                 wstring)
               "hello")))

(mat foreign-fixed-types
     ; test {integer,unsigned}-8, {single,double}-float
     (begin
       (define i8-to-i8
         (foreign-procedure "i8_to_i8" (integer-8 int) integer-8))
       (define u8-to-u8
         (foreign-procedure "u8_to_u8" (unsigned-8 int) unsigned-8))
       (define i16-to-i16
         (foreign-procedure "i16_to_i16" (integer-16 int) integer-16))
       (define u16-to-u16
         (foreign-procedure "u16_to_u16" (unsigned-16 int) unsigned-16))
       (define i24-to-i24
         (foreign-procedure "i32_to_i32" (integer-24 int) integer-24))
       (define u24-to-u24
         (foreign-procedure "u32_to_u32" (unsigned-24 int) unsigned-24))
       (define i32-to-i32
         (foreign-procedure "i32_to_i32" (integer-32 int) integer-32))
       (define u32-to-u32
         (foreign-procedure "u32_to_u32" (unsigned-32 int) unsigned-32))
       (define i40-to-i40
         (foreign-procedure "i64_to_i64" (integer-40 int) integer-40))
       (define u40-to-u40
         (foreign-procedure "u64_to_u64" (unsigned-40 int) unsigned-40))
       (define i48-to-i48
         (foreign-procedure "i64_to_i64" (integer-48 int) integer-48))
       (define u48-to-u48
         (foreign-procedure "u64_to_u64" (unsigned-48 int) unsigned-48))
       (define i56-to-i56
         (foreign-procedure "i64_to_i64" (integer-56 int) integer-56))
       (define u56-to-u56
         (foreign-procedure "u64_to_u64" (unsigned-56 int) unsigned-56))
       (define i64-to-i64
         (foreign-procedure "i64_to_i64" (integer-64 int) integer-64))
       (define u64-to-u64
         (foreign-procedure "u64_to_u64" (unsigned-64 int) unsigned-64))
       (define sf-to-sf
         (foreign-procedure "sf_to_sf" (single-float) single-float))
       (define df-to-df
         (foreign-procedure "df_to_df" (double-float) double-float))
       (define $test-int-to-int
         (lambda (fp size signed?)
           (define n10000 (expt 256 size))
           (define nffff (- n10000 1))
           (define nfffe (- nffff 1))
           (define n8000 (ash n10000 -1))
           (define n8001 (+ n8000 1))
           (define n7fff (- n8000 1))
           (define n7ffe (- n7fff 1))
           (define n100 (expt 16 size))
           (define n101 (+ n100 1))
           (define nff (- n100 1))
           (define nfe (- nff 1))
           (define n80 (ash n100 -1))
           (define n81 (+ n80 1))
           (define n7f (- n80 1))
           (define n7e (- n7f 1))
           (define (expect x k)
             (if signed?
                 (if (<= (- n8000) x nffff) (mod0 (+ x k) n10000) 'err)
                 (if (<= (- n8000) x nffff) (mod (+ x k) n10000) 'err)))
           (define (check x)
             (define (do-one x k)
               (let ([a (expect x k)])
                 (if (eq? a 'err)
                     (or (= (optimize-level) 3)
                         (guard (c [#t (display-condition c) (newline) #t])
                                (fp x k)
                                (printf "no error for x = ~x, k = ~d\n" x k)
                                #f))
                     (or (eqv? (fp x k) a)
                         (begin
                           (printf "incorrect answer ~x should be ~x for x = ~x, k = ~d\n"
                                   (fp x k)
                                   a
                                   x
                                   k)
                           #f)))))
             (list (do-one x 1)
                   (do-one x -1)
                   (do-one (- x) 1)
                   (do-one (- x) -1)))
           (andmap (lambda (x)
                     (and (list? x)
                          (= (length x) 4)
                          (andmap (lambda (x) (eq? x #t)) x)))
             (list (check n10000)
                   (check nffff)
                   (check nfffe)
                   (check n8001)
                   (check n8000)
                   (check n7fff)
                   (check n7ffe)
                   (check n101)
                   (check n100)
                   (check nff)
                   (check nfe)
                   (check n81)
                   (check n80)
                   (check n7f)
                   (check n7e)
                   (check 73)
                   (check 5)
                   (check 1)
                   (check 0)))))
       #t)
     ($test-int-to-int i8-to-i8 1 #t)
     ($test-int-to-int u8-to-u8 1 #f)
     ($test-int-to-int i16-to-i16 2 #t)
     ($test-int-to-int u16-to-u16 2 #f)
     ($test-int-to-int i24-to-i24 3 #t)
     ($test-int-to-int u24-to-u24 3 #f)
     ($test-int-to-int i32-to-i32 4 #t)
     ($test-int-to-int u32-to-u32 4 #f)
     ($test-int-to-int i40-to-i40 5 #t)
     ($test-int-to-int u40-to-u40 5 #f)
     ($test-int-to-int i48-to-i48 6 #t)
     ($test-int-to-int u48-to-u48 6 #f)
     ($test-int-to-int i56-to-i56 7 #t)
     ($test-int-to-int u56-to-u56 7 #f)
     ($test-int-to-int i64-to-i64 8 #t)
     ($test-int-to-int u64-to-u64 8 #f)
     (eqv? (sf-to-sf 73.5) 74.5)
     (eqv? (df-to-df 73.5) 74.5)

     (error? (i8-to-i8 'qqq 0))
     (error? (u8-to-u8 'qqq 0))
     (error? (i16-to-i16 'qqq 0))
     (error? (u16-to-u16 'qqq 0))
     (error? (i24-to-i24 'qqq 0))
     (error? (u24-to-u24 'qqq 0))
     (error? (i32-to-i32 'qqq 0))
     (error? (u32-to-u32 'qqq 0))
     (error? (i64-to-i64 'qqq 0))
     (error? (u64-to-u64 'qqq 0))
     (error? (i8-to-i8 0 "oops"))
     (error? (u8-to-u8 0 "oops"))
     (error? (i16-to-i16 0 "oops"))
     (error? (u16-to-u16 0 "oops"))
     (error? (i32-to-i32 0 "oops"))
     (error? (u32-to-u32 0 "oops"))
     (error? (i64-to-i64 0 "oops"))
     (error? (u64-to-u64 0 "oops"))

     (error? (sf-to-sf 'qqq))
     (error? (df-to-df 'qqq))

     (begin
       (define call-i8
         (foreign-procedure "call_i8" (ptr integer-8 int int) integer-8))
       (define call-u8
         (foreign-procedure "call_u8" (ptr unsigned-8 int int) unsigned-8))
       (define call-i16
         (foreign-procedure "call_i16" (ptr integer-16 int int) integer-16))
       (define call-u16
         (foreign-procedure "call_u16"
           (ptr unsigned-16 int int)
           unsigned-16))
       (define call-i24
         (foreign-procedure "call_i32" (ptr integer-24 int int) integer-24))
       (define call-u24
         (foreign-procedure "call_u32"
           (ptr unsigned-24 int int)
           unsigned-24))
       (define call-i32
         (foreign-procedure "call_i32" (ptr integer-32 int int) integer-32))
       (define call-u32
         (foreign-procedure "call_u32"
           (ptr unsigned-32 int int)
           unsigned-32))
       (define call-i40
         (foreign-procedure "call_i64" (ptr integer-40 int int) integer-40))
       (define call-u40
         (foreign-procedure "call_u64"
           (ptr unsigned-40 int int)
           unsigned-40))
       (define call-i48
         (foreign-procedure "call_i64" (ptr integer-48 int int) integer-48))
       (define call-u48
         (foreign-procedure "call_u64"
           (ptr unsigned-48 int int)
           unsigned-48))
       (define call-i56
         (foreign-procedure "call_i64" (ptr integer-56 int int) integer-56))
       (define call-u56
         (foreign-procedure "call_u64"
           (ptr unsigned-56 int int)
           unsigned-56))
       (define call-i64
         (foreign-procedure "call_i64" (ptr integer-64 int int) integer-64))
       (define call-u64
         (foreign-procedure "call_u64"
           (ptr unsigned-64 int int)
           unsigned-64))
       (define call-sf
         (foreign-procedure "call_sf"
           (ptr single-float int int)
           single-float))
       (define call-df
         (foreign-procedure "call_df"
           (ptr double-float int int)
           double-float))
       (define ($test-call-int signed? size call-int make-fc)
         (define n10000 (expt 256 size))
         (define nffff (- n10000 1))
         (define nfffe (- nffff 1))
         (define n8000 (ash n10000 -1))
         (define n8001 (+ n8000 1))
         (define n7fff (- n8000 1))
         (define n7ffe (- n7fff 1))
         (define n100 (expt 16 size))
         (define n101 (+ n100 1))
         (define nff (- n100 1))
         (define nfe (- nff 1))
         (define n80 (ash n100 -1))
         (define n81 (+ n80 1))
         (define n7f (- n80 1))
         (define n7e (- n7f 1))
         (define (expect x m k)
           (if signed?
               (if (<= (- n8000) x nffff) (mod0 (+ x m k) n10000) 'err)
               (if (<= (- n8000) x nffff) (mod (+ x m k) n10000) 'err)))
         (define fc (make-fc values))
         (define fp (lambda (x m k) (call-int fc x m k)))
         (define (check x)
           (define (do-one x m k)
             (let ([a (expect x m k)])
               (if (eq? a 'err)
                   (or (= (optimize-level) 3)
                       (guard (c [#t (display-condition c) (newline) #t])
                              (fp x m k)))
                   (eqv? (fp x m k) a))))
           (list (do-one x 0 0)
                 (do-one x 5 7)
                 (do-one x -5 7)
                 (do-one x 5 -7)
                 (do-one x -5 -7)
                 (do-one (- x) 0 0)
                 (do-one (- x) 5 7)
                 (do-one (- x) -5 7)
                 (do-one (- x) 5 -7)
                 (do-one (- x) -5 -7)))
         (andmap (lambda (x)
                   (and (list? x)
                        (= (length x) 10)
                        (andmap (lambda (x) (eq? x #t)) x)))
           (list (check n10000)
                 (check nffff)
                 (check nfffe)
                 (check n8001)
                 (check n8000)
                 (check n7fff)
                 (check n7ffe)
                 (check n101)
                 (check n100)
                 (check nff)
                 (check nfe)
                 (check n81)
                 (check n80)
                 (check n7f)
                 (check n7e)
                 (check 73)
                 (check 5)
                 (check 1)
                 (check 0))))
       #t)
     ($test-call-int #t
       (foreign-sizeof 'integer-8)
       call-i8
       (lambda (p)
         (foreign-callable p (integer-8) integer-8)))
     ($test-call-int #t
       (foreign-sizeof 'integer-16)
       call-i16
       (lambda (p)
         (foreign-callable p (integer-16) integer-16)))
     ($test-call-int #t
       (foreign-sizeof 'integer-24)
       call-i24
       (lambda (p)
         (foreign-callable p (integer-24) integer-24)))
     ($test-call-int #t
       (foreign-sizeof 'integer-32)
       call-i32
       (lambda (p)
         (foreign-callable p (integer-32) integer-32)))
     ($test-call-int #t
       (foreign-sizeof 'integer-40)
       call-i40
       (lambda (p)
         (foreign-callable p (integer-40) integer-40)))
     ($test-call-int #t
       (foreign-sizeof 'integer-48)
       call-i48
       (lambda (p)
         (foreign-callable p (integer-48) integer-48)))
     ($test-call-int #t
       (foreign-sizeof 'integer-56)
       call-i56
       (lambda (p)
         (foreign-callable p (integer-56) integer-56)))
     ($test-call-int #t
       (foreign-sizeof 'integer-64)
       call-i64
       (lambda (p)
         (foreign-callable p (integer-64) integer-64)))
     ($test-call-int #f
       (foreign-sizeof 'unsigned-8)
       call-u8
       (lambda (p)
         (foreign-callable p (unsigned-8) unsigned-8)))
     ($test-call-int #f
       (foreign-sizeof 'unsigned-16)
       call-u16
       (lambda (p)
         (foreign-callable p (unsigned-16) unsigned-16)))
     ($test-call-int #f
       (foreign-sizeof 'unsigned-24)
       call-u24
       (lambda (p)
         (foreign-callable p (unsigned-24) unsigned-24)))
     ($test-call-int #f
       (foreign-sizeof 'unsigned-32)
       call-u32
       (lambda (p)
         (foreign-callable p (unsigned-32) unsigned-32)))
     ($test-call-int #f
       (foreign-sizeof 'unsigned-40)
       call-u40
       (lambda (p)
         (foreign-callable p (unsigned-40) unsigned-40)))
     ($test-call-int #f
       (foreign-sizeof 'unsigned-48)
       call-u48
       (lambda (p)
         (foreign-callable p (unsigned-48) unsigned-48)))
     ($test-call-int #f
       (foreign-sizeof 'unsigned-56)
       call-u56
       (lambda (p)
         (foreign-callable p (unsigned-56) unsigned-56)))
     ($test-call-int #f
       (foreign-sizeof 'unsigned-64)
       call-u64
       (lambda (p)
         (foreign-callable p (unsigned-64) unsigned-64)))
     (equal? (call-sf (foreign-callable (lambda (x) (+ x 5))
                        (single-float)
                        single-float)
                      73.25
                      7
                      23)
             108.25)
     (equal? (call-df (foreign-callable (lambda (x) (+ x 5))
                        (double-float)
                        double-float)
                      73.25
                      7
                      23)
             108.25)

     (error? (call-i8 (foreign-callable (lambda (x) '(- x 7))
                        (integer-8)
                        integer-8)
                      73
                      0
                      0))
     (error? (call-u8 (foreign-callable (lambda (x) '(- x 7))
                        (unsigned-8)
                        unsigned-8)
                      73
                      0
                      0))
     (error? (call-i16 (foreign-callable (lambda (x) '(- x 7))
                         (integer-16)
                         integer-16)
                       73
                       0
                       0))
     (error? (call-u16 (foreign-callable (lambda (x) '(- x 7))
                         (unsigned-16)
                         unsigned-16)
                       73
                       0
                       0))
     (error? (call-i32 (foreign-callable (lambda (x) '(- x 7))
                         (integer-32)
                         integer-32)
                       73
                       0
                       0))
     (error? (call-u32 (foreign-callable (lambda (x) '(- x 7))
                         (unsigned-32)
                         unsigned-32)
                       73
                       0
                       0))
     (error? (call-i64 (foreign-callable (lambda (x) '(- x 7))
                         (integer-64)
                         integer-64)
                       73
                       0
                       0))
     (error? (call-u64 (foreign-callable (lambda (x) '(- x 7))
                         (unsigned-64)
                         unsigned-64)
                       73
                       0
                       0))
     (error? (call-sf (foreign-callable (lambda (x) '(- x 7))
                        (single-float)
                        single-float)
                      73.25
                      0
                      0))
     (error? (call-df (foreign-callable (lambda (x) '(- x 7))
                        (double-float)
                        double-float)
                      73.25
                      0
                      0))

     (begin
       (define u32xu32->u64
         (foreign-procedure "u32xu32_to_u64"
           (unsigned-32 unsigned-32)
           unsigned-64))
       (define i32xu32->i64
         (foreign-procedure "i32xu32_to_i64"
           (integer-32 unsigned-32)
           integer-64))
       (define call-i32xu32->i64
         (foreign-procedure "call_i32xu32_to_i64"
           (ptr integer-32 unsigned-32 int)
           integer-64))
       (define fc-i32xu32->i64
         (foreign-callable i32xu32->i64
           (integer-32 unsigned-32)
           integer-64))
       #t)

     (eqv? (u32xu32->u64 #xFFFFFFFF #xFFFFFFFF) #xFFFFFFFFFFFFFFFF)
     (eqv? (u32xu32->u64 #xFF3FFFFF #xFFFFF0FF) #xFF3FFFFFFFFFF0FF)
     (eqv? (u32xu32->u64 #xFFFFFFFF #xF0000000) #xFFFFFFFFF0000000)

     (eqv? (i32xu32->i64 #x0 #x5) #x5)
     (eqv? (i32xu32->i64 #x7 #x5) #x700000005)
     (eqv? (i32xu32->i64 #xFFFFFFFF #xFFFFFFFF) #x-1)
     (eqv? (fixnum? (i32xu32->i64 #xFFFFFFFF #xFFFFFFFF)) #t)
     (eqv? (i32xu32->i64 #xFFFFFFFF #xFFFFFFFE) #x-2)
     (eqv? (i32xu32->i64 #xFFFFFFFF #x00000000) #x-100000000)
     (eqv? (i32xu32->i64 #xFFFFFFFE #x00000000) #x-200000000)
     (eqv? (i32xu32->i64 #xFFFFFFFF #x00000001) #x-FFFFFFFF)
     (eqv? (i32xu32->i64 #x0 #xFFFFFFFF) #xFFFFFFFF)
     (eqv? (i32xu32->i64 #x7FFFFFFF #xFFFFFFFF) #x7FFFFFFFFFFFFFFF)
     (eqv? (i32xu32->i64 #x80000000 #x00000000) #x-8000000000000000)

     (eqv? (call-i32xu32->i64 fc-i32xu32->i64 #x0 #x5 #x13) #x18)
     (eqv? (call-i32xu32->i64 fc-i32xu32->i64 #x7 #x5 7) #x70000000C)
     (eqv? (call-i32xu32->i64 fc-i32xu32->i64 #xFFFFFFFF #xFFFFFFFF -3)
           #x-4)
     (eqv? (fixnum? (call-i32xu32->i64
                      fc-i32xu32->i64
                      #xFFFFFFFF
                      #xFFFFFFFF
                      0))
           #t)
     (eqv? (call-i32xu32->i64 fc-i32xu32->i64 #xFFFFFFFF #xFFFFFFFE -1)
           #x-3)
     (eqv? (call-i32xu32->i64 fc-i32xu32->i64 #xFFFFFFFF #x00000000 0)
           #x-100000000)
     (eqv? (call-i32xu32->i64 fc-i32xu32->i64 #xFFFFFFFE #x00000000 0)
           #x-200000000)
     (eqv? (call-i32xu32->i64 fc-i32xu32->i64 #xFFFFFFFF #x00000001 0)
           #x-FFFFFFFF)
     (eqv? (call-i32xu32->i64 fc-i32xu32->i64 #x0 #xFFFFFFFF 0) #xFFFFFFFF)
     (eqv? (call-i32xu32->i64 fc-i32xu32->i64 #x7FFFFFFF #xFFFFFFFF 0)
           #x7FFFFFFFFFFFFFFF)
     (eqv? (call-i32xu32->i64 fc-i32xu32->i64 #x80000000 #x00000000 0)
           #x-8000000000000000)

     ; check for 64-bit alignment issues
     (begin
       (define ufoo64a
         (foreign-procedure "ufoo64a"
           (unsigned-64
             unsigned-64
             unsigned-64
             unsigned-64
             unsigned-64
             unsigned-64
             unsigned-64)
           unsigned-64))
       (define ufoo64b
         (foreign-procedure "ufoo64b"
           (integer-32
             unsigned-64
             unsigned-64
             unsigned-64
             unsigned-64
             unsigned-64
             unsigned-64
             unsigned-64)
           unsigned-64))
       (define test-ufoo
         (lambda (foo x a b c d e f g)
           (eqv? (foo x a b c d e f g)
                 (mod (+ x (- a b) (- c d) (- e f) g) (expt 2 64)))))
       #t)
     (test-ufoo
       (lambda (x a b c d e f g)
         (+ x (ufoo64a a b c d e f g)))
       #x0000000010000000
       #x0000000120000000
       #x0000002003000000
       #x0000030000400000
       #x0000400000050000
       #x0005000000006000
       #x0060000000000700
       #x0700000000000080)
     (test-ufoo
       ufoo64b
       #x0000000010000000
       #x0000000120000000
       #x0000002003000000
       #x0000030000400000
       #x0000400000050000
       #x0005000000006000
       #x0060000000000700
       #x0700000000000080)
     (test-ufoo
       (lambda (x a b c d e f g)
         (+ x (ufoo64a a b c d e f g)))
       #x0000000010000000
       #x0000000120000000
       #x0000002003000000
       #x0000030000400000
       #x0000400000050000
       #x0005000000006000
       #x0060000000000700
       #xC700000000000080)
     (test-ufoo
       ufoo64b
       #x0000000010000000
       #x0000000120000000
       #x0000002003000000
       #x0000030000400000
       #x0000400000050000
       #x0005000000006000
       #x0060000000000700
       #xC700000000000080)
     (do ([i 1000 (fx- i 1)])
         ((fx= i 0) #t)
         (let ([ls (cons (random (expt 2 32))
                         (map random
                              (make-list 7 (expt 2 64))))])
           (unless (apply test-ufoo
                     (lambda (x a b c d e f g)
                       (+ x (ufoo64a a b c d e f g)))
                     ls)
                   (pretty-print ls)
                   (errorf #f "failed for ufoo64a on ~s" ls))
           (unless (apply test-ufoo ufoo64b ls)
                   (pretty-print ls)
                   (errorf #f "failed for ufoo64b on ~s" ls))))
     (begin
       (define ifoo64a
         (foreign-procedure "ifoo64a"
           (integer-64
             integer-64
             integer-64
             integer-64
             integer-64
             integer-64
             integer-64)
           integer-64))
       (define ifoo64b
         (foreign-procedure "ifoo64b"
           (integer-32
             integer-64
             integer-64
             integer-64
             integer-64
             integer-64
             integer-64
             integer-64)
           integer-64))
       (define test-ifoo
         (lambda (foo x a b c d e f g)
           (eqv? (foo x a b c d e f g)
                 (mod0 (+ x (- a b) (- c d) (- e f) g) (expt 2 64)))))
       #t)
     (test-ifoo
       (lambda (x a b c d e f g)
         (+ x (ifoo64a a b c d e f g)))
       #x0000000010000000
       #x0000000120000000
       #x0000002003000000
       #x0000030000400000
       #x0000400000050000
       #x0005000000006000
       #x0060000000000700
       #x0700000000000080)
     (test-ifoo
       ifoo64b
       #x0000000010000000
       #x0000000120000000
       #x0000002003000000
       #x0000030000400000
       #x0000400000050000
       #x0005000000006000
       #x0060000000000700
       #x0700000000000080)
     (test-ifoo
       (lambda (x a b c d e f g)
         (+ x (ifoo64a a b c d e f g)))
       #x0000000010000000
       #x0000000120000000
       #x0000002003000000
       #x0000030000400000
       #x0000400000050000
       #x0005000000006000
       #x0060000000000700
       #xC700000000000080)
     (test-ifoo
       ifoo64b
       #x0000000010000000
       #x0000000120000000
       #x0000002003000000
       #x0000030000400000
       #x0000400000050000
       #x0005000000006000
       #x0060000000000700
       #xC700000000000080)
     (do ([i 1000 (fx- i 1)])
         ((fx= i 0) #t)
         (let ([ls (cons (- (random (expt 2 32)) (expt 2 31))
                         (map (lambda (n) (- (random n) (expt 2 31)))
                              (make-list 7 (expt 2 64))))])
           (unless (apply test-ifoo
                     (lambda (x a b c d e f g)
                       (+ x (ifoo64a a b c d e f g)))
                     ls)
                   (pretty-print ls)
                   (errorf #f "failed for ifoo64a on ~s" ls))
           (unless (apply test-ifoo ifoo64b ls)
                   (pretty-print ls)
                   (errorf #f "failed for ifoo64b on ~s" ls)))))

(mat foreign-C-types
     ; test void*, int, unsigned, float, etc.
     (begin
       (define int-to-int
         (foreign-procedure "int_to_int" (int int) int))
       (define unsigned-to-unsigned
         (foreign-procedure "unsigned_to_unsigned" (unsigned int) unsigned))
       (define unsigned-int-to-unsigned-int
         (foreign-procedure "unsigned_to_unsigned"
           (unsigned-int int)
           unsigned-int))
       (define char-to-char
         (foreign-procedure "char_to_char" (char) char))
       (define wchar-to-wchar
         (foreign-procedure "wchar_to_wchar" (wchar) wchar))
       (define short-to-short
         (foreign-procedure "short_to_short" (short int) short))
       (define unsigned-short-to-unsigned-short
         (foreign-procedure "unsigned_short_to_unsigned_short"
           (unsigned-short int)
           unsigned-short))
       (define long-to-long
         (foreign-procedure "long_to_long" (long int) long))
       (define unsigned-long-to-unsigned-long
         (foreign-procedure "unsigned_long_to_unsigned_long"
           (unsigned-long int)
           unsigned-long))
       (define long-long-to-long-long
         (foreign-procedure "long_long_to_long_long"
           (long-long int)
           long-long))
       (define unsigned-long-long-to-unsigned-long-long
         (foreign-procedure "unsigned_long_long_to_unsigned_long_long"
           (unsigned-long-long int)
           unsigned-long-long))
       (define float-to-float
         (foreign-procedure "float_to_float" (float) float))
       (define double-to-double
         (foreign-procedure "double_to_double" (double) double))
       (define iptr-to-iptr
         (foreign-procedure "iptr_to_iptr" (iptr int) iptr))
       (define uptr-to-uptr
         (foreign-procedure "uptr_to_uptr" (uptr int) uptr))
       (define void*-to-void*
         (foreign-procedure "uptr_to_uptr" (void* int) void*))
       #t)
     ($test-int-to-int int-to-int (foreign-sizeof 'int) #t)
     ($test-int-to-int unsigned-to-unsigned (foreign-sizeof 'unsigned) #f)
     ($test-int-to-int unsigned-int-to-unsigned-int
       (foreign-sizeof 'unsigned-int)
       #f)
     ($test-int-to-int short-to-short (foreign-sizeof 'short) #t)
     ($test-int-to-int unsigned-short-to-unsigned-short
       (foreign-sizeof 'unsigned-short)
       #f)
     ($test-int-to-int long-to-long (foreign-sizeof 'long) #t)
     ($test-int-to-int unsigned-long-to-unsigned-long
       (foreign-sizeof 'unsigned-long)
       #f)
     ($test-int-to-int long-long-to-long-long
       (foreign-sizeof 'long-long)
       #t)
     ($test-int-to-int unsigned-long-long-to-unsigned-long-long
       (foreign-sizeof 'unsigned-long-long)
       #f)
     ($test-int-to-int iptr-to-iptr (foreign-sizeof 'iptr) #t)
     ($test-int-to-int uptr-to-uptr (foreign-sizeof 'uptr) #f)
     ($test-int-to-int void*-to-void* (foreign-sizeof 'void*) #f)

     (eqv? (char-to-char #\a) #\A)
     (eqv? (wchar-to-wchar #\x3bb) #\x39b)
     (eqv? (float-to-float 73.5) 74.5)
     (eqv? (double-to-double 73.5) 74.5)

     (error? (int-to-int 'qqq 0))
     (error? (unsigned-to-unsigned 'qqq 0))
     (error? (unsigned-int-to-unsigned-int 'qqq 0))
     (error? (unsigned-short-to-unsigned-short 'qqq 0))
     (error? (short-to-short 'qqq 0))
     (error? (long-to-long 'qqq 0))
     (error? (unsigned-long-to-unsigned-long 'qqq 0))
     (error? (long-long-to-long-long 'qqq 0))
     (error? (unsigned-long-long-to-unsigned-long-long 'qqq 0))
     (error? (iptr-to-iptr 'qqq 0))
     (error? (uptr-to-uptr 'qqq 0))
     (error? (void*-to-void* 'qqq 0))
     (error? (int-to-int 0 "oops"))
     (error? (unsigned-to-unsigned 0 "oops"))
     (error? (unsigned-int-to-unsigned-int 0 "oops"))
     (error? (unsigned-short-to-unsigned-short 0 "oops"))
     (error? (short-to-short 0 "oops"))
     (error? (long-to-long 0 "oops"))
     (error? (unsigned-long-to-unsigned-long 0 "oops"))
     (error? (long-long-to-long-long 0 "oops"))
     (error? (unsigned-long-long-to-unsigned-long-long 0 "oops"))
     (error? (iptr-to-iptr 0 "oops"))
     (error? (uptr-to-uptr 0 "oops"))
     (error? (void*-to-void* 0 "oops"))

     (error? (char-to-char 73))
     (error? (char-to-char #\x100))
     (error? (wchar-to-wchar 73))
     (or (= (optimize-level) 3)
         (if (eq? (foreign-sizeof 'wchar) 16)
             (guard? (c [#t]) (wchar-to-char #\x10000) #f)
             #t))
     (error? (float-to-float 'qqq.5))
     (error? (double-to-double 'qqq.5))

     (begin
       (define call-int
         (foreign-procedure "call_int" (ptr int int int) int))
       (define call-unsigned
         (foreign-procedure "call_unsigned"
           (ptr unsigned int int)
           unsigned))
       (define call-unsigned-int
         (foreign-procedure "call_unsigned"
           (ptr unsigned-int int int)
           unsigned-int))
       (define call-char
         (foreign-procedure "call_char" (ptr char int int) char))
       (define call-wchar
         (foreign-procedure "call_wchar" (ptr wchar int int) wchar))
       (define call-short
         (foreign-procedure "call_short" (ptr short int int) short))
       (define call-unsigned-short
         (foreign-procedure "call_unsigned_short"
           (ptr unsigned-short int int)
           unsigned-short))
       (define call-long
         (foreign-procedure "call_long" (ptr long int int) long))
       (define call-unsigned-long
         (foreign-procedure "call_unsigned_long"
           (ptr unsigned-long int int)
           unsigned-long))
       (define call-long-long
         (foreign-procedure "call_long_long"
           (ptr long-long int int)
           long-long))
       (define call-unsigned-long-long
         (foreign-procedure "call_unsigned_long_long"
           (ptr unsigned-long-long int int)
           unsigned-long-long))
       (define call-float
         (foreign-procedure "call_float" (ptr float int int) float))
       (define call-double
         (foreign-procedure "call_double" (ptr double int int) double))
       (define call-iptr
         (foreign-procedure "call_iptr" (ptr iptr int int) iptr))
       (define call-uptr
         (foreign-procedure "call_uptr" (ptr uptr int int) uptr))
       (define call-void*
         (foreign-procedure "call_uptr" (ptr void* int int) void*))
       #t)
     ($test-call-int #t
       (foreign-sizeof 'int)
       call-int
       (lambda (p) (foreign-callable p (int) int)))
     ($test-call-int #f
       (foreign-sizeof 'unsigned)
       call-unsigned
       (lambda (p) (foreign-callable p (unsigned) unsigned)))
     ($test-call-int #f
       (foreign-sizeof 'unsigned-int)
       call-unsigned-int
       (lambda (p)
         (foreign-callable p (unsigned-int) unsigned-int)))
     ($test-call-int #t
       (foreign-sizeof 'short)
       call-short
       (lambda (p) (foreign-callable p (short) short)))
     ($test-call-int #f
       (foreign-sizeof 'unsigned-short)
       call-unsigned-short
       (lambda (p)
         (foreign-callable p (unsigned-short) unsigned-short)))
     ($test-call-int #t
       (foreign-sizeof 'long)
       call-long
       (lambda (p) (foreign-callable p (long) long)))
     ($test-call-int #f
       (foreign-sizeof 'unsigned-long)
       call-unsigned-long
       (lambda (p)
         (foreign-callable p (unsigned-long) unsigned-long)))
     ($test-call-int #t
       (foreign-sizeof 'long-long)
       call-long-long
       (lambda (p)
         (foreign-callable p (long-long) long-long)))
     ($test-call-int #f
       (foreign-sizeof 'unsigned-long-long)
       call-unsigned-long-long
       (lambda (p)
         (foreign-callable p (unsigned-long-long) unsigned-long-long)))
     ($test-call-int #t
       (foreign-sizeof 'iptr)
       call-iptr
       (lambda (p) (foreign-callable p (iptr) iptr)))
     ($test-call-int #f
       (foreign-sizeof 'uptr)
       call-uptr
       (lambda (p) (foreign-callable p (uptr) uptr)))
     ($test-call-int #f
       (foreign-sizeof 'void*)
       call-void*
       (lambda (p) (foreign-callable p (void*) void*)))
     (equal? (call-char
               (foreign-callable
                 (lambda (x)
                   (integer->char (+ (char->integer x) 5)))
                 (char)
                 char)
               #\a
               7
               11)
             #\x)
     (equal? (call-wchar
               (foreign-callable
                 (lambda (x)
                   (integer->char (+ (char->integer x) 5)))
                 (wchar)
                 wchar)
               #\x3bb
               7
               11)
             #\x3d2)
     (equal? (call-float
               (foreign-callable (lambda (x) (+ x 5)) (float) single-float)
               73.25
               7
               23)
             108.25)
     (equal? (call-double
               (foreign-callable (lambda (x) (+ x 5))
                 (double)
                 double-float)
               73.25
               7
               23)
             108.25)

     (error? (call-int (foreign-callable (lambda (x) (list x (+ x 1)))
                         (int)
                         int)
                       73
                       0
                       0))
     (error? (call-unsigned
               (foreign-callable (lambda (x) (list x (+ x 1)))
                 (unsigned)
                 unsigned)
               73
               0
               0))
     (error? (call-unsigned-int
               (foreign-callable (lambda (x) (list x (+ x 1)))
                 (unsigned-int)
                 unsigned-int)
               73
               0
               0))
     (error? (call-char
               (foreign-callable (lambda (x) (list x)) (char) char)
               #\a
               0
               0))
     (error? (call-wchar
               (foreign-callable (lambda (x) (list x)) (wchar) wchar)
               #\a
               0
               0))
     (error? (call-short
               (foreign-callable (lambda (x) (list x (+ x 1))) (short) short)
               73
               0
               0))
     (error? (call-unsigned-short
               (foreign-callable (lambda (x) (list x (+ x 1)))
                 (unsigned-short)
                 unsigned-short)
               73
               0
               0))
     (error? (call-long
               (foreign-callable (lambda (x) (list x (+ x 1))) (long) long)
               73
               0
               0))
     (error? (call-unsigned-long
               (foreign-callable (lambda (x) (list x (+ x 1)))
                 (unsigned-long)
                 unsigned-long)
               73
               0
               0))
     (error? (call-long-long
               (foreign-callable (lambda (x) (list x (+ x 1)))
                 (long-long)
                 long-long)
               73
               0
               0))
     (error? (call-unsigned-long-long
               (foreign-callable (lambda (x) (list x (+ x 1)))
                 (unsigned-long-long)
                 unsigned-long-long)
               73
               0
               0))
     (error? (call-float
               (foreign-callable (lambda (x) (list x (+ x 1))) (float) float)
               73.25
               0
               0))
     (error? (call-double
               (foreign-callable (lambda (x) (list x (+ x 1))) (double) double)
               73.25
               0
               0))
     (error? (call-iptr
               (foreign-callable (lambda (x) (list x (+ x 1))) (iptr) iptr)
               73
               0
               0))
     (error? (call-uptr
               (foreign-callable (lambda (x) (list x (+ x 1))) (uptr) uptr)
               73
               0
               0))
     (error? (call-void*
               (foreign-callable (lambda (x) (list x (+ x 1))) (void*) void*)
               73
               0
               0)))

(mat foreign-ftype
     (begin
       (define-ftype A (struct [x double] [y wchar]))
       (define-ftype B (struct [x (array 10 A)] [y A]))
       (define B->*int
         (foreign-procedure "uptr_to_uptr" ((* B) int) (* int)))
       (define B->A
         (foreign-procedure "uptr_to_uptr" ((* B) int) (* A)))
       (define B->uptr
         (foreign-procedure "uptr_to_uptr" ((* B) int) uptr))
       (define uptr->A
         (foreign-procedure "uptr_to_uptr" (uptr int) (* A)))
       (define b
         ((foreign-procedure (if (windows?) "windows_malloc" "malloc")
            (ssize_t)
            (* B)) (ftype-sizeof B)))
       #t)
     (eqv? (ftype-pointer-address
             (uptr->A (ftype-pointer-address (ftype-&ref B (y) b)) 0))
           (ftype-pointer-address (ftype-&ref B (y) b)))
     (eqv? (ftype-pointer-address
             (uptr->A (ftype-pointer-address b) (* 10 (ftype-sizeof A))))
           (ftype-pointer-address (ftype-&ref B (y) b)))
     (eqv? (B->uptr b (* 10 (ftype-sizeof A)))
           (ftype-pointer-address (ftype-&ref B (y) b)))
     (eqv? (ftype-pointer-address (B->A b (* 10 (ftype-sizeof A))))
           (ftype-pointer-address (ftype-&ref B (y) b)))
     (begin
       (define uptr->uptr
         (foreign-callable values (uptr) uptr))
       (define uptr->A
         (foreign-callable (lambda (a) (make-ftype-pointer A a)) (uptr) (* A)))
       (define B->uptr
         (foreign-callable ftype-pointer-address ((* B)) uptr))
       (define B->A
         (foreign-callable (lambda (b) (ftype-&ref B (y) b)) ((* B)) (* A)))
       (define call-B->A
         (foreign-procedure "call_uptr" (ptr (* B) int int) (* A)))
       #t)
     (eqv? (ftype-pointer-address
             (call-B->A
               uptr->uptr
               b
               (* 5 (ftype-sizeof A))
               (* 5 (ftype-sizeof A))))
           (ftype-pointer-address (ftype-&ref B (y) b)))
     (eqv? (ftype-pointer-address
             (call-B->A
               uptr->A
               b
               (* 5 (ftype-sizeof A))
               (* 5 (ftype-sizeof A))))
           (ftype-pointer-address (ftype-&ref B (y) b)))
     (eqv? (ftype-pointer-address
             (call-B->A
               B->uptr
               b
               (* 5 (ftype-sizeof A))
               (* 5 (ftype-sizeof A))))
           (ftype-pointer-address (ftype-&ref B (y) b)))
     (eqv? (ftype-pointer-address (call-B->A B->A b 0 0))
           (ftype-pointer-address (ftype-&ref B (y) b)))
     (begin
       ((foreign-procedure (if (windows?) "windows_free" "free") ((* B)) void) b)
       (set! b #f)
       #t)
     (error? ; unrecognized foreign-procedure argument ftype name
             (foreign-procedure "foo" ((* broken)) void))
     (error? ; invalid foreign-procedure argument type specifier
             (foreign-procedure "foo" ((+ * -)) void))
     (error? ; invalid foreign-procedure argument type specifier
             (foreign-procedure "foo" ((* * *)) void))
     (error? ; invalid foreign-procedure argument type specifier
             (foreign-procedure "foo" ((struct [a int])) void))
     (error? ; invalid foreign-procedure argument type specifier
             (foreign-procedure "foo" (hag) void))
     (error? ; unrecognized foreign-procedure return ftype name
             (foreign-procedure "foo" () (* broken)))
     (error? ; invalid foreign-procedure return type specifier
             (foreign-procedure "foo" () (+ * -)))
     (error? ; invalid foreign-procedure return type specifier
             (foreign-procedure "foo" () (* * *)))
     (error? ; invalid foreign-procedure argument type specifier
             (foreign-procedure "foo" () ((struct [a int]))))
     (error? ; invalid foreign-procedure return type specifier
             (foreign-procedure "foo" () hag))
     (error? ; invalid (non-base) ... ftype
             (foreign-procedure "foo" (A) void))
     (error? ; invalid (non-base) ... ftype
             (foreign-procedure "foo" () A))
     (begin
       (meta-cond
         [(eq? (native-endianness) 'little)
          (define-ftype swap-fixnum (endian big fixnum))]
         [(eq? (native-endianness) 'big)
          (define-ftype swap-fixnum (endian little fixnum))])
       #t)
     (error? ; invalid (swapped) ... ftype
             (foreign-procedure "foo" (swap-fixnum) void))
     (error? ; invalid (swapped) ... ftype
             (foreign-procedure "foo" () swap-fixnum))
     (error? ; invalid syntax
       (define-ftype foo (function "wtf" () void) +))
     (error? ; invalid convention
             (define-ftype foo (function "wtf" () void)))
     (error? ; invalid argument type void
             (define-ftype foo (function (void) int)))
     (equal? (let ()
               (define-ftype foo (function (int) void))
               (list (ftype-pointer? (make-ftype-pointer foo 0))
                     (ftype-pointer? foo (make-ftype-pointer double 0))
                     (ftype-pointer? foo (make-ftype-pointer foo 0))))
             '(#t #f #t))
     (error? ; non-function ftype with "memcpy" address
             (define $fp-bvcopy
               (make-ftype-pointer double "memcpy")))
     (error? ; unrecognized ftype
       (define $fp-bvcopy
         (make-ftype-pointer spam "memcpy")))
     (error? ; invalid syntax 
       (define $fp-bvcopy
         (make-ftype-pointer (struct [x int]) "memcpy")))
     (error? ; invalid function-ftype result type specifier u8
       (let ()
         (define-ftype foo (function (u8* u8* size_t) u8))
         (define $fp-bvcopy
           (make-ftype-pointer foo "memcpy"))))
     (error? ; invalid function-ftype argument type specifier u8
             (let ()
               (define-ftype foo (function (u8* u8 size_t) u8*))
               (define $fp-bvcopy
                 (make-ftype-pointer foo "memcpy"))))
     (begin
       (define-ftype memcpy_t (function (u8* u8* size_t) u8*))
       (define $fp-bvcopy
         (ftype-ref memcpy_t () (make-ftype-pointer memcpy_t "memcpy")))
       #t)
     (let ([bv1 (string->utf8 "hello")] [bv2 (make-bytevector 5)])
       ($fp-bvcopy bv2 bv1 5)
       (and (bytevector=? bv1 bv2)
            (bytevector=? bv1 (string->utf8 "hello"))))
     (begin
       (define-ftype bvcopy-t (function (u8* u8* size_t) u8*))
       (define $fp-bvcopy
         (ftype-ref bvcopy-t () (make-ftype-pointer bvcopy-t "memcpy")))
       #t)
     (let ([bv1 (string->utf8 "hello")] [bv2 (make-bytevector 5)])
       ($fp-bvcopy bv2 bv1 5)
       (and (bytevector=? bv1 bv2)
            (bytevector=? bv1 (string->utf8 "hello"))))
     ;; No longer an error since make-ftype-pointer also serves to make foriegn-pointers
     #;
     (error? ; "memcpy" is not a procedure
             (make-ftype-pointer memcpy_t "memcpy"))
     (error? ; unrecognized ftype
             (make-ftype-pointer spam +))
     (error? ; non-function ftype
             (make-ftype-pointer double +))
     (error? ; invalid syntax
             (make-ftype-pointer (struct [x int]) +))
     (eqv? (let ()
             (define-ftype foo (function (int int) double))
             (define code
               (make-ftype-pointer foo (lambda (x y) (inexact (+ x y)))))
             (let ([code-object
                     (foreign-callable-code-object
                       (ftype-pointer-address code))])
               (dynamic-wind (lambda () (lock-object code-object))
                 (lambda ()
                   (define f (ftype-ref foo () code))
                   (f 3 4))
                 (lambda () (unlock-object code-object)))))
           7.0)
     (eqv? (let ()
             (define-ftype foo (function (int int) double))
             (define code
               (make-ftype-pointer foo (lambda (x y) (inexact (+ x y)))))
             (define f (ftype-ref foo () code))
             (let ([x (f 8 4)])
               (unlock-object
                 (foreign-callable-code-object
                   (ftype-pointer-address code)))
               x))
           12.0)
     (eqv? (let ()
             (define-ftype foo (function (void* void*) ptrdiff_t))
             (define code (make-ftype-pointer foo -))
             (let ([code-object
                     (foreign-callable-code-object
                       (ftype-pointer-address code))])
               (dynamic-wind (lambda () (lock-object code-object))
                 (lambda ()
                   ((ftype-ref foo () code) 17 (* (most-positive-fixnum) 2)))
                 (lambda () (unlock-object code-object)))))
           (- 17 (* (most-positive-fixnum) 2)))
     (eqv? (let ()
             (define-ftype foo (function (void* void*) ptrdiff_t))
             (define code (make-ftype-pointer foo -))
             (let ([x ((ftype-ref foo () code)
                       19
                       (* (most-positive-fixnum) 2))])
               (unlock-object
                 (foreign-callable-code-object
                   (ftype-pointer-address code)))
               x))
           (- 19 (* (most-positive-fixnum) 2)))
     (eqv? (let ()
             (define-ftype foo (function (int int) size_t))
             (define code (make-ftype-pointer foo -))
             (let ([code-object
                     (foreign-callable-code-object
                       (ftype-pointer-address code))])
               (dynamic-wind (lambda () (lock-object code))
                 (lambda () ((ftype-ref foo () code) 17 32))
                 (lambda () (unlock-object code)))))
           (- (expt 2 (* (ftype-sizeof size_t) 8)) 15))
     (eqv? (let ()
             (define-ftype foo (function (int int) size_t))
             (define code (make-ftype-pointer foo -))
             (let ([x ((ftype-ref foo () code) 17 32)])
               (unlock-object
                 (foreign-callable-code-object
                   (ftype-pointer-address code)))
               x))
           (- (expt 2 (* (ftype-sizeof size_t) 8)) 15))

     (error? ; not a string
             (foreign-entry #e1e6))

     (error? ; no entry for "i am not defined"
             (foreign-entry "i am not defined"))

     (begin
       (define-ftype F (function (size_t) int))
       (define malloc-fptr1
         (make-ftype-pointer F (if (windows?) "windows_malloc" "malloc")))
       (define malloc-fptr2
         (make-ftype-pointer F
           (foreign-entry (if (windows?) "windows_malloc" "malloc"))))
       #t)

     (equal? (foreign-address-name (ftype-pointer-address malloc-fptr1))
             (if (windows?) "windows_malloc" "malloc"))

     (equal? (foreign-address-name (ftype-pointer-address malloc-fptr2))
             (if (windows?) "windows_malloc" "malloc"))

     (eqv? (ftype-pointer-address malloc-fptr1)
           (ftype-pointer-address malloc-fptr2))

     (procedure? (ftype-ref F () malloc-fptr1))

     (begin
       (define-ftype SF (struct [i int] [f (* F)]))
       (define sf
         (make-ftype-pointer SF (foreign-alloc (ftype-sizeof SF))))
       (ftype-set! SF (i) sf 10)
       (ftype-set! SF (f) sf malloc-fptr2)
       #t)

     (ftype-pointer? F (ftype-ref SF (f) sf))

     (procedure? (ftype-ref SF (f *) sf))

     (error? (begin
               (define-ftype A (struct [x double] [y wchar]))
               (define-ftype B (struct [x (array 10 A)] [y A]))
               ; see if defns above mess up defn below
               (define-ftype [A (function ((* B)) (* B))]
                 [B (struct [x A])])))

     (begin
       (define-ftype A (struct [x double] [y wchar]))
       (define-ftype B (struct [x (array 10 A)] [y A]))
       ; see if defns above mess up defn below
       (define-ftype [A (function ((* B)) (* B))] [B (struct [x (* A)])])
       (define b
         (make-ftype-pointer B (foreign-alloc (ftype-sizeof B))))
       (define a
         (ftype-ref A () (make-ftype-pointer A "idiptr")))
       #t)
     (eqv? (ftype-pointer-address (a b)) (ftype-pointer-address b))

     (begin
       (define-ftype [A (function ((* B)) (* B))] [B (struct [x (* A)])])
       (define b
         (make-ftype-pointer B (foreign-alloc (ftype-sizeof B))))
       (define a
         (ftype-ref A () (make-ftype-pointer A "idiptr")))
       #t)
     (eqv? (ftype-pointer-address (a b)) (ftype-pointer-address b))

     (begin
       (define-ftype [B (struct [x (* A)])] [A (function ((* B)) (* B))])
       (define b
         (make-ftype-pointer B (foreign-alloc (ftype-sizeof B))))
       (define a
         (ftype-ref A () (make-ftype-pointer A "idiptr")))
       #t)
     (eqv? (ftype-pointer-address (a b)) (ftype-pointer-address b))

     (begin
       (define-ftype A (function ((* A)) (* A)))
       (define a (make-ftype-pointer A "idiptr"))
       #t)
     (eqv? (ftype-pointer-address ((ftype-ref A () a) a))
           (ftype-pointer-address a))

     (begin
       (define-ftype A (struct [x uptr] [y uptr]))
       (define a
         (make-ftype-pointer A (foreign-alloc (ftype-sizeof A))))
       (define ff-init-lock
         (foreign-procedure "init_lock" ((* uptr)) void))
       (define ff-spinlock
         (foreign-procedure "spinlock" ((* uptr)) void))
       (define ff-unlock
         (foreign-procedure "unlock" ((* uptr)) void))
       (define ff-locked-incr
         (foreign-procedure "locked_incr" ((* uptr)) boolean))
       (define ff-locked-decr
         (foreign-procedure "locked_decr" ((* uptr)) boolean))
       #t)
     (eq? (ff-init-lock (ftype-&ref A (x) a)) (void))
     (ftype-lock! A (x) a)
     (not (ftype-lock! A (x) a))
     (eq? (ftype-unlock! A (x) a) (void))
     (eq? (ff-spinlock (ftype-&ref A (x) a)) (void))
     (not (ftype-lock! A (x) a))
     (eq? (ff-unlock (ftype-&ref A (x) a)) (void))
     (ftype-lock! A (x) a)
     (eq? (ff-unlock (ftype-&ref A (x) a)) (void))
     (eq? (ff-spinlock (ftype-&ref A (x) a)) (void))
     (not (ftype-lock! A (x) a))
     (eq? (ff-unlock (ftype-&ref A (x) a)) (void))
     (eq? (ftype-set! A (y) a 1) (void))
     (not (ff-locked-incr (ftype-&ref A (y) a)))
     (eqv? (ftype-ref A (y) a) 2)
     (not (ff-locked-decr (ftype-&ref A (y) a)))
     (ff-locked-decr (ftype-&ref A (y) a))
     (eqv? (ftype-ref A (y) a) 0)
     (not (ff-locked-decr (ftype-&ref A (y) a)))
     (ff-locked-incr (ftype-&ref A (y) a)))

(mat foreign-anonymous
     (eqv? (let ([addr ((foreign-procedure "idiptr_addr" () iptr))])
             (define idiptr
               (foreign-procedure addr (scheme-object) scheme-object))
             (idiptr 'friggle))
           'friggle))

(machine-case
  [(i3nt ti3nt)
   (mat i3nt-stdcall
        (let ()
          (define (win32:number-32-ptr->number n32ptr)
            (+ (fx+ (char->integer (string-ref n32ptr 0))
                    (fxsll (char->integer (string-ref n32ptr 1)) 8)
                    (fxsll (char->integer (string-ref n32ptr 2)) 16))
               (* (char->integer (string-ref n32ptr 3)) #x1000000)))
          (define (win32:GetVolumeSerialNumber root)
            (define f-proc
              (foreign-procedure
                __stdcall
                "GetVolumeInformationA"
                (string string
                        unsigned-32
                        string
                        string
                        string
                        string
                        unsigned-32)
                boolean))
            (let ([vol-sid (make-string 4)]
                  [max-filename-len (make-string 4)]
                  [sys-flags (make-string 4)])
              (and (f-proc root
                           #f
                           0
                           vol-sid
                           max-filename-len
                           sys-flags
                           #f
                           0)
                   (win32:number-32-ptr->number vol-sid))))
          (number? (win32:GetVolumeSerialNumber "C:\\"))))])

(mat single-float
     (= (let ((x (foreign-procedure "sxstos"
                   (single-float single-float)
                   single-float)))
          (x 3.0 5.0))
        15)
     (let ((args '(1.25 2.25
                        3.25
                        4.25
                        5.25
                        6.25
                        7.25
                        8.25
                        9.25
                        10.25
                        11.25
                        12.25)))
       (= (apply + args)
          (apply (foreign-procedure "singlesum12"
                   (single-float
                     single-float
                     single-float
                     single-float
                     single-float
                     single-float
                     single-float
                     single-float
                     single-float
                     single-float
                     single-float
                     single-float)
                   single-float)
                 args))))

(mat auto-mat-icks
     (auto-mat-ick "d1d2")
     (auto-mat-ick "s1s2")
     (auto-mat-ick "s1d1")
     (auto-mat-ick "d1s1")
     (auto-mat-ick "n1n2n3n4")
     (auto-mat-ick "d1n1d2")
     (auto-mat-ick "d1n1n2")
     (auto-mat-ick "s1n1n2")
     (auto-mat-ick "n1n2n3d1")
     (auto-mat-ick "n1n2n3s1")
     (auto-mat-ick "n1n2d1")
     (auto-mat-ick "n1d1")
     (auto-mat-ick "s1s2s3s4")
     (auto-mat-ick "s1n1s2n2")
     (auto-mat-ick "d1s1s2")
     (auto-mat-ick "s1s2d1")
     (auto-mat-ick "n1s1n2s2")
     (auto-mat-ick "n1s1n2n3")
     (auto-mat-ick "n1n2s1n3")
     (auto-mat-ick "d1d2s1s2")
     (auto-mat-ick "d1d2n1n2")
     (auto-mat-ick "s1d1s2s3"))

(mat foreign-callable
     (error? ; spam is not a procedure
             (foreign-callable 'spam () void))
     (error? ; spam is not a procedure
             (begin (foreign-callable 'spam () void) 'q))
     (error? ; spam is not a procedure
             (if (foreign-callable 'spam () void) 'q 'p))
     (equal? (let ()
               (define Sinvoke2
                 (foreign-procedure "Sinvoke2"
                   (scheme-object scheme-object iptr)
                   scheme-object))
               (define Fcons
                 (foreign-callable
                   (lambda (x y)
                     (collect)
                     (let ([ls (map (lambda (x) (make-vector 200 x))
                                    (make-list 100))])
                       (collect)
                       (collect)
                       (collect)
                       (collect)
                       (collect)
                       (cons (length ls) (cons x y))))
                   (scheme-object iptr)
                   scheme-object))
               (define (go) (Sinvoke2 Fcons 4 5))
               (define initial-result (go))
               (let loop ([i 100])
                 (if (zero? i)
                     initial-result
                     (and (equal? initial-result (go))
                          (loop (sub1 i))))))
             '(100 4 . 5))
     (eqv? (let ()
             (define Sinvoke2
               (foreign-procedure "Sinvoke2"
                 (scheme-object scheme-object iptr)
                 scheme-object))
             (define fxFsum
               (foreign-callable
                 (lambda (x y)
                   (if (fx= x 0)
                       y
                       (fx+ x (Sinvoke2 fxFsum (fx- x 1) y))))
                 (scheme-object iptr)
                 scheme-object))
             (define (fxgosum n) (Sinvoke2 fxFsum n 0))
             (fxgosum 20))
           210)
     (eqv? (let ()
             (define Sinvoke2
               (foreign-procedure "Sinvoke2"
                 (scheme-object scheme-object iptr)
                 scheme-object))
             (define Fsum
               (foreign-callable
                 (lambda (x y)
                   (if (= x 0)
                       y
                       (+ x (Sinvoke2 Fsum (- x 1) y))))
                 (scheme-object iptr)
                 scheme-object))
             (define (gosum n)
               (Sinvoke2 Fsum n (most-positive-fixnum)))
             (gosum 20))
           (+ (most-positive-fixnum) 210))
     (let ()
       (define Fargtest
         (foreign-callable
           (lambda (bool char fixnum double single string)
             (list string single double fixnum char bool))
           (boolean char fixnum double-float single-float string)
           scheme-object))
       (define Sargtest
         (foreign-procedure "Sargtest"
           (iptr boolean char fixnum double-float single-float string)
           scheme-object))
       (define args1
         (list #t #\Q 12345 3.1415 2.0 "hit me"))
       (define args2
         (list #f #\newline -51293 3.1415 2.5 ""))
       (define args3
         (list #f #\newline -51293 3.1415 2.5 #f))
       (let ()
         (define addr
           (begin
             (lock-object Fargtest)
             (foreign-callable-entry-point Fargtest)))
         (dynamic-wind void
           (lambda ()
             (collect (collect-maximum-generation))
             (collect (collect-maximum-generation))
             (and (equal? (apply Sargtest addr args1) (reverse args1))
                  (equal? (apply Sargtest addr args2) (reverse args2))
                  (equal? (apply Sargtest addr args3) (reverse args3))))
           (lambda () (unlock-object Fargtest)))))
     (let ()
       (define Fargtest2
         (foreign-callable
           (lambda (x1 x2 x3 x4 x5 x6)
             (list x6 x5 x4 x3 x2 x1))
           (short int char double short char)
           scheme-object))
       (define Sargtest2
         (foreign-procedure "Sargtest2"
           (iptr short int char double short char)
           scheme-object))
       (define args1
         (list 32123 #xc7c7c7 #\% 3.1415 -32768 #\!))
       (define args2
         (list 17 #x-987654 #\P -521.125 -1955 #\Q))
       (define args3
         (list -7500 #x987654 #\? +inf.0 3210 #\7))
       (let ()
         (define addr
           (begin
             (lock-object Fargtest2)
             (foreign-callable-entry-point Fargtest2)))
         (dynamic-wind void
           (lambda ()
             (collect (collect-maximum-generation))
             (collect (collect-maximum-generation))
             (and (equal? (apply Sargtest2 addr args1) (reverse args1))
                  (equal? (apply Sargtest2 addr args2) (reverse args2))
                  (equal? (apply Sargtest2 addr args3) (reverse args3))))
           (lambda () (unlock-object Fargtest2)))))
     (let ()
       (define Frvtest_int32
         (foreign-callable (lambda (x) (* x x)) (scheme-object) integer-32))
       (define Srvtest_int32
         (foreign-procedure "Srvtest_int32"
           (scheme-object scheme-object)
           integer-32))
       (and (eqv? (Srvtest_int32 Frvtest_int32 16) 256)
            (eqv? (Srvtest_int32 Frvtest_int32 #x8000) #x40000000)))
     (let ()
       (define Frvtest_uns32
         (foreign-callable (lambda (x) (- (* x x) 1))
           (scheme-object)
           unsigned-32))
       (define Srvtest_uns32
         (foreign-procedure "Srvtest_uns32"
           (scheme-object scheme-object)
           unsigned-32))
       (and (eqv? (Srvtest_uns32 Frvtest_uns32 16) 255)
            (eqv? (Srvtest_uns32 Frvtest_uns32 #x10000) #xffffffff)))
     (let ()
       (define Frvtest_single
         (foreign-callable (lambda (x) (* x x))
           (scheme-object)
           single-float))
       (define Srvtest_single
         (foreign-procedure "Srvtest_single"
           (scheme-object scheme-object)
           single-float))
       (eqv? (Srvtest_single Frvtest_single 16.0) 256.0))
     (let ()
       (define Frvtest_double
         (foreign-callable (lambda (x) (* x x))
           (scheme-object)
           double-float))
       (define Srvtest_double
         (foreign-procedure "Srvtest_double"
           (scheme-object scheme-object)
           double-float))
       (eqv? (Srvtest_double Frvtest_double 16.0) 256.0))
     (let ()
       (define Frvtest_char
         (foreign-callable (lambda (x) (string-ref x 3))
           (scheme-object)
           char))
       (define Srvtest_char
         (foreign-procedure "Srvtest_char"
           (scheme-object scheme-object)
           char))
       (eqv? (Srvtest_char Frvtest_char "abcdefg") #\d))
     (let ()
       (define Frvtest_boolean
         (foreign-callable (lambda (x) (equal? x "abcdefg"))
           (scheme-object)
           boolean))
       (define Srvtest_boolean
         (foreign-procedure "Srvtest_int32"
           (scheme-object scheme-object)
           boolean))
       (and (eqv? (Srvtest_boolean Frvtest_boolean "abcdefg") #t)
            (eqv? (Srvtest_boolean Frvtest_boolean "gfedcba") #f)))
     (let ()
       (define Frvtest_fixnum
         (foreign-callable (lambda (x) (* x x)) (scheme-object) fixnum))
       (define Srvtest_fixnum
         (foreign-procedure "Srvtest_int32"
           (scheme-object scheme-object)
           fixnum))
       (eqv? (Srvtest_fixnum Frvtest_fixnum 16) 256))
     (let ()
       (define Frvtest_fixnum
         (foreign-callable (lambda (x) (* x x)) (scheme-object) void))
       (define Srvtest_fixnum
         (foreign-procedure "Srvtest_int32"
           (scheme-object scheme-object)
           void))
       (eqv? (Srvtest_fixnum Frvtest_fixnum 16) (void)))
     #;
     (error? (foreign-callable values (scheme-object) foreign-pointer))
     #;
     (error? (foreign-callable values
               (scheme-object)
               (foreign-object 16 4)))
     #;
     (error? (foreign-callable values (foreign-pointer) void))
     #;
     (error? (foreign-callable values ((foreign-object 16 4)) void))
     (equal? (let ([x 5])
               (define call-twice
                 (foreign-procedure "call_twice" (void* int int) void))
               (let ([co (foreign-callable (lambda (y) (set! x (+ x y)))
                           (int)
                           void)])
                 (lock-object co)
                 (call-twice (foreign-callable-entry-point co) 7 31)
                 (unlock-object co))
               x)
             43)
     (equal? (let ()
               ; foreign_callable example adapted from foreign.stex
               (define cb-init
                 (foreign-procedure "cb_init" () void))
               (define register-callback
                 (foreign-procedure "register_callback" (char iptr) void))
               (define event-loop
                 (foreign-procedure "event_loop" (string) void))

               (define callback
                 (lambda (p)
                   (let ([code (foreign-callable p (char) void)])
                     (lock-object code)
                     (foreign-callable-entry-point code))))
               (let ()
                 (define ouch
                   (callback (lambda (c) (printf "Ouch! Hit by '~c'~%" c))))
                 (define rats
                   (callback (lambda (c)
                               (printf "Rats! Received '~c'~%" c))))
                 (cb-init)
                 (register-callback #\a ouch)
                 (register-callback #\c rats)
                 (register-callback #\e ouch)
                 (parameterize ([current-output-port (open-output-string)])
                   (event-loop "abcde")
                   (get-output-string (current-output-port)))))
             (format "Ouch! Hit by 'a'~%Rats! Received 'c'~%Ouch! Hit by 'e'~%"))
     ; make sure foreign-procedure's code-object is properly locked when
     ; calling back into Scheme
     (begin
       (define call-collect
         (lambda ()
           (collect)
           (collect (collect-maximum-generation))))
       (define code (foreign-callable call-collect () void))
       (collect)
       #t)
     ; this form needs to be after the preceding form and not part of it, so that when
     ; we lock code we don't also lock the code object created by foreign-procedure
     (begin
       (lock-object code)
       ((foreign-procedure (foreign-callable-entry-point code) () scheme-object))
       (unlock-object code)
       #t)

     (not (locked-object?
            (let ()
              (define cb
                (foreign-callable (lambda (i) i) (int) int))
              (define unlock-callback
                (foreign-procedure "unlock_callback" (void*) void))
              (lock-object cb)
              (unlock-callback (foreign-callable-entry-point cb))
              cb)))
     (not (locked-object?
            (let ()
              (define cb
                (foreign-callable (lambda (i) i) (int) int))
              (define unlock-callback
                (foreign-procedure "unlock_callback" (void*) void))
              (lock-object cb)
              (collect)
              (unlock-callback (foreign-callable-entry-point cb))
              cb)))
     (equal? (let ()
               (define cb
                 (foreign-callable (lambda (i) (+ i 10)) (int) int))
               (define call-and-unlock
                 (foreign-procedure "call_and_unlock" (void* int) int))
               (lock-object cb)
               (let ([ans (call-and-unlock
                            (foreign-callable-entry-point cb)
                            5)])
                 (list (locked-object? cb) ans)))
             '(#f 15))
     (equal? (let ()
               (define cb
                 (foreign-callable (lambda (i) (+ i 10)) (int) int))
               (define call-and-unlock
                 (foreign-procedure "call_and_unlock" (void* int) int))
               (lock-object cb)
               (collect)
               (let ([ans (call-and-unlock
                            (foreign-callable-entry-point cb)
                            3)])
                 (list (locked-object? cb) ans)))
             '(#f 13))
     (begin
       (define $stack-depth 8000)
       (define $base-value 37)
       #t)
     (eqv? ; make sure foreign-callable does it's overflow checks
           (let ()
             (define-ftype foo (function (fixnum fixnum) fixnum))
             (define f
               (lambda (n m)
                 (if (fx= n 0) m (g (fx- n 1) (fx+ m 1)))))
             (define fptr (make-ftype-pointer foo f))
             (define g (ftype-ref foo () fptr))
             (let ([v (f $stack-depth $base-value)])
               (unlock-object
                 (foreign-callable-code-object
                   (ftype-pointer-address fptr)))
               v))
           (+ $stack-depth $base-value))
     (begin
       (define $with-exit-proc
         ; if you change this, consider changing the definition of with-exit-proc
         ; in foreign.stex
         (lambda (p)
           (define th (lambda () (call/cc p)))
           (define-ftype ->ptr (function () ptr))
           (let ([fptr (make-ftype-pointer ->ptr th)])
             (let ([v ((ftype-ref ->ptr () fptr))])
               (unlock-object
                 (foreign-callable-code-object
                   (ftype-pointer-address fptr)))
               v))))
       #t)
     (eqv? ; make sure we can jump out of a deep nest of C/Scheme calls
           (let ()
             (define *k*)
             (define-ftype foo (function (fixnum fixnum) fixnum))
             (define f
               (lambda (n m)
                 (if (fx= n 0)
                     (*k* m)
                     (g (fx- n 1) (fx+ m 1)))))
             (define fptr (make-ftype-pointer foo f))
             (define g (ftype-ref foo () fptr))
             (let ([v ($with-exit-proc
                        (lambda (k)
                          (set! *k* k)
                          (f $stack-depth $base-value)))])
               (unlock-object
                 (foreign-callable-code-object
                   (ftype-pointer-address fptr)))
               v))
           (+ $stack-depth $base-value))
     (eqv? ; make sure we can jump out a few frames at a time
           (let ()
             (define-ftype foo (function (fixnum fixnum ptr) fixnum))
             (define f
               (lambda (n m k)
                 (if (fx= n 0)
                     (k m)
                     (if (fx= (fxmodulo n 10) 0)
                         (k (call/cc
                              (lambda (k)
                                (g (fx- n 1) (fx+ m 1) k))))
                         (g (fx- n 1) (fx+ m 1) k)))))
             (define fptr (make-ftype-pointer foo f))
             (define g (ftype-ref foo () fptr))
             (let ([v ($with-exit-proc
                        (lambda (k)
                          (f $stack-depth $base-value k)))])
               (unlock-object
                 (foreign-callable-code-object
                   (ftype-pointer-address fptr)))
               v))
           (+ $stack-depth $base-value))
     (or (= (optimize-level) 3)
         ; make sure we can jump out a few frames at a time, returning from
         ; each with an invalid number of values, just for fun
         (eqv? ($with-exit-proc
                 (lambda (ignore)
                   (define *m*)
                   (define *k*)
                   (define-ftype foo (function (fixnum fixnum) fixnum))
                   (define f
                     (lambda (n m)
                       (if (fx= n 0)
                           (begin (set! *m* m) (values))
                           (if (fx= (fxmodulo n 10) 0)
                               (begin
                                 (set! *m*
                                   (call/cc
                                     (lambda (k)
                                       (fluid-let ([*k* k])
                                         (g (fx- n 1) (fx+ m 1))))))
                                 (values))
                               (g (fx- n 1) (fx+ m 1))))))
                   (define fptr (make-ftype-pointer foo f))
                   (define g (ftype-ref foo () fptr))
                   (with-exception-handler (lambda (c) (*k* *m*))
                     (lambda ()
                       (call/cc
                         (lambda (k)
                           (fluid-let ([*k* k])
                             (f $stack-depth $base-value))))))
                   (unlock-object
                     (foreign-callable-code-object
                       (ftype-pointer-address fptr)))
                   *m*))
               (+ $stack-depth $base-value)))
     (or (= (optimize-level) 3)
         ; similarly, but with a ptr return value so the values error is signaled
         ; by S_call_help wrather than the foreign-procedure wrapper
         (eqv? ($with-exit-proc
                 (lambda (ignore)
                   (define *m*)
                   (define *k*)
                   (define-ftype foo (function (fixnum fixnum) ptr))
                   (define f
                     (lambda (n m)
                       (if (fx= n 0)
                           (begin (set! *m* m) (values))
                           (if (fx= (fxmodulo n 10) 0)
                               (begin
                                 (set! *m*
                                   (call/cc
                                     (lambda (k)
                                       (fluid-let ([*k* k])
                                         (g (fx- n 1) (fx+ m 1))))))
                                 (values))
                               (g (fx- n 1) (fx+ m 1))))))
                   (define fptr (make-ftype-pointer foo f))
                   (define g (ftype-ref foo () fptr))
                   (with-exception-handler (lambda (c) (*k* *m*))
                     (lambda ()
                       (call/cc
                         (lambda (k)
                           (fluid-let ([*k* k])
                             (f $stack-depth $base-value))))))
                   (unlock-object
                     (foreign-callable-code-object
                       (ftype-pointer-address fptr)))
                   *m*))
               (+ $stack-depth $base-value)))
     (or (= (optimize-level) 3)
         ; make sure we can jump out a few frames at a time, returning from
         ; each with an fasl-reading error, just for fun
         (eqv? (let ()
                 (define *m*)
                 (define *k*)
                 (define ip (open-file-input-port "mat.ss"))
                 (define-ftype foo (function (fixnum fixnum) fixnum))
                 (define f
                   (lambda (n m)
                     (if (fx= n 0)
                         (begin (set! *m* m) (fasl-read ip))
                         (if (fx= (fxmodulo n 10) 0)
                             (begin
                               (set! *m*
                                 (call/cc
                                   (lambda (k)
                                     (fluid-let ([*k* k])
                                       (g (fx- n 1) (fx+ m 1))))))
                               (fasl-read ip))
                             (g (fx- n 1) (fx+ m 1))))))
                 (define fptr (make-ftype-pointer foo f))
                 (define g (ftype-ref foo () fptr))
                 ; position "fasl" file at eof to make sure fasl-read isn't tripped up
                 ; by something that appears almost valid
                 (get-bytevector-all ip)
                 (with-exception-handler (lambda (c) (*k* *m*))
                   (lambda ()
                     ($with-exit-proc
                       (lambda (k)
                         (fluid-let ([*k* k])
                           (f $stack-depth $base-value))))))
                 (unlock-object
                   (foreign-callable-code-object
                     (ftype-pointer-address fptr)))
                 *m*)
               (+ $stack-depth $base-value)))
     ;; Make sure that a callable is suitably locked, and that it's
     ;; unlocked when the C stack is popped by an escape
     (equal? (let ()
               (define Sinvoke2
                 (foreign-procedure "Sinvoke2"
                   (scheme-object scheme-object iptr)
                   scheme-object))
               (define Fcons
                 (foreign-callable
                   (lambda (k y)
                     ;; Escape with locked, which should be #t
                     ;; because a callable is locked while it's
                     ;; called:
                     (k (locked-object? Fcons)))
                   (scheme-object iptr)
                   scheme-object))
               (list ;; Call and normal callable return:
                     (let ([v (Sinvoke2 Fcons (lambda (x) x) 5)])
                       (list v (locked-object? Fcons)))
                     ;; Escape from callable:
                     (let ([v ($with-exit-proc
                                (lambda (k)
                                  (Sinvoke2 Fcons k 5)))])
                       (list v (locked-object? Fcons)))))
             '((#t #f) (#t #f)))

     ;; Make sure the code pointer for a call into a
     ;; foreign procedure is correctly saved for locking
     ;; when entering a callback as a callable:
     (equal? (let ()
               (define v 0)
               (define call_many_times
                 (foreign-procedure "call_many_times" (void*) void))
               (define work
                 (lambda (n)
                   ;; This loop needs to be non-allocating, but
                   ;; causes varying numbers of ticks
                   ;; to be used up.
                   (let loop ([n (bitwise-and n #xFFFF)])
                     (unless (zero? n)
                             (set! v (add1 v))
                             (loop (bitwise-arithmetic-shift-right n 1))))))
               (define handler
                 (foreign-callable work (long) void))
               (lock-object handler)
               (call_many_times (foreign-callable-entry-point handler))
               v)
             14995143)

     ;; regression test related to saving registers that hold allocated
     ;; callable argument
     (let* ([call-with-many-args
              (foreign-procedure "call_with_many_args" (void*) boolean)]
            [result #f]
            [cb (foreign-callable
                  (lambda (i s1 s2 s3 s4 i2 s6 s7 i3)
                    (set! result
                      (and (eqv? i 0)
                           (equal? (string->utf8 "this") s1)
                           (equal? (string->utf8 "is") s2)
                           (equal? (string->utf8 "working") s3)
                           (equal? (string->utf8 "just") s4)
                           (eqv? i2 1)
                           (equal? (string->utf8 "fine") s6)
                           (equal? (string->utf8 "or does it?") s7)
                           (eqv? i3 2))))
                  (int u8* u8* u8* u8* int u8* u8* int)
                  void)])
       (lock-object cb)
       (call-with-many-args (foreign-callable-entry-point cb))
       (unlock-object cb)
       result)
     )

(machine-case
  [(i3nt ti3nt)
   (mat i3nt-stdcall-foreign-callable
        (equal? (let ()
                  (define Sinvoke2
                    (foreign-procedure "Sinvoke2_stdcall"
                      (scheme-object scheme-object iptr)
                      scheme-object))
                  (define Fcons
                    (foreign-callable __stdcall
                      (lambda (x y)
                        (collect)
                        (let ([ls (make-list 20000 #\z)])
                          (collect)
                          (collect)
                          (collect)
                          (collect)
                          (collect)
                          (cons (length ls) (cons x y))))
                      (scheme-object iptr)
                      scheme-object))
                  (define (go) (Sinvoke2 Fcons 4 5))
                  (go))
                '(20000 4 . 5))
        (eqv? (let ()
                (define Sinvoke2
                  (foreign-procedure "Sinvoke2_stdcall"
                    (scheme-object scheme-object iptr)
                    scheme-object))
                (define fxFsum
                  (foreign-callable __stdcall
                    (lambda (x y)
                      (if (fx= x 0)
                          y
                          (fx+ x (Sinvoke2 fxFsum (fx- x 1) y))))
                    (scheme-object iptr)
                    scheme-object))
                (define (fxgosum n) (Sinvoke2 fxFsum n 0))
                (fxgosum 20))
              210)
        (eqv? (let ()
                (define Sinvoke2
                  (foreign-procedure "Sinvoke2_stdcall"
                    (scheme-object scheme-object iptr)
                    scheme-object))
                (define Fsum
                  (foreign-callable __stdcall
                    (lambda (x y)
                      (if (= x 0)
                          y
                          (+ x (Sinvoke2 Fsum (- x 1) y))))
                    (scheme-object iptr)
                    scheme-object))
                (define (gosum n)
                  (Sinvoke2 Fsum n (most-positive-fixnum)))
                (gosum 20))
              536871121))
   (mat i3nt-com
        (eqv? (let ()
                (define com-instance
                  ((foreign-procedure "get_com_instance" () iptr)))
                ((foreign-procedure __com 0 (iptr int) int) com-instance 3)
                ((foreign-procedure __com 4 (iptr int) int) com-instance 17))
              37))])

(mat die-gracefully-without-stderr
     (let-values ([(to-stdin from-stdout from-stderr pid)
                   (open-process-ports
                     (format "~a -q" (patch-exec-path *scheme*))
                     (buffer-mode block)
                     (native-transcoder))])
       (fprintf to-stdin "(error #f \"oops 1\")\n")
       (flush-output-port to-stdin)
       (let ([s1 (get-line from-stderr)])
         (close-port from-stderr)
         (fprintf to-stdin "(error #f \"oops 2\")\n")
         ; this message should disappear
         (flush-output-port to-stdin)
         (fprintf to-stdin "(+ 17 44)\n")
         (flush-output-port to-stdin)
         (let ([s2 (get-line from-stdout)])
           (fprintf to-stdin "(reset-handler abort)\n")
           (fprintf to-stdin "(reset-handler)\n")
           (flush-output-port to-stdin)
           (let ([s3 (get-line from-stdout)])
             (close-port from-stdout)
             (fprintf to-stdin "'hello\n")
             ; should cause exception, then abort (via reset)
             (flush-output-port to-stdin)
             (let ([pid^ (machine-case [(i3nt ti3nt a6nt ta6nt) pid]
                           [else
                            ((foreign-procedure "waitpid"
                               (int (* int) int)
                               int)
                             pid
                             (make-ftype-pointer int 0)
                             0)])])
               (and (equal? s1 "Exception: oops 1")
                    (equal? s2 "61")
                    (equal? s3 "#<procedure abort>")
                    (eqv? pid^ pid))))))))

(mat varargs
     (begin
       (define load-libc
         (machine-case
           [(i3ob ti3ob
                  a6ob
                  ta6ob
                  a6s2
                  ta6s2
                  i3s2
                  ti3s2
                  i3qnx
                  ti3qnx
                  i3nb
                  ti3nb
                  a6nb
                  ta6nb)
            '(load-shared-object "libc.so")]
           [(i3le ti3le a6le ta6le arm32le tarm32le ppc32le tppc32le)
            '(load-shared-object "libc.so.6")]
           [(i3fb ti3fb a6fb ta6fb) '(load-shared-object "libc.so.7")]
           [(i3nt ti3nt a6nt ta6nt) '(load-shared-object "msvcrt.dll")]
           [(i3osx ti3osx a6osx ta6osx) '(load-shared-object "libc.dylib")]
           [else
            (error 'load-libc "unrecognized machine type ~s"
                   (machine-type))]))
       #t)
     (equal? (with-input-from-string
               (separate-eval
                 `(begin
                    ,load-libc
                    (define f
                      (foreign-procedure "printf" (string double) int))
                    (f "(%g)" 3.5)
                    (void)))
               read)
             '(3.5))
     (equal? (with-input-from-string
               (separate-eval
                 `(begin
                    ,load-libc
                    (define f
                      (foreign-procedure "printf"
                        (string double double double double double double)
                        int))
                    (f "(%g %g %g %g %g %g)" 3.5 2.5 -1.5 6.75 8.25 -9.5)
                    (void)))
               read)
             '(3.5 2.5 -1.5 6.75 8.25 -9.5))
     (equal? (with-input-from-string
               (separate-eval
                 `(begin
                    ,load-libc
                    (define f
                      (foreign-procedure "printf"
                        (string double
                                double
                                double
                                double
                                double
                                double
                                double
                                double)
                        int))
                    (f "(%g %g %g %g %g %g %g %g)"
                       3.5
                       2.5
                       -1.5
                       6.75
                       8.25
                       -9.5
                       1e32
                       -4.5)
                    (void)))
               read)
             '(3.5 2.5 -1.5 6.75 8.25 -9.5 1e32 -4.5))
     (equal? (with-input-from-string
               (separate-eval
                 `(begin
                    ,load-libc
                    (define f
                      (foreign-procedure "printf"
                        (string double
                                double
                                double
                                double
                                double
                                double
                                double
                                double
                                double
                                double)
                        int))
                    (f "(%g %g %g %g %g %g %g %g %g %g)"
                       3.5
                       2.5
                       -1.5
                       6.75
                       8.25
                       -9.5
                       1e32
                       -4.5
                       7.25
                       -0.5)
                    (void)))
               read)
             '(3.5 2.5 -1.5 6.75 8.25 -9.5 1e32 -4.5 7.25 -0.5)))

(mat structs
     (begin
       (define-ftype i8 integer-8)
       (define-ftype u8 unsigned-8)
       (define-ftype u16 unsigned-16)
       (define-ftype i64 integer-64)
       (define-syntax check*
         (syntax-rules ()
           [(_ (conv ...) T s [vi ...] [T-ref ...] [T-set! ...])
            (let ()
              (define-ftype callback (function conv ... ((& T)) double))
              (define-ftype callback-two
                (function conv ... ((& T) (& T)) double))
              (define-ftype pre-int-callback
                (function conv ... (int (& T)) double))
              (define-ftype pre-double-callback
                (function conv ... (double (& T)) double))
              (define-ftype callback-r (function conv ... () (& T)))
              (define get
                (foreign-procedure conv ... (format "f4_get~a" s) () (& T)))
              (define sum
                (foreign-procedure
                  conv
                  ...
                  (format "f4_sum~a" s)
                  ((& T))
                  double))
              (define sum_two
                (foreign-procedure
                  conv
                  ...
                  (format "f4_sum_two~a" s)
                  ((& T) (& T))
                  double))
              (define sum_pre_int
                (foreign-procedure
                  conv
                  ...
                  (format "f4_sum_pre_int~a" s)
                  (int (& T))
                  double))
              (define sum_pre_int_int
                (foreign-procedure
                  conv
                  ...
                  (format "f4_sum_pre_int_int~a" s)
                  (int int (& T))
                  double))
              (define sum_pre_int_int_int_int
                (foreign-procedure
                  conv
                  ...
                  (format "f4_sum_pre_int_int_int_int~a" s)
                  (int int int int (& T))
                  double))
              (define sum_pre_int_int_int_int_int_int
                (foreign-procedure
                  conv
                  ...
                  (format "f4_sum_pre_int_int_int_int_int_int~a" s)
                  (int int int int int int (& T))
                  double))
              (define sum_post_int
                (foreign-procedure
                  conv
                  ...
                  (format "f4_sum~a_post_int" s)
                  ((& T) int)
                  double))
              (define sum_pre_double
                (foreign-procedure
                  conv
                  ...
                  (format "f4_sum_pre_double~a" s)
                  (double (& T))
                  double))
              (define sum_pre_double_double
                (foreign-procedure
                  conv
                  ...
                  (format "f4_sum_pre_double_double~a" s)
                  (double double (& T))
                  double))
              (define sum_pre_double_double_double_double
                (foreign-procedure
                  conv
                  ...
                  (format "f4_sum_pre_double_double_double_double~a" s)
                  (double double double double (& T))
                  double))
              (define sum_pre_double_double_double_double_double_double_double_double
                (foreign-procedure
                  conv
                  ...
                  (format "f4_sum_pre_double_double_double_double_double_double_double_double~a"
                          s)
                  (double double
                          double
                          double
                          double
                          double
                          double
                          double
                          (& T))
                  double))
              (define sum_post_double
                (foreign-procedure
                  conv
                  ...
                  (format "f4_sum~a_post_double" s)
                  ((& T) double)
                  double))
              (define cb_send
                (foreign-procedure
                  conv
                  ...
                  (format "f4_cb_send~a" s)
                  ((* callback))
                  double))
              (define cb_send_two
                (foreign-procedure
                  conv
                  ...
                  (format "f4_cb_send_two~a" s)
                  ((* callback-two))
                  double))
              (define cb_send_pre_int
                (foreign-procedure
                  conv
                  ...
                  (format "f4_cb_send_pre_int~a" s)
                  ((* pre-int-callback))
                  double))
              (define cb_send_pre_double
                (foreign-procedure
                  conv
                  ...
                  (format "f4_cb_send_pre_double~a" s)
                  ((* pre-double-callback))
                  double))
              (define sum_cb
                (foreign-procedure
                  conv
                  ...
                  (format "f4_sum_cb~a" s)
                  ((* callback-r))
                  double))
              (define-syntax with-callback
                (syntax-rules ()
                  [(_ ([id rhs]) body)
                   (let ([id rhs])
                     (let ([v body])
                       (unlock-object
                         (foreign-callable-code-object
                           (ftype-pointer-address id)))
                       v))]))
              (and (let ([v (make-ftype-pointer T
                              (malloc_at_boundary (ftype-sizeof T)))])
                     (get v)
                     (and (= (T-ref v) vi)
                          ...
                          (begin
                            (free_at_boundary (ftype-pointer-address v))
                            #t)))
                   (let ([a (make-ftype-pointer T
                              (malloc_at_boundary (ftype-sizeof T)))])
                     (T-set! a)
                     ...
                     (and (= (+ vi ...) (sum a))
                          (= (+ vi ... vi ...) (sum_two a a))
                          (= (+ 8 vi ...) (sum_pre_int 8 a))
                          (= (+ 8 9 vi ...) (sum_pre_int_int 8 9 a))
                          (= (+ 8 9 10 11 vi ...)
                             (sum_pre_int_int_int_int 8 9 10 11 a))
                          (= (+ 8 9 10 11 12 13 vi ...)
                             (sum_pre_int_int_int_int_int_int 8 9 10 11 12 13 a))
                          (= (+ 8 vi ...) (sum_post_int a 8))
                          (= (+ 8.25 vi ...) (sum_pre_double 8.25 a))
                          (= (+ 8.25 9.25 vi ...)
                             (sum_pre_double_double 8.25 9.25 a))
                          (= (+ 8.25 9.25 10.25 11.25 vi ...)
                             (sum_pre_double_double_double_double
                               8.25
                               9.25
                               10.25
                               11.25
                               a))
                          (= (+ 8.25
                                9.25
                                10.25
                                11.25
                                12.25
                                13.25
                                14.25
                                15.25
                                vi
                                ...)
                             (sum_pre_double_double_double_double_double_double_double_double
                               8.25
                               9.25
                               10.25
                               11.25
                               12.25
                               13.25
                               14.25
                               15.25
                               a))
                          (= (+ 8.25 vi ...) (sum_post_double a 8.25))
                          (= (+ 1.0 vi ...)
                             (with-callback
                               ([cb (make-ftype-pointer callback
                                      (lambda (r)
                                        (exact->inexact (+ (T-ref r) ...))))])
                               (cb_send cb)))
                          (= (+ 1.0 vi ... vi ...)
                             (with-callback
                               ([cb (make-ftype-pointer callback-two
                                      (lambda (r1 r2)
                                        (exact->inexact (+ (T-ref r1) ... (T-ref r2) ...))))])
                               (cb_send_two cb)))
                          (= (+ 1.0 8 vi ...)
                             (with-callback
                               ([cb (make-ftype-pointer pre-int-callback
                                      (lambda (v r)
                                        (exact->inexact (+ v (T-ref r) ...))))])
                               (cb_send_pre_int cb)))
                          (= (+ 1.0 8.25 vi ...)
                             (with-callback
                               ([cb (make-ftype-pointer pre-double-callback
                                      (lambda (v r)
                                        (exact->inexact (+ v (T-ref r) ...))))])
                               (cb_send_pre_double cb)))
                          (= (+ vi ...)
                             (with-callback
                               ([cb (make-ftype-pointer callback-r
                                      (lambda (r)
                                        (T-set! r)
                                        ...))])
                               (sum_cb cb)))
                          (begin
                            (free_at_boundary (ftype-pointer-address a))
                            #t)))))]))
       (define-syntax check*t
         (syntax-rules ()
           [(_ arg ...)
            (and (check* () arg ...)
                 (check* (__collect_safe) arg ...))]))
       (define-syntax check-n
         (syntax-rules ()
           [(_ [ni ti vi] ...)
            (let ()
              (define-ftype T (struct [ni ti] ...))
              (define s
                (apply string-append "_struct"
                       (let loop ([l '(ti ...)])
                         (cond
                           [(null? l) '()]
                           [else
                            (cons (format "_~a" (car l))
                                  (loop (cdr l)))]))))
              (check*t T
                       s
                       [vi ...]
                       [(lambda (a) (ftype-ref T (ni) a)) ...]
                       [(lambda (a) (ftype-set! T (ni) a vi)) ...]))]))
       (define-syntax check
         (syntax-rules ()
           [(_ t1 v1)
            (check*t t1
              (format "_~a" 't1)
              [v1]
              [(lambda (a) (ftype-ref t1 () a))]
              [(lambda (a) (ftype-set! t1 () a v1))])]))
       (define-syntax check-union
         (syntax-rules ()
           [(_ [n0 t0 v0] [ni ti vi] ...)
            (let ()
              (define-ftype T (union [n0 t0] [ni ti] ...))
              (define s
                (apply string-append "_union"
                       (let loop ([l '(t0 ti ...)])
                         (cond
                           [(null? l) '()]
                           [else
                            (cons (format "_~a" (car l))
                                  (loop (cdr l)))]))))
              (check*t T
                       s
                       [v0]
                       [(lambda (a) (ftype-ref T (n0) a))]
                       [(lambda (a) (ftype-set! T (n0) a v0))]))]))
       (define-syntax check-1
         (syntax-rules () [(_ t1 v1) (check-n [x t1 v1])]))
       (define-syntax check-2
         (syntax-rules ()
           [(_ t1 t2 v1 v2) (check-n [x t1 v1] [y t2 v2])]))
       (define-syntax check-2-set
         (syntax-rules ()
           [(_ t x)
            (and (check-2 t i8 (+ 1 x) 10)
                 (check-2 t short (+ 2 x) 20)
                 (check-2 t long (+ 3 x) 30)
                 (check-2 t i64 (+ 5 x) 50)
                 (check-2 short t 6 (+ 60 x))
                 (check-2 long t 7 (+ 70 x))
                 (check-2 i64 t 9 (+ 90 x))
                 (check-2 i8 t 10 (+ 100 x)))]))
       (define-syntax check-3
         (syntax-rules ()
           [(_ t1 t2 t3 v1 v2 v3) (check-n [x t1 v1] [y t2 v2] [z t3 v3])]))
       (define-syntax check-3-set
         (syntax-rules ()
           [(_ t x)
            (and (check-3 t i8 int (+ 1 x) 10 100)
                 (check-3 t short int (+ 2 x) 20 200)
                 (check-3 t long int (+ 3 x) 30 300)
                 (check-3 t i64 int (+ 5 x) 50 500)
                 (check-3 short t int 6 (+ 60 x) 600)
                 (check-3 long t int 7 (+ 70 x) 700)
                 (check-3 i64 t int 9 (+ 90 x) 900)
                 (check-3 i8 t int 10 (+ 100 x) 1000))]))
       (define malloc_at_boundary
         (foreign-procedure "malloc_at_boundary" (int) uptr))
       (define free_at_boundary
         (foreign-procedure "free_at_boundary" (uptr) void))
       #t)
     (check i8 -11)
     (check u8 129)
     (check short -22)
     (check u16 33022)
     (check long 33)
     (check int 44)
     (check i64 49)
     (check float 55.0)
     (check double 66.0)
     (check-1 i8 -12)
     (check-1 u8 212)
     (check-1 short -23)
     (check-1 u16 33023)
     (check-1 long 34)
     (check-1 int 45)
     (check-1 i64 48)
     (check-1 float 56.0)
     (check-1 double 67.0)
     (check-2-set int 0)
     (check-2-set float 0.5)
     (check-2-set double 0.25)
     (check-2 int int 4 40)
     (check-2 float float 4.5 40.5)
     (check-2 double double 4.25 40.25)
     (check-3-set int 0)
     (check-3-set float 0.5)
     (check-3-set double 0.25)
     (check-3 i8 i8 i8 4 38 127)
     (check-3 short short short 4 39 399)
     (check-3 int int int 4 40 400)
     (check-3 float float float 4.5 40.5 400.5)
     (check-3 double double double 4.25 40.25 400.25)
     (check-n [x i8 1] [y i8 2] [z i8 3] [w i8 4] [q i8 5])
     (check-n [x i8 1]
       [y i8 2]
       [z i8 3]
       [w i8 4]
       [q i8 5]
       [r i8 6]
       [s i8 7])
     (check-union [x i8 -17])
     (check-union [x u8 217])
     (check-union [x short -27])
     (check-union [x u16 33027])
     (check-union [x long 37])
     (check-union [x int 47])
     (check-union [x i64 49])
     (check-union [x float 57.0])
     (check-union [x double 77.0])
     (check-union [x i8 18] [y int 0])
     (check-union [x short 28] [y int 0])
     (check-union [x long 38] [y int 0])
     (check-union [x int 48] [y int 0])
     (check-union [x i64 43] [y int 0])
     (check-union [x float 58.0] [y int 0])
     (check-union [x double 68.0] [y int 0]))

(mat collect-safe
     (error? (foreign-procedure __collect_safe "unknown" (utf-8) void))
     (error? (foreign-procedure __collect_safe "unknown" (utf-16be) void))
     (error? (foreign-procedure __collect_safe "unknown" (utf-16le) void))
     (error? (foreign-procedure __collect_safe "unknown" (utf-32be) void))
     (error? (foreign-procedure __collect_safe "unknown" (utf-32le) void))
     (error? (foreign-procedure __collect_safe "unknown" (string) void))
     (error? (foreign-procedure __collect_safe "unknown" (wstring) void))
     (error? (foreign-callable __collect_safe (lambda () #f) () utf-8))
     (error? (foreign-callable __collect_safe (lambda () #f) () utf-16le))
     (error? (foreign-callable __collect_safe (lambda () #f) () utf-16be))
     (error? (foreign-callable __collect_safe (lambda () #f) () utf-32le))
     (error? (foreign-callable __collect_safe (lambda () #f) () utf-32be))
     (error? (foreign-callable __collect_safe (lambda () #f) () string))
     (error? (foreign-callable __collect_safe (lambda () #f) () wstring))
     (begin
       (define-ftype thread-callback-T
         (function __collect_safe (double) double))
       (define (call-with-thread-callback cb-proc proc)
         (let ([callback (make-ftype-pointer thread-callback-T cb-proc)])
           (let ([r (proc callback)])
             (unlock-object
               (foreign-callable-code-object
                 (ftype-pointer-address callback)))
             r)))
       (define (call-in-unknown-thread-1 proc arg n-times)
         ;; Baseline implementation that uses the current thread
         (let loop ([i 0] [arg arg])
           (cond
             [(= i n-times) arg]
             [else (loop (fx+ i 1) (proc arg))])))
       (define call-in-unknown-thread-2
         ;; Call in the current thread, but through the foreign procedure
         (if (and (threaded?) (foreign-entry? "call_in_unknown_thread"))
             (let ([call (foreign-procedure "call_in_unknown_thread"
                           ((* thread-callback-T) double int boolean boolean)
                           double)])
               (lambda (proc arg n-times)
                 (call-with-thread-callback proc
                   (lambda (callback)
                     (call callback arg n-times #f #t)))))
             call-in-unknown-thread-1))
       (define call-in-unknown-thread-3
         ;; Call in a truly unknown thread:
         (if (and (threaded?) (foreign-entry? "call_in_unknown_thread"))
             (let ([call (foreign-procedure "call_in_unknown_thread"
                           ((* thread-callback-T) double int boolean boolean)
                           double)])
               (lambda (proc arg n-times)
                 (call-with-thread-callback proc
                   (lambda (callback)
                     (call callback arg n-times #t #t)))))
             call-in-unknown-thread-1))
       (define call-in-unknown-thread-4
         ;; In an truly unknown thread, but also using `__collect_safe` to
         ;; deactivate the current thread instead of using `Sdeactivate_thread`
         ;; within the foreign function:
         (if (and (threaded?) (foreign-entry? "call_in_unknown_thread"))
             (let ([call (foreign-procedure
                           __collect_safe
                           "call_in_unknown_thread"
                           ((* thread-callback-T) double int boolean boolean)
                           double)])
               (lambda (proc arg n-times)
                 (call-with-thread-callback proc
                   (lambda (callback)
                     (call callback arg n-times #t #f)))))
             call-in-unknown-thread-1))
       #t)
     ;; These tests will pass only if `collect` can run, where `collect`
     ;; can run only if a single thread is active
     (equal? (call-in-unknown-thread-1 (lambda (n) (collect 0) (+ n 1.0)) 3.5 1)
             4.5)
     (equal? (call-in-unknown-thread-2 (lambda (n) (collect 0) (+ n 1.0)) 3.5 2)
             5.5)
     (equal? (call-in-unknown-thread-3 (lambda (n) (collect 0) (+ n 1.0)) 3.5 3)
             6.5)
     (equal? (call-in-unknown-thread-4 (lambda (n) (collect 0) (+ n 1.0)) 3.5 4)
             7.5)
     (equal? (let loop ([n 10.0])
               (call-in-unknown-thread-4
                 (lambda (n)
                   (cond
                     [(zero? n) (collect) 0.5]
                     [else (+ 1.0 (loop (- n 1.0)))]))
                 n
                 1))
             10.5)
     ;; Try to crash a `__collect_safe` foreign-procedure call by moving the
     ;; return address out from under the foreign procedure. This attempt
     ;; should fail, because deactivating a thread first locks the
     ;; current code object.
     (or (not (threaded?))
         (let ([m (make-mutex)] [done? #f] [ok? #t])
           (fork-thread
             (lambda ()
               (let loop ([i 10])
                 (unless (zero? i)
                         (let ([spin (eval '(foreign-procedure
                                              __collect_safe
                                              "spin_a_while"
                                              (int unsigned unsigned)
                                              unsigned))])
                           (spin 1000000 0 1))
                         (loop (sub1 i))))
               (mutex-acquire m)
               (set! done? #t)
               (mutex-release m)))
           (let loop ()
             (mutex-acquire m)
             (let ([done? done?])
               (mutex-release m)
               (unless done?
                       (let loop ([i 10])
                         (unless (zero? i)
                                 (eval '(foreign-procedure "spin_a_while" () void))
                                 (loop (sub1 i))))
                       (loop))))
           ok?)))

(machine-case
  [(i3nt ti3nt)
   (mat i3nt-stdcall-collect-safe
        (equal? (let ()
                  (define sum
                    (foreign-procedure
                      __collect_safe
                      __stdcall
                      "_sum_stdcall@8"
                      (int int)
                      int))
                  (sum 3 7))
                10)
        (equal? (let ()
                  (define Sinvoke2
                    (foreign-procedure
                      __collect_safe
                      "Sinvoke2_stdcall"
                      (scheme-object scheme-object iptr)
                      scheme-object))
                  (define Fcons
                    (foreign-callable
                      __collect_safe
                      __stdcall
                      (lambda (x y) (cons x y))
                      (scheme-object iptr)
                      scheme-object))
                  (Sinvoke2 Fcons 41 51))
                '(41 . 51)))
   (mat i3nt-com-thread
        (eqv? (let ()
                (define com-instance
                  ((foreign-procedure "get_com_instance" () iptr)))
                ((foreign-procedure __collect_safe __com 0 (iptr int) int) com-instance 3)
                ((foreign-procedure __collect_safe __com 4 (iptr int) int) com-instance 17))
              37))])
;;; unix.ms
;;; Copyright 1984-2017 Cisco Systems, Inc.
;;; 
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;; 
;;; http://www.apache.org/licenses/LICENSE-2.0
;;; 
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

(if (or (windows?) (equal? (getenv "USER") "root") (embedded?))
    (mat unix-file-io
         (error? (errorf 'open-output-file "failed for testfile.ss: file exists"))
         (error? (errorf 'open-output-file "failed for testfile.ss: file exists"))
         (error? (errorf 'open-output-file "failed for testfile.ss: permission denied"))
         (error? (errorf 'open-output-file "failed for testfile.ss: permission denied"))
         (error? (errorf 'open-output-file "failed for testfile.ss: file exists"))
         (error? (errorf 'open-output-file "failed for testfile.ss: file exists"))
         (error? (errorf 'open-output-file "failed for testfile.ss: permission denied"))
         (error? (errorf 'open-output-file "failed for testfile.ss: permission denied"))
         (error? (errorf 'open-input-file "failed for testfile.ss: permission denied"))
         (error? (errorf 'open-input-output-file "failed for testfile.ss: permission denied"))
         (error? (errorf 'with-output-to-file "failed for testfile.ss: permission denied"))
         (error? (errorf 'with-input-from-file "failed for testfile.ss: permission denied"))
         (error? (errorf 'call-with-input-file "failed for testfile.ss: permission denied")))
    (mat unix-file-io
         (let ([p (open-output-file "/dev/null" 'truncate)])
           (close-output-port p)
           #t)
         (let ([p (open-output-file "testfile.ss" 'truncate)])
           (close-output-port p)
           (system "chmod -w testfile.ss")
           #t)
         (error? (open-output-file "testfile.ss"))
         (error? (open-output-file "testfile.ss" 'error))
         (error? (open-output-file "testfile.ss" 'truncate))
         (error? (open-output-file "testfile.ss" 'append))
         (let ([p (open-output-file "testfile.ss" 'replace)])
           (close-output-port p)
           #t)
         (delete-file "testfile.ss" #f)
         (eqv? (with-output-to-file "testfile.ss"
                 (lambda () (display "hello\n"))
                 '(mode #o000))
               (void))
         (error? (open-output-file "testfile.ss"))
         (error? (open-output-file "testfile.ss" 'error))
         (error? (open-output-file "testfile.ss" 'truncate))
         (error? (open-output-file "testfile.ss" 'append))
         (error? (open-input-file "testfile.ss"))
         (error? (open-input-output-file "testfile.ss"))
         (error? (with-output-to-file "testfile.ss" void '(truncate)))
         (error? (with-input-from-file "testfile.ss" void))
         (error? (call-with-input-file "testfile.ss" values))
         (delete-file "testfile.ss" #f)))

(mat system (error? ; not a string
                    (system 5)))

(unless (windows?)
        (mat system
             (eqv? (with-output-to-file "testfile.ss" void '(replace))
                   (void))
             (begin
               (system (format "~:[~;/pkg~]/bin/rm testfile.ss"
                               (embedded?)))
               (system (format "~:[~;/pkg~]/bin/echo hello > testfile.ss"
                               (embedded?)))
               (let ([p (open-input-file "testfile.ss")])
                 (and (eq? (read p) 'hello)
                      (begin (close-input-port p) #t))))))

(unless (windows?)
        (mat process-port
             (let ()
               (define make-process-port
                 (let ()
                   (define kill
                     (lambda (pid sig)
                       (if (= sig 0)
                           -1
                           (system (format "kill -~s ~s" sig pid)))))
                   (define make-handler
                     (lambda (name ip op pid)
                       (lambda (msg . args)
                         (record-case (cons msg args)
                           [block-read (p s n) (block-read ip s n)]
                           [block-write (p s n) (block-write op s n)]
                           [char-ready? (p) (char-ready? ip)]
                           [clear-input-port (p) (clear-input-port ip)]
                           [clear-output-port (p) (clear-output-port op)]
                           [close-port (p)
                             (close-port ip)
                             (close-port op)
                             (mark-port-closed! p)]
                           [file-position (p . pos)
                             (if (null? pos)
                                 (most-negative-fixnum)
                                 (errorf 'process-port "cannot reposition"))]
                           [flush-output-port (p) (flush-output-port op)]
                           [kill (p signal) (kill pid signal)]
                           [peek-char (p) (peek-char ip)]
                           [port-name (p) name]
                           [read-char (p) (read-char ip)]
                           [unread-char (c p) (unread-char c ip)]
                           [write-char (c p) (write-char c op)]
                           [else
                            (errorf 'process-port
                                    "operation ~s not handled"
                                    msg)]))))
                   (lambda (command)
                     (let ([handler (apply make-handler
                                      (format "process ~s" command)
                                      (process command))])
                       (make-input/output-port handler "" "")))))
               (define port-kill
                 (lambda (p s) ((port-handler p) 'kill p s)))
               (and (let ()
                      (define p
                        (make-process-port (format "exec ~a" $cat_flush)))
                      (and (not (char-ready? p))
                           (begin
                             (fprintf p "hello!~%")
                             (eq? (read p) 'hello!))
                           (char-ready? p)
                           (char=? (read-char p) #\newline)
                           (not (char-ready? p))
                           (begin (close-port p) #t)
                           ; sleep 1 may not be enough on a loaded system...
                           (begin
                             (system "sleep 5")
                             (= (port-kill p 0) -1))))
                    (let ()
                      (define p
                        (make-process-port (format "exec ~a" $cat_flush)))
                      (and (not (char-ready? p))
                           (begin
                             (fprintf p "hello!~%")
                             (eq? (read p) 'hello!))
                           (char-ready? p)
                           (char=? (read-char p) #\newline)
                           (not (char-ready? p))
                           (= (port-kill p 15) 0)
                           (let f ()
                             (if (char-ready? p)
                                 (eof-object? (read-char p))
                                 (f)))
                           ; sleep 1 may not be enough on a loaded system...
                           (begin
                             (system "sleep 1")
                             (eqv? (port-kill p 0) -1))))))))

(if (windows?)
    (mat register-signal-handler
         (error? (errorf 'register-signal-handler "#<procedure list> is not a fixnum"))
         (error? (errorf 'register-signal-handler "14 is not a procedure"))
         (error? (errorf 'register-signal-handler "#<procedure list> is not a fixnum")))
    (mat register-signal-handler
         (error? (register-signal-handler list 14))
         (error? (register-signal-handler 14 14))
         (error? (register-signal-handler list list))
         (let ((x #f))
           (register-signal-handler 14 (lambda (sig) (set! x sig)))
           ; guard the call to system, since openbsd gets an EINTR error,
           ; probably in system's call to waitpid, causing s_system to
           ; raise an exception
           (guard (c [#t (display-condition c)
                         (printf "\nexception ignored\n")])
                  (system "exec kill -14 $PPID"))
           (let f ((n 1000000))
             (or (eqv? x 14)
                 (and (not (= n 0)) (f (- n 1))))))))

(if (or (windows?) (equal? (getenv "USER") "root") (embedded?))
    (mat file-operations
         (error? (errorf 'delete-directory
                         "failed for ~a: ~a"
                         "testlink1"
                         "not a directory"))
         (error? (errorf 'delete-directory
                         "failed for ~a: ~a"
                         "testlink2"
                         "not a directory"))
         (error? (errorf 'delete-directory
                         "failed for ~a: ~a"
                         "testdir/testfile.ss"
                         "not a directory"))
         (error? (errorf 'delete-file
                         "failed for ~a: ~a"
                         "testdir/w"
                         "permission denied"))
         (error? (errorf 'get-mode
                         "failed for ~s: ~(~a~)"
                         "testlink"
                         "no such file or directory"))
         (error? (errorf 'file-access-time
                         "failed for ~s: ~(~a~)"
                         "testlink"
                         "no such file or directory"))
         (error? (errorf 'file-change-time
                         "failed for ~s: ~(~a~)"
                         "testlink"
                         "no such file or directory"))
         (error? (errorf 'file-modification-time
                         "failed for ~s: ~(~a~)"
                         "testlink"
                         "no such file or directory"))
         (error? (errorf 'get-mode
                         "failed for ~s: ~(~a~)"
                         "testlink"
                         "no such file or directory"))
         (error? (errorf 'file-access-time
                         "failed for ~s: ~(~a~)"
                         "testlink"
                         "no such file or directory"))
         (error? (errorf 'file-change-time
                         "failed for ~s: ~(~a~)"
                         "testlink"
                         "no such file or directory"))
         (error? (errorf 'file-modification-time
                         "failed for ~s: ~(~a~)"
                         "testlink"
                         "no such file or directory")))
    (mat file-operations
         (boolean? (delete-file "testlink1" #f))
         (boolean? (delete-file "testlink2" #f))
         (not (file-exists? "testdir"))
         (begin
           (system "ln -s testdir testlink1")
           (and (not (file-exists? "testlink1"))
                (not (file-exists? "testlink1" #t))
                (file-exists? "testlink1" #f))
           (and (not (file-regular? "testlink1"))
                (not (file-regular? "testlink1" #t))
                (not (file-regular? "testlink1" #f)))
           (and (not (file-directory? "testlink1"))
                (not (file-directory? "testlink1" #t))
                (not (file-directory? "testlink1" #f)))
           (file-symbolic-link? "testlink1"))
         (begin
           (system "ln -s testdir/testfile.ss testlink2")
           (and (not (file-exists? "testlink2"))
                (not (file-exists? "testlink2" #t))
                (file-exists? "testlink2" #f))
           (and (not (file-regular? "testlink2"))
                (not (file-regular? "testlink2" #t))
                (not (file-regular? "testlink2" #f)))
           (and (not (file-directory? "testlink2"))
                (not (file-directory? "testlink2" #t))
                (not (file-directory? "testlink2" #f)))
           (file-symbolic-link? "testlink2"))
         (begin
           (mkdir "testdir")
           (and (file-exists? "testlink1")
                (file-exists? "testlink1" #t)
                (file-exists? "testlink1" #f))
           (and (not (file-regular? "testlink1"))
                (not (file-regular? "testlink1" #t))
                (not (file-regular? "testlink1" #f)))
           (and (file-directory? "testlink1")
                (file-directory? "testlink1" #t)
                (not (file-directory? "testlink1" #f)))
           (file-symbolic-link? "testlink1"))
         (begin
           (and (not (file-exists? "testlink2"))
                (not (file-exists? "testlink2" #t))
                (file-exists? "testlink2" #f))
           (and (not (file-regular? "testlink2"))
                (not (file-regular? "testlink2" #t))
                (not (file-regular? "testlink2" #f)))
           (and (not (file-directory? "testlink2"))
                (not (file-directory? "testlink2" #t))
                (not (file-directory? "testlink2" #f)))
           (file-symbolic-link? "testlink2"))
         (begin
           (with-output-to-file "testdir/testfile.ss" values 'replace)
           (and (file-exists? "testlink2")
                (file-exists? "testlink2" #t)
                (file-exists? "testlink2" #f))
           (and (file-regular? "testlink2")
                (file-regular? "testlink2" #t)
                (not (file-regular? "testlink2" #f)))
           (and (not (file-directory? "testlink2"))
                (not (file-directory? "testlink2" #t))
                (not (file-directory? "testlink2" #f)))
           (file-symbolic-link? "testlink2"))
         (delete-file "testlink1" #f)
         (delete-file "testlink2" #f)
         (begin
           (system "ln -s testdir testlink1")
           (and (file-exists? "testlink1")
                (file-exists? "testlink1" #t)
                (file-exists? "testlink1" #f))
           (and (not (file-regular? "testlink1"))
                (not (file-regular? "testlink1" #t))
                (not (file-regular? "testlink1" #f)))
           (and (file-directory? "testlink1")
                (file-directory? "testlink1" #t)
                (not (file-directory? "testlink1" #f)))
           (file-symbolic-link? "testlink1"))
         (begin
           (system "ln -s testdir/testfile.ss testlink2")
           (and (file-exists? "testlink2")
                (file-exists? "testlink2" #t)
                (file-exists? "testlink2" #f))
           (and (file-regular? "testlink2")
                (file-regular? "testlink2" #t)
                (not (file-regular? "testlink2" #f)))
           (and (not (file-directory? "testlink2"))
                (not (file-directory? "testlink2" #t))
                (not (file-directory? "testlink2" #f)))
           (file-symbolic-link? "testlink2"))
         (error? (delete-directory "testlink1" #t))
         (error? (delete-directory "testlink2" #t))
         (delete-file "testlink1" #f)
         (delete-file "testlink2" #f)
         (guard (c [(and (i/o-filename-error? c)
                         (equal? (i/o-error-filename c) "testdir"))])
                (delete-directory "testdir" #t))
         (error? (delete-directory "testdir/testfile.ss" #t))
         (delete-file "testdir/testfile.ss" #f)
         (guard (c [(and (i/o-filename-error? c)
                         (equal? (i/o-error-filename c) "testdir"))])
                (delete-file "testdir" #t))
         (eqv? (delete-directory "testdir" #t) (void))
         (begin (mkdir "testdir" #o700) #t)
         (begin
           (with-output-to-file "testdir/r" values)
           (with-output-to-file "testdir/w" values)
           (with-output-to-file "testdir/x" values)
           (with-output-to-file "testdir/rx" values)
           (with-output-to-file "testdir/rw" values)
           (chmod "testdir/r" #o400)
           (chmod "testdir/w" #o200)
           (chmod "testdir/x" #o100)
           (chmod "testdir/rx" #o500)
           (chmod "testdir/rw" #o600)
           #t)
         (eqv? (chmod "testdir" #o500) (void))
         (error? (delete-file "testdir/w" #t))
         (eqv? (chmod "testdir" #o700) (void))
         (guard (c [(and (i/o-filename-error? c)
                         (equal? (i/o-error-filename c) "testdir"))])
                (delete-directory "testdir" #t))
         (eqv? (delete-file "testdir/w" #t) (void))
         (eqv? (delete-file "testdir/rw" #t) (void))
         (delete-file "testdir/r" #f)
         (delete-file "testdir/x" #f)
         (delete-file "testdir/rx")
         (delete-directory "testdir" #f)
         (begin
           (system "echo one > testfile.ss")
           (system "ln -s testfile.ss testlink")
           #t)
         (time=? (file-access-time "testlink")
                 (file-access-time "testfile.ss"))
         (time=? (file-change-time "testlink")
                 (file-change-time "testfile.ss"))
         (time=? (file-modification-time "testlink")
                 (file-modification-time "testfile.ss"))
         ; no guarantee what times are returned for symbolic links.
         ; just make sure they return time objects
         (andmap time?
           (map (lambda (p) (p "testlink" #f))
                (list file-access-time
                      file-change-time
                      file-modification-time)))
         (= (get-mode "testlink") (get-mode "testfile.ss"))
         (begin
           (define $taccess
             (file-access-time "testfile.ss"))
           (define $tmodification
             (file-modification-time "testfile.ss"))
           (define $tchange
             (file-change-time "testfile.ss"))
           #t)
         (eq? (sleep (make-time 'time-duration 0 2)) (void))
         (symbol? (with-input-from-file "testfile.ss" read))
         ; following should be time<?, but access times are not updated on some
         ; file systems, particulary nfs file systems.  but we wouldn't expect
         ; time to run backwards (except for one hour for DST)
         (time<=? $taccess (file-access-time "testfile.ss"))
         (begin (system "echo two > testfile.ss") #t)
         ; for whatever reason, there seems to be no guarantee about this either ...
         (time<=? $tmodification (file-modification-time "testfile.ss"))
         (or (begin
               (chmod "testfile.ss" #o770)
               (not (= (get-mode "testlink" #f) (get-mode "testfile.ss"))))
             (begin
               (chmod "testfile.ss" #o777)
               (not (= (get-mode "testlink" #f) (get-mode "testfile.ss")))))
         ; ... or this
         (time>=? (file-change-time "testfile.ss") $tchange)
         (delete-file "testfile.ss" #f)
         (andmap time?
           (map (lambda (p) (p "testlink" #f))
                (list file-access-time
                      file-change-time
                      file-modification-time)))
         (error? (get-mode "testlink"))
         (error? (file-access-time "testlink"))
         (error? (file-change-time "testlink"))
         (error? (file-modification-time "testlink"))
         (error? (get-mode "testlink" #t))
         (error? (file-access-time "testlink" #t))
         (error? (file-change-time "testlink" #t))
         (error? (file-modification-time "testlink" #t))
         (delete-file "testlink" #f)))

(if (windows?)
    (mat nonblocking
         ; verify no windows nonblocking support for binary file ports
         (let-values ([(to-stdin from-stdout from-stderr pid)
                       (open-process-ports $cat_flush)])
           (dynamic-wind void
             (lambda ()
               (and (not (port-has-port-nonblocking?? to-stdin))
                    (not (port-has-set-port-nonblocking!? to-stdin))
                    (not (port-has-port-nonblocking?? from-stdout))
                    (not (port-has-set-port-nonblocking!? from-stdout))
                    (not (port-has-port-nonblocking?? from-stderr))
                    (not (port-has-set-port-nonblocking!? from-stderr))))
             (lambda ()
               (close-port to-stdin)
               (close-port from-stdout)
               (close-port from-stderr))))
         ; verify no windows nonblocking support for textual file ports
         (let-values ([(to-stdin from-stdout from-stderr pid)
                       (open-process-ports $cat_flush
                         (buffer-mode block)
                         (native-transcoder))])
           (dynamic-wind void
             (lambda ()
               (and (not (port-has-port-nonblocking?? to-stdin))
                    (not (port-has-set-port-nonblocking!? to-stdin))
                    (not (port-has-port-nonblocking?? from-stdout))
                    (not (port-has-set-port-nonblocking!? from-stdout))
                    (not (port-has-port-nonblocking?? from-stderr))
                    (not (port-has-set-port-nonblocking!? from-stderr))))
             (lambda ()
               (close-port to-stdin)
               (close-port from-stdout)
               (close-port from-stderr)))))
    (mat nonblocking
         ; see also io.ms (mat open-process-ports ...)
         ; test get-bytevector-some on nonblocking binary input port
         (let-values ([(to-stdin from-stdout from-stderr pid)
                       (open-process-ports $cat_flush)])
           (define put-string
             (lambda (bp s)
               (put-bytevector bp (string->utf8 s))))
           (define get-string-some
             (lambda (bp)
               (let ([x (get-bytevector-some bp)])
                 (if (eof-object? x) x (utf8->string x)))))
           (define get-string-n
             (lambda (bp n)
               (let ([x (get-bytevector-n bp n)])
                 (if (eof-object? x) x (utf8->string x)))))
           (dynamic-wind void
             (lambda ()
               (put-string to-stdin "life in the fast lane\n")
               (flush-output-port to-stdin)
               (let f ()
                 (when (input-port-ready? from-stderr)
                       (errorf #f "input ready on from-stderr ~s"
                               (get-string-some from-stderr)))
                 (if (input-port-ready? from-stdout)
                     (let ([s (get-string-n from-stdout 10)])
                       (unless (equal? s "life in th")
                               (errorf #f "unexpected from-stdout string ~s" s)))
                     (begin
                       (display ".")
                       (flush-output-port)
                       (f))))
               (set-port-nonblocking! from-stdout #t)
               (let f ([all ""])
                 (let ([s (get-string-some from-stdout)])
                   (when (eof-object? s)
                         (errorf #f "unexpected from-stdout eof"))
                   (if (equal? s "")
                       (unless (equal? all "e fast lane\n")
                               (display ".")
                               (flush-output-port)
                               (f all))
                       (f (string-append all s)))))
               (and (equal? (get-string-some from-stdout) "")
                    (not (input-port-ready? from-stdout))
                    (equal? (get-string-some from-stdout) "")
                    (begin
                      (close-port to-stdin)
                      (let f ()
                        (unless (and (port-eof? from-stdout)
                                     (port-eof? from-stderr))
                                (display ".")
                                (flush-output-port)
                                (f)))
                      #t)))
             (lambda ()
               (close-port to-stdin)
               (close-port from-stdout)
               (close-port from-stderr))))
         ; test get-string-some on nonblocking textual input port
         (let-values ([(to-stdin from-stdout from-stderr pid)
                       (open-process-ports $cat_flush
                         (buffer-mode block)
                         (native-transcoder))])
           (dynamic-wind void
             (lambda ()
               (put-string to-stdin "life in the fast lane\n")
               (flush-output-port to-stdin)
               (let f ()
                 (when (input-port-ready? from-stderr)
                       (errorf #f "input ready on from-stderr ~s"
                               (get-string-some from-stderr)))
                 (if (input-port-ready? from-stdout)
                     (let ([s (get-string-n from-stdout 10)])
                       (unless (equal? s "life in th")
                               (errorf #f "unexpected from-stdout string ~s" s)))
                     (begin
                       (display ".")
                       (flush-output-port)
                       (f))))
               (set-port-nonblocking! from-stdout #t)
               (let f ([all ""])
                 (let ([s (get-string-some from-stdout)])
                   (when (eof-object? s)
                         (errorf #f "unexpected from-stdout eof"))
                   (if (equal? s "")
                       (unless (equal? all "e fast lane\n")
                               (display ".")
                               (flush-output-port)
                               (f all))
                       (f (string-append all s)))))
               (and (equal? (get-string-some from-stdout) "")
                    (not (input-port-ready? from-stdout))
                    (equal? (get-string-some from-stdout) "")
                    (begin
                      (close-port to-stdin)
                      (let f ()
                        (unless (and (port-eof? from-stdout)
                                     (port-eof? from-stderr))
                                (display ".")
                                (flush-output-port)
                                (f)))
                      #t)))
             (lambda ()
               (close-port to-stdin)
               (close-port from-stdout)
               (close-port from-stderr))))
         ; test get-bytevector-some! on nonblocking binary input port
         (let-values ([(to-stdin from-stdout from-stderr pid)
                       (open-process-ports $cat_flush)])
           (define get-bytevector-some
             (lambda (bp)
               (let ([buf (make-bytevector 5)])
                 (let ([n (get-bytevector-some!
                            bp
                            buf
                            0
                            (bytevector-length buf))])
                   (if (eof-object? n)
                       n
                       (bytevector-truncate! buf n))))))
           (define put-string
             (lambda (bp s)
               (put-bytevector bp (string->utf8 s))))
           (define get-string-some
             (lambda (bp)
               (let ([x (get-bytevector-some bp)])
                 (if (eof-object? x) x (utf8->string x)))))
           (define get-string-n
             (lambda (bp n)
               (let ([x (get-bytevector-n bp n)])
                 (if (eof-object? x) x (utf8->string x)))))
           (dynamic-wind void
             (lambda ()
               (set-port-nonblocking! to-stdin #t)
               ; not testing whether this does anything
               (set-port-nonblocking! from-stdout #t)
               (set-port-nonblocking! from-stderr #t)
               (put-string to-stdin "that don't impress me much\n")
               (flush-output-port to-stdin)
               (let f ([all ""])
                 (unless (equal? all "that don't impress me much\n")
                         (let ([s (get-string-some from-stderr)])
                           (when (eof-object? s)
                                 (errorf #f "unexpected from-stderr eof"))
                           (unless (equal? s "")
                                   (errorf #f "unexpected from-stderr input ~s" s)))
                         (let ([s (get-string-some from-stdout)])
                           (when (eof-object? s)
                                 (errorf #f "unexpected from-stdout eof"))
                           (if (equal? s "")
                               (begin
                                 (display ".")
                                 (flush-output-port)
                                 (f all))
                               (f (string-append all s))))))
               (and (equal? (get-string-some from-stdout) "")
                    (not (input-port-ready? from-stdout))
                    (equal? (get-string-some from-stdout) "")
                    (begin
                      (close-port to-stdin)
                      (let f ()
                        (unless (and (port-eof? from-stdout)
                                     (port-eof? from-stderr))
                                (display ".")
                                (flush-output-port)
                                (f)))
                      #t)))
             (lambda ()
               (close-port to-stdin)
               (close-port from-stdout)
               (close-port from-stderr))))
         ; test get-string-some! on nonblocking textual input port
         (let-values ([(to-stdin from-stdout from-stderr pid)
                       (open-process-ports $cat_flush
                         (buffer-mode block)
                         (native-transcoder))])
           (define get-string-some
             (lambda (tp)
               (let ([buf (make-string 5)])
                 (let ([n (get-string-some! tp buf 0 (string-length buf))])
                   (if (eof-object? n)
                       n
                       (substring buf 0 n))))))
           (dynamic-wind void
             (lambda ()
               (set-port-nonblocking! to-stdin #t)
               ; not testing whether this does anything
               (set-port-nonblocking! from-stdout #t)
               (set-port-nonblocking! from-stderr #t)
               (put-string to-stdin "that don't impress me much\n")
               (flush-output-port to-stdin)
               (let f ([all ""])
                 (unless (equal? all "that don't impress me much\n")
                         (let ([s (get-string-some from-stderr)])
                           (when (eof-object? s)
                                 (errorf #f "unexpected from-stderr eof"))
                           (unless (equal? s "")
                                   (errorf #f "unexpected from-stderr input ~s" s)))
                         (let ([s (get-string-some from-stdout)])
                           (when (eof-object? s)
                                 (errorf #f "unexpected from-stdout eof"))
                           (if (equal? s "")
                               (begin
                                 (display ".")
                                 (flush-output-port)
                                 (f all))
                               (f (string-append all s))))))
               (and (equal? (get-string-some from-stdout) "")
                    (not (input-port-ready? from-stdout))
                    (equal? (get-string-some from-stdout) "")
                    (begin
                      (close-port to-stdin)
                      (let f ()
                        (unless (and (port-eof? from-stdout)
                                     (port-eof? from-stderr))
                                (display ".")
                                (flush-output-port)
                                (f)))
                      #t)))
             (lambda ()
               (close-port to-stdin)
               (close-port from-stdout)
               (close-port from-stderr))))
         ; test put-bytevector-some on nonblocking binary output port,
         ; counting on O/S to limit amount we can write to a pipe that
         ; no one has yet read from
         (let-values ([(to-stdin from-stdout from-stderr pid)
                       (open-process-ports $cat_flush (buffer-mode none))])
           (define put-string-some
             (lambda (bp s)
               (put-bytevector-some bp
                 (string->utf8 s)
                 0
                 (string-length s))))
           (define get-string-some
             (lambda (bp)
               (let ([x (get-bytevector-some bp)])
                 (if (eof-object? x) x (utf8->string x)))))
           (dynamic-wind void
             (lambda ()
               (define s
                 "my future lies beyond the yellow brick road")
               (set-port-nonblocking! to-stdin #t)
               (set-port-nonblocking! from-stdout #t)
               (set-port-nonblocking! from-stderr #t)
               (let ([len (string-length s)])
                 (let f ([n 0])
                   (let ([i (put-string-some to-stdin s)])
                     (if (= i len)
                         (f (+ n 1))
                         (let f ()
                           (if (string=? (get-string-some from-stdout) "")
                               (or (= (put-string-some to-stdin "\n") 1)
                                   (begin
                                     (display ".")
                                     (flush-output-port)
                                     (f)))
                               (f))))))))
             (lambda ()
               (close-port to-stdin)
               (close-port from-stdout)
               (close-port from-stderr))))
         ; test put-string-some on nonblocking textual output port,
         ; counting on O/S to limit amount we can write to a pipe that
         ; no one has yet read from
         (let-values ([(to-stdin from-stdout from-stderr pid)
                       (open-process-ports $cat_flush
                         (buffer-mode none)
                         (native-transcoder))])
           (dynamic-wind void
             (lambda ()
               (define s
                 "my future lies beyond the yellow brick road")
               (set-port-nonblocking! to-stdin #t)
               (set-port-nonblocking! from-stdout #t)
               (set-port-nonblocking! from-stderr #t)
               (let ([len (string-length s)])
                 (let f ([n 0])
                   (let ([i (put-string-some to-stdin s)])
                     (if (= i len)
                         (f (+ n 1))
                         (let f ()
                           (if (string=? (get-string-some from-stdout) "")
                               (or (= (put-string-some to-stdin "\n") 1)
                                   (begin
                                     (display ".")
                                     (flush-output-port)
                                     (f)))
                               (f))))))))
             (lambda ()
               (close-port to-stdin)
               (close-port from-stdout)
               (close-port from-stderr))))))
;;; windows.ms
;;; Copyright 1984-2017 Cisco Systems, Inc.
;;; 
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;; 
;;; http://www.apache.org/licenses/LICENSE-2.0
;;; 
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

(if (windows?)
    (begin
      (mat registry
           (error? (get-registry))
           (error? (get-registry 1 2))
           (error? (put-registry! "hi"))
           (error? (put-registry! 1))
           (error? (put-registry! 1 2 3))
           (error? (remove-registry!))
           (error? (remove-registry! 1 2))
           (error? (get-registry 'pooh))
           (error? (put-registry! "hi" 3))
           (error? (put-registry! 3 "hi"))
           (error? (remove-registry! '(a b c)))
           (error? (get-registry "bogus, is it not?"))

           (not (get-registry "hkey_current_user\\CSmat\\FratRat"))
           (eq? (put-registry!
                  "hkey_current_user\\CSmat\\FratRat"
                  "7233259")
                (void))
           (equal? (get-registry "hkey_current_user\\CSmat\\FratRat")
                   "7233259")
           (equal? (get-registry "HkEy_CuRrEnT_UsER\\CSmat\\FratRat")
                   "7233259")
           (eq? (remove-registry! "hkey_current_user\\CSmat\\FratRat")
                (void))
           (error? (remove-registry! "hkey_current_user\\CSmat\\FratRat"))
           (not (get-registry "hkey_current_user\\CSmat\\FratRat"))

           (eq? (put-registry!
                  "hkey_current_user\\CSmat\\North\\South"
                  "east")
                (void))
           (equal? (get-registry "hkey_current_user\\CSmat\\North\\South")
                   "east")
           (eq? (remove-registry! "hkey_current_user\\CSmat\\North")
                (void))
           (not (get-registry "hkey_current_user\\CSmat\\North\\South"))

           (eq? (put-registry!
                  "hkey_current_user\\CSmat\\Apple\\Orange\\Banana"
                  "kumquat")
                (void))
           (equal? (get-registry
                     "hkey_current_user\\CSmat\\Apple\\Orange\\Banana")
                   "kumquat")
           (error? (remove-registry! "hkey_current_user\\CSmat\\Apple"))
           (equal? (get-registry
                     "hkey_current_user\\CSmat\\Apple\\Orange\\Banana")
                   "kumquat")
           (eq? (remove-registry!
                  "hkey_current_user\\CSmat\\Apple\\Orange\\Banana")
                (void))
           (not (get-registry
                  "hkey_current_user\\CSmat\\Apple\\Orange\\Banana"))
           (error? (remove-registry! "hkey_current_user\\CSmat\\Apple"))
           (eq? (remove-registry!
                  "hkey_current_user\\CSmat\\Apple\\Orange")
                (void))
           (eq? (remove-registry! "hkey_current_user\\CSmat\\Apple")
                (void))
           (not (get-registry
                  "hkey_current_user\\CSmat\\Apple\\Orange\\Banana"))))
    (begin
      ; provide expected errors
      (set! bad-arg-count
        (lambda (who . args)
          (if (#%$suppress-primitive-inlining)
              (errorf #f
                      "incorrect number of arguments to #<procedure ~a>"
                      who)
              (errorf #f "incorrect argument count in call ~s"
                      (cons who args)))))
      (mat registry
           (error? (bad-arg-count 'get-registry))
           (error? (bad-arg-count 'get-registry 1 2))
           (error? (bad-arg-count 'put-registry! "hi"))
           (error? (bad-arg-count 'put-registry! 1))
           (error? (bad-arg-count 'put-registry! 1 2 3))
           (error? (bad-arg-count 'remove-registry!))
           (error? (bad-arg-count 'remove-registry! 1 2))
           (error? (errorf 'get-registry "pooh is not a string"))
           (error? (errorf 'put-registry! "3 is not a string"))
           (error? (errorf 'put-registry! "3 is not a string"))
           (error? (errorf 'remove-registry! "(a b c) is not a string"))
           (error? (errorf 'get-registry
                           "invalid registry key \"bogus, is it not?\""))
           (error? (errorf 'remove-registry!
                           "cannot remove hkey_current_user\\CSmat\\FratRat (not found)"))
           (error? (errorf 'remove-registry!
                           "cannot remove hkey_current_user\\CSmat\\Apple (insufficient permission or subkeys exist)"))
           (error? (errorf 'remove-registry!
                           "cannot remove hkey_current_user\\CSmat\\Apple (insufficient permission or subkeys exist)")))))

(when (windows?)
      (mat multibyte
           (guard (c [(equal? (condition-message c) "invalid code page ~s")])
                  (string->multibyte -1 "hello")
                  #t)
           (guard (c [(equal? (condition-message c) "invalid code page ~s")])
                  (string->multibyte 'cp-what? "hello")
                  #t)
           (guard (c [(equal? (condition-message c) "invalid code page ~s")])
                  (multibyte->string -1 #vu8(#x61 #x62))
                  #t)
           (guard (c [(equal? (condition-message c) "invalid code page ~s")])
                  (multibyte->string 'cp-not! #vu8(#x61 #x62))
                  #t)
           (guard (c [(equal? (condition-message c)
                              "~s is not a bytevector")])
                  (multibyte->string 'cp-acp "hello")
                  #t)
           (guard (c [(equal? (condition-message c) "~s is not a string")])
                  (string->multibyte 'cp-acp 'hello)
                  #t)
           (let ()
             (define (f str)
               (let ([bv (string->utf8 str)])
                 (equal? (multibyte->string 'cp-utf8 bv) str)))
             (and (f "hello\n")
                  (f "hel\x0;lo\n")
                  (f "hel\x0;\x3bb;lo\n")))
           (let ()
             (define (g str)
               (let ([bv (string->multibyte 'cp-utf8 str)])
                 (equal? (utf8->string bv) str)))
             (and (g "hello\n")
                  (g "hel\x0;lo\n")
                  (g "hel\x0;\x3bb;lo\n")))
           (let ()
             (define (f str)
               (let ([bv (string->multibyte 'cp-acp str)])
                 (equal? (multibyte->string 'cp-acp bv) str)))
             (and (f "hello\n") (f "hel\x0;lo\n")))
           (let ()
             (define (f str)
               (let ([bv (string->multibyte 'cp-oemcp str)])
                 (equal? (multibyte->string 'cp-oemcp bv) str)))
             (and (f "hello\n") (f "hel\x0;lo\n")))
           (let ()
             (define (f str)
               (let ([bv (string->multibyte 'cp-thread-acp str)])
                 (equal? (multibyte->string 'cp-thread-acp bv) str)))
             (and (f "hello\n") (f "hel\x0;lo\n")))
           (let ()
             (define (f str)
               (let ([bv (string->multibyte 'cp-utf7 str)])
                 (equal? (multibyte->string 'cp-utf7 bv) str)))
             (and (f "hello\n")
                  (f "hel\x0;lo\n")
                  (f "hel\x0;\x3bb;lo\n")))
           (let ()
             (define (f str)
               (let ([bv (string->multibyte 'cp-utf8 str)])
                 (equal? (multibyte->string 'cp-utf8 bv) str)))
             (and (f "hello\n")
                  (f "hel\x0;lo\n")
                  (f "hel\x0;\x3bb;lo\n")))))
;;; examples.ms
;;; Copyright 1984-2017 Cisco Systems, Inc.
;;; 
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;; 
;;; http://www.apache.org/licenses/LICENSE-2.0
;;; 
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

;;; define *examples-directory* in Makefile
(define-syntax examples-mat
  (syntax-rules ()
    [(_ name (file ...) expr ...)
     (begin
       (mat name
            (begin
              (parameterize
                ((source-directories
                   (cons *examples-directory*
                         (source-directories))))
                (load (format "~a/~a.ss" *examples-directory* file))
                ...)
              #t)
            expr
            ...)
       (mat name
            (begin
              (parameterize
                ((source-directories
                   (cons *examples-directory*
                         (source-directories))))
                (load (format "~a/~a.so" *examples-directory* file))
                ...
                #t))
            expr
            ...))]))

(define load-example
  (case-lambda
    [(str) (load (format "~a/~a.ss" *examples-directory* str)) #t]
    [(str eval)
     (load (format "~a/~a.ss" *examples-directory* str) eval)
     #t]))

(define file=?
  (lambda (fn1 fn2)
    (let ([p1 (open-input-file fn1)] [p2 (open-input-file fn2)])
      (let loop ()
        (let ([c1 (read-char p1)] [c2 (read-char p2)])
          (if (eof-object? c1)
              (begin
                (close-port p1)
                (close-port p2)
                (eof-object? c2))
              (and (not (eof-object? c2))
                   (char=? c1 c2)
                   (loop))))))))

(examples-mat def-edit
  ("def" "edit")
  (begin
    (def fact (lambda (x) (if (zero? x) 1 (* x (fact (x 1))))))
    (procedure? fact))
  (equal? (ls-def) '(fact))
  (let ([in (open-input-string "3 3 4 3 2 (ib 1 -) t")]
        [out (open-output-string)])
    (and (eqv? (parameterize
                 ([current-input-port in] [current-output-port out])
                 (ed-def fact))
               'fact)
         (equal? (get-output-string out)
                 "(def fact (lambda (...) (...)))
edit> (lambda (x) (if (...) 1 (...)))
edit> (if (zero? x) 1 (* x (...)))
edit> (* x (fact (...)))
edit> (fact (x 1))
edit> (x 1)
edit> (- x 1)
edit> (def fact (lambda (...) (...)))
edit> 
")))
  (eqv? (fact 30) 265252859812191058636308480000000))

(examples-mat fact
  ("fact")
  (eqv? (fact 30) 265252859812191058636308480000000))

(examples-mat fatfib ("fatfib") (eqv? (fatfib 10) 89))

(examples-mat fib
  ("fib")
  (begin
    (printf "***** expect trace of (fib 4):~%")
    (eqv? (fib 4) 5)))

(examples-mat freq
  ("freq")
  ;; freq.in and freq.out come from example in TSPL
  (begin (delete-file "testfile.freq" #f) #t)
  (begin
    (frequency "freq.in" "testfile.freq")
    (file=? "testfile.freq" "freq.out")))

;-------- freq.in: --------
;Peter Piper picked a peck of pickled peppers;
;A peck of pickled peppers Peter Piper picked.
;If Peter Piper picked a peck of pickled peppers,
;Where's the peck of pickled peppers Peter Piper picked?

;-------- freq.out: --------
;1       A
;1       If
;4       Peter
;4       Piper
;1       Where
;2       a
;4       of
;4       peck
;4       peppers
;4       picked
;4       pickled
;1       s
;1       the

; "interpret" can't handle all Chez core forms
;(mat interpret
;   (and (eq? (getprop 'interpret '*type*) 'primitive)
;        (begin (remprop 'interpret '*type*) #t))
;   (load-example "interpret")
;   (load-example "interpret" interpret)
;   (load-example "fatfib" interpret)
;   (eqv? (fatfib 4) 5)
;   (begin (putprop 'interpret '*type* 'primitive) #t)
; )

(examples-mat m4
  ("m4")
  (begin
    (m4 "testfile.m4" "m4test.in")
    (file=? "m4test.out" "testfile.m4")))

(examples-mat macro
  ("macro")
  (begin (macro xxxxxx (lambda (x) `',x)) #t)
  (equal? (xxxxxx 3) '(xxxxxx 3)))

(examples-mat matrix
  ("matrix")
  ;; examples from TSPL2:
  (equal? (mul 3 4) 12)
  (equal? (mul 1/2 '#(#(1 2 3))) '#(#(1/2 1 3/2)))
  (equal? (mul -2 '#(#(3 -2 -1) #(-3 0 -5) #(7 -1 -1)))
          '#(#(-6 4 2) #(6 0 10) #(-14 2 2)))
  (equal? (mul '#(#(1 2 3)) '#(#(2 3) #(3 4) #(4 5))) '#(#(20 26)))
  (equal? (mul '#(#(2 3 4) #(3 4 5)) '#(#(1) #(2) #(3))) '#(#(20) #(26)))
  (equal? (mul '#(#(1 2 3) #(4 5 6)) '#(#(1 2 3 4) #(2 3 4 5) #(3 4 5 6)))
          '#(#(14 20 26 32) #(32 47 62 77))))

(examples-mat object
  ("object")
  (begin
    (define-object (summit x)
      ([y 3])
      ([getx (lambda () x)]
       [sumxy (lambda () (+ x y))]
       [setx (lambda (v) (set! x v))]))
    (procedure? summit))
  (begin (define a (summit 1)) (procedure? a))
  (eq? (send-message a getx) 1)
  (eq? (send-message a sumxy) 4)
  (begin
    (send-message a setx 13)
    (eq? (send-message a sumxy) 16))
  ;; examples from TSPL:
  (begin
    (define-object (kons kar kdr)
      ([get-car (lambda () kar)]
       [get-cdr (lambda () kdr)]
       [set-car! (lambda (x) (set! kar x))]
       [set-cdr! (lambda (x) (set! kdr x))]))
    (procedure? kons))
  (begin (define p (kons 'a 'b)) (procedure? p))
  (eq? (send-message p get-car) 'a)
  (eq? (send-message p get-cdr) 'b)
  (begin
    (send-message p set-cdr! 'c)
    (eq? (send-message p get-cdr) 'c))
  (begin
    (define-object (kons kar kdr pwd)
      ([get-car (lambda () kar)]
       [get-cdr (lambda () kar)]
       [set-car! (lambda (x p) (when (string=? p pwd) (set! kar x)))]
       [set-cdr! (lambda (x p) (when (string=? p pwd) (set! kar x)))]))
    (procedure? kons))
  (begin
    (define p1 (kons 'a 'b "magnificent"))
    (procedure? p1))
  (begin
    (send-message p1 set-car! 'c "magnificent")
    (eq? (send-message p1 get-car) 'c))
  (begin
    (send-message p1 set-car! 'd "please")
    (eq? (send-message p1 get-car) 'c))
  (begin (define p2 (kons 'x 'y "please")) (procedure? p2))
  (begin
    (send-message p2 set-car! 'z "please")
    (eq? (send-message p2 get-car) 'z))
  (begin
    (define-object (kons kar kdr)
      ([count 0])
      ([get-car (lambda () (set! count (+ count 1)) kar)]
       [get-cdr (lambda () (set! count (+ count 1)) kdr)]
       [accesses (lambda () count)]))
    (procedure? kons))
  (begin (define p (kons 'a 'b)) (procedure? p))
  (eq? (send-message p get-car) 'a)
  (eq? (send-message p get-cdr) 'b)
  (eq? (send-message p accesses) '2)
  (eq? (send-message p get-cdr) 'b)
  (eq? (send-message p accesses) '3))

(examples-mat power ("power") (eqv? (power 1/2 3) 1/8))

(examples-mat rabbit
  ("rabbit")
  (begin
    (printf "***** expect rabbit output:~%")
    (rabbit 3)
    (dispatch)
    #t))

(examples-mat rsa
  ("rsa")
  (begin
    (printf "***** expect rsa output:~%")
    (make-user bonzo)
    (make-user bobo)
    (make-user tiger)
    (show-center)
    #t)
  (equal? (send "hi there" bonzo bobo) "hi there")
  (equal? (send "hi there to you" bobo bonzo) "hi there to you")
  (not (equal? (decrypt (encrypt "hi there" bonzo bobo) tiger) "hi there")))

(define stream->list
  (lambda (s)
    (if (procedure? s)
        '()
        (cons (car s) (stream->list (cdr s))))))

(examples-mat scons
  ("scons")
  (eqv? (stream-ref factlist 3) 6)
  (equal? (stream->list factlist) '(1 1 2 6))
  (eqv? (stream-ref factlist 10) 3628800)
  (equal? (stream->list factlist)
          '(1 1 2 6 24 120 720 5040 40320 362880 3628800))
  (eqv? (stream-ref fiblist 3) 3)
  (equal? (stream->list fiblist) '(1 1 2 3))
  (eqv? (stream-ref fiblist 5) 8)
  (equal? (stream->list fiblist) '(1 1 2 3 5 8)))

(examples-mat setof
  ("setof")
  (equal? (set-of x (x in '(a b c))) '(a b c))
  (equal? (set-of x (x in '(1 2 3 4)) (even? x)) '(2 4))
  (equal? (set-of (cons x y) (x in '(1 2 3)) (y is (* x x)))
          '((1 . 1) (2 . 4) (3 . 9)))
  (equal? (set-of (cons x y) (x in '(a b)) (y in '(1 2)))
          '((a . 1) (a . 2) (b . 1) (b . 2))))

(examples-mat unify
  ("unify")
  ;; examples from TSPL:
  (eq? (unify 'x 'y) 'y)
  (equal? (unify '(f x y) '(g x y)) "clash")
  (equal? (unify '(f x (h)) '(f (h) y)) '(f (h) (h)))
  (equal? (unify '(f (g x) y) '(f y x)) "cycle")
  (equal? (unify '(f (g x) y) '(f y (g x))) '(f (g x) (g x))))

(examples-mat fft
  ("fft")
  (equal? (dft '(0 0 0 0)) '(0 0 0 0))
  (equal? (dft '(2.0 2.0 2.0 2.0)) '(8.0 0.0-0.0i 0.0 0.0+0.0i))
  (equal? (dft '(+2.i +2.i +2.i +2.i))
          '(+0.0+8.0i 0.0+0.0i 0.0+0.0i 0.0+0.0i)))

(examples-mat compat
  ("compat")
  (eqv? (define! defined-with-define! (lambda () defined-with-define!))
        'defined-with-define!)
  (let ((p defined-with-define!))
    (set! defined-with-define! 0)
    (eqv? (p) 0))

  (eqv? (defrec! defined-with-defrec! (lambda () defined-with-defrec!))
        'defined-with-defrec!)
  (let ((p defined-with-defrec!))
    (set! defined-with-defrec! 0)
    (eqv? (p) p))

  (eqv? (begin0 1 2 3 4) 1)

  (equal? (recur f
            ((ls '(a b c)) (new '()))
            (if (null? ls)
                new
                (f (cdr ls) (cons (car ls) new))))
          '(c b a))

  (equal? (tree-copy '()) '())
  (equal? (tree-copy 'a) 'a)
  (equal? (tree-copy '(a)) '(a))
  (equal? (tree-copy '(a (b c) . d)) '(a (b c) . d))
  (let* ((p1 '((a . b) c)) (p2 (car p1)) (p3 (cdr p1)))
    (let ((c1 (tree-copy p1)))
      (not (or (memq c1 (list p1 p2 p3))
               (memq (car c1) (list p1 p2 p3))
               (memq (cdr c1) (list p1 p2 p3))))))

  (= *most-positive-short-integer* *most-positive-fixnum*
     (most-positive-fixnum))

  (= *most-negative-short-integer* *most-negative-fixnum*
     (most-negative-fixnum))

  (eof-object? *eof*)

  (eq? short-integer? fixnum?)
  (eq? big-integer? bignum?)
  (eq? ratio? ratnum?)
  (eq? float? flonum?)

  (eq? bound? top-level-bound?)
  (eq? global-value top-level-value)
  (eq? set-global-value! set-top-level-value!)
  (eq? define-global-value define-top-level-value)
  (eq? symbol-value top-level-value)
  (eq? set-symbol-value! set-top-level-value!)

  (eq? put putprop)
  (eq? get getprop)

  (eq? copy-list list-copy)
  (eq? copy-tree tree-copy)
  (eq? copy-string string-copy)
  (eq? copy-vector vector-copy)

  (eq? intern string->symbol)
  (eq? symbol-name symbol->string)
  (eq? make-temp-symbol gensym)
  (eq? temp-symbol? gensym?)
  (eq? string->uninterned-symbol gensym)
  (eq? uninterned-symbol? gensym?)

  (eq? compile-eval compile)

  (eq? closure? procedure?)

  (eq? =? =)
  (eq? <? <)
  (eq? >? >)
  (eq? <=? <=)
  (eq? >=? >=)

  (eq? float exact->inexact)
  (eq? rational inexact->exact)

  (eq? char-equal? char=?)
  (eq? char-less? char<?)
  (eq? string-equal? string=?)
  (eq? string-less? string<?)

  (eq? flush-output flush-output-port)
  (eq? clear-output clear-output-port)
  (eq? clear-input clear-input-port)

  (eq? mapcar map)
  (eq? mapc for-each)
  (eq? true #t)
  (eq? false #f)
  (eq? t #t)
  (eq? nil '())

  (eq? macro-expand expand)

  (eq? (cull negative? '()) '())
  (let ((x (list -1 2 -3 -3 1 -5 2 6)))
    (and (equal? (cull pair? x) '())
         (equal? (cull negative? x) '(-1 -3 -3 -5))
         (equal? x '(-1 2 -3 -3 1 -5 2 6))))

  (eq? (cull! negative? '()) '())
  (let ((x (list -1 2 -3 -3 1 -5 2 6)))
    (and (equal? (cull! pair? x) '())
         (equal? (cull! negative? x) '(-1 -3 -3 -5))))

  (eq? (mem (lambda (x) #t) '()) #f)
  (let ((x '(a b c)))
    (and (equal? (mem (lambda (x) (eq? x 'a)) x) x)
         (equal? (mem (lambda (x) (eq? x 'b)) x) (cdr x))
         (equal? (mem (lambda (x) (eq? x 'c)) x) (cddr x))
         (equal? (mem (lambda (x) (eq? x 'd)) x) #f)))
  (let ((x '(1 -2 3)))
    (and (equal? (mem negative? x) (cdr x))
         (equal? (mem positive? x) x)
         (equal? (mem pair? x) #f)))

  (eq? (rem (lambda (x) #t) '()) '())
  (let ((x (list 1 -2 3)))
    (and (equal? (rem negative? x) '(1 3))
         (equal? x '(1 -2 3))))
  (let ((x (list 1 -2 3)))
    (and (equal? (rem positive? x) '(-2))
         (equal? x '(1 -2 3))))

  (eq? (rem! (lambda (x) #t) '()) '())
  (let ((x (list 1 -2 3)))
    (equal? (rem! negative? x) '(1 3)))
  (let ((x (list 1 -2 3)))
    (equal? (rem! positive? x) '(-2)))

  (eq? (ass (lambda (x) #t) '()) #f)
  (let ((a (list -1)) (b (list 2)) (c (list 3)))
    (let ((l (list a b c)))
      (and (equal? (ass negative? l) a)
           (equal? (ass positive? l) b)
           (equal? (ass (lambda (x) (= x 3)) l) c)
           (equal? (ass pair? l) #f))))

  (equal? (decode-float 0.0) '#(0 0 1))
  (let ((x (decode-float (inexact 2/3))))
    (define ~=
      (let ([*fuzz* .0001])
        (lambda (x y)
          (and (flonum? x)
               (flonum? y)
               (<= (abs (- x y)) *fuzz*)))))
    (~= (inexact (* (vector-ref x 2)
                    (vector-ref x 0)
                    (expt 2 (vector-ref x 1))))
        (inexact 2/3)))

  (let ((x (box 3)))
    (and (equal? (swap-box! x 4) 3) (equal? (unbox x) 4)))

  (begin
    (define-macro! fudge (a (b . c) d) `(quote (,a ,b ,c ,d)))
    (equal? (fudge + (- . *) /) '(+ - * /)))

  ; tests from MichaelL@frogware.com, testing the changes he suggested
  (let ()
    (define-macro test-1 (val) `',val)
    (equal? 'x (test-1 x)))
  (let ()
    (define-macro (test-1 val) `',val)
    (equal? 'x (test-1 x)))
  (let ()
    (define-macro test-2 (val) `'(,val))
    (equal? '(x) (test-2 x)))
  (let ()
    (define-macro (test-2 val) `'(,val))
    (equal? '(x) (test-2 x)))
  (let ([xyz '(x y z)])
    (define-macro test-3 (val) `(,@val))
    (equal? '(x y z) (test-3 xyz)))
  (let ([xyz '(x y z)])
    (define-macro (test-3 val) `(,@val))
    (equal? '(x y z) (test-3 xyz)))
  (let ()
    (define-macro test-4
      (val)
      (let ([test-function
              (lambda (x)
                (string->symbol (string-append (symbol->string x) "!!!")))])
        `'(,(test-function val))))
    (equal? '(xyz!!!) (test-4 xyz)))
  (let ()
    (define-macro (test-4 val)
      (let ([test-function
              (lambda (x)
                (string->symbol (string-append (symbol->string x) "!!!")))])
        `'(,(test-function val))))
    (equal? '(xyz!!!) (test-4 xyz)))
  (let ()
    (define-macro test-5 (this . that) `'(,this ,that))
    (equal? '(x (y z)) (test-5 x y z)))
  (let ()
    (define-macro (test-5 this . that) `'(,this ,that))
    (equal? '(x (y z)) (test-5 x y z)))
  (let ()
    (define-macro test-6 (this . that) `'(,this ,@that))
    (equal? '(x y z) (test-6 x y z)))
  (let ()
    (define-macro (test-6 this . that) `'(,this ,@that))
    (equal? '(x y z) (test-6 x y z)))
  (let ()
    (defmacro test-1 (val) `',val)
    (equal? 'x (test-1 x)))
  (let ()
    (defmacro (test-1 val) `',val)
    (equal? 'x (test-1 x)))
  (let ()
    (defmacro test-2 (val) `'(,val))
    (equal? '(x) (test-2 x)))
  (let ()
    (defmacro (test-2 val) `'(,val))
    (equal? '(x) (test-2 x)))
  (let ([xyz '(x y z)])
    (defmacro test-3 (val) `(,@val))
    (equal? '(x y z) (test-3 xyz)))
  (let ([xyz '(x y z)])
    (defmacro (test-3 val) `(,@val))
    (equal? '(x y z) (test-3 xyz)))
  (let ()
    (defmacro test-4
      (val)
      (let ([test-function
              (lambda (x)
                (string->symbol (string-append (symbol->string x) "!!!")))])
        `'(,(test-function val))))
    (equal? '(xyz!!!) (test-4 xyz)))
  (let ()
    (defmacro (test-4 val)
      (let ([test-function
              (lambda (x)
                (string->symbol (string-append (symbol->string x) "!!!")))])
        `'(,(test-function val))))
    (equal? '(xyz!!!) (test-4 xyz)))
  (let ()
    (defmacro test-5 (this . that) `'(,this ,that))
    (equal? '(x (y z)) (test-5 x y z)))
  (let ()
    (defmacro (test-5 this . that) `'(,this ,that))
    (equal? '(x (y z)) (test-5 x y z)))
  (let ()
    (defmacro test-6 (this . that) `'(,this ,@that))
    (equal? '(x y z) (test-6 x y z)))
  (let ()
    (defmacro (test-6 this . that) `'(,this ,@that))
    (equal? '(x y z) (test-6 x y z)))

  (begin
    (define-struct! caramel x y z)
    (eqv? (caramel-x (caramel 1 2 3)) 1)))

(examples-mat ez-grammar-test
  ("ez-grammar-test")
  (equal? (with-output-to-string ez-grammar-test) "8 tests ran\n"))
;;; 5_3.ms
;;; Copyright 1984-2017 Cisco Systems, Inc.
;;; 
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;; 
;;; http://www.apache.org/licenses/LICENSE-2.0
;;; 
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

(define <<
  (case-lambda
    [(x y)
     (and (flonum? x)
          (flonum? y)
          (if (and (fl= x 0.0) (fl= y 0.0))
              (fl< (fl/ 1.0 x) (fl/ 1.0 y))
              (fl< x y)))]
    [(x y z) (and (<< x y) (<< y z))]))

(mat inexact
     (== (inexact 0) +0.0)
     (== (inexact #e+1e-400) +0.0)
     (== (inexact #e-1e-400) -0.0)
     (== (inexact #e+1e+400) +inf.0)
     (== (inexact #e-1e+400) -inf.0)
     (== (inexact #e+1e-5000) +0.0)
     (== (inexact #e-1e-5000) -0.0)
     (== (inexact #e+1e+5000) +inf.0)
     (== (inexact #e-1e+5000) -inf.0)

     ; make sure inexact rounds to even whenever exactly half way to next
     ; (assuming 52-bit mantissa + hidden bit)
     ; ratios
     (fl= (inexact (+ (ash 1 52) 0/2)) #x10000000000000.0)
     (fl= (inexact (+ (ash 1 52) 1/2)) #x10000000000000.0)
     (fl= (inexact (+ (ash 1 52) 2/2)) #x10000000000001.0)
     (fl= (inexact (+ (ash 1 52) 3/2)) #x10000000000002.0)
     (fl= (inexact (+ (ash 1 52) 4/2)) #x10000000000002.0)
     (fl= (inexact (+ (ash 1 52) 5/2)) #x10000000000002.0)
     ; integers
     (fl= (inexact (* (+ (ash 1 52) 0/2) 2)) #x20000000000000.0)
     (fl= (inexact (* (+ (ash 1 52) 1/2) 2)) #x20000000000000.0)
     (fl= (inexact (* (+ (ash 1 52) 2/2) 2)) #x20000000000002.0)
     (fl= (inexact (* (+ (ash 1 52) 3/2) 2)) #x20000000000004.0)
     (fl= (inexact (* (+ (ash 1 52) 4/2) 2)) #x20000000000004.0)
     (fl= (inexact (* (+ (ash 1 52) 5/2) 2)) #x20000000000004.0)
     (fl= (inexact (ash (* (+ (ash 1 52) 0/2) 2) 40))
          #x200000000000000000000000.0)
     (fl= (inexact (ash (* (+ (ash 1 52) 1/2) 2) 40))
          #x200000000000000000000000.0)
     (fl= (inexact (ash (* (+ (ash 1 52) 2/2) 2) 40))
          #x200000000000020000000000.0)
     (fl= (inexact (ash (* (+ (ash 1 52) 3/2) 2) 40))
          #x200000000000040000000000.0)
     (fl= (inexact (ash (* (+ (ash 1 52) 4/2) 2) 40))
          #x200000000000040000000000.0)
     (fl= (inexact (ash (* (+ (ash 1 52) 5/2) 2) 40))
          #x200000000000040000000000.0)
     ; make sure inexact rounds up when more than half way to next
     ; (assuming 52-bit mantissa + hidden bit)
     ; ratios
     (fl= (inexact (+ (ash 1 52) 0/2 1/4)) #x10000000000000.0)
     (fl= (inexact (+ (ash 1 52) 1/2 1/4)) #x10000000000001.0)
     (fl= (inexact (+ (ash 1 52) 2/2 1/4)) #x10000000000001.0)
     (fl= (inexact (+ (ash 1 52) 3/2 1/4)) #x10000000000002.0)
     (fl= (inexact (+ (ash 1 52) 4/2 1/4)) #x10000000000002.0)
     (fl= (inexact (+ (ash 1 52) 5/2 1/4)) #x10000000000003.0)
     (fl= (inexact (+ (ash 1 52) 1/2 1/8)) #x10000000000001.0)
     (fl= (inexact (+ (ash 1 52) 3/2 1/8)) #x10000000000002.0)
     (fl= (inexact (+ (ash 1 52) 1/2 (expt 2 -80))) #x10000000000001.0)
     (fl= (inexact (+ (ash 1 52) 3/2 (expt 2 -80))) #x10000000000002.0)
     ; integers
     (fl= (inexact (* (+ (ash 1 52) 0/2 1/4) 4)) #x40000000000000.0)
     (fl= (inexact (* (+ (ash 1 52) 1/2 1/4) 4)) #x40000000000004.0)
     (fl= (inexact (* (+ (ash 1 52) 2/2 1/4) 4)) #x40000000000004.0)
     (fl= (inexact (* (+ (ash 1 52) 3/2 1/4) 4)) #x40000000000008.0)
     (fl= (inexact (* (+ (ash 1 52) 4/2 1/4) 4)) #x40000000000008.0)
     (fl= (inexact (* (+ (ash 1 52) 5/2 1/4) 4)) #x4000000000000C.0)
     (fl= (inexact (* (+ (ash 1 52) 1/2 1/8) 8)) #x80000000000008.0)
     (fl= (inexact (* (+ (ash 1 52) 3/2 1/8) 8)) #x80000000000010.0)
     (fl= (inexact (* (+ (ash 1 52) 1/2 (expt 2 -80)) (expt 2 80)))
          #x1000000000000100000000000000000000.0)
     (fl= (inexact (* (+ (ash 1 52) 3/2 (expt 2 -80)) (expt 2 80)))
          #x1000000000000200000000000000000000.0)
     ; verify fix for incorrect input of 2.2250738585072011e-308 reported by leppie
     ; 2.2250738585072011e-308 falls right on the edge between normalized and denormalized numbers,
     ; and should not be rounded up to a normalized number
     (equal? (number->string (string->number "2.2250738585072011e-308"))
             "2.225073858507201e-308|52")
     (equal? (decode-float (string->number "2.2250738585072011e-308"))
             '#(#b1111111111111111111111111111111111111111111111111111
                -1074 1))
     ; similar case in binary...
     (equal? (decode-float
               (string->number
                 "#b1.111111111111111111111111111111111111111111111111111011e-1111111111"))
             '#(#b1111111111111111111111111111111111111111111111111111
                -1074 1))
     (equal? (number->string
               (string->number
                 "#b1.111111111111111111111111111111111111111111111111111011e-1111111111"))
             "2.225073858507201e-308|52")
     ; slightly higher number should be rounded up
     (equal? (number->string (string->number "2.2250738585072012e-308"))
             "2.2250738585072014e-308")
     (equal? (number->string
               (string->number
                 "#b1.111111111111111111111111111111111111111111111111111100e-1111111111"))
             "2.2250738585072014e-308"))

(mat exact
     (error? (exact (nan)))
     (error? (exact +inf.0))
     (error? (exact -inf.0))
     (eq? (exact +0.0) 0)
     (eq? (exact -0.0) 0))

(mat ==
     (== 1.0 1.0)
     (== -1.0 -1.0)
     (not (== -1.0 +1.0))
     (not (== +1.0 -1.0))
     (== 0.0 0.0)
     (== -0.0 -0.0)
     (not (== -0.0 +0.0))
     (not (== +0.0 -0.0))
     (== +inf.0 +inf.0)
     (== -inf.0 -inf.0)
     (not (== -inf.0 +inf.0))
     (not (== +inf.0 -inf.0))
     (== (nan) (nan))
     (not (== +inf.0 (nan)))
     (not (== (nan) -inf.0))
     (not (== 0.0 0.0-0.0i))
     (== +e +e)
     (== -e -e)
     (not (== +e +0.0))
     (not (== -e -0.0)))

(mat <<
     (<< -1.0 1.0)
     (not (<< +1.0 -1.0))
     (not (<< 0.0 0.0))
     (<< -0.0 +0.0)
     (not (<< +0.0 -0.0))
     (<< -inf.0 +inf.0)
     (not (<< +inf.0 -inf.0))
     (not (<< (nan) (nan)))
     (not (<< (nan) +0.0))
     (not (<< +0.0 (nan)))
     (<< -e +0.0 +e)
     (<< -e -0.0 +e)
     (not (<< +e +e))
     (not (<< -e -e)))

(mat fl=
     (let ((n (read (open-input-string "+nan.0"))))
       (not (fl= n n)))
     (not (fl= (nan)))
     (not (fl= (nan) +inf.0))
     (not (fl= (nan) -inf.0))
     (not (fl= (nan) (nan)))
     (not (fl= (nan) 0.0))
     (fl= +inf.0 +inf.0)
     (fl= -inf.0 -inf.0)
     (not (fl= -inf.0 +inf.0))
     (fl= +0.0 -0.0))

(mat fl<
     (not (fl< (nan)))
     (not (fl< (nan) (nan)))
     (not (fl< (nan) 0.0))
     (not (fl< 0.0 (nan)))
     (fl< -inf.0 0.0))

(mat fl>
     (not (fl> (nan)))
     (not (fl> (nan) (nan)))
     (not (fl> (nan) 0.0))
     (not (fl> 0.0 (nan)))
     (fl> +inf.0 -inf.0)
     (fl> +inf.0 0.0)
     (not (fl> +0.0 -0.0)))

(mat fl<=
     (not (fl<= (nan)))
     (not (fl<= (nan) (nan)))
     (not (fl<= (nan) 0.0))
     (not (fl<= 0.0 (nan))))

(mat fl>=
     (not (fl>= (nan)))
     (not (fl>= (nan) (nan)))
     (not (fl>= (nan) 0.0))
     (not (fl>= 0.0 (nan))))

(mat fl-
     (== (fl- +0.0) -0.0)
     (== (fl- -0.0) +0.0)
     (== (fl- +inf.0) -inf.0)
     (== (fl- -inf.0) +inf.0)
     (== (fl- (nan)) (nan))
     (== (fl- -0.0 -0.0) +0.0)
     (== (fl- +0.0 -0.0) +0.0)
     (== (fl- -0.0 +0.0) -0.0)
     (== (fl- +0.0 +0.0) +0.0)
     (andmap (lambda (a)
               (andmap (lambda (b)
                         (andmap (lambda (c)
                                   (== (fl- a b c) (fl- (fl- a b) c)))
                                 '(0.0 -0.0)))
                       '(0.0 -0.0)))
             '(0.0 -0.0))
     (let ()
       (define-syntax ff
         (syntax-rules ()
           [(_ k1 k2)
            (lambda (x)
              (eqv? (fl- k1 x k2) (fl- (fl- k1 x) k2)))]))
       (andmap (lambda (p) (and (p +0.0) (p -0.0)))
               (list (ff +0.0 +0.0)
                     (ff +0.0 -0.0)
                     (ff -0.0 +0.0)
                     (ff -0.0 -0.0))))
     (error? (fl- 3.0 5.4 'a))
     (error? (fl- 'a 3.0 5.4))
     (error? (fl- 3.0 'a 5.4))
     (== (fl- 5.0 4.0 3.0 2.0) -4.0)
     (== (fl- 5.0 4.0 3.0 2.0 1.0 0.0 -1.0 -2.0) -2.0)
     (begin
       (define ($fl-f x y) (fl- -0.0 x y))
       (procedure? $fl-f))
     (== ($fl-f 3.0 4.0) -7.0)
     (== (fl- 1e30 1e30 7.0) -7.0))

(mat +
     ; just in case we're ever tempted to combine nested generic arithmetic operators...
     (begin
       (define f1a (lambda (x) (= (+ x 2) (+ (+ x 1) 1))))
       (define f1b (lambda (x) (= (+ (+ x 1) 1) x)))
       (define f2
         (lambda (x) (= (- (+ x 1e308) 1e308) +inf.0)))
       #t)
     (f1a 0)
     (not (f1a (inexact (expt 2 53))))
     (not (f1b 0))
     (f1b (inexact (expt 2 53)))
     (not (f2 (inexact 0)))
     (f2 +inf.0)
     (not (f2 +nan.0))
     (f2 1e308))

(mat -
     (== (- +0.0) -0.0)
     (== (- -0.0) +0.0)
     (== (- +inf.0) -inf.0)
     (== (- -inf.0) +inf.0)
     (== (- (nan)) (nan))
     (== (- -0.0 -0.0) +0.0)
     (== (- +0.0 -0.0) +0.0)
     (== (- -0.0 +0.0) -0.0)
     (== (- +0.0 +0.0) +0.0)
     (andmap (lambda (a)
               (andmap (lambda (b)
                         (andmap (lambda (c) (== (- a b c) (- (- a b) c)))
                                 '(0.0 -0.0)))
                       '(0.0 -0.0)))
             '(0.0 -0.0))
     (error? (- 3.0 5.4 'a))
     (error? (- 'a 3.0 5.4))
     (error? (- 3.0 'a 5.4))
     (== (- 1e30 1e30 7.0) -7.0)
     (begin
       (define $ieee-foo (lambda (x) (- x 1e30 7.0)))
       #t)
     (== ($ieee-foo 1e30) -7.0))

(mat fl+
     (== (fl+ -0.0 -0.0) -0.0)
     (== (fl+ +0.0 -0.0) +0.0)
     (== (fl+ -0.0 +0.0) +0.0)
     (== (fl+ +0.0 +0.0) +0.0))

(mat fl*
     (== (fl* -1.0 +0.0) -0.0)
     (== (fl* -1.0 -0.0) +0.0)
     (== (fl* +1.0 +0.0) +0.0)
     (== (fl* +1.0 -0.0) -0.0))

(mat fl/
     (== (fl/ +0.0) +inf.0)
     (== (fl/ -0.0) -inf.0)
     (== (fl/ +inf.0) +0.0)
     (== (fl/ -inf.0) -0.0)
     (== (fl/ (nan)) (nan))
     (== (fl/ +1.0 +0.0) +inf.0)
     (== (fl/ +1.0 -0.0) -inf.0)
     (== (fl/ -1.0 +0.0) -inf.0)
     (== (fl/ -1.0 -0.0) +inf.0)
     (== (fl/ +0.0 +0.0) (nan))
     (== (fl/ +0.0 -0.0) (nan))
     (== (fl/ -0.0 +0.0) (nan))
     (== (fl/ -0.0 -0.0) (nan))
     (andmap (lambda (a)
               (andmap (lambda (b)
                         (andmap (lambda (c)
                                   (== (fl/ a b c) (fl/ (fl/ a b) c)))
                                 '(1e300 1e250)))
                       '(1e300 1e250)))
             '(1e300 1e250))
     (error? (fl/ 3.0 5.4 'a))
     (error? (fl/ 'a 3.0 5.4))
     (error? (fl/ 3.0 'a 5.4))
     (== (fl/ 16.0 2.0 -2.0 2.0) -2.0)
     (== (fl/ 16.0 2.0 -2.0 2.0 4.0 1.0 -1.0) 0.5)
     (== (fl/ 1e300 1e300 1e300) 1e-300))

(mat /
     (== (/ +0.0) +inf.0)
     (== (/ -0.0) -inf.0)
     (== (/ +inf.0) +0.0)
     (== (/ -inf.0) -0.0)
     (== (/ (nan)) (nan))
     (== (/ +1.0 +0.0) +inf.0)
     (== (/ +1.0 -0.0) -inf.0)
     (== (/ -1.0 +0.0) -inf.0)
     (== (/ -1.0 -0.0) +inf.0)
     (== (/ +0.0 +0.0) (nan))
     (== (/ +0.0 -0.0) (nan))
     (== (/ -0.0 +0.0) (nan))
     (== (/ -0.0 -0.0) (nan))
     (andmap (lambda (a)
               (andmap (lambda (b)
                         (andmap (lambda (c) (== (/ a b c) (/ (/ a b) c)))
                                 '(1e300 1e250)))
                       '(1e300 1e250)))
             '(1e300 1e250))
     (error? (/ 3.0 5.4 'a))
     (error? (/ 'a 3.0 5.4))
     (error? (/ 3.0 'a 5.4))
     (== (fl/ 1e300 1e300 1e300) 1e-300))

(mat expt
     (== (expt +0.0 +0.0) +1.0)
     (== (expt -0.0 +0.0) +1.0)
     (== (expt +0.0 -0.0) +1.0)
     (== (expt -0.0 -0.0) +1.0)
     (== (expt +1.0 +0.0) +1.0)
     (== (expt -1.0 +0.0) +1.0)
     (== (expt +0.0 +1.0) +0.0)
     (== (expt -0.0 +1.0) -0.0)
     (== (expt -0.0 +2.0) +0.0)
     (== (expt -0.0 +3.0) -0.0)
     (== (expt +inf.0 +0.0) +1.0)
     (== (expt +inf.0 +1.0) +inf.0)
     (== (expt -inf.0 +0.0) +1.0)
     (== (expt -inf.0 +1.0) -inf.0)
     (== (expt +inf.0 +inf.0) +inf.0)
     (== (expt +inf.0 -inf.0) +0.0)
     (== (expt -inf.0 +inf.0) +inf.0)
     (== (expt -inf.0 -inf.0) +0.0)
     (== (expt +inf.0 +.5) +inf.0)
     (== (expt (nan) +.5) (nan))
     (== (expt +.5 (nan)) (nan))
     (== (expt (nan) (nan)) (nan))
     (== (expt (nan) +0.0) +1.0)
     (== (expt +0.0 (nan)) (nan))
     (== (expt +0.0 (nan)) (nan))
     (== (expt +inf.0+2i 2) +inf.0+0.0i)
     (== (let ([n (expt 2 32)]) (expt 2 (make-rectangular n n)))
         -inf.0+inf.0i))

(mat magnitude
     (== (magnitude -0.0) 0.0)
     (== (magnitude 0.0) 0.0)
     (== (magnitude 0.0-0.0i) 0.0)
     (== (magnitude -1.0) 1.0)
     (== (magnitude 1.0) 1.0)
     (== (magnitude 0.0+1.0i) 1.0)
     (== (magnitude +inf.0) +inf.0)
     (== (magnitude -inf.0) +inf.0)
     (== (magnitude +inf.0+inf.0i) +inf.0)
     (== (magnitude +inf.0+2.0i) +inf.0)
     (== (magnitude +2.0+inf.0i) +inf.0)
     (== (magnitude (nan)) (nan))
     (== (magnitude (make-rectangular (nan) (nan))) (nan))
     (== (magnitude (make-rectangular +0.0 (nan))) (nan))
     (<< +0.0 (magnitude (make-rectangular +e +e)))
     (<< +0.0 (magnitude (make-rectangular -e -e))))

(mat sqrt
     ; from Kahan
     (== (sqrt -0.0) +0.0+0.0i)
     (== (sqrt -4.0) +0.0+2.0i)
     (== (sqrt -inf.0) +0.0+inf.0i)
     (== (sqrt 0.0+inf.0i) +inf.0+inf.0i)
     (== (sqrt 4.0+inf.0i) +inf.0+inf.0i)
     (== (sqrt +inf.0+inf.0i) +inf.0+inf.0i)
     (== (sqrt -0.0+inf.0i) +inf.0+inf.0i)
     (== (sqrt -4.0+inf.0i) +inf.0+inf.0i)
     (== (sqrt -inf.0+inf.0i) +inf.0+inf.0i)
     (== (sqrt 0.0-inf.0i) +inf.0-inf.0i)
     (== (sqrt 4.0-inf.0i) +inf.0-inf.0i)
     (== (sqrt +inf.0-inf.0i) +inf.0-inf.0i)
     (== (sqrt -0.0-inf.0i) +inf.0-inf.0i)
     (== (sqrt -4.0-inf.0i) +inf.0-inf.0i)
     (== (sqrt -inf.0-inf.0i) +inf.0-inf.0i)
     (== (sqrt (make-rectangular (nan) +0.0))
         (make-rectangular (nan) (nan)))
     (== (sqrt (make-rectangular 0.0 (nan)))
         (make-rectangular (nan) (nan)))
     (== (sqrt (make-rectangular (nan) (nan)))
         (make-rectangular (nan) (nan)))
     (== (sqrt +inf.0+0.0i) +inf.0+0.0i)
     (== (sqrt +inf.0+4.0i) +inf.0+0.0i)
     (== (sqrt +inf.0-0.0i) +inf.0-0.0i)
     (== (sqrt +inf.0-4.0i) +inf.0-0.0i)
     (== (sqrt (make-rectangular +inf.0 (nan)))
         (make-rectangular +inf.0 (nan)))
     (== (sqrt -inf.0+0.0i) +0.0+inf.0i)
     (== (sqrt -inf.0+4.0i) +0.0+inf.0i)
     (== (sqrt -inf.0-0.0i) +0.0-inf.0i)
     (== (sqrt -inf.0-4.0i) +0.0-inf.0i)
     (let ([z (sqrt (make-rectangular -inf.0 (nan)))])
       (and (== (real-part z) (nan))
            (== (abs (imag-part z)) +inf.0)))
     ; others
     (== (sqrt +0.0) +0.0)
     (== (sqrt +1.0) +1.0)
     (== (sqrt +4.0) +2.0)
     (== (sqrt +inf.0) +inf.0)
     (== (sqrt +0.0+0.0i) +0.0+0.0i)
     (== (sqrt +1.0+0.0i) +1.0+0.0i)
     (== (sqrt +4.0+0.0i) +2.0+0.0i)
     (== (sqrt +inf.0+0.0i) +inf.0+0.0i)
     (== (sqrt -0.0+0.0i) +0.0+0.0i)
     (== (sqrt -1.0+0.0i) +0.0+1.0i)
     (== (sqrt -4.0+0.0i) +0.0+2.0i)
     (== (sqrt -inf.0+0.0i) +0.0+inf.0i)
     (== (sqrt -0.0-0.0i) +0.0-0.0i)
     (== (sqrt -1.0-0.0i) +0.0-1.0i)
     (== (sqrt -inf.0-0.0i) +0.0-inf.0i)
     (== (sqrt +0.0-0.0i) +0.0-0.0i)
     (== (sqrt +1.0-0.0i) +1.0-0.0i)
     (== (sqrt +inf.0-0.0i) +inf.0-0.0i)
     (== (sqrt (nan)) (nan)))

(mat exp
     (== (exp +0.0) +1.0)
     (== (exp -0.0) +1.0)
     (== (exp +inf.0) +inf.0)
     (== (exp -inf.0) +0.0)
     (== (exp (nan)) (nan))
     (== (exp +0.0+0.0i) +1.0+0.0i)
     (== (exp -0.0-0.0i) +1.0-0.0i)
     ; if exp treats x+0.0i the same as x:
     (== (exp +inf.0+0.0i) +inf.0+0.0i)
     ; otherwise:
     #;
     (== (exp +inf.0+0.0i) +inf.0+nan.0i)
     (== (exp +inf.0-0.0i) +inf.0-0.0i)
     (== (exp -inf.0+0.0i) 0.0+0.0i)
     (== (exp -inf.0-0.0i) 0.0-0.0i)
     ; if exp treats x+0.0i the same as x:
     (== (exp (make-rectangular (nan) +0.0)) (make-rectangular (nan) +0.0))
     ; otherwise:
     #;
     (== (exp (make-rectangular (nan) +0.0))
         (make-rectangular (nan) (nan)))
     ; if exp treats x+0.0i the same as x:
     (== (exp (make-rectangular (nan) -0.0)) (make-rectangular (nan) -0.0))
     ; otherwise:
     #;
     (== (exp (make-rectangular (nan) -0.0))
         (make-rectangular (nan) (nan)))
     (~= (exp 700.0+.75i) 7.421023049046266e303+6.913398801654868e303i)
     (~= (exp 700.0-.75i) 7.421023049046266e303-6.913398801654868e303i)
     (== (exp 800.0+.75i) +inf.0+inf.0i)
     (== (exp 800.0-.75i) +inf.0-inf.0i)
     (== (exp 800.0+1e-200i) +inf.0+2.7263745721125063e147i)
     (== (exp 800.0-1e-200i) +inf.0-2.7263745721125063e147i)
     (== (exp +inf.0+1.0i) +inf.0+inf.0i)
     (== (exp +inf.0+2.0i) -inf.0+inf.0i)
     (== (exp +inf.0+3.0i) -inf.0+inf.0i)
     (== (exp +inf.0+4.0i) -inf.0-inf.0i)
     (== (exp +inf.0+123.0i) -inf.0-inf.0i))

(mat log
     (== (log 0.0) -inf.0)
     (== (log 1.0) 0.0)
     (== (log +inf.0) +inf.0)

     (== (log -0.0) (make-rectangular -inf.0 +pi))
     (== (log -1.0) (make-rectangular 0.0 +pi))
     (== (log -inf.0) (make-rectangular +inf.0 +pi))

     (== (log +1.0i) (make-rectangular 0.0 +pi/2))
     (== (log -1.0i) (make-rectangular 0.0 -pi/2))

     (== (log -0.0+0.0i) (make-rectangular -inf.0 +pi))
     (== (log -0.0-0.0i) (make-rectangular -inf.0 -pi))
     (== (log +0.0+0.0i) -inf.0+0.0i)
     (== (log +0.0-0.0i) -inf.0-0.0i)

     (== (log +1.0+0.0i) 0.0+0.0i)
     (== (log -1.0+0.0i) (make-rectangular 0.0 +pi))
     (== (log +1.0-0.0i) 0.0-0.0i)
     (== (log -1.0-0.0i) (make-rectangular 0.0 -pi)))

(mat fllog
     (== (log 0.0) -inf.0)
     (== (log 1.0) 0.0)
     (== (log +inf.0) +inf.0)

     (== (log -0.0) (make-rectangular -inf.0 +pi))
     (== (log -1.0) (make-rectangular 0.0 +pi))
     (== (log -inf.0) (make-rectangular +inf.0 +pi))

     (== (log +1.0i) (make-rectangular 0.0 +pi/2))
     (== (log -1.0i) (make-rectangular 0.0 -pi/2))

     (== (log -0.0+0.0i) (make-rectangular -inf.0 +pi))
     (== (log -0.0-0.0i) (make-rectangular -inf.0 -pi))
     (== (log +0.0+0.0i) -inf.0+0.0i)
     (== (log +0.0-0.0i) -inf.0-0.0i)

     (== (log +1.0+0.0i) 0.0+0.0i)
     (== (log -1.0+0.0i) (make-rectangular 0.0 +pi))
     (== (log +1.0-0.0i) 0.0-0.0i)
     (== (log -1.0-0.0i) (make-rectangular 0.0 -pi)))

(mat sin
     (== (sin +0.0) +0.0)
     (== (sin -0.0) -0.0)
     (== (sin +inf.0) (nan))
     (== (sin -inf.0) (nan))
     (== (sin (nan)) (nan)))

(mat cos
     (== (cos +0.0) +1.0)
     (== (cos -0.0) +1.0)
     (== (cos +inf.0) (nan))
     (== (cos -inf.0) (nan))
     (== (cos (nan)) (nan)))

(mat tan
     (== (tan +0.0) +0.0)
     (== (tan -0.0) -0.0)
     (== (tan +inf.0) (nan))
     (== (tan -inf.0) (nan))
     (== (tan (nan)) (nan))
     (== (tan -0.0+0.0i) -0.0+0.0i))

(mat asin
     (== (asin +0.0) +0.0)
     (== (asin -0.0) -0.0)
     (== (asin +1.0) +pi/2)
     (== (asin -1.0) -pi/2)
     (== (asin (nan)) (nan))
     (== (asin -0.0+0.0i) -0.0+0.0i))

(mat acos
     (== (acos +1.0) +0.0)
     (== (acos -1.0) +pi)
     (== (acos +0.0) +pi/2)
     (== (acos -0.0) +pi/2)
     (== (acos (nan)) (nan)))

(mat atan
     ; cases from Steele (CLtL)
     (== (atan +0.0 +e) +0.0)
     (== (atan +0.0 +inf.0) +0.0)
     (<< +0.0 (atan +e +e) +pi/2)
     (<< +0.0 (atan +inf.0 +inf.0) +pi/2)
     (== (atan +e +0.0) +pi/2)
     (== (atan +inf.0 +0.0) +pi/2)
     (== (atan +e -0.0) +pi/2)
     (== (atan +inf.0 -0.0) +pi/2)
     (<< +pi/2 (atan +e -e) +pi)
     (<< +pi/2 (atan +inf.0 -inf.0) +pi)
     (== (atan +0.0 -e) +pi)
     (== (atan +0.0 -inf.0) +pi)
     (== (atan -0.0 -e) -pi)
     ; Steele erroneously says +pi
     (== (atan -0.0 -inf.0) -pi)
     ; Steele erroneously says +pi
     (<< -pi (atan -e -e) -pi/2)
     (<< -pi (atan -inf.0 -inf.0) -pi/2)
     (== (atan -e +0.0) -pi/2)
     (== (atan -e -0.0) -pi/2)
     (== (atan -inf.0 +0.0) -pi/2)
     (== (atan -inf.0 -0.0) -pi/2)
     (<< -pi/2 (atan -e +e) -0.0)
     (<< -pi/2 (atan -inf.0 +inf.0) -0.0)
     (== (atan -0.0 +e) -0.0)
     (== (atan -0.0 +inf.0) -0.0)
     (== (atan +0.0 +0.0) +0.0)
     (== (atan -0.0 +0.0) -0.0)
     (== (atan +0.0 -0.0) +pi)
     (== (atan -0.0 -0.0) -pi)

     (== (atan -inf.0) -pi/2)
     (== (atan +inf.0) +pi/2)
     (== (atan +0.0) +0.0)
     (== (atan -0.0) -0.0)
     (if (memq (machine-type) '(i3qnx ti3qnx))
         (~= (atan +1.0) +pi/4)
         (== (atan +1.0) +pi/4))
     (== (atan -1.0) -pi/4)
     (== (atan (nan)) (nan))
     (== (atan -0.0+0.0i) -0.0+0.0i))

(mat sinh
     (== (sinh 0.0) 0.0)
     (== (sinh -0.0) -0.0)
     (== (sinh +inf.0) +inf.0)
     (== (sinh -inf.0) -inf.0)
     (== (sinh (nan)) (nan))
     (== (sinh -0.0+0.0i) -0.0+0.0i))

(mat cosh
     (== (cosh 0.0) 1.0)
     (== (cosh -0.0) 1.0)
     (== (cosh +inf.0) +inf.0)
     (== (cosh -inf.0) +inf.0)
     (== (cosh (nan)) (nan)))

(mat tanh
     (== (tanh 0.0) 0.0)
     (== (tanh -0.0) -0.0)
     (== (tanh +inf.0) +1.0)
     (== (tanh -inf.0) -1.0)
     (== (tanh (nan)) (nan))
     (== (tanh -0.0+0.0i) -0.0+0.0i))

(mat asinh
     (== (asinh 0.0) 0.0)
     (== (asinh -0.0) -0.0)
     (== (asinh +inf.0) +inf.0)
     (== (asinh -inf.0) -inf.0)
     (== (asinh (nan)) (nan))
     (== (asinh -0.0+0.0i) -0.0+0.0i))

(mat acosh
     (== (acosh 1.0) 0.0)
     (== (acosh +inf.0) +inf.0)
     (== (acosh (nan)) (nan)))

(mat atanh
     (== (atanh 0.0) 0.0)
     (== (atanh -0.0) -0.0)
     (== (atanh +1.0) +inf.0)
     (== (atanh -1.0) -inf.0)
     (== (atanh (nan)) (nan))
     (== (atanh -0.0+0.0i) -0.0+0.0i)
     (== (atanh -0.0+0.0i) -0.0+0.0i))

(mat flonum->fixnum
     (error? (flonum->fixnum +inf.0))
     (error? (flonum->fixnum -inf.0))
     (error? (flonum->fixnum (nan)))
     (eq? (flonum->fixnum -0.0) 0))

(mat fllp
     (error? (fllp 3))
     (eqv? (fllp 0.0) 0)
     (eqv? (fllp 1.0) 2046)
     (eqv? (fllp -1.0) 2046)
     (eqv? (fllp 1.5) 2047)
     (eqv? (fllp -1.5) 2047)
     (and (memv (fllp +nan.0) '(4094 4095)) #t)
     (eqv? (fllp +inf.0) 4094)
     (eqv? (fllp -inf.0) 4094)
     (eqv? (fllp #b1.1111111111111111111111111111111111111111111111111111e1111111111)
           4093)
     (eqv? (fllp #b1.0e-1111111110) 2)
     (or (eqv? #b.1e-1111111110 0.0)
         (eqv? (fllp #b.1e-1111111110) 1))
     (eqv? (fllp #b.01e-1111111110) 0))

(mat fp-output
     (equal? (number->string 1e23) "1e23")
     (equal? (number->string 4.450147717014403e-308) "4.450147717014403e-308")
     (equal? (number->string 1.1665795231290236e-302) "1.1665795231290236e-302")
     ; fp printing algorithm always rounds up on ties
     (equal? (number->string 3.6954879760742188e-6) "3.6954879760742188e-6")
     (equal? (number->string 5.629499534213123e14) "5.629499534213123e14"))

(mat string->number
     (equal? (string->number "+1e-400") +0.0)
     (equal? (string->number "-1e-400") -0.0)
     (equal? (string->number "+1e+400") +inf.0)
     (equal? (string->number "-1e+400") -inf.0)
     (equal? (string->number "+1e-5000") +0.0)
     (equal? (string->number "-1e-5000") -0.0)
     (equal? (string->number "+1e+5000") +inf.0)
     (equal? (string->number "-1e+5000") -inf.0)
     (equal? (string->number "+1e-50000") +0.0)
     (equal? (string->number "-1e-50000") -0.0)
     (equal? (string->number "+1e+50000") +inf.0)
     (equal? (string->number "-1e+50000") -inf.0)
     (equal? (string->number "+1e-500000") +0.0)
     (equal? (string->number "-1e-500000") -0.0)
     (equal? (string->number "+1e+500000") +inf.0)
     (equal? (string->number "-1e+500000") -inf.0)

     (equal? (string->number "#b1e-10000110010") 5e-324)
     (equal? (string->number "5e-324") 5e-324)
     (equal? (string->number "#b-1e-10000110010") -5e-324)
     (equal? (string->number "-5e-324") -5e-324)
     (equal? (string->number "#b1e-10000110010")
             (inexact (* 5 (expt 10 -324))))
     (equal? (string->number "5e-324") (inexact (* 5 (expt 10 -324))))
     (equal? (string->number "#b-1e-10000110010")
             (inexact (* -5 (expt 10 -324))))
     (equal? (string->number "-5e-324") (inexact (* -5 (expt 10 -324))))

     (if (memq (machine-type) '(a6nt ta6nt))
         ; tolerably inaccurate
         (equal? (string->number "#b1e-10000110100") 0.0)
         (equal? (string->number "#b1e-10000110011") 0.0))
     (if (memq (machine-type) '(a6nt ta6nt))
         ; tolerably inaccurate
         (equal? (string->number "#b-1e-10000110100") -0.0)
         (equal? (string->number "#b-1e-10000110011") -0.0))
     (equal? (string->number "5e-325") 0.0)
     (equal? (string->number "-5e-325") -0.0)

     (equal? (string->number "1.7976931348623157e308")
             1.7976931348623157e308)
     (equal? (string->number "-1.7976931348623157e308")
             -1.7976931348623157e308)
     (equal? (string->number
               "#b1.1111111111111111111111111111111111111111111111111111e1111111111")
             1.7976931348623157e308)
     (equal? (string->number
               "#b-1.1111111111111111111111111111111111111111111111111111e1111111111")
             -1.7976931348623157e308)
     (equal? (string->number "1.7976931348623157e308")
             (inexact (* 9007199254740991 (expt 2 971))))
     (equal? (string->number "-1.7976931348623157e308")
             (inexact (* -9007199254740991 (expt 2 971))))
     (equal? (string->number
               "#b1.1111111111111111111111111111111111111111111111111111e1111111111")
             (inexact (* 9007199254740991 (expt 2 971))))
     (equal? (string->number
               "#b-1.1111111111111111111111111111111111111111111111111111e1111111111")
             (inexact (* -9007199254740991 (expt 2 971))))

     (equal? (string->number
               "#b1.11111111111111111111111111111111111111111111111111111e1111111111")
             +inf.0)
     (equal? (string->number
               "#b-1.11111111111111111111111111111111111111111111111111111e1111111111")
             -inf.0)
     (equal? (string->number "1.7976931348623159e308") +inf.0)
     (equal? (string->number "-1.7976931348623159e308") -inf.0)

     (equal? (string->number "1e100000000000000000000") +inf.0)
     (equal? (string->number "-1e100000000000000000000") -inf.0)
     (equal? (string->number "1e-100000000000000000000") 0.0)
     (equal? (string->number "-1e-100000000000000000000") -0.0))
;;; date.ms
;;; Copyright 1984-2017 Cisco Systems, Inc.
;;; 
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;; 
;;; http://www.apache.org/licenses/LICENSE-2.0
;;; 
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

(mat time
     (error? ; wrong number of arguments
             (make-time))
     (error? ; wrong number of arguments
             (make-time 'time-utc))
     (error? ; wrong number of arguments
             (make-time 'time-utc 17))
     (error? ; wrong number of arguments
             (make-time 'time-utc 17 0 50))
     (error? ; invalid type
             (make-time 'time-nonsense 17 0))
     (error? ; invalid seconds
             (make-time 'time-utc 0 #f))
     (error? ; invalid nanoseconds
             (make-time 'time-utc -1 17))
     (error? ; invalid nanoseconds
             (make-time 'time-utc #e1e9 17))
     (error? ; invalid nanoseconds
             (make-time 'time-utc #f 17))
     (error? ; wrong number of arguments
             (time?))
     (error? ; wrong number of arguments
             (time? #f 3))
     (begin
       (define $time-t1
         (make-time 'time-utc (- #e1e9 1) #e1e9))
       (and (time? $time-t1) (not (date? $time-t1))))
     (error? ; wrong number of arguments
             (time-type))
     (error? ; wrong number of arguments
             (time-type $time-t1 #t))
     (error? ; not a time record
             (time-type 17))
     (error? ; wrong number of arguments
             (time-second))
     (error? ; wrong number of arguments
             (time-second $time-t1 #t))
     (error? ; not a time record
             (time-second 17))
     (error? ; wrong number of arguments
             (time-nanosecond))
     (error? ; wrong number of arguments
             (time-nanosecond $time-t1 #t))
     (error? ; not a time record
             (time-nanosecond 17))
     (error? ; wrong number of arguments
             (set-time-type!))
     (error? ; wrong number of arguments
             (set-time-type! $time-t1))
     (error? ; wrong number of arguments
             (set-time-type! $time-t1 'time-utc 0))
     (error? ; not a time record
             (set-time-type! 'time-utc 'time-utc))
     (error? ; invalid type
       (set-time-type! $time-t1 'time-nonsense))
     (error? ; wrong number of arguments
             (set-time-second!))
     (error? ; wrong number of arguments
             (set-time-second! $time-t1))
     (error? ; wrong number of arguments
             (set-time-second! $time-t1 5000 0))
     (error? ; not a time record
             (set-time-second! 5000 5000))
     (error? ; invalid second
             (set-time-second! $time-t1 'time-utc))
     (error? ; wrong number of arguments
             (set-time-nanosecond!))
     (error? ; wrong number of arguments
             (set-time-nanosecond! $time-t1))
     (error? ; wrong number of arguments
             (set-time-nanosecond! $time-t1 5000 0))
     (error? ; not a time record
             (set-time-nanosecond! 5000 5000))
     (error? ; invalid nanosecond
             (set-time-nanosecond! $time-t1 -1))
     (error? ; invalid nanosecond
             (set-time-nanosecond! $time-t1 'time-utc))
     (error? ; invalid nanosecond
             (set-time-nanosecond! $time-t1 #e1e9))
     (error? ; wrong number of arguments
             (current-time 'time-utc #t))
     (error? ; invalid type
             (current-time 'time-nonsense))
     (begin
       (define $time-t2 (current-time 'time-utc))
       (and (time? $time-t2) (not (date? $time-t2))))
     (begin
       (define $time-t3 (current-time 'time-monotonic))
       (and (time? $time-t3) (not (date? $time-t3))))
     (begin
       (define $time-t4 (current-time 'time-duration))
       (and (time? $time-t4) (not (date? $time-t4))))
     (begin
       (define $time-t5 (current-time 'time-process))
       (and (time? $time-t5) (not (date? $time-t5))))
     (begin
       (define $time-t6 (current-time 'time-thread))
       (and (time? $time-t6) (not (date? $time-t6))))
     (begin
       (define $time-t7 (current-time 'time-collector-cpu))
       (and (time? $time-t7) (not (date? $time-t7))))
     (begin
       (define $time-t8 (current-time 'time-collector-real))
       (and (time? $time-t8) (not (date? $time-t8))))
     (eqv? (time-type $time-t1) 'time-utc)
     (eqv? (time-type $time-t2) 'time-utc)
     (eqv? (time-type $time-t3) 'time-monotonic)
     (eqv? (time-type $time-t4) 'time-duration)
     (eqv? (time-type $time-t5) 'time-process)
     (eqv? (time-type $time-t6) 'time-thread)
     (eqv? (time-type $time-t7) 'time-collector-cpu)
     (eqv? (time-type $time-t8) 'time-collector-real)
     (eqv? (time-second $time-t1) #e1e9)
     (eqv? (time-nanosecond $time-t1) (- #e1e9 1))
     ((lambda (x) (and (or (fixnum? x) (bignum? x)) (>= x 0)))
      (time-second $time-t2))
     ((lambda (x) (and (or (fixnum? x) (bignum? x)) (>= x 0)))
      (time-second $time-t3))
     ((lambda (x) (and (or (fixnum? x) (bignum? x)) (>= x 0)))
      (time-second $time-t4))
     ((lambda (x) (and (or (fixnum? x) (bignum? x)) (>= x 0)))
      (time-second $time-t5))
     ((lambda (x) (and (or (fixnum? x) (bignum? x)) (>= x 0)))
      (time-second $time-t6))
     ((lambda (x) (and (or (fixnum? x) (bignum? x)) (>= x 0)))
      (time-second $time-t7))
     ((lambda (x) (and (or (fixnum? x) (bignum? x)) (>= x 0)))
      (time-second $time-t8))
     ((lambda (x) (and (or (fixnum? x) (bignum? x)) (<= 0 x (- #e1e9 1))))
      (time-nanosecond $time-t2))
     ((lambda (x) (and (or (fixnum? x) (bignum? x)) (<= 0 x (- #e1e9 1))))
      (time-nanosecond $time-t3))
     ((lambda (x) (and (or (fixnum? x) (bignum? x)) (<= 0 x (- #e1e9 1))))
      (time-nanosecond $time-t4))
     ((lambda (x) (and (or (fixnum? x) (bignum? x)) (<= 0 x (- #e1e9 1))))
      (time-nanosecond $time-t5))
     ((lambda (x) (and (or (fixnum? x) (bignum? x)) (<= 0 x (- #e1e9 1))))
      (time-nanosecond $time-t6))
     ((lambda (x) (and (or (fixnum? x) (bignum? x)) (<= 0 x (- #e1e9 1))))
      (time-nanosecond $time-t7))
     ((lambda (x) (and (or (fixnum? x) (bignum? x)) (<= 0 x (- #e1e9 1))))
      (time-nanosecond $time-t8))
     (eqv? (let ([sec (+ (time-second (current-time 'time-thread)) 3)] [cnt 0] [ans 0])
             (define fib
               (lambda (x)
                 (if (< x 2)
                     x
                     (+ (fib (- x 1)) (fib (- x 2))))))
             (let f ()
               (when (< (time-second (current-time 'time-thread)) sec)
                     (for-each
                       (lambda (t)
                         (let ([n (time-nanosecond (current-time t))])
                           (unless (<= 0 n #e1e9)
                                   (errorf #f
                                           "(time-nanosecond (current-time '~s)) = ~s"
                                           t
                                           n))))
                       '(time-utc time-monotonic
                                  time-duration
                                  time-process
                                  time-thread))
                     (set! ans (+ ans (fib 20)))
                     (set! cnt (+ cnt 1))
                     (f)))
             (/ ans cnt))
           6765)
     (begin
       (set-time-type! $time-t1 'time-monotonic)
       (eqv? (time-type $time-t1) 'time-monotonic))
     (begin
       (set-time-second! $time-t1 3)
       (eqv? (time-second $time-t1) 3))
     (begin
       (set-time-nanosecond! $time-t1 3000)
       (eqv? (time-nanosecond $time-t1) 3000))
     (error? ; wrong number of arguments
             (time=?))
     (error? ; wrong number of arguments
             (time=? $time-t1))
     (error? ; wrong number of arguments
             (time=? $time-t1 $time-t1 $time-t1))
     (error? ; invalid argument
             (time=? $time-t1 3))
     (error? ; invalid argument
             (time=? car $time-t1))
     (error? ; different types
             (time=? $time-t4 $time-t5))
     (error? ; wrong number of arguments
             (time<?))
     (error? ; wrong number of arguments
             (time<? $time-t1))
     (error? ; wrong number of arguments
             (time<? $time-t1 $time-t1 $time-t1))
     (error? ; invalid argument
             (time<? $time-t1 3))
     (error? ; invalid argument
             (time<? car $time-t1))
     (error? ; different types
             (time<? $time-t4 $time-t5))
     (error? ; wrong number of arguments
             (time<=?))
     (error? ; wrong number of arguments
             (time<=? $time-t1))
     (error? ; wrong number of arguments
             (time<=? $time-t1 $time-t1 $time-t1))
     (error? ; invalid argument
             (time<=? $time-t1 3))
     (error? ; invalid argument
             (time<=? car $time-t1))
     (error? ; different types
             (time<=? $time-t4 $time-t5))
     (error? ; wrong number of arguments
             (time>?))
     (error? ; wrong number of arguments
             (time>? $time-t1))
     (error? ; wrong number of arguments
             (time>? $time-t1 $time-t1 $time-t1))
     (error? ; invalid argument
             (time>? $time-t1 3))
     (error? ; invalid argument
             (time>? car $time-t1))
     (error? ; different types
             (time>? $time-t4 $time-t5))
     (error? ; wrong number of arguments
             (time>=?))
     (error? ; wrong number of arguments
             (time>=? $time-t1))
     (error? ; wrong number of arguments
             (time>=? $time-t1 $time-t1 $time-t1))
     (error? ; invalid argument
             (time>=? $time-t1 3))
     (error? ; invalid argument
             (time>=? car $time-t1))
     (error? ; different types
             (time>=? $time-t4 $time-t5))
     (time=? $time-t1 $time-t1)
     (time<=? $time-t1 $time-t1)
     (time>=? $time-t1 $time-t1)
     (not (time<? $time-t1 $time-t1))
     (not (time>? $time-t1 $time-t1))
     (equal? (let ([ta (make-time 'time-duration 200 #e1e19)]
                   [tb (make-time 'time-duration 300 #e1e20)]
                   [tc (make-time 'time-duration 300 #e1e20)]
                   [td (make-time 'time-duration 301 #e1e20)]
                   [te (make-time 'time-duration 400 #e1e21)])
               (define-syntax foo
                 (syntax-rules ()
                   [(_ x ...)
                    (list (let ([t x])
                            (list (time<? t x)
                                  ...
                                  (time<=? t x)
                                  ...
                                  (time=? t x)
                                  ...
                                  (time>=? t x)
                                  ...
                                  (time>? t x)
                                  ...))
                          ...)]))
               (foo ta tb tc td te))
             '((#f #t
                   #t
                   #t
                   #t
                   #t
                   #t
                   #t
                   #t
                   #t
                   #t
                   #f
                   #f
                   #f
                   #f
                   #t
                   #f
                   #f
                   #f
                   #f
                   #f
                   #f
                   #f
                   #f
                   #f)
               (#f #f #f #t #t #f #t #t #t #t #f #t #t #f #f #t #t #t #f #f #t #f #f #f #f)
               (#f #f #f #t #t #f #t #t #t #t #f #t #t #f #f #t #t #t #f #f #t #f #f #f #f)
               (#f #f #f #f #t #f #f #f #t #t #f #f #f #t #f #t #t #t #t #f #t #t #t #f #f)
               (#f #f #f #f #f #f #f #f #f #t #f #f #f #f #t #t #t #t #t #t #t #t #t #t #f)))
     (error? (time-difference $time-t2 $time-t3))
     (error? (add-duration $time-t3 $time-t2))
     (error? (subtract-duration $time-t3 $time-t2))
     (let ([t (make-time 'time-duration 1000000 -20)])
       (and (time? t)
            (not (date? t))
            (eqv? (time-second t) -20)
            (eqv? (time-nanosecond t) 1000000)))
     (equal? (let ([t1 (make-time 'time-process 999999999 7)]
                   [t2 (make-time 'time-duration 10 2)])
               (let ([t3 (add-duration t1 t2)]
                     [t4 (subtract-duration t1 t2)])
                 (let ([t5 (time-difference t3 t1)]
                       [t6 (time-difference t1 t3)]
                       [t7 (time-difference t1 t4)]
                       [t8 (time-difference t4 t1)])
                   (list (list (time-second t3) (time-nanosecond t3))
                         (list (time-second t4) (time-nanosecond t4))
                         (time=? t5 t2)
                         (list (time-second t6) (time-nanosecond t6))
                         (time=? t7 t2)
                         (list (time-second t8) (time-nanosecond t8))))))
             '((10 9) (5 999999989) #t (-3 999999990) #t (-3 999999990)))
     (error? (copy-time (current-date)))
     (begin
       (define $new-time-t2 (copy-time $time-t2))
       (time? $new-time-t2))
     (not (eq? $new-time-t2 $time-t2))
     (time=? $new-time-t2 $time-t2))

(mat date
     (error? ; wrong number of arguments
             (make-date))
     (error? ; wrong number of arguments
             (make-date 0))
     (error? ; wrong number of arguments
             (make-date 0 0))
     (error? ; wrong number of arguments
             (make-date 0 0 0))
     (error? ; wrong number of arguments
             (make-date 0 0 0 0))
     (error? ; wrong number of arguments
             (make-date 0 0 0 0 1))
     (error? ; wrong number of arguments
             (make-date 0 0 0 0 1 1))
     (error? ; wrong number of arguments
             (make-date 0 0 0 0 1 1 2007 0 0))
     (error? ; invalid nanosecond
             (make-date -1 0 0 0 1 1 2007 0))
     (error? ; invalid nanosecond
             (make-date #e1e9 0 0 0 1 1 2007 0))
     (error? ; invalid nanosecond
             (make-date 'zero 0 0 0 1 1 2007 0))
     (error? ; invalid second
             (make-date 0 -1 0 0 1 1 2007 0))
     (error? ; invalid second
             (make-date 0 62 0 0 1 1 2007 0))
     (error? ; invalid second
             (make-date 0 "hello" 0 0 1 1 2007 0))
     (error? ; invalid minute
             (make-date 0 0 -1 0 1 1 2007 0))
     (error? ; invalid minute
             (make-date 0 0 60 0 1 1 2007 0))
     (error? ; invalid minute
             (make-date 0 0 "hello" 0 1 1 2007 0))
     (error? ; invalid hour
             (make-date 0 0 0 -1 1 1 2007 0))
     (error? ; invalid hour
             (make-date 0 0 0 24 1 1 2007 0))
     (error? ; invalid hour
             (make-date 0 0 0 "hello" 1 1 2007 0))
     (error? ; invalid day
             (make-date 0 0 0 0 0 1 2007 0))
     (error? ; invalid day
             (make-date 0 0 0 0 32 1 2007 0))
     (error? ; invalid day
             (make-date 0 0 0 0 31 11 2007 0))
     (error? ; invalid day
             (make-date 0 0 0 0 29 2 2007 0))
     (error? ; invalid day
       (make-date 0 0 0 0 "hello" 1 2007 0))
     (error? ; invalid month
             (make-date 0 0 0 0 1 0 2007 0))
     (error? ; invalid month
             (make-date 0 0 0 0 1 13 2007 0))
     (error? ; invalid month
             (make-date 0 0 0 0 1 'eleven 2007 0))
     (error? ; invalid year
             (make-date 0 0 0 0 1 1 'mmvii 0))
     (error? ; invalid tz
       (make-date 0 0 0 0 1 1 2007 (* -25 60 60)))
     (error? ; invalid tz
       (make-date 0 0 0 0 1 1 2007 (* 25 60 60)))
     (error? ; invalid tz
       (make-date 0 0 0 0 1 1 2007 'est))
     (error? ; invalid tz
       (make-date 0 0 0 0 1 1 2007 "est"))
     (error? ; wrong number of arguments
             (date?))
     (error? ; wrong number of arguments
             (date? #f 3))
     (begin
       (define $date-d1 (make-date 1 2 3 4 5 6 1970 8))
       (and (date? $date-d1) (not (time? $date-d1))))
     (error? ; wrong number of arguments
             (date-nanosecond))
     (error? ; wrong number of arguments
             (date-nanosecond $date-d1 #t))
     (error? ; not a date record
             (date-nanosecond 17))
     (error? ; not a date record
             (date-nanosecond $time-t1))
     (error? ; wrong number of arguments
             (date-nanosecond))
     (error? ; wrong number of arguments
             (date-nanosecond $date-d1 #t))
     (error? ; not a date record
             (date-nanosecond 17))
     (error? ; not a date record
             (date-nanosecond $time-t1))
     (error? ; wrong number of arguments
             (date-second))
     (error? ; wrong number of arguments
             (date-second $date-d1 #t))
     (error? ; not a date record
             (date-second 17))
     (error? ; not a date record
             (date-second $time-t1))
     (error? ; wrong number of arguments
             (date-minute))
     (error? ; wrong number of arguments
             (date-minute $date-d1 #t))
     (error? ; not a date record
             (date-minute 17))
     (error? ; not a date record
             (date-minute $time-t1))
     (error? ; wrong number of arguments
             (date-hour))
     (error? ; wrong number of arguments
             (date-hour $date-d1 #t))
     (error? ; not a date record
             (date-hour 17))
     (error? ; not a date record
             (date-hour $time-t1))
     (error? ; wrong number of arguments
             (date-day))
     (error? ; wrong number of arguments
             (date-day $date-d1 #t))
     (error? ; not a date record
             (date-day 17))
     (error? ; not a date record
             (date-day $time-t1))
     (error? ; wrong number of arguments
             (date-month))
     (error? ; wrong number of arguments
             (date-month $date-d1 #t))
     (error? ; not a date record
             (date-month 17))
     (error? ; not a date record
             (date-month $time-t1))
     (error? ; wrong number of arguments
             (date-year))
     (error? ; wrong number of arguments
             (date-year $date-d1 #t))
     (error? ; not a date record
             (date-year 17))
     (error? ; not a date record
             (date-year $time-t1))
     (error? ; wrong number of arguments
             (date-week-day))
     (error? ; wrong number of arguments
             (date-week-day $date-d1 #t))
     (error? ; not a date record
             (date-week-day 17))
     (error? ; not a date record
             (date-week-day $time-t1))
     (error? ; wrong number of arguments
             (date-year-day))
     (error? ; wrong number of arguments
             (date-year-day $date-d1 #t))
     (error? ; not a date record
             (date-year-day 17))
     (error? ; not a date record
             (date-year-day $time-t1))
     (error? ; wrong number of arguments
             (date-dst?))
     (error? ; wrong number of arguments
             (date-dst? $date-d1 #t))
     (error? ; not a date record
             (date-dst? 17))
     (error? ; not a date record
             (date-dst? $time-t1))
     (error? ; wrong number of arguments
             (date-zone-offset))
     (error? ; wrong number of arguments
             (date-zone-offset $date-d1 #t))
     (error? ; not a date record
             (date-zone-offset 17))
     (error? ; not a date record
             (date-zone-offset $time-t1))
     (error? ; wrong number of arguments
             (date-zone-name))
     (error? ; wrong number of arguments
             (date-zone-name $date-d1 #t))
     (error? ; not a date record
             (date-zone-name 17))
     (error? ; not a date record
             (date-zone-name $time-t1))
     (error? ; wrong number of arguments
             (current-date 0 #t))
     (error? ; invalid offset
             (current-date (* -25 60 60)))
     (error? ; invalid offset
             (current-date (* 25 60 60)))
     (begin
       (define $date-d2 (current-date))
       (and (date? $date-d2) (not (time? $date-d2))))
     (begin
       (define $date-d3 (current-date (* -5 60 60)))
       (and (date? $date-d3) (not (time? $date-d3))))
     (begin
       (define $date-d4 (current-date (* 10 60 60)))
       (and (date? $date-d4) (not (time? $date-d4))))
     (begin
       (define $date-d5 (make-date 0 1 1 1 15 6 2016))
       (and (date? $date-d5) (not (time? $date-d5))))
     (date? (make-date 0 0 0 0 1 1 1970 -24))
     (date? (make-date 999999999 59 59 23 31 12 2007 24))
     (eqv? (date-nanosecond $date-d1) 1)
     (eqv? (date-second $date-d1) 2)
     (eqv? (date-minute $date-d1) 3)
     (eqv? (date-hour $date-d1) 4)
     (eqv? (date-day $date-d1) 5)
     (eqv? (date-month $date-d1) 6)
     (eqv? (date-year $date-d1) 1970)
     (eqv? (date-zone-offset $date-d1) 8)
     (boolean? (date-dst? $date-d5))
     (fixnum? (date-zone-offset $date-d5))
     (eqv? (date-zone-name $date-d1) #f)
     (or (string? (date-zone-name $date-d2))
         (not (date-zone-name $date-d2)))
     (eqv? (date-zone-name $date-d3) #f)
     (eqv? (date-zone-name $date-d4) #f)
     (or (string? (date-zone-name $date-d5))
         (not (date-zone-name $date-d5)))
     (begin
       (define (plausible-dst? d)
         ;; Recognize a few time zone names and correlate with the DST field.
         ;; Names like "EST" appear on Unix variants, while the long names
         ;; show up on Windows.
         (cond
           [(member (date-zone-name d)
              '("EST" "CST"
                      "MST"
                      "PST"
                      "Eastern Standard Time"
                      "Central Standard Time"
                      "Mountain Standard Time"
                      "Pacific Standard Time"))
            (eqv? (date-dst? d) #f)]
           [(member (date-zone-name d)
              '("EDT" "CDT"
                      "MDT"
                      "PDT"
                      "Eastern Daylight Time"
                      "Central Daylight Time"
                      "Mountain Daylight Time"
                      "Pacific Daylight Time"))
            (eqv? (date-dst? d) #t)]
           [else #t]))
       (plausible-dst? $date-d5))
     (begin
       (define $date-d6 (make-date 0 1 1 1 15 1 2016))
       (plausible-dst? $date-d6))
     ; check whether tz offsets are set according to DST, assuming that
     ; DST always means a 1-hour shift
     (let ([delta (time-second
                    (time-difference (date->time-utc $date-d5)
                      (date->time-utc $date-d6)))]
           [no-dst-delta (* 152 24 60 60)]
           ; 152 days
           [hour-delta (* 60 60)])
       (cond
         [(and (date-dst? $date-d5) (not (date-dst? $date-d6)))
          ;; Northern-hemisphere DST reduces delta
          (= delta (- no-dst-delta hour-delta))]
         [(and (not (date-dst? $date-d5)) (date-dst? $date-d6))
          ;; Southern-hemisphere DST increases delta
          (= delta (+ no-dst-delta hour-delta))]
         [else
          ;; No DST or always DST
          (= delta no-dst-delta)]))
     ; check to make sure dst isn't screwing with our explicitly created dates
     ; when we call mktime to fill in wday and yday
     (let f ([mon 1])
       (or (= mon 13)
           (and (andmap (lambda (day)
                          (let ([d (make-date 5 6 7 8 day mon 2007 -18000)])
                            (and (eqv? (date-nanosecond d) 5)
                                 (eqv? (date-second d) 6)
                                 (eqv? (date-minute d) 7)
                                 (eqv? (date-hour d) 8)
                                 (eqv? (date-day d) day)
                                 (eqv? (date-month d) mon)
                                 (eqv? (date-year d) 2007)
                                 (eqv? (date-zone-offset d) -18000))))
                        '(5 10 15 20 25))
                (f (+ mon 1)))))
     (eqv? (date-zone-offset $date-d3) (* -5 60 60))
     (eqv? (date-zone-offset $date-d4) (* 10 60 60))
     ((lambda (x) (and (or (fixnum? x) (bignum? x)) (<= 0 x 999999999)))
      (date-nanosecond $date-d2))
     ((lambda (x) (and (or (fixnum? x) (bignum? x)) (<= 0 x 999999999)))
      (date-nanosecond $date-d3))
     ((lambda (x) (and (or (fixnum? x) (bignum? x)) (<= 0 x 999999999)))
      (date-nanosecond $date-d4))
     ((lambda (x) (and (fixnum? x) (<= 0 x 61))) (date-second $date-d2))
     ((lambda (x) (and (fixnum? x) (<= 0 x 61))) (date-second $date-d3))
     ((lambda (x) (and (fixnum? x) (<= 0 x 61))) (date-second $date-d4))
     ((lambda (x) (and (fixnum? x) (<= 0 x 59))) (date-minute $date-d2))
     ((lambda (x) (and (fixnum? x) (<= 0 x 59))) (date-minute $date-d3))
     ((lambda (x) (and (fixnum? x) (<= 0 x 59))) (date-minute $date-d4))
     ((lambda (x) (and (fixnum? x) (<= 0 x 23))) (date-hour $date-d2))
     ((lambda (x) (and (fixnum? x) (<= 0 x 23))) (date-hour $date-d3))
     ((lambda (x) (and (fixnum? x) (<= 0 x 23))) (date-hour $date-d4))
     ((lambda (x) (and (fixnum? x) (<= 1 x 31))) (date-day $date-d2))
     ((lambda (x) (and (fixnum? x) (<= 1 x 31))) (date-day $date-d3))
     ((lambda (x) (and (fixnum? x) (<= 1 x 31))) (date-day $date-d4))
     ((lambda (x) (and (fixnum? x) (<= 1 x 12))) (date-month $date-d2))
     ((lambda (x) (and (fixnum? x) (<= 1 x 12))) (date-month $date-d3))
     ((lambda (x) (and (fixnum? x) (<= 1 x 12))) (date-month $date-d4))
     ((lambda (x) (and (fixnum? x) (<= 1900 x 2038))) (date-year $date-d2))
     ((lambda (x) (and (fixnum? x) (<= 1900 x 2038))) (date-year $date-d3))
     ((lambda (x) (and (fixnum? x) (<= 1900 x 2038))) (date-year $date-d4))
     (let ([s (date-and-time)])
       (and (fixnum? (read (open-input-string (substring s 8 10))))
            (fixnum? (read (open-input-string (substring s 20 24))))))
     (let ([d (current-date)])
       (let ([s (date-and-time d)])
         (and (= (read (open-input-string (substring s 8 10)))
                 (date-day d))
              (= (read (open-input-string (substring s 11 13))) (date-hour d))
              (= (read (open-input-string (substring s 20 24))) (date-year d))))))

(mat conversions/sleep
     (error? (date->time-utc (current-time)))
     (error? (time-utc->date (current-date)))
     (error? (sleep 20))
     (time? (date->time-utc (current-date)))
     (date? (time-utc->date (current-time 'time-utc)))
     (let ([t (current-time 'time-utc)])
       (sleep (make-time 'time-duration 0 1))
       (time<? t (date->time-utc (current-date))))
     (let ([t (current-time)])
       (and (time=? (date->time-utc (time-utc->date t)) t)
            (time=? (date->time-utc (time-utc->date t -86400)) t)
            (time=? (date->time-utc (time-utc->date t 0)) t)
            (time=? (date->time-utc (time-utc->date t 86400)) t))))

(mat time&date-printing
     (equal? (with-output-to-string
               (lambda ()
                 (pretty-print (make-time 'time-duration 1 -1))))
             "#<time-duration -0.999999999>\n")
     (equal? (with-output-to-string
               (lambda ()
                 (write (time-utc->date
                          (make-time 'time-utc 708626501 1427137297)
                          -14400))))
             "#<date Mon Mar 23 15:01:37 2015>"))
;;; exceptions.ms
;;; Copyright 1984-2017 Cisco Systems, Inc.
;;; 
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;; 
;;; http://www.apache.org/licenses/LICENSE-2.0
;;; 
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

(mat exceptions
     (begin
       (define ($$capture thunk)
         (with-output-to-string
           (lambda ()
             (call/cc
               (lambda (k)
                 (with-exception-handler
                   (lambda (x)
                     (printf "default handler: ~s\n" x)
                     (k))
                   (lambda () (printf "~s\n" (thunk)))))))))
       (define-syntax $capture
         (syntax-rules ()
           [(_ e1 e2 ...) ($$capture (lambda () e1 e2 ...))]))
       #t)
     (equal? ($capture 'hello) "hello\n")
     (begin
       (define ($ex-test1)
         (raise 'oops)
         (printf "finished\n"))
       (define ($ex-test2)
         (printf "handler returned: ~s\n" (raise-continuable 'oops))
         'done)
       #t)
     (equal? ($capture (list ($ex-test1))) "default handler: oops\n")
     (equal? ($capture (list (with-exception-handler
                               (lambda (arg)
                                 (printf "hello: ~s\n" arg))
                               $ex-test1)))
             "hello: oops\ndefault handler: #<condition &non-continuable>\n")
     (equal? ($capture (list (with-exception-handler
                               (lambda (arg)
                                 (raise (list arg)))
                               $ex-test1)))
             "default handler: (oops)\n")
     (equal? ($capture (list ($ex-test2))) "default handler: oops\n")
     (equal? ($capture (list (with-exception-handler
                               (lambda (arg)
                                 (printf "hello: ~s\n" arg)
                                 17)
                               $ex-test2)))
             "hello: oops\nhandler returned: 17\n(done)\n")
     (equal? ($capture (list (with-exception-handler
                               (lambda (arg)
                                 (raise (list arg)))
                               $ex-test2)))
             "default handler: (oops)\n")
     (equal? ($capture (list (guard (foo [(null? foo) 'empty] [(pair? foo) foo])
                                    (raise '()))))
             "(empty)\n")
     (equal? ($capture (list (guard (foo [(null? foo) 'empty] [(pair? foo) foo])
                                    (raise '(a . b)))))
             "((a . b))\n")
     (equal? ($capture (list (guard (foo [(null? foo) 'empty] [(pair? foo) foo])
                                    (raise 'oops))))
             "default handler: oops\n")
     (equal? ($capture (list (guard (foo [(null? foo) 'empty] [(pair? foo) foo])
                               (with-exception-handler
                                 (lambda (x)
                                   (printf "just passing through...\n")
                                   (raise x))
                                 (lambda () (raise '()))))))
             "just passing through...\n(empty)\n")
     (equal? ($capture (list (guard (foo [(null? foo) 'empty] [(pair? foo) foo])
                               (with-exception-handler
                                 (lambda (x)
                                   (printf "just passing through...\n")
                                   (raise x))
                                 (lambda () (raise '(a . b)))))))
             "just passing through...\n((a . b))\n")
     (equal? ($capture (list (guard (foo [(null? foo) 'empty] [(pair? foo) foo])
                               (with-exception-handler
                                 (lambda (x)
                                   (printf "just passing through...\n")
                                   (raise x))
                                 (lambda () (raise 'oops))))))
             "just passing through...\ndefault handler: oops\n")
     (equal? ($capture (list (guard (foo [(null? foo) 'empty]
                                         [(pair? foo) foo]
                                         [else
                                          (raise 'hair)])
                                    (with-exception-handler
                                      (lambda (x)
                                        (printf "just passing through...\n")
                                        (raise x))
                                      (lambda ()
                                        (raise '(a . b)))))))
             "just passing through...\n((a . b))\n")
     (equal? ($capture (list (guard (foo [(null? foo) 'empty]
                                         [(pair? foo) foo]
                                         [else
                                          (raise 'hair)])
                                    (with-exception-handler
                                      (lambda (x)
                                        (printf "just passing through...\n")
                                        (raise x))
                                      (lambda ()
                                        (raise 'oops))))))
             "just passing through...\ndefault handler: hair\n")
     (equal? ($capture (list (call/cc
                               (lambda (k)
                                 (with-exception-handler
                                   (lambda (arg)
                                     (printf "outer handler: ~s\n" arg)
                                     (k 'fini))
                                   (lambda ()
                                     (guard (foo [(begin
                                                    (printf "checking null\n")
                                                    (null? foo)) 'empty]
                                                 [(begin
                                                    (printf "checking pair\n")
                                                    (pair? foo)) foo])
                                            (dynamic-wind
                                              (lambda () (printf "in\n"))
                                              (lambda () (raise 'oops))
                                              (lambda () (printf "out\n"))))))))))
             "in\nout\nchecking null\nchecking pair\nin\nouter handler: oops\nout\n(fini)\n")
     (equal? ($capture (list (guard (foo [(null? foo) 'empty] [(pair? foo) foo])
                               (with-exception-handler
                                 (lambda (x)
                                   (printf "returning...\n"))
                                 (lambda ()
                                   (raise-continuable 'oops)
                                   'continuing)))))
             "returning...\n(continuing)\n")
     (equal? ($capture ; test to make sure guard reraises with raise-continuable per r6rs errata
               (list (with-exception-handler
                       (lambda (x)
                         (printf "returning...\n"))
                       (lambda ()
                         (guard (foo [(null? foo) 'empty] [(pair? foo) foo])
                                (raise-continuable 'oops)
                                'continuing)))))
             "returning...\n(continuing)\n"))

(mat assert
     (equal? (begin (assert #t) "yes") "yes")
     (equal? (assert (memq 'a '(1 2 a 3 4))) '(a 3 4))
     (error? ; assertion failed
             (assert (memq 'b '(1 2 a 3 4))))
     (equal? (begin (assert (< 3 4)) "yes") "yes")
     (equal? (guard (c [#t "yes"]) (begin (assert #f) "no")) "yes")
     (equal? (guard (c [#t "yes"]) (begin (assert (< 4 3)) "no")) "yes")
     ; make sure pattern variables and ellipses on RHS don't screw us up
     (equal? (guard (c [#t "oops"])
               (let-syntax ([q (lambda (x) #t)])
                 (assert (q ...))
                 "okay"))
             "okay")
     (equal? (guard (c [#t "oops"])
               (let-syntax ([q (lambda (x) #f)])
                 (assert (q ...))
                 "okay"))
             "oops")
     (error? ; assertion failed
       (let-syntax ([q (lambda (x) #f)])
         (assert (q ...))
         "okay"))
     (equal? (syntax-case '(a b c) ()
               [(x ...)
                (begin
                  (assert (andmap symbol? #'(x ...)))
                  #'((x . x) ...))])
             '((a . a) (b . b) (c . c)))
     (error? ; assertion failed
       (syntax-case '(a b 3) ()
         [(x ...)
          (begin
            (assert (andmap symbol? #'(x ...)))
            #'((x . x) ...))])))

(mat exceptions-r6rs
     ; r6rs examples
     (equal? ($capture (guard (con ((error? con)
                                    (if (message-condition? con)
                                        (display (condition-message con))
                                        (display "an error has occurred"))
                                    'error)
                                   ((violation? con)
                                    (if (message-condition? con)
                                        (display (condition-message con))
                                        (display "the program has a bug"))
                                    'violation))
                              (raise (condition (make-error)
                                       (make-message-condition "I am an error")))))
             "I am an errorerror\n")
     (equal? ($capture (guard (con ((error? con)
                                    (if (message-condition? con)
                                        (display (condition-message con))
                                        (display "an error has occurred"))
                                    'error))
                              (raise (condition (make-violation)
                                       (make-message-condition "I am an error")))))
             "default handler: #<compound condition>\n")
     (equal? ($capture (with-exception-handler
                         (lambda (con)
                           (cond
                             ((not (warning? con)) (raise con))
                             ((message-condition? con)
                              (display (condition-message con)))
                             (else
                              (display "a warning has been issued")))
                           42)
                         (lambda ()
                           (+ (raise-continuable
                                (condition (make-warning)
                                  (make-message-condition "should be a number")))
                              23))))
             "should be a number65\n"))

(mat conditions-r6rs
     ; r6rs examples
     (begin
       (define-record-type ($co-&cond1 $co-make-cond1 $co-real-cond1?)
         (parent &condition)
         (fields (immutable x $co-real-cond1-x)))
       (define $co-cond1?
         (condition-predicate (record-type-descriptor $co-&cond1)))
       (define $co-cond1-x
         (condition-accessor
           (record-type-descriptor $co-&cond1)
           $co-real-cond1-x))
       (define $co-foo ($co-make-cond1 'foo))
       #t)
     (condition? $co-foo)
     ($co-cond1? $co-foo)
     (eq? ($co-cond1-x $co-foo) 'foo)
     (begin
       (define-record-type ($co-&cond2 $co-make-cond2 $co-real-cond2?)
         (parent &condition)
         (fields (immutable y $co-real-cond2-y)))
       (define $co-cond2?
         (condition-predicate (record-type-descriptor $co-&cond2)))
       (define $co-cond2-y
         (condition-accessor
           (record-type-descriptor $co-&cond2)
           $co-real-cond2-y))
       (define $co-bar ($co-make-cond2 'bar))
       #t)
     (condition? (condition $co-foo $co-bar))
     ($co-cond1? (condition $co-foo $co-bar))
     ($co-cond2? (condition $co-foo $co-bar))
     ($co-cond1? (condition $co-foo))
     (list? (memq ($co-real-cond1? (condition $co-foo)) '(#t #f)))
     (not ($co-real-cond1? (condition $co-foo $co-bar)))
     (eq? ($co-cond1-x (condition $co-foo $co-bar)) 'foo)
     (eq? ($co-cond2-y (condition $co-foo $co-bar)) 'bar)
     (equal? (simple-conditions (condition $co-foo $co-bar))
             (list $co-foo $co-bar))
     (equal? (simple-conditions (condition $co-foo (condition $co-bar)))
             (list $co-foo $co-bar))
     (begin
       (define-condition-type
         $co-&c
         &condition
         $co-make-c
         $co-c?
         (x $co-c-x))
       (define-condition-type
         $co-&c1
         $co-&c
         $co-make-c1
         $co-c1?
         (a $co-c1-a))
       (define-condition-type
         $co-&c2
         $co-&c
         $co-make-c2
         $co-c2?
         (b $co-c2-b))
       (define $co-v1 ($co-make-c1 "V1" "a1"))
       #t)
     ($co-c? $co-v1)
     ($co-c1? $co-v1)
     (not ($co-c2? $co-v1))
     (equal? ($co-c-x $co-v1) "V1")
     (equal? ($co-c1-a $co-v1) "a1")
     (begin
       (define $co-v2 ($co-make-c2 "V2" "b2"))
       (define $co-v3
         (condition ($co-make-c1 "V3/1" "a3") ($co-make-c2 "V3/2" "b3")))
       (define $co-v4 (condition $co-v1 $co-v2))
       (define $co-v5 (condition $co-v2 $co-v3))
       #t)
     ($co-c? $co-v2)
     (not ($co-c1? $co-v2))
     ($co-c2? $co-v2)
     (equal? ($co-c-x $co-v2) "V2")
     (equal? ($co-c2-b $co-v2) "b2")
     ($co-c? $co-v3)
     ($co-c1? $co-v3)
     ($co-c2? $co-v3)
     (equal? ($co-c-x $co-v3) "V3/1")
     (equal? ($co-c1-a $co-v3) "a3")
     (equal? ($co-c2-b $co-v3) "b3")
     ($co-c? $co-v4)
     ($co-c1? $co-v4)
     ($co-c2? $co-v4)
     (equal? ($co-c-x $co-v4) "V1")
     (equal? ($co-c1-a $co-v4) "a1")
     (equal? ($co-c2-b $co-v4) "b2")
     ($co-c? $co-v5)
     ($co-c1? $co-v5)
     ($co-c2? $co-v5)
     (equal? ($co-c-x $co-v5) "V2")
     (equal? ($co-c1-a $co-v5) "a3")
     (equal? ($co-c2-b $co-v5) "b2"))

(mat system-exceptions
     (equal? ($capture ; from r6rs
               (guard (con ((error? con) (display "error opening file") #f))
                      (call-with-input-file "/probably/not/here" read)))
             "error opening file#f\n")
     (guard (c [else
                (and (assertion-violation? c)
                     (not (implementation-restriction-violation? c)))])
            (let ()
              (define-record-type foo (fields x))
              (foo-x 17))))

(mat exception-state
     (#%$record? (current-exception-state))
     (not (record? (current-exception-state)))
     (eq? (call/cc
            (lambda (k)
              (parameterize
                ([current-exception-state
                   (create-exception-state
                     (lambda (x)
                       (if (eq? x 'oops)
                           (raise 'rats)
                           (k x))))])
                (raise 'oops))))
          'rats))